diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/ar71xx.c linux-2.6.39/arch/mips/ar71xx/ar71xx.c
--- linux-2.6.39.orig/arch/mips/ar71xx/ar71xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/ar71xx.c	2011-08-24 02:41:55.227990426 +0200
@@ -0,0 +1,230 @@
+/*
+ *  AR71xx SoC routines
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+static DEFINE_MUTEX(ar71xx_flash_mutex);
+static DEFINE_SPINLOCK(ar71xx_device_lock);
+
+void __iomem *ar71xx_ddr_base;
+EXPORT_SYMBOL_GPL(ar71xx_ddr_base);
+
+void __iomem *ar71xx_pll_base;
+EXPORT_SYMBOL_GPL(ar71xx_pll_base);
+
+void __iomem *ar71xx_reset_base;
+EXPORT_SYMBOL_GPL(ar71xx_reset_base);
+
+void __iomem *ar71xx_gpio_base;
+EXPORT_SYMBOL_GPL(ar71xx_gpio_base);
+
+void __iomem *ar71xx_usb_ctrl_base;
+EXPORT_SYMBOL_GPL(ar71xx_usb_ctrl_base);
+
+void ar71xx_device_stop(u32 mask)
+{
+	unsigned long flags;
+	u32 mask_inv;
+	u32 t;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR71XX_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR71XX_RESET_REG_RESET_MODULE, t | mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		mask_inv = mask & RESET_MODULE_USB_OHCI_DLL_7240;
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
+		t |= mask;
+		t &= ~mask_inv;
+		ar71xx_reset_wr(AR724X_RESET_REG_RESET_MODULE, t);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR91XX_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR91XX_RESET_REG_RESET_MODULE, t | mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR933X_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR933X_RESET_REG_RESET_MODULE, t | mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR934X_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR934X_RESET_REG_RESET_MODULE, t | mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	default:
+		BUG();
+	}
+}
+EXPORT_SYMBOL_GPL(ar71xx_device_stop);
+
+void ar71xx_device_start(u32 mask)
+{
+	unsigned long flags;
+	u32 mask_inv;
+	u32 t;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR71XX_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR71XX_RESET_REG_RESET_MODULE, t & ~mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		mask_inv = mask & RESET_MODULE_USB_OHCI_DLL_7240;
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
+		t &= ~mask;
+		t |= mask_inv;
+		ar71xx_reset_wr(AR724X_RESET_REG_RESET_MODULE, t);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR91XX_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR91XX_RESET_REG_RESET_MODULE, t & ~mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR933X_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR933X_RESET_REG_RESET_MODULE, t & ~mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR934X_RESET_REG_RESET_MODULE);
+		ar71xx_reset_wr(AR934X_RESET_REG_RESET_MODULE, t & ~mask);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	default:
+		BUG();
+	}
+}
+EXPORT_SYMBOL_GPL(ar71xx_device_start);
+
+int ar71xx_device_stopped(u32 mask)
+{
+	unsigned long flags;
+	u32 t;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR71XX_RESET_REG_RESET_MODULE);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR91XX_RESET_REG_RESET_MODULE);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR933X_RESET_REG_RESET_MODULE);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		spin_lock_irqsave(&ar71xx_device_lock, flags);
+		t = ar71xx_reset_rr(AR934X_RESET_REG_RESET_MODULE);
+		spin_unlock_irqrestore(&ar71xx_device_lock, flags);
+		break;
+
+	default:
+		BUG();
+	}
+
+	return ((t & mask) == mask);
+}
+EXPORT_SYMBOL_GPL(ar71xx_device_stopped);
+
+void ar71xx_ddr_flush(u32 reg)
+{
+	ar71xx_ddr_wr(reg, 1);
+	while ((ar71xx_ddr_rr(reg) & 0x1))
+		;
+
+	ar71xx_ddr_wr(reg, 1);
+	while ((ar71xx_ddr_rr(reg) & 0x1))
+		;
+}
+EXPORT_SYMBOL_GPL(ar71xx_ddr_flush);
+
+void ar71xx_flash_acquire(void)
+{
+	mutex_lock(&ar71xx_flash_mutex);
+}
+EXPORT_SYMBOL_GPL(ar71xx_flash_acquire);
+
+void ar71xx_flash_release(void)
+{
+	mutex_unlock(&ar71xx_flash_mutex);
+}
+EXPORT_SYMBOL_GPL(ar71xx_flash_release);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-ap91-pci.c linux-2.6.39/arch/mips/ar71xx/dev-ap91-pci.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-ap91-pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-ap91-pci.c	2011-08-24 02:41:55.277990824 +0200
@@ -0,0 +1,71 @@
+/*
+ *  Atheros AP91 reference board PCI initialization
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-ap91-pci.h"
+#include "pci-ath9k-fixup.h"
+
+static struct ath9k_platform_data ap91_wmac_data = {
+	.led_pin = -1,
+};
+static char ap91_wmac_mac[6];
+
+static struct ar71xx_pci_irq ap91_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}
+};
+
+static int ap91_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 0:
+		dev->dev.platform_data = &ap91_wmac_data;
+		break;
+	}
+
+	return 0;
+}
+
+__init void ap91_pci_setup_wmac_led_pin(int pin)
+{
+	ap91_wmac_data.led_pin = pin;
+}
+
+__init void ap91_pci_setup_wmac_gpio(u32 mask, u32 val)
+{
+	ap91_wmac_data.gpio_mask = mask;
+	ap91_wmac_data.gpio_val = val;
+}
+
+void __init ap91_pci_init(u8 *cal_data, u8 *mac_addr)
+{
+	if (cal_data)
+		memcpy(ap91_wmac_data.eeprom_data, cal_data,
+		       sizeof(ap91_wmac_data.eeprom_data));
+
+	if (mac_addr) {
+		memcpy(ap91_wmac_mac, mac_addr, sizeof(ap91_wmac_mac));
+		ap91_wmac_data.macaddr = ap91_wmac_mac;
+	}
+
+	ar71xx_pci_plat_dev_init = ap91_pci_plat_dev_init;
+	ar71xx_pci_init(ARRAY_SIZE(ap91_pci_irqs), ap91_pci_irqs);
+
+	pci_enable_ath9k_fixup(0, ap91_wmac_data.eeprom_data);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-ap91-pci.h linux-2.6.39/arch/mips/ar71xx/dev-ap91-pci.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-ap91-pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-ap91-pci.h	2011-08-24 02:41:55.287981779 +0200
@@ -0,0 +1,25 @@
+/*
+ *  Atheros AP91 reference board PCI initialization
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_AP91_PCI_H
+#define _AR71XX_DEV_AP91_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_AP91_PCI)
+void ap91_pci_init(u8 *cal_data, u8 *mac_addr) __init;
+void ap91_pci_setup_wmac_led_pin(int pin) __init;
+void ap91_pci_setup_wmac_gpio(u32 mask, u32 val) __init;
+#else
+static inline void ap91_pci_init(u8 *cal_data, u8 *mac_addr) { }
+static inline void ap91_pci_setup_wmac_led_pin(int pin) { }
+static inline void ap91_pci_setup_wmac_gpio(u32 mask, u32 gpio) { }
+#endif
+
+#endif /* _AR71XX_DEV_AP91_PCI_H */
+
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-ap94-pci.c linux-2.6.39/arch/mips/ar71xx/dev-ap94-pci.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-ap94-pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-ap94-pci.c	2011-08-24 02:41:55.287981779 +0200
@@ -0,0 +1,109 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-ap94-pci.h"
+#include "pci-ath9k-fixup.h"
+
+static struct ath9k_platform_data ap94_wmac0_data = {
+	.led_pin = -1,
+};
+static struct ath9k_platform_data ap94_wmac1_data = {
+	.led_pin = -1,
+};
+static char ap94_wmac0_mac[6];
+static char ap94_wmac1_mac[6];
+
+static struct ar71xx_pci_irq ap94_pci_irqs[] __initdata = {
+	{
+		.slot   = 0,
+		.pin    = 1,
+		.irq    = AR71XX_PCI_IRQ_DEV0,
+	}, {
+		.slot   = 1,
+		.pin    = 1,
+		.irq    = AR71XX_PCI_IRQ_DEV1,
+	}
+};
+
+static int ap94_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &ap94_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &ap94_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+__init void ap94_pci_setup_wmac_led_pin(unsigned wmac, int pin)
+{
+	switch (wmac) {
+	case 0:
+		ap94_wmac0_data.led_pin = pin;
+		break;
+	case 1:
+		ap94_wmac1_data.led_pin = pin;
+		break;
+	}
+}
+
+__init void ap94_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val)
+{
+	switch (wmac) {
+	case 0:
+		ap94_wmac0_data.gpio_mask = mask;
+		ap94_wmac0_data.gpio_val = val;
+		break;
+	case 1:
+		ap94_wmac1_data.gpio_mask = mask;
+		ap94_wmac1_data.gpio_val = val;
+		break;
+	}
+}
+
+void __init ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			  u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0)
+		memcpy(ap94_wmac0_data.eeprom_data, cal_data0,
+		       sizeof(ap94_wmac0_data.eeprom_data));
+
+	if (cal_data1)
+		memcpy(ap94_wmac1_data.eeprom_data, cal_data1,
+		       sizeof(ap94_wmac1_data.eeprom_data));
+
+	if (mac_addr0) {
+		memcpy(ap94_wmac0_mac, mac_addr0, sizeof(ap94_wmac0_mac));
+		ap94_wmac0_data.macaddr = ap94_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(ap94_wmac1_mac, mac_addr1, sizeof(ap94_wmac1_mac));
+		ap94_wmac1_data.macaddr = ap94_wmac1_mac;
+	}
+
+	ar71xx_pci_plat_dev_init = ap94_pci_plat_dev_init;
+	ar71xx_pci_init(ARRAY_SIZE(ap94_pci_irqs), ap94_pci_irqs);
+
+	pci_enable_ath9k_fixup(17, ap94_wmac0_data.eeprom_data);
+	pci_enable_ath9k_fixup(18, ap94_wmac1_data.eeprom_data);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-ap94-pci.h linux-2.6.39/arch/mips/ar71xx/dev-ap94-pci.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-ap94-pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-ap94-pci.h	2011-08-24 02:41:55.287981779 +0200
@@ -0,0 +1,31 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_AP94_PCI_H
+#define _AR71XX_DEV_AP94_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_AP94_PCI)
+void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+		   u8 *cal_data1, u8 *mac_addr1) __init;
+
+void ap94_pci_setup_wmac_led_pin(unsigned wmac, int pin) __init;
+void ap94_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val) __init;
+
+#else
+static inline void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				 u8 *cal_data1, u8 *mac_addr1) {}
+
+static inline void ap94_pci_setup_wmac_led_pin(unsigned wmac, int pin) {}
+static inline void ap94_pci_setup_wmac_gpio(unsigned wmac,
+					    u32 mask, u32 val) {}
+#endif
+
+#endif /* _AR71XX_DEV_AP94_PCI_H */
+
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-ar9xxx-wmac.c linux-2.6.39/arch/mips/ar71xx/dev-ar9xxx-wmac.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-ar9xxx-wmac.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-ar9xxx-wmac.c	2011-08-24 02:41:55.287981779 +0200
@@ -0,0 +1,154 @@
+/*
+ *  Atheros AR9XXX SoCs built-in WMAC device support
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15/2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "dev-ar9xxx-wmac.h"
+
+#define MHZ_25	(25 * 1000 * 1000)
+
+static struct ath9k_platform_data ar9xxx_wmac_data = {
+	.led_pin = -1,
+};
+static char ar9xxx_wmac_mac[6];
+
+static struct resource ar9xxx_wmac_resources[] = {
+	{
+		/* .start and .end fields are filled dynamically */
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= AR71XX_CPU_IRQ_IP2,
+		.end	= AR71XX_CPU_IRQ_IP2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ar9xxx_wmac_device = {
+	.name		= "ath9k",
+	.id		= -1,
+	.resource	= ar9xxx_wmac_resources,
+	.num_resources	= ARRAY_SIZE(ar9xxx_wmac_resources),
+	.dev = {
+		.platform_data = &ar9xxx_wmac_data,
+	},
+};
+
+static void ar913x_wmac_init(void)
+{
+	ar71xx_device_stop(RESET_MODULE_AMBA2WMAC);
+	mdelay(10);
+
+	ar71xx_device_start(RESET_MODULE_AMBA2WMAC);
+	mdelay(10);
+
+	ar9xxx_wmac_resources[0].start = AR91XX_WMAC_BASE;
+	ar9xxx_wmac_resources[0].end = AR91XX_WMAC_BASE + AR91XX_WMAC_SIZE - 1;
+}
+
+static int ar933x_r1_get_wmac_revision(void)
+{
+	return ar71xx_soc_rev;
+}
+
+static int ar933x_wmac_reset(void)
+{
+	unsigned retries = 0;
+
+	ar71xx_device_stop(AR933X_RESET_WMAC);
+	ar71xx_device_start(AR933X_RESET_WMAC);
+
+	while (1) {
+		u32 bootstrap;
+
+		bootstrap = ar71xx_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+		if ((bootstrap & AR933X_BOOTSTRAP_EEPBUSY) == 0)
+			return 0;
+
+		if (retries > 20)
+			break;
+
+		udelay(10000);
+		retries++;
+	}
+
+	pr_err("ar93xx: WMAC reset timed out");
+	return -ETIMEDOUT;
+}
+
+static void ar933x_wmac_init(void)
+{
+	ar9xxx_wmac_device.name = "ar933x_wmac";
+	ar9xxx_wmac_resources[0].start = AR933X_WMAC_BASE;
+	ar9xxx_wmac_resources[0].end = AR933X_WMAC_BASE + AR933X_WMAC_SIZE - 1;
+	if (ar71xx_ref_freq == MHZ_25)
+		ar9xxx_wmac_data.is_clk_25mhz = true;
+
+	if (ar71xx_soc_rev == 1)
+		ar9xxx_wmac_data.get_mac_revision = ar933x_r1_get_wmac_revision;
+
+	ar9xxx_wmac_data.external_reset = ar933x_wmac_reset;
+
+	ar933x_wmac_reset();
+}
+
+static void ar934x_wmac_init(void)
+{
+	ar9xxx_wmac_device.name = "ar934x_wmac";
+	ar9xxx_wmac_resources[0].start = AR934X_WMAC_BASE;
+	ar9xxx_wmac_resources[0].end = AR934X_WMAC_BASE + AR934X_WMAC_SIZE - 1;
+	if (ar71xx_ref_freq == MHZ_25)
+		ar9xxx_wmac_data.is_clk_25mhz = true;
+}
+
+void __init ar9xxx_add_device_wmac(u8 *cal_data, u8 *mac_addr)
+{
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		ar913x_wmac_init();
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ar933x_wmac_init();
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar934x_wmac_init();
+		break;
+
+	default:
+		BUG();
+	}
+
+	if (cal_data)
+		memcpy(ar9xxx_wmac_data.eeprom_data, cal_data,
+		       sizeof(ar9xxx_wmac_data.eeprom_data));
+
+	if (mac_addr) {
+		memcpy(ar9xxx_wmac_mac, mac_addr, sizeof(ar9xxx_wmac_mac));
+		ar9xxx_wmac_data.macaddr = ar9xxx_wmac_mac;
+	}
+
+	platform_device_register(&ar9xxx_wmac_device);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-ar9xxx-wmac.h linux-2.6.39/arch/mips/ar71xx/dev-ar9xxx-wmac.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-ar9xxx-wmac.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-ar9xxx-wmac.h	2011-08-24 02:41:55.297981663 +0200
@@ -0,0 +1,20 @@
+/*
+ *  Atheros AR9XXX SoCs built-in WMAC device support
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15/2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_AR9XXX_WMAC_H
+#define _AR71XX_DEV_AR9XXX_WMAC_H
+
+void ar9xxx_add_device_wmac(u8 *cal_data, u8 *mac_addr) __init;
+
+#endif /* _AR71XX_DEV_AR9XXX_WMAC_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-db120-pci.c linux-2.6.39/arch/mips/ar71xx/dev-db120-pci.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-db120-pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-db120-pci.c	2011-08-24 02:41:55.317990461 +0200
@@ -0,0 +1,31 @@
+/*
+ *  Atheros db120 reference board PCI initialization
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *
+ *  Parts of this file are based on Atheros linux 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-db120-pci.h"
+
+static struct ar71xx_pci_irq db120_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}
+};
+
+void __init db120_pci_init(void)
+{
+	ar71xx_pci_init(ARRAY_SIZE(db120_pci_irqs), db120_pci_irqs);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-db120-pci.h linux-2.6.39/arch/mips/ar71xx/dev-db120-pci.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-db120-pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-db120-pci.h	2011-08-24 02:41:55.327990934 +0200
@@ -0,0 +1,22 @@
+/*
+ *  Atheros DB120 reference board PCI initialization
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *
+ *  Parts of this file are based on Atheros linux 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_DB120_PCI_H
+#define _AR71XX_DEV_DB120_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_DB120_PCI)
+void db120_pci_init(void);
+#else
+static inline void db120_pci_init(void) { }
+#endif
+
+#endif /* _AR71XX_DEV_DB120_PCI_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-dsa.c linux-2.6.39/arch/mips/ar71xx/dev-dsa.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-dsa.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-dsa.c	2011-08-24 02:41:55.337990441 +0200
@@ -0,0 +1,50 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "devices.h"
+#include "dev-dsa.h"
+
+static struct platform_device ar71xx_dsa_switch_device = {
+	.name		= "dsa",
+	.id		= 0,
+};
+
+void __init ar71xx_add_device_dsa(unsigned int id,
+				  struct dsa_platform_data *d)
+{
+	int i;
+
+	switch (id) {
+	case 0:
+		d->netdev = &ar71xx_eth0_device.dev;
+		break;
+	case 1:
+		d->netdev = &ar71xx_eth1_device.dev;
+		break;
+	default:
+		printk(KERN_ERR
+			"ar71xx: invalid ethernet id %d for DSA switch\n",
+			id);
+		return;
+	}
+
+	for (i = 0; i < d->nr_chips; i++)
+		d->chip[i].mii_bus = &ar71xx_mdio_device.dev;
+
+	ar71xx_dsa_switch_device.dev.platform_data = d;
+
+	platform_device_register(&ar71xx_dsa_switch_device);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-dsa.h linux-2.6.39/arch/mips/ar71xx/dev-dsa.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-dsa.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-dsa.h	2011-08-24 02:41:55.347990727 +0200
@@ -0,0 +1,20 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_DSA_H
+#define _AR71XX_DEV_DSA_H
+
+#include <net/dsa.h>
+
+void ar71xx_add_device_dsa(unsigned int id,
+			   struct dsa_platform_data *d) __init;
+
+#endif /* _AR71XX_DEV_DSA_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-gpio-buttons.c linux-2.6.39/arch/mips/ar71xx/dev-gpio-buttons.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-gpio-buttons.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-gpio-buttons.c	2011-08-24 02:41:55.347990727 +0200
@@ -0,0 +1,58 @@
+/*
+ *  Atheros AR71xx GPIO button support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "linux/init.h"
+#include "linux/slab.h"
+#include <linux/platform_device.h>
+
+#include "dev-gpio-buttons.h"
+
+void __init ar71xx_register_gpio_keys_polled(int id,
+					     unsigned poll_interval,
+					     unsigned nbuttons,
+					     struct gpio_keys_button *buttons)
+{
+	struct platform_device *pdev;
+	struct gpio_keys_platform_data pdata;
+	struct gpio_keys_button *p;
+	int err;
+
+	p = kmalloc(nbuttons * sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return;
+
+	memcpy(p, buttons, nbuttons * sizeof(*p));
+
+	pdev = platform_device_alloc("gpio-keys-polled", id);
+	if (!pdev)
+		goto err_free_buttons;
+
+	memset(&pdata, 0, sizeof(pdata));
+	pdata.poll_interval = poll_interval;
+	pdata.nbuttons = nbuttons;
+	pdata.buttons = p;
+
+	err = platform_device_add_data(pdev, &pdata, sizeof(pdata));
+	if (err)
+		goto err_put_pdev;
+
+	err = platform_device_add(pdev);
+	if (err)
+		goto err_put_pdev;
+
+	return;
+
+err_put_pdev:
+	platform_device_put(pdev);
+
+err_free_buttons:
+	kfree(p);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-gpio-buttons.h linux-2.6.39/arch/mips/ar71xx/dev-gpio-buttons.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-gpio-buttons.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-gpio-buttons.h	2011-08-24 02:41:55.347990727 +0200
@@ -0,0 +1,23 @@
+/*
+ *  Atheros AR71xx GPIO button support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_GPIO_BUTTONS_H
+#define _AR71XX_DEV_GPIO_BUTTONS_H
+
+#include <linux/input.h>
+#include <linux/gpio_keys.h>
+
+void ar71xx_register_gpio_keys_polled(int id,
+				      unsigned poll_interval,
+				      unsigned nbuttons,
+				      struct gpio_keys_button *buttons);
+
+#endif /* _AR71XX_DEV_GPIO_BUTTONS_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/devices.c linux-2.6.39/arch/mips/ar71xx/devices.c
--- linux-2.6.39.orig/arch/mips/ar71xx/devices.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/devices.c	2011-08-24 02:41:55.347990727 +0200
@@ -0,0 +1,765 @@
+/*
+ *  Atheros AR71xx SoC platform devices
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar933x_uart_platform.h>
+
+#include "devices.h"
+
+unsigned char ar71xx_mac_base[ETH_ALEN] __initdata;
+
+static struct resource ar71xx_uart_resources[] = {
+	{
+		.start	= AR71XX_UART_BASE,
+		.end	= AR71XX_UART_BASE + AR71XX_UART_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+#define AR71XX_UART_FLAGS (UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_IOREMAP)
+static struct plat_serial8250_port ar71xx_uart_data[] = {
+	{
+		.mapbase	= AR71XX_UART_BASE,
+		.irq		= AR71XX_MISC_IRQ_UART,
+		.flags		= AR71XX_UART_FLAGS,
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+	}, {
+		/* terminating entry */
+	}
+};
+
+static struct platform_device ar71xx_uart_device = {
+	.name		= "serial8250",
+	.id		= PLAT8250_DEV_PLATFORM,
+	.resource	= ar71xx_uart_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_uart_resources),
+	.dev = {
+		.platform_data	= ar71xx_uart_data
+	},
+};
+
+static struct resource ar933x_uart_resources[] = {
+	{
+		.start  = AR933X_UART_BASE,
+		.end    = AR933X_UART_BASE + AR71XX_UART_SIZE - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = AR71XX_MISC_IRQ_UART,
+		.end    = AR71XX_MISC_IRQ_UART,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct ar933x_uart_platform_data ar933x_uart_data;
+static struct platform_device ar933x_uart_device = {
+	.name           = "ar933x-uart",
+	.id             = -1,
+	.resource       = ar933x_uart_resources,
+	.num_resources  = ARRAY_SIZE(ar933x_uart_resources),
+	.dev = {
+		.platform_data  = &ar933x_uart_data,
+	},
+};
+
+void __init ar71xx_add_device_uart(void)
+{
+	struct platform_device *pdev;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		pdev = &ar71xx_uart_device;
+		ar71xx_uart_data[0].uartclk = ar71xx_ahb_freq;
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		pdev = &ar933x_uart_device;
+		ar933x_uart_data.uartclk = ar71xx_ref_freq;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		pdev = &ar71xx_uart_device;
+		ar71xx_uart_data[0].uartclk = ar71xx_ref_freq;
+		break;
+
+	default:
+		BUG();
+	}
+
+	platform_device_register(pdev);
+}
+
+static struct resource ar71xx_mdio_resources[] = {
+	{
+		.name	= "mdio_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}
+};
+
+static struct ag71xx_mdio_platform_data ar71xx_mdio_data;
+
+struct platform_device ar71xx_mdio_device = {
+	.name		= "ag71xx-mdio",
+	.id		= -1,
+	.resource	= ar71xx_mdio_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_mdio_resources),
+	.dev = {
+		.platform_data = &ar71xx_mdio_data,
+	},
+};
+
+static void ar71xx_set_pll(u32 cfg_reg, u32 pll_reg, u32 pll_val, u32 shift)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+
+	t = __raw_readl(base + cfg_reg);
+	t &= ~(3 << shift);
+	t |=  (2 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	__raw_writel(pll_val, base + pll_reg);
+
+	t |= (3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	t &= ~(3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	printk(KERN_DEBUG "ar71xx: pll_reg %#x: %#x\n",
+		(unsigned int)(base + pll_reg), __raw_readl(base + pll_reg));
+
+	iounmap(base);
+}
+
+void __init ar71xx_add_device_mdio(u32 phy_mask)
+{
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7240:
+		ar71xx_mdio_data.is_ar7240 = 1;
+		break;
+	case AR71XX_SOC_AR7241:
+		ar71xx_mdio_data.is_ar7240 = 1;
+		ar71xx_mdio_resources[0].start = AR71XX_GE1_BASE;
+		ar71xx_mdio_resources[0].end = AR71XX_GE1_BASE + 0x200 - 1;
+		break;
+	case AR71XX_SOC_AR7242:
+		ar71xx_set_pll(AR71XX_PLL_REG_SEC_CONFIG,
+			       AR7242_PLL_REG_ETH0_INT_CLOCK, 0x62000000,
+			       AR71XX_ETH0_PLL_SHIFT);
+		break;
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ar71xx_mdio_data.is_ar7240 = 1;
+		ar71xx_mdio_resources[0].start = AR71XX_GE1_BASE;
+		ar71xx_mdio_resources[0].end = AR71XX_GE1_BASE + 0x200 - 1;
+		break;
+	default:
+		break;
+	}
+
+	ar71xx_mdio_data.phy_mask = phy_mask;
+
+	platform_device_register(&ar71xx_mdio_device);
+}
+
+struct ar71xx_eth_pll_data ar71xx_eth0_pll_data;
+struct ar71xx_eth_pll_data ar71xx_eth1_pll_data;
+
+static u32 ar71xx_get_eth_pll(unsigned int mac, int speed)
+{
+	struct ar71xx_eth_pll_data *pll_data;
+	u32 pll_val;
+
+	switch (mac) {
+	case 0:
+		pll_data = &ar71xx_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ar71xx_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (speed) {
+	case SPEED_10:
+		pll_val = pll_data->pll_10;
+		break;
+	case SPEED_100:
+		pll_val = pll_data->pll_100;
+		break;
+	case SPEED_1000:
+		pll_val = pll_data->pll_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	return pll_val;
+}
+
+static void ar71xx_set_pll_ge0(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(0, speed);
+
+	ar71xx_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH0_INT_CLOCK,
+			val, AR71XX_ETH0_PLL_SHIFT);
+}
+
+static void ar71xx_set_pll_ge1(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(1, speed);
+
+	ar71xx_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR71XX_ETH1_PLL_SHIFT);
+}
+
+static void ar724x_set_pll_ge0(int speed)
+{
+	/* TODO */
+}
+
+static void ar724x_set_pll_ge1(int speed)
+{
+	/* TODO */
+}
+
+static void ar7242_set_pll_ge0(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(0, speed);
+
+	ar71xx_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR7242_PLL_REG_ETH0_INT_CLOCK,
+		       val, AR71XX_ETH0_PLL_SHIFT);
+}
+
+static void ar91xx_set_pll_ge0(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(0, speed);
+
+	ar71xx_set_pll(AR91XX_PLL_REG_ETH_CONFIG, AR91XX_PLL_REG_ETH0_INT_CLOCK,
+			 val, AR91XX_ETH0_PLL_SHIFT);
+}
+
+static void ar91xx_set_pll_ge1(int speed)
+{
+	u32 val = ar71xx_get_eth_pll(1, speed);
+
+	ar71xx_set_pll(AR91XX_PLL_REG_ETH_CONFIG, AR91XX_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR91XX_ETH1_PLL_SHIFT);
+}
+
+static void ar933x_set_pll_ge0(int speed)
+{
+	/* TODO */
+}
+
+static void ar933x_set_pll_ge1(int speed)
+{
+	/* TODO */
+}
+
+static void ar71xx_ddr_flush_ge0(void)
+{
+	ar71xx_ddr_flush(AR71XX_DDR_REG_FLUSH_GE0);
+}
+
+static void ar71xx_ddr_flush_ge1(void)
+{
+	ar71xx_ddr_flush(AR71XX_DDR_REG_FLUSH_GE1);
+}
+
+static void ar724x_ddr_flush_ge0(void)
+{
+	ar71xx_ddr_flush(AR724X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar724x_ddr_flush_ge1(void)
+{
+	ar71xx_ddr_flush(AR724X_DDR_REG_FLUSH_GE1);
+}
+
+static void ar91xx_ddr_flush_ge0(void)
+{
+	ar71xx_ddr_flush(AR91XX_DDR_REG_FLUSH_GE0);
+}
+
+static void ar91xx_ddr_flush_ge1(void)
+{
+	ar71xx_ddr_flush(AR91XX_DDR_REG_FLUSH_GE1);
+}
+
+static void ar933x_ddr_flush_ge0(void)
+{
+	ar71xx_ddr_flush(AR933X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar933x_ddr_flush_ge1(void)
+{
+	ar71xx_ddr_flush(AR933X_DDR_REG_FLUSH_GE1);
+}
+
+static struct resource ar71xx_eth0_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}, {
+		.name	= "mii_ctrl",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_MII_BASE + MII_REG_MII0_CTRL,
+		.end	= AR71XX_MII_BASE + MII_REG_MII0_CTRL + 3,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= AR71XX_CPU_IRQ_GE0,
+		.end	= AR71XX_CPU_IRQ_GE0,
+	},
+};
+
+struct ag71xx_platform_data ar71xx_eth0_data = {
+	.reset_bit	= RESET_MODULE_GE0_MAC,
+};
+
+struct platform_device ar71xx_eth0_device = {
+	.name		= "ag71xx",
+	.id		= 0,
+	.resource	= ar71xx_eth0_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_eth0_resources),
+	.dev = {
+		.platform_data = &ar71xx_eth0_data,
+	},
+};
+
+static struct resource ar71xx_eth1_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE1_BASE,
+		.end	= AR71XX_GE1_BASE + 0x200 - 1,
+	}, {
+		.name	= "mii_ctrl",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_MII_BASE + MII_REG_MII1_CTRL,
+		.end	= AR71XX_MII_BASE + MII_REG_MII1_CTRL + 3,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= AR71XX_CPU_IRQ_GE1,
+		.end	= AR71XX_CPU_IRQ_GE1,
+	},
+};
+
+struct ag71xx_platform_data ar71xx_eth1_data = {
+	.reset_bit	= RESET_MODULE_GE1_MAC,
+};
+
+struct platform_device ar71xx_eth1_device = {
+	.name		= "ag71xx",
+	.id		= 1,
+	.resource	= ar71xx_eth1_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_eth1_resources),
+	.dev = {
+		.platform_data = &ar71xx_eth1_data,
+	},
+};
+
+#define AR71XX_PLL_VAL_1000	0x00110000
+#define AR71XX_PLL_VAL_100	0x00001099
+#define AR71XX_PLL_VAL_10	0x00991099
+
+#define AR724X_PLL_VAL_1000	0x00110000
+#define AR724X_PLL_VAL_100	0x00001099
+#define AR724X_PLL_VAL_10	0x00991099
+
+#define AR7242_PLL_VAL_1000	0x1c000000
+#define AR7242_PLL_VAL_100	0x00000101
+#define AR7242_PLL_VAL_10	0x00001616
+
+#define AR91XX_PLL_VAL_1000	0x1a000000
+#define AR91XX_PLL_VAL_100	0x13000a44
+#define AR91XX_PLL_VAL_10	0x00441099
+
+#define AR933X_PLL_VAL_1000	0x00110000
+#define AR933X_PLL_VAL_100	0x00001099
+#define AR933X_PLL_VAL_10	0x00991099
+
+static void __init ar71xx_init_eth_pll_data(unsigned int id)
+{
+	struct ar71xx_eth_pll_data *pll_data;
+	u32 pll_10, pll_100, pll_1000;
+
+	switch (id) {
+	case 0:
+		pll_data = &ar71xx_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ar71xx_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		pll_10 = AR71XX_PLL_VAL_10;
+		pll_100 = AR71XX_PLL_VAL_100;
+		pll_1000 = AR71XX_PLL_VAL_1000;
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+		pll_10 = AR724X_PLL_VAL_10;
+		pll_100 = AR724X_PLL_VAL_100;
+		pll_1000 = AR724X_PLL_VAL_1000;
+		break;
+
+	case AR71XX_SOC_AR7242:
+		pll_10 = AR7242_PLL_VAL_10;
+		pll_100 = AR7242_PLL_VAL_100;
+		pll_1000 = AR7242_PLL_VAL_1000;
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		pll_10 = AR91XX_PLL_VAL_10;
+		pll_100 = AR91XX_PLL_VAL_100;
+		pll_1000 = AR91XX_PLL_VAL_1000;
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		pll_10 = AR933X_PLL_VAL_10;
+		pll_100 = AR933X_PLL_VAL_100;
+		pll_1000 = AR933X_PLL_VAL_1000;
+		break;
+
+	default:
+		BUG();
+	}
+
+	if (!pll_data->pll_10)
+		pll_data->pll_10 = pll_10;
+
+	if (!pll_data->pll_100)
+		pll_data->pll_100 = pll_100;
+
+	if (!pll_data->pll_1000)
+		pll_data->pll_1000 = pll_1000;
+}
+
+static int ar71xx_eth_instance __initdata;
+void __init ar71xx_add_device_eth(unsigned int id)
+{
+	struct platform_device *pdev;
+	struct ag71xx_platform_data *pdata;
+
+	ar71xx_init_eth_pll_data(id);
+
+	switch (id) {
+	case 0:
+		switch (ar71xx_eth0_data.phy_if_mode) {
+		case PHY_INTERFACE_MODE_MII:
+			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_MII;
+			break;
+		case PHY_INTERFACE_MODE_GMII:
+			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_GMII;
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_RGMII;
+			break;
+		case PHY_INTERFACE_MODE_RMII:
+			ar71xx_eth0_data.mii_if = MII0_CTRL_IF_RMII;
+			break;
+		default:
+			printk(KERN_ERR "ar71xx: invalid PHY interface mode "
+					"for eth0\n");
+			return;
+		}
+		pdev = &ar71xx_eth0_device;
+		break;
+	case 1:
+		switch (ar71xx_eth1_data.phy_if_mode) {
+		case PHY_INTERFACE_MODE_RMII:
+			ar71xx_eth1_data.mii_if = MII1_CTRL_IF_RMII;
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			ar71xx_eth1_data.mii_if = MII1_CTRL_IF_RGMII;
+			break;
+		default:
+			printk(KERN_ERR "ar71xx: invalid PHY interface mode "
+					"for eth1\n");
+			return;
+		}
+		pdev = &ar71xx_eth1_device;
+		break;
+	default:
+		printk(KERN_ERR "ar71xx: invalid ethernet id %d\n", id);
+		return;
+	}
+
+	pdata = pdev->dev.platform_data;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+		pdata->ddr_flush = id ? ar71xx_ddr_flush_ge1
+				      : ar71xx_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar71xx_set_pll_ge1
+				     : ar71xx_set_pll_ge0;
+		break;
+
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		pdata->ddr_flush = id ? ar71xx_ddr_flush_ge1
+				      : ar71xx_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar71xx_set_pll_ge1
+				     : ar71xx_set_pll_ge0;
+		pdata->has_gbit = 1;
+		break;
+
+	case AR71XX_SOC_AR7242:
+		ar71xx_eth0_data.reset_bit |= AR724X_RESET_GE0_MDIO |
+					      RESET_MODULE_GE0_PHY;
+		ar71xx_eth1_data.reset_bit |= AR724X_RESET_GE1_MDIO |
+					      RESET_MODULE_GE1_PHY;
+		pdata->ddr_flush = id ? ar724x_ddr_flush_ge1
+				      : ar724x_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar724x_set_pll_ge1
+				     : ar7242_set_pll_ge0;
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case AR71XX_SOC_AR7241:
+		ar71xx_eth0_data.reset_bit |= AR724X_RESET_GE0_MDIO;
+		ar71xx_eth1_data.reset_bit |= AR724X_RESET_GE1_MDIO;
+		/* fall through */
+	case AR71XX_SOC_AR7240:
+		ar71xx_eth0_data.reset_bit |= RESET_MODULE_GE0_PHY;
+		ar71xx_eth1_data.reset_bit |= RESET_MODULE_GE1_PHY;
+		pdata->ddr_flush = id ? ar724x_ddr_flush_ge1
+				      : ar724x_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar724x_set_pll_ge1
+				     : ar724x_set_pll_ge0;
+		pdata->is_ar724x = 1;
+		if (ar71xx_soc == AR71XX_SOC_AR7240)
+			pdata->is_ar7240 = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case AR71XX_SOC_AR9130:
+		pdata->ddr_flush = id ? ar91xx_ddr_flush_ge1
+				      : ar91xx_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar91xx_set_pll_ge1
+				     : ar91xx_set_pll_ge0;
+		pdata->is_ar91xx = 1;
+		break;
+
+	case AR71XX_SOC_AR9132:
+		pdata->ddr_flush = id ? ar91xx_ddr_flush_ge1
+				      : ar91xx_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar91xx_set_pll_ge1
+				      : ar91xx_set_pll_ge0;
+		pdata->is_ar91xx = 1;
+		pdata->has_gbit = 1;
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ar71xx_eth0_data.reset_bit = AR933X_RESET_GE0_MAC |
+					     AR933X_RESET_GE0_MDIO;
+		ar71xx_eth1_data.reset_bit = AR933X_RESET_GE1_MAC |
+					     AR933X_RESET_GE1_MDIO;
+		pdata->ddr_flush = id ? ar933x_ddr_flush_ge1
+				      : ar933x_ddr_flush_ge0;
+		pdata->set_pll =  id ? ar933x_set_pll_ge1
+				     : ar933x_set_pll_ge0;
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	default:
+		BUG();
+	}
+
+	switch (pdata->phy_if_mode) {
+	case PHY_INTERFACE_MODE_GMII:
+	case PHY_INTERFACE_MODE_RGMII:
+		if (!pdata->has_gbit) {
+			printk(KERN_ERR "ar71xx: no gbit available on eth%d\n",
+					id);
+			return;
+		}
+		/* fallthrough */
+	default:
+		break;
+	}
+
+	if (!is_valid_ether_addr(pdata->mac_addr)) {
+		random_ether_addr(pdata->mac_addr);
+		printk(KERN_DEBUG
+			"ar71xx: using random MAC address for eth%d\n",
+			ar71xx_eth_instance);
+	}
+
+	if (pdata->mii_bus_dev == NULL)
+		pdata->mii_bus_dev = &ar71xx_mdio_device.dev;
+
+	/* Reset the device */
+	ar71xx_device_stop(pdata->reset_bit);
+	mdelay(100);
+
+	ar71xx_device_start(pdata->reset_bit);
+	mdelay(100);
+
+	platform_device_register(pdev);
+	ar71xx_eth_instance++;
+}
+
+static struct resource ar71xx_spi_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ar71xx_spi_device = {
+	.name		= "ar71xx-spi",
+	.id		= -1,
+	.resource	= ar71xx_spi_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_spi_resources),
+};
+
+void __init ar71xx_add_device_spi(struct ar71xx_spi_platform_data *pdata,
+				struct spi_board_info const *info,
+				unsigned n)
+{
+	spi_register_board_info(info, n);
+	ar71xx_spi_device.dev.platform_data = pdata;
+	platform_device_register(&ar71xx_spi_device);
+}
+
+void __init ar71xx_add_device_wdt(void)
+{
+	platform_device_register_simple("ar71xx-wdt", -1, NULL, 0);
+}
+
+void __init ar71xx_set_mac_base(unsigned char *mac)
+{
+	memcpy(ar71xx_mac_base, mac, ETH_ALEN);
+}
+
+void __init ar71xx_parse_mac_addr(char *mac_str)
+{
+	u8 tmp[ETH_ALEN];
+	int t;
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+			&tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]);
+
+	if (t != ETH_ALEN)
+		t = sscanf(mac_str, "%02hhx.%02hhx.%02hhx.%02hhx.%02hhx.%02hhx",
+			&tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]);
+
+	if (t == ETH_ALEN)
+		ar71xx_set_mac_base(tmp);
+	else
+		printk(KERN_DEBUG "ar71xx: failed to parse mac address "
+				"\"%s\"\n", mac_str);
+}
+
+static int __init ar71xx_ethaddr_setup(char *str)
+{
+	ar71xx_parse_mac_addr(str);
+	return 1;
+}
+__setup("ethaddr=", ar71xx_ethaddr_setup);
+
+static int __init ar71xx_kmac_setup(char *str)
+{
+	ar71xx_parse_mac_addr(str);
+	return 1;
+}
+__setup("kmac=", ar71xx_kmac_setup);
+
+void __init ar71xx_init_mac(unsigned char *dst, const unsigned char *src,
+			    unsigned offset)
+{
+	u32 t;
+
+	if (!is_valid_ether_addr(src)) {
+		memset(dst, '\0', ETH_ALEN);
+		return;
+	}
+
+	t = (((u32) src[3]) << 16) + (((u32) src[4]) << 8) + ((u32) src[5]);
+	t += offset;
+
+	dst[0] = src[0];
+	dst[1] = src[1];
+	dst[2] = src[2];
+	dst[3] = (t >> 16) & 0xff;
+	dst[4] = (t >> 8) & 0xff;
+	dst[5] = t & 0xff;
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/devices.h linux-2.6.39/arch/mips/ar71xx/devices.h
--- linux-2.6.39.orig/arch/mips/ar71xx/devices.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/devices.h	2011-08-24 02:41:55.347990727 +0200
@@ -0,0 +1,50 @@
+/*
+ *  Atheros AR71xx SoC device definitions
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __AR71XX_DEVICES_H
+#define __AR71XX_DEVICES_H
+
+#include <asm/mach-ar71xx/platform.h>
+
+struct platform_device;
+
+void ar71xx_add_device_spi(struct ar71xx_spi_platform_data *pdata,
+			   struct spi_board_info const *info,
+			   unsigned n) __init;
+
+extern unsigned char ar71xx_mac_base[] __initdata;
+void ar71xx_parse_mac_addr(char *mac_str) __init;
+void ar71xx_init_mac(unsigned char *dst, const unsigned char *src,
+		     unsigned offset) __init;
+
+struct ar71xx_eth_pll_data {
+	u32	pll_10;
+	u32	pll_100;
+	u32	pll_1000;
+};
+
+extern struct ar71xx_eth_pll_data ar71xx_eth0_pll_data;
+extern struct ar71xx_eth_pll_data ar71xx_eth1_pll_data;
+
+extern struct ag71xx_platform_data ar71xx_eth0_data;
+extern struct ag71xx_platform_data ar71xx_eth1_data;
+extern struct platform_device ar71xx_eth0_device;
+extern struct platform_device ar71xx_eth1_device;
+void ar71xx_add_device_eth(unsigned int id) __init;
+
+extern struct platform_device ar71xx_mdio_device;
+void ar71xx_add_device_mdio(u32 phy_mask) __init;
+
+void ar71xx_add_device_uart(void) __init;
+
+void ar71xx_add_device_wdt(void) __init;
+
+#endif /* __AR71XX_DEVICES_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-leds-gpio.c linux-2.6.39/arch/mips/ar71xx/dev-leds-gpio.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-leds-gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-leds-gpio.c	2011-08-24 02:41:55.347990727 +0200
@@ -0,0 +1,57 @@
+/*
+ *  Atheros AR71xx GPIO LED device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#include "dev-leds-gpio.h"
+
+void __init ar71xx_add_device_leds_gpio(int id, unsigned num_leds,
+					struct gpio_led *leds)
+{
+	struct platform_device *pdev;
+	struct gpio_led_platform_data pdata;
+	struct gpio_led *p;
+	int err;
+
+	p = kmalloc(num_leds * sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return;
+
+	memcpy(p, leds, num_leds * sizeof(*p));
+
+	pdev = platform_device_alloc("leds-gpio", id);
+	if (!pdev)
+		goto err_free_leds;
+
+	memset(&pdata, 0, sizeof(pdata));
+	pdata.num_leds = num_leds;
+	pdata.leds = p;
+
+	err = platform_device_add_data(pdev, &pdata, sizeof(pdata));
+	if (err)
+		goto err_put_pdev;
+
+	err = platform_device_add(pdev);
+	if (err)
+		goto err_put_pdev;
+
+	return;
+
+err_put_pdev:
+	platform_device_put(pdev);
+
+err_free_leds:
+	kfree(p);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-leds-gpio.h linux-2.6.39/arch/mips/ar71xx/dev-leds-gpio.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-leds-gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-leds-gpio.h	2011-08-24 02:41:55.367990903 +0200
@@ -0,0 +1,21 @@
+/*
+ *  Atheros AR71xx GPIO LED device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_LEDS_GPIO_H
+#define _AR71XX_DEV_LEDS_GPIO_H
+
+#include <linux/leds.h>
+
+void ar71xx_add_device_leds_gpio(int id,
+				 unsigned num_leds,
+				 struct gpio_led *leds) __init;
+
+#endif /* _AR71XX_DEV_LEDS_GPIO_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-m25p80.c linux-2.6.39/arch/mips/ar71xx/dev-m25p80.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-m25p80.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-m25p80.c	2011-08-24 02:41:55.367990903 +0200
@@ -0,0 +1,30 @@
+/*
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+#include "devices.h"
+#include "dev-m25p80.h"
+
+static struct spi_board_info ar71xx_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+	}
+};
+
+void __init ar71xx_add_device_m25p80(struct flash_platform_data *pdata)
+{
+	ar71xx_spi_info[0].platform_data = pdata;
+	ar71xx_add_device_spi(NULL, ar71xx_spi_info,
+			      ARRAY_SIZE(ar71xx_spi_info));
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-m25p80.h linux-2.6.39/arch/mips/ar71xx/dev-m25p80.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-m25p80.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-m25p80.h	2011-08-24 02:41:55.377990515 +0200
@@ -0,0 +1,16 @@
+/*
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_M25P80_H
+#define _AR71XX_DEV_M25P80_H
+
+#include <linux/spi/flash.h>
+
+void ar71xx_add_device_m25p80(struct flash_platform_data *pdata) __init;
+
+#endif /* _AR71XX_DEV_M25P80_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-pb42-pci.c linux-2.6.39/arch/mips/ar71xx/dev-pb42-pci.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-pb42-pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-pb42-pci.c	2011-08-24 02:41:55.377990515 +0200
@@ -0,0 +1,40 @@
+/*
+ *  Atheros PB42 reference board PCI initialization
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-pb42-pci.h"
+
+static struct ar71xx_pci_irq pb42_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}, {
+		.slot	= 1,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV1,
+	}, {
+		.slot	= 2,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV2,
+	}
+};
+
+void __init pb42_pci_init(void)
+{
+	ar71xx_pci_init(ARRAY_SIZE(pb42_pci_irqs), pb42_pci_irqs);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-pb42-pci.h linux-2.6.39/arch/mips/ar71xx/dev-pb42-pci.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-pb42-pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-pb42-pci.h	2011-08-24 02:41:55.387991243 +0200
@@ -0,0 +1,21 @@
+/*
+ *  Atheros PB42 reference board PCI initialization
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_PB42_PCI_H
+#define _AR71XX_DEV_PB42_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_PB42_PCI)
+void pb42_pci_init(void) __init;
+#else
+static inline void pb42_pci_init(void) { }
+#endif
+
+#endif /* _AR71XX_DEV_PB42_PCI_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-pb9x-pci.c linux-2.6.39/arch/mips/ar71xx/dev-pb9x-pci.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-pb9x-pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-pb9x-pci.c	2011-08-24 02:41:55.387991243 +0200
@@ -0,0 +1,33 @@
+/*
+ *  Atheros PB9x reference board PCI initialization
+ *
+ *  Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "dev-pb9x-pci.h"
+
+static struct ar71xx_pci_irq pb9x_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}
+};
+
+void __init pb9x_pci_init(void)
+{
+	ar71xx_pci_init(ARRAY_SIZE(pb9x_pci_irqs), pb9x_pci_irqs);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-pb9x-pci.h linux-2.6.39/arch/mips/ar71xx/dev-pb9x-pci.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-pb9x-pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-pb9x-pci.h	2011-08-24 02:41:55.387991243 +0200
@@ -0,0 +1,22 @@
+/*
+ *  Atheros PB9x reference board PCI initialization
+ *
+ *  Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_PB9X_PCI_H
+#define _AR71XX_DEV_PB9X_PCI_H
+
+#if defined(CONFIG_AR71XX_DEV_PB9X_PCI)
+void pb9x_pci_init(void) __init;
+#else
+static inline void pb9x_pci_init(void) { }
+#endif
+
+#endif /* _AR71XX_DEV_PB9X_PCI_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-usb.c linux-2.6.39/arch/mips/ar71xx/dev-usb.c
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-usb.c	2011-08-24 02:41:55.417990329 +0200
@@ -0,0 +1,199 @@
+/*
+ *  Atheros AR71xx USB host device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/platform.h>
+
+#include "dev-usb.h"
+
+/*
+ * OHCI (USB full speed host controller)
+ */
+static struct resource ar71xx_ohci_resources[] = {
+	[0] = {
+		.start	= AR71XX_OHCI_BASE,
+		.end	= AR71XX_OHCI_BASE + AR71XX_OHCI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AR71XX_MISC_IRQ_OHCI,
+		.end	= AR71XX_MISC_IRQ_OHCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ar7240_ohci_resources[] = {
+	[0] = {
+		.start	= AR7240_OHCI_BASE,
+		.end	= AR7240_OHCI_BASE + AR7240_OHCI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AR71XX_CPU_IRQ_USB,
+		.end	= AR71XX_CPU_IRQ_USB,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ar71xx_ohci_dmamask = DMA_BIT_MASK(32);
+static struct platform_device ar71xx_ohci_device = {
+	.name		= "ar71xx-ohci",
+	.id		= -1,
+	.resource	= ar71xx_ohci_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_ohci_resources),
+	.dev = {
+		.dma_mask		= &ar71xx_ohci_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+};
+
+/*
+ * EHCI (USB high/full speed host controller)
+ */
+static struct resource ar71xx_ehci_resources[] = {
+	[0] = {
+		.start	= AR71XX_EHCI_BASE,
+		.end	= AR71XX_EHCI_BASE + AR71XX_EHCI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AR71XX_CPU_IRQ_USB,
+		.end	= AR71XX_CPU_IRQ_USB,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ar71xx_ehci_dmamask = DMA_BIT_MASK(32);
+static struct ar71xx_ehci_platform_data ar71xx_ehci_data;
+
+static struct platform_device ar71xx_ehci_device = {
+	.name		= "ar71xx-ehci",
+	.id		= -1,
+	.resource	= ar71xx_ehci_resources,
+	.num_resources	= ARRAY_SIZE(ar71xx_ehci_resources),
+	.dev = {
+		.dma_mask		= &ar71xx_ehci_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &ar71xx_ehci_data,
+	},
+};
+
+#define AR71XX_USB_RESET_MASK \
+	(RESET_MODULE_USB_HOST | RESET_MODULE_USB_PHY \
+	| RESET_MODULE_USB_OHCI_DLL)
+
+#define AR7240_USB_RESET_MASK \
+	(RESET_MODULE_USB_HOST | RESET_MODULE_USB_OHCI_DLL_7240)
+
+static void __init ar71xx_usb_setup(void)
+{
+	ar71xx_device_stop(AR71XX_USB_RESET_MASK);
+	mdelay(1000);
+	ar71xx_device_start(AR71XX_USB_RESET_MASK);
+
+	/* Turning on the Buff and Desc swap bits */
+	ar71xx_usb_ctrl_wr(USB_CTRL_REG_CONFIG, 0xf0000);
+
+	/* WAR for HW bug. Here it adjusts the duration between two SOFS */
+	ar71xx_usb_ctrl_wr(USB_CTRL_REG_FLADJ, 0x20c00);
+
+	mdelay(900);
+
+	platform_device_register(&ar71xx_ohci_device);
+	platform_device_register(&ar71xx_ehci_device);
+}
+
+static void __init ar7240_usb_setup(void)
+{
+	ar71xx_device_stop(AR7240_USB_RESET_MASK);
+	mdelay(1000);
+	ar71xx_device_start(AR7240_USB_RESET_MASK);
+
+	/* WAR for HW bug. Here it adjusts the duration between two SOFS */
+	ar71xx_usb_ctrl_wr(USB_CTRL_REG_FLADJ, 0x3);
+
+	ar71xx_ohci_device.resource = ar7240_ohci_resources;
+	ar71xx_ohci_device.num_resources = ARRAY_SIZE(ar7240_ohci_resources);
+	platform_device_register(&ar71xx_ohci_device);
+}
+
+static void __init ar7241_usb_setup(void)
+{
+	ar71xx_device_start(AR724X_RESET_USBSUS_OVERRIDE);
+	mdelay(10);
+
+	ar71xx_device_start(AR724X_RESET_USB_HOST);
+	mdelay(10);
+
+	ar71xx_device_start(AR724X_RESET_USB_PHY);
+	mdelay(10);
+
+	ar71xx_ehci_data.is_ar91xx = 1;
+	ar71xx_ehci_device.resource = ar7240_ohci_resources;
+	ar71xx_ehci_device.num_resources = ARRAY_SIZE(ar7240_ohci_resources);
+	platform_device_register(&ar71xx_ehci_device);
+}
+
+static void __init ar91xx_usb_setup(void)
+{
+	ar71xx_device_stop(RESET_MODULE_USBSUS_OVERRIDE);
+	mdelay(10);
+
+	ar71xx_device_start(RESET_MODULE_USB_HOST);
+	mdelay(10);
+
+	ar71xx_device_start(RESET_MODULE_USB_PHY);
+	mdelay(10);
+
+	ar71xx_ehci_data.is_ar91xx = 1;
+	platform_device_register(&ar71xx_ehci_device);
+}
+
+void __init ar71xx_add_device_usb(void)
+{
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7240:
+		ar7240_usb_setup();
+		break;
+
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ar7241_usb_setup();
+		break;
+
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ar71xx_usb_setup();
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar91xx_usb_setup();
+		break;
+
+	default:
+		BUG();
+	}
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/dev-usb.h linux-2.6.39/arch/mips/ar71xx/dev-usb.h
--- linux-2.6.39.orig/arch/mips/ar71xx/dev-usb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/dev-usb.h	2011-08-24 02:41:55.427989786 +0200
@@ -0,0 +1,17 @@
+/*
+ *  Atheros AR71xx USB host device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_DEV_USB_H
+#define _AR71XX_DEV_USB_H
+
+void ar71xx_add_device_usb(void) __init;
+
+#endif /* _AR71XX_DEV_USB_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/early_printk.c linux-2.6.39/arch/mips/ar71xx/early_printk.c
--- linux-2.6.39.orig/arch/mips/ar71xx/early_printk.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/early_printk.c	2011-08-24 02:41:55.427989786 +0200
@@ -0,0 +1,96 @@
+/*
+ *  Atheros AR7xxx/AR9xxx SoC early printk support
+ *
+ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/serial_reg.h>
+#include <asm/addrspace.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar933x_uart.h>
+
+static void (*_prom_putchar) (unsigned char);
+
+static inline void prom_putchar_wait(void __iomem *reg, u32 mask, u32 val)
+{
+	u32 t;
+
+	do {
+		t = __raw_readl(reg);
+		if ((t & mask) == val)
+			break;
+	} while (1);
+}
+
+static void prom_putchar_ar71xx(unsigned char ch)
+{
+	void __iomem *base = (void __iomem *)(KSEG1ADDR(AR71XX_UART_BASE));
+
+	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);
+	__raw_writel(ch, base + UART_TX * 4);
+	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);
+}
+
+static void prom_putchar_ar933x(unsigned char ch)
+{
+	void __iomem *base = (void __iomem *)(KSEG1ADDR(AR933X_UART_BASE));
+
+	prom_putchar_wait(base + AR933X_UART_DATA_REG, AR933X_UART_DATA_TX_CSR,
+			  AR933X_UART_DATA_TX_CSR);
+	__raw_writel(AR933X_UART_DATA_TX_CSR | ch, base + AR933X_UART_DATA_REG);
+	prom_putchar_wait(base + AR933X_UART_DATA_REG, AR933X_UART_DATA_TX_CSR,
+			  AR933X_UART_DATA_TX_CSR);
+}
+
+static void prom_putchar_dummy(unsigned char ch)
+{
+	/* nothing to do */
+}
+
+static void prom_putchar_init(void)
+{
+	void __iomem *base;
+	u32 id;
+
+	base = (void __iomem *)(KSEG1ADDR(AR71XX_RESET_BASE));
+	id = __raw_readl(base + AR71XX_RESET_REG_REV_ID);
+	id &= REV_ID_MAJOR_MASK;
+
+	switch (id) {
+	case REV_ID_MAJOR_AR71XX:
+	case REV_ID_MAJOR_AR7240:
+	case REV_ID_MAJOR_AR7241:
+	case REV_ID_MAJOR_AR7242:
+	case REV_ID_MAJOR_AR913X:
+	case REV_ID_MAJOR_AR9341:
+	case REV_ID_MAJOR_AR9342:
+	case REV_ID_MAJOR_AR9344:
+		_prom_putchar = prom_putchar_ar71xx;
+		break;
+
+	case REV_ID_MAJOR_AR9330:
+	case REV_ID_MAJOR_AR9331:
+		_prom_putchar = prom_putchar_ar933x;
+		break;
+
+	default:
+		_prom_putchar = prom_putchar_dummy;
+		break;
+	}
+}
+
+void prom_putchar(unsigned char ch)
+{
+	if (!_prom_putchar)
+		prom_putchar_init();
+
+	_prom_putchar(ch);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/gpio.c linux-2.6.39/arch/mips/ar71xx/gpio.c
--- linux-2.6.39.orig/arch/mips/ar71xx/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/gpio.c	2011-08-24 02:41:55.457989607 +0200
@@ -0,0 +1,193 @@
+/*
+ *  Atheros AR7XXX/AR9XXX SoC GPIO API support
+ *
+ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+static DEFINE_SPINLOCK(ar71xx_gpio_lock);
+
+unsigned long ar71xx_gpio_count;
+EXPORT_SYMBOL(ar71xx_gpio_count);
+
+void __ar71xx_gpio_set_value(unsigned gpio, int value)
+{
+	void __iomem *base = ar71xx_gpio_base;
+
+	if (value)
+		__raw_writel(1 << gpio, base + GPIO_REG_SET);
+	else
+		__raw_writel(1 << gpio, base + GPIO_REG_CLEAR);
+}
+EXPORT_SYMBOL(__ar71xx_gpio_set_value);
+
+int __ar71xx_gpio_get_value(unsigned gpio)
+{
+	return (__raw_readl(ar71xx_gpio_base + GPIO_REG_IN) >> gpio) & 1;
+}
+EXPORT_SYMBOL(__ar71xx_gpio_get_value);
+
+static int ar71xx_gpio_get_value(struct gpio_chip *chip, unsigned offset)
+{
+	return __ar71xx_gpio_get_value(offset);
+}
+
+static void ar71xx_gpio_set_value(struct gpio_chip *chip,
+				  unsigned offset, int value)
+{
+	__ar71xx_gpio_set_value(offset, value);
+}
+
+static int ar71xx_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) & ~(1 << offset),
+		     base + GPIO_REG_OE);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+
+	return 0;
+}
+
+static int ar71xx_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	if (value)
+		__raw_writel(1 << offset, base + GPIO_REG_SET);
+	else
+		__raw_writel(1 << offset, base + GPIO_REG_CLEAR);
+
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) | (1 << offset),
+		     base + GPIO_REG_OE);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+
+	return 0;
+}
+
+static struct gpio_chip ar71xx_gpio_chip = {
+	.label			= "ar71xx",
+	.get			= ar71xx_gpio_get_value,
+	.set			= ar71xx_gpio_set_value,
+	.direction_input	= ar71xx_gpio_direction_input,
+	.direction_output	= ar71xx_gpio_direction_output,
+	.base			= 0,
+	.ngpio			= AR71XX_GPIO_COUNT,
+};
+
+void ar71xx_gpio_function_enable(u32 mask)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	__raw_writel(__raw_readl(base + GPIO_REG_FUNC) | mask,
+		     base + GPIO_REG_FUNC);
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_FUNC);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+}
+
+void ar71xx_gpio_function_disable(u32 mask)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	__raw_writel(__raw_readl(base + GPIO_REG_FUNC) & ~mask,
+		     base + GPIO_REG_FUNC);
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_FUNC);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+}
+
+void ar71xx_gpio_function_setup(u32 set, u32 clear)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar71xx_gpio_lock, flags);
+
+	__raw_writel((__raw_readl(base + GPIO_REG_FUNC) & ~clear) | set,
+		     base + GPIO_REG_FUNC);
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_FUNC);
+
+	spin_unlock_irqrestore(&ar71xx_gpio_lock, flags);
+}
+EXPORT_SYMBOL(ar71xx_gpio_function_setup);
+
+void __init ar71xx_gpio_init(void)
+{
+	int err;
+
+	if (!request_mem_region(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE,
+				"AR71xx GPIO controller"))
+		panic("cannot allocate AR71xx GPIO registers page");
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ar71xx_gpio_chip.ngpio = AR71XX_GPIO_COUNT;
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ar71xx_gpio_chip.ngpio = AR724X_GPIO_COUNT;
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		ar71xx_gpio_chip.ngpio = AR91XX_GPIO_COUNT;
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ar71xx_gpio_chip.ngpio = AR933X_GPIO_COUNT;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar71xx_gpio_chip.ngpio = AR934X_GPIO_COUNT;
+		break;
+
+	default:
+		BUG();
+	}
+
+	err = gpiochip_add(&ar71xx_gpio_chip);
+	if (err)
+		panic("cannot add AR71xx GPIO chip, error=%d", err);
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/irq.c linux-2.6.39/arch/mips/ar71xx/irq.c
--- linux-2.6.39.orig/arch/mips/ar71xx/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/irq.c	2011-08-24 02:41:55.457989607 +0200
@@ -0,0 +1,377 @@
+/*
+ *  Atheros AR71xx SoC specific interrupt handling
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+static void ar71xx_gpio_irq_dispatch(void)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 pending;
+
+	pending = __raw_readl(base + GPIO_REG_INT_PENDING) &
+		  __raw_readl(base + GPIO_REG_INT_ENABLE);
+
+	if (pending)
+		do_IRQ(AR71XX_GPIO_IRQ_BASE + fls(pending) - 1);
+	else
+		spurious_interrupt();
+}
+
+static void ar71xx_gpio_irq_unmask(struct irq_data *d)
+{
+	unsigned int irq = d->irq - AR71XX_GPIO_IRQ_BASE;
+	void __iomem *base = ar71xx_gpio_base;
+	u32 t;
+
+	t = __raw_readl(base + GPIO_REG_INT_ENABLE);
+	__raw_writel(t | (1 << irq), base + GPIO_REG_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_INT_ENABLE);
+}
+
+static void ar71xx_gpio_irq_mask(struct irq_data *d)
+{
+	unsigned int irq = d->irq - AR71XX_GPIO_IRQ_BASE;
+	void __iomem *base = ar71xx_gpio_base;
+	u32 t;
+
+	t = __raw_readl(base + GPIO_REG_INT_ENABLE);
+	__raw_writel(t & ~(1 << irq), base + GPIO_REG_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + GPIO_REG_INT_ENABLE);
+}
+
+static struct irq_chip ar71xx_gpio_irq_chip = {
+	.name		= "AR71XX GPIO",
+	.irq_unmask	= ar71xx_gpio_irq_unmask,
+	.irq_mask	= ar71xx_gpio_irq_mask,
+	.irq_mask_ack	= ar71xx_gpio_irq_mask,
+};
+
+static struct irqaction ar71xx_gpio_irqaction = {
+	.handler	= no_action,
+	.name		= "cascade [AR71XX GPIO]",
+};
+
+#define GPIO_INT_ALL	0xffff
+
+static void __init ar71xx_gpio_irq_init(void)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	int i;
+
+	__raw_writel(0, base + GPIO_REG_INT_ENABLE);
+	__raw_writel(0, base + GPIO_REG_INT_PENDING);
+
+	/* setup type of all GPIO interrupts to level sensitive */
+	__raw_writel(GPIO_INT_ALL, base + GPIO_REG_INT_TYPE);
+
+	/* setup polarity of all GPIO interrupts to active high */
+	__raw_writel(GPIO_INT_ALL, base + GPIO_REG_INT_POLARITY);
+
+	for (i = AR71XX_GPIO_IRQ_BASE;
+	     i < AR71XX_GPIO_IRQ_BASE + AR71XX_GPIO_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ar71xx_gpio_irq_chip,
+					 handle_level_irq);
+
+	setup_irq(AR71XX_MISC_IRQ_GPIO, &ar71xx_gpio_irqaction);
+}
+
+static void ar71xx_misc_irq_dispatch(void)
+{
+	u32 pending;
+
+	pending = ar71xx_reset_rr(AR71XX_RESET_REG_MISC_INT_STATUS)
+	    & ar71xx_reset_rr(AR71XX_RESET_REG_MISC_INT_ENABLE);
+
+	if (pending & MISC_INT_UART)
+		do_IRQ(AR71XX_MISC_IRQ_UART);
+
+	else if (pending & MISC_INT_DMA)
+		do_IRQ(AR71XX_MISC_IRQ_DMA);
+
+	else if (pending & MISC_INT_PERFC)
+		do_IRQ(AR71XX_MISC_IRQ_PERFC);
+
+	else if (pending & MISC_INT_TIMER)
+		do_IRQ(AR71XX_MISC_IRQ_TIMER);
+
+	else if (pending & MISC_INT_OHCI)
+		do_IRQ(AR71XX_MISC_IRQ_OHCI);
+
+	else if (pending & MISC_INT_ERROR)
+		do_IRQ(AR71XX_MISC_IRQ_ERROR);
+
+	else if (pending & MISC_INT_GPIO)
+		ar71xx_gpio_irq_dispatch();
+
+	else if (pending & MISC_INT_WDOG)
+		do_IRQ(AR71XX_MISC_IRQ_WDOG);
+
+	else if (pending & MISC_INT_TIMER2)
+		do_IRQ(AR71XX_MISC_IRQ_TIMER2);
+
+	else if (pending & MISC_INT_TIMER3)
+		do_IRQ(AR71XX_MISC_IRQ_TIMER3);
+
+	else if (pending & MISC_INT_TIMER4)
+		do_IRQ(AR71XX_MISC_IRQ_TIMER4);
+
+	else if (pending & MISC_INT_DDR_PERF)
+		do_IRQ(AR71XX_MISC_IRQ_DDR_PERF);
+
+	else if (pending & MISC_INT_ENET_LINK)
+		do_IRQ(AR71XX_MISC_IRQ_ENET_LINK);
+
+	else
+		spurious_interrupt();
+}
+
+static void ar71xx_misc_irq_unmask(struct irq_data *d)
+{
+	unsigned int irq = d->irq - AR71XX_MISC_IRQ_BASE;
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+	__raw_writel(t | (1 << irq), base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+}
+
+static void ar71xx_misc_irq_mask(struct irq_data *d)
+{
+	unsigned int irq = d->irq - AR71XX_MISC_IRQ_BASE;
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+	__raw_writel(t & ~(1 << irq), base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+}
+
+static void ar724x_misc_irq_ack(struct irq_data *d)
+{
+	unsigned int irq = d->irq - AR71XX_MISC_IRQ_BASE;
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_MISC_INT_STATUS);
+	__raw_writel(t & ~(1 << irq), base + AR71XX_RESET_REG_MISC_INT_STATUS);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_MISC_INT_STATUS);
+}
+
+static struct irq_chip ar71xx_misc_irq_chip = {
+	.name		= "AR71XX MISC",
+	.irq_unmask	= ar71xx_misc_irq_unmask,
+	.irq_mask	= ar71xx_misc_irq_mask,
+};
+
+static struct irqaction ar71xx_misc_irqaction = {
+	.handler	= no_action,
+	.name		= "cascade [AR71XX MISC]",
+};
+
+static void __init ar71xx_misc_irq_init(void)
+{
+	void __iomem *base = ar71xx_reset_base;
+	int i;
+
+	__raw_writel(0, base + AR71XX_RESET_REG_MISC_INT_ENABLE);
+	__raw_writel(0, base + AR71XX_RESET_REG_MISC_INT_STATUS);
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar71xx_misc_irq_chip.irq_ack = ar724x_misc_irq_ack;
+		break;
+	default:
+		ar71xx_misc_irq_chip.irq_mask_ack = ar71xx_misc_irq_mask;
+		break;
+	}
+
+	for (i = AR71XX_MISC_IRQ_BASE;
+	     i < AR71XX_MISC_IRQ_BASE + AR71XX_MISC_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ar71xx_misc_irq_chip,
+					 handle_level_irq);
+
+	setup_irq(AR71XX_CPU_IRQ_MISC, &ar71xx_misc_irqaction);
+}
+
+/*
+ * The IP2/IP3 lines are tied to a PCI/WMAC/USB device. Drivers for
+ * these devices typically allocate coherent DMA memory, however the
+ * DMA controller may still have some unsynchronized data in the FIFO.
+ * Issue a flush in the handlers to ensure that the driver sees
+ * the update.
+ */
+static void ar71xx_ip2_handler(void)
+{
+	ar71xx_ddr_flush(AR71XX_DDR_REG_FLUSH_PCI);
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar724x_ip2_handler(void)
+{
+	ar71xx_ddr_flush(AR724X_DDR_REG_FLUSH_PCIE);
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar913x_ip2_handler(void)
+{
+	ar71xx_ddr_flush(AR91XX_DDR_REG_FLUSH_WMAC);
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar933x_ip2_handler(void)
+{
+	ar71xx_ddr_flush(AR933X_DDR_REG_FLUSH_WMAC);
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar934x_ip2_handler(void)
+{
+	ar71xx_ddr_flush(AR934X_DDR_REG_FLUSH_PCIE);
+	do_IRQ(AR71XX_CPU_IRQ_IP2);
+}
+
+static void ar71xx_ip3_handler(void)
+{
+	ar71xx_ddr_flush(AR71XX_DDR_REG_FLUSH_USB);
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void ar724x_ip3_handler(void)
+{
+	ar71xx_ddr_flush(AR724X_DDR_REG_FLUSH_USB);
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void ar913x_ip3_handler(void)
+{
+	ar71xx_ddr_flush(AR91XX_DDR_REG_FLUSH_USB);
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void ar933x_ip3_handler(void)
+{
+	ar71xx_ddr_flush(AR933X_DDR_REG_FLUSH_USB);
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void ar934x_ip3_handler(void)
+{
+	do_IRQ(AR71XX_CPU_IRQ_USB);
+}
+
+static void (*ip2_handler)(void);
+static void (*ip3_handler)(void);
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned long pending;
+
+	pending = read_c0_status() & read_c0_cause() & ST0_IM;
+
+	if (pending & STATUSF_IP7)
+		do_IRQ(AR71XX_CPU_IRQ_TIMER);
+
+	else if (pending & STATUSF_IP2)
+		ip2_handler();
+
+	else if (pending & STATUSF_IP4)
+		do_IRQ(AR71XX_CPU_IRQ_GE0);
+
+	else if (pending & STATUSF_IP5)
+		do_IRQ(AR71XX_CPU_IRQ_GE1);
+
+	else if (pending & STATUSF_IP3)
+		ip3_handler();
+
+	else if (pending & STATUSF_IP6)
+		ar71xx_misc_irq_dispatch();
+
+	spurious_interrupt();
+}
+
+void __init arch_init_irq(void)
+{
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ip2_handler = ar71xx_ip2_handler;
+		ip3_handler = ar71xx_ip3_handler;
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ip2_handler = ar724x_ip2_handler;
+		ip3_handler = ar724x_ip3_handler;
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		ip2_handler = ar913x_ip2_handler;
+		ip3_handler = ar913x_ip3_handler;
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ip2_handler = ar933x_ip2_handler;
+		ip3_handler = ar933x_ip3_handler;
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ip2_handler = ar934x_ip2_handler;
+		ip3_handler = ar934x_ip3_handler;
+		break;
+
+	default:
+		BUG();
+	}
+
+	mips_cpu_irq_init();
+
+	ar71xx_misc_irq_init();
+
+	cp0_perfcount_irq = AR71XX_MISC_IRQ_PERFC;
+
+	ar71xx_gpio_irq_init();
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/Kconfig linux-2.6.39/arch/mips/ar71xx/Kconfig
--- linux-2.6.39.orig/arch/mips/ar71xx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/Kconfig	2011-08-24 04:20:27.209240389 +0200
@@ -0,0 +1,420 @@
+if ATHEROS_AR71XX
+
+menu "Atheros AR71xx machine selection"
+
+config AR71XX_MACH_AP81
+	bool "Atheros AP81 board support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_AP83
+	bool "Atheros AP83 board support"
+	select SOC_AR913X
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_AP96
+	bool "Atheros AP96 board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP94_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_AP121
+	bool "Atheros AP121 board support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	select AR71XX_DEV_AR9XXX_WMAC
+	select SOC_AR933X
+	default n
+
+config AR71XX_MACH_DB120
+	bool "Atheros DB120 board support"
+	select SOC_AR934X
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_DB120_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_DIR_600_A1
+	bool "D-Link DIR-600 rev. A1 support"
+	select SOC_AR724X
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_NVRAM
+	default n
+
+config AR71XX_MACH_DIR_615_C1
+	bool "D-Link DIR-615 rev. C1 support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_NVRAM
+	default n
+
+config AR71XX_MACH_DIR_825_B1
+	bool "D-Link DIR-825 rev. B1 board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP94_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_JA76PF
+	bool "jjPlus JA76PF board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_JWAP003
+	bool "jjPlus JWAP003 board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_PB42
+	bool "Atheros PB42 board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	default n
+
+config AR71XX_MACH_PB44
+	bool "Atheros PB44 board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_PB92
+	bool "Atheros PB92 board support"
+	select SOC_AR724X
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB9X_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_AW_NR580
+	bool "AzureWave AW-NR580 board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_WZR_HP_AG300H
+	bool "Buffalo WZR-HP-AG300H board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_WZR_HP_G300NH
+	bool "Buffalo WZR-HP-G300NH board support"
+	select SOC_AR913X
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	select RTL8366_SMI
+	default n
+
+config AR71XX_MACH_WP543
+	bool "Compex WP543/WPJ543 board support"
+	select SOC_AR71XX
+	select MYLOADER
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_WRT160NL
+	bool "Linksys WRT160NL board support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	select AR71XX_NVRAM
+	default n
+
+config AR71XX_MACH_WRT400N
+	bool "Linksys WRT400N board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_AP94_PCI if PCI
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_RB4XX
+	bool "MikroTik RouterBOARD 4xx series support"
+	select SOC_AR71XX
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_RB750
+	bool "MikroTik RouterBOARD 750 support"
+	select SOC_AR724X
+	default n
+
+config AR71XX_MACH_WNDR3700
+	bool "NETGEAR WNDR3700 board support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP94_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_WNR2000
+	bool "NETGEAR WNR2000 board support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_MZK_W04NU
+	bool "Planex MZK-W04NU board support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_MZK_W300NH
+	bool "Planex MZK-W300NH board support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_NBG460N
+	bool "Zyxel NBG460N/550N/550NH board support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_MR3X20
+	bool "TP-LINK TL-MR3220/3420 support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_TL_WA901ND
+	bool "TP-LINK TL-WA901ND support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_WA901ND_V2
+	bool "TP-LINK TL-WA901ND v2 support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_WR741ND
+	bool "TP-LINK TL-WR741ND support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_WR841N_V1
+	bool "TP-LINK TL-WR841N v1 support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_DSA
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_WR941ND
+	bool "TP-LINK TL-WR941ND support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_DSA
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_TL_WR1043ND
+	bool "TP-LINK TL-WR1043ND support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_TEW_632BRP
+	bool "TRENDnet TEW-632BRP support"
+	select SOC_AR913X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AR9XXX_WMAC
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_NVRAM
+	default n
+
+config AR71XX_MACH_UBNT
+	bool "Ubiquiti AR71xx based boards support"
+	select SOC_AR71XX
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_PB42_PCI if PCI
+	select AR71XX_DEV_USB
+	default n
+
+config AR71XX_MACH_EAP7660D
+	bool "Senao EAP7660D support"
+	select SOC_AR71XX
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+config AR71XX_MACH_ZCN_1523H
+	bool "Zcomax ZCN-1523H support"
+	select SOC_AR724X
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	default n
+
+endmenu
+
+config SOC_AR71XX
+	bool
+	select USB_ARCH_HAS_EHCI
+	select USB_ARCH_HAS_OHCI
+
+config SOC_AR724X
+	bool
+	select USB_ARCH_HAS_EHCI
+	select USB_ARCH_HAS_OHCI
+
+config SOC_AR913X
+	bool
+	select USB_ARCH_HAS_EHCI
+
+config SOC_AR934X
+	bool
+	select USB_ARCH_HAS_EHCI
+
+config AR71XX_DEV_M25P80
+	def_bool n
+
+config AR71XX_DEV_AP91_PCI
+	select AR71XX_PCI_ATH9K_FIXUP
+	def_bool n
+
+config AR71XX_DEV_AP94_PCI
+	select AR71XX_PCI_ATH9K_FIXUP
+	def_bool n
+
+config AR71XX_DEV_AR9XXX_WMAC
+	def_bool n
+
+config AR71XX_DEV_DB120_PCI
+	select AR71XX_PCI_ATH9K_FIXUP
+	def_bool n
+
+config AR71XX_DEV_DSA
+	def_bool n
+
+config AR71XX_DEV_GPIO_BUTTONS
+	def_bool n
+
+config AR71XX_DEV_LEDS_GPIO
+	def_bool n
+
+config AR71XX_DEV_PB42_PCI
+	def_bool n
+
+config AR71XX_DEV_PB9X_PCI
+	def_bool n
+
+config AR71XX_DEV_USB
+	def_bool n
+
+config AR71XX_NVRAM
+	def_bool n
+
+config AR71XX_PCI_ATH9K_FIXUP
+	def_bool n
+
+config SOC_AR933X
+	bool
+	select USB_ARCH_HAS_EHCI
+
+endif
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-ap121.c linux-2.6.39/arch/mips/ar71xx/mach-ap121.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-ap121.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-ap121.c	2011-08-24 02:41:55.477989660 +0200
@@ -0,0 +1,245 @@
+/*
+ *  Atheros AP121 board support
+ *
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/flash.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+
+#define AP121_GPIO_LED_WLAN		0
+#define AP121_GPIO_LED_USB		1
+
+#define AP121_GPIO_BTN_JUMPSTART	11
+#define AP121_GPIO_BTN_RESET		12
+
+#define AP121_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP121_KEYS_DEBOUNCE_INTERVAL	(3 * AP121_KEYS_POLL_INTERVAL)
+
+#define AP121_MAC0_OFFSET	0x0000
+#define AP121_MAC1_OFFSET	0x0006
+#define AP121_CALDATA_OFFSET	0x1000
+#define AP121_WMAC_MAC_OFFSET	0x1002
+
+#define AP121_MINI_GPIO_LED_WLAN	0
+#define AP121_MINI_GPIO_BTN_JUMPSTART	12
+#define AP121_MINI_GPIO_BTN_RESET	11
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition ap121_parts[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{
+		.name		= "rootfs",
+		.offset		= 0x010000,
+		.size		= 0x130000,
+	},
+	{
+		.name		= "uImage",
+		.offset		= 0x140000,
+		.size		= 0x0a0000,
+	},
+	{
+		.name		= "NVRAM",
+		.offset		= 0x1e0000,
+		.size		= 0x010000,
+	},
+	{
+		.name		= "ART",
+		.offset		= 0x1f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+};
+#define ap121_nr_parts		ARRAY_SIZE(ap121_parts)
+
+static struct mtd_partition ap121_mini_parts[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x2b0000,
+	},
+	{
+		.name		= "uImage",
+		.offset		= 0x300000,
+		.size		= 0x0e0000,
+	},
+	{
+		.name		= "NVRAM",
+		.offset		= 0x3e0000,
+		.size		= 0x010000,
+	},
+	{
+		.name		= "ART",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+};
+
+#define ap121_mini_nr_parts	ARRAY_SIZE(ap121_parts)
+
+#else
+#define ap121_parts		NULL
+#define ap121_nr_parts		0
+#define ap121_mini_parts	NULL
+#define ap121_mini_nr_parts	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data ap121_flash_data = {
+	.parts		= ap121_parts,
+	.nr_parts	= ap121_nr_parts,
+};
+
+static struct gpio_led ap121_leds_gpio[] __initdata = {
+	{
+		.name		= "ap121:green:usb",
+		.gpio		= AP121_GPIO_LED_USB,
+		.active_low	= 0,
+	},
+	{
+		.name		= "ap121:green:wlan",
+		.gpio		= AP121_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ap121_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led ap121_mini_leds_gpio[] __initdata = {
+	{
+		.name		= "ap121:green:wlan",
+		.gpio		= AP121_MINI_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ap121_mini_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_MINI_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_MINI_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init ap121_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_add_device_m25p80(&ap121_flash_data);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, art + AP121_MAC0_OFFSET, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, art + AP121_MAC1_OFFSET, 0);
+
+	/* WAN port */
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = BIT(4);
+
+	/* LAN ports */
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+	ar71xx_eth1_data.has_ar7240_switch = 1;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ar9xxx_add_device_wmac(art + AP121_CALDATA_OFFSET,
+			       art + AP121_WMAC_MAC_OFFSET);
+}
+
+static void __init ap121_setup(void)
+{
+	ap121_flash_data.parts = ap121_parts;
+	ap121_flash_data.nr_parts = ap121_nr_parts;
+
+	ap121_common_setup();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap121_leds_gpio),
+					ap121_leds_gpio);
+	ar71xx_register_gpio_keys_polled(-1, AP121_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap121_gpio_keys),
+					 ap121_gpio_keys);
+
+	ar71xx_add_device_usb();
+}
+
+static void __init ap121_mini_setup(void)
+{
+	ap121_flash_data.parts = ap121_mini_parts;
+	ap121_flash_data.nr_parts = ap121_mini_nr_parts;
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap121_mini_leds_gpio),
+					ap121_mini_leds_gpio);
+	ar71xx_register_gpio_keys_polled(-1, AP121_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap121_mini_gpio_keys),
+					 ap121_mini_gpio_keys);
+
+	ap121_common_setup();
+}
+
+MIPS_MACHINE(AR71XX_MACH_AP121, "AP121", "Atheros AP121",
+	     ap121_setup);
+
+MIPS_MACHINE(AR71XX_MACH_AP121_MINI, "AP121-MINI", "Atheros AP121-MINI",
+	     ap121_mini_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-ap81.c linux-2.6.39/arch/mips/ar71xx/mach-ap81.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-ap81.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-ap81.c	2011-08-24 02:41:55.477989660 +0200
@@ -0,0 +1,142 @@
+/*
+ *  Atheros AP81 board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2009 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define AP81_GPIO_LED_STATUS	1
+#define AP81_GPIO_LED_AOSS	3
+#define AP81_GPIO_LED_WLAN	6
+#define AP81_GPIO_LED_POWER	14
+
+#define AP81_GPIO_BTN_SW4	12
+#define AP81_GPIO_BTN_SW1	21
+
+#define AP81_KEYS_POLL_INTERVAL		20 /* msecs */
+#define AP81_KEYS_DEBOUNCE_INTERVAL	(3 * AP81_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition ap81_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x500000,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x550000,
+		.size		= 0x100000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x650000,
+		.size		= 0x1b0000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data ap81_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= ap81_partitions,
+	.nr_parts	= ARRAY_SIZE(ap81_partitions),
+#endif
+};
+
+static struct gpio_led ap81_leds_gpio[] __initdata = {
+	{
+		.name		= "ap81:green:status",
+		.gpio		= AP81_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "ap81:amber:aoss",
+		.gpio		= AP81_GPIO_LED_AOSS,
+		.active_low	= 1,
+	}, {
+		.name		= "ap81:green:wlan",
+		.gpio		= AP81_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap81:green:power",
+		.gpio		= AP81_GPIO_LED_POWER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap81_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = AP81_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP81_GPIO_BTN_SW1,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = AP81_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP81_GPIO_BTN_SW4,
+		.active_low	= 1,
+	}
+};
+
+static void __init ap81_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&ap81_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap81_leds_gpio),
+					ap81_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, AP81_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap81_gpio_keys),
+					 ap81_gpio_keys);
+
+	ar9xxx_add_device_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_AP81, "AP81", "Atheros AP81", ap81_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-ap83.c linux-2.6.39/arch/mips/ar71xx/mach-ap83.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-ap83.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-ap83.c	2011-08-24 02:41:55.477989660 +0200
@@ -0,0 +1,267 @@
+/*
+ *  Atheros AP83 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/spi/vsc7385.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar91xx_flash.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define AP83_GPIO_LED_WLAN	6
+#define AP83_GPIO_LED_POWER	14
+#define AP83_GPIO_LED_JUMPSTART	15
+#define AP83_GPIO_BTN_JUMPSTART	12
+#define AP83_GPIO_BTN_RESET	21
+
+#define AP83_050_GPIO_VSC7385_CS	1
+#define AP83_050_GPIO_VSC7385_MISO	3
+#define AP83_050_GPIO_VSC7385_MOSI	16
+#define AP83_050_GPIO_VSC7385_SCK	17
+
+#define AP83_KEYS_POLL_INTERVAL		20	/* msecs */
+#define AP83_KEYS_DEBOUNCE_INTERVAL	(3 * AP83_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition ap83_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x060000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x1a0000,
+		.size		= 0x650000,
+	}, {
+		.name		= "art",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x060000,
+		.size		= 0x790000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct ar91xx_flash_platform_data ap83_flash_data = {
+	.width		= 2,
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= ap83_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(ap83_flash_partitions),
+#endif
+};
+
+static struct resource ap83_flash_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ap83_flash_device = {
+	.name		= "ar91xx-flash",
+	.id		= -1,
+	.resource	= ap83_flash_resources,
+	.num_resources	= ARRAY_SIZE(ap83_flash_resources),
+	.dev		= {
+		.platform_data = &ap83_flash_data,
+	}
+};
+
+static struct gpio_led ap83_leds_gpio[] __initdata = {
+	{
+		.name		= "ap83:green:jumpstart",
+		.gpio		= AP83_GPIO_LED_JUMPSTART,
+		.active_low	= 0,
+	}, {
+		.name		= "ap83:green:power",
+		.gpio		= AP83_GPIO_LED_POWER,
+		.active_low	= 0,
+	}, {
+		.name		= "ap83:green:wlan",
+		.gpio		= AP83_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ap83_gpio_keys[] __initdata = {
+	{
+		.desc		= "soft_reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP83_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP83_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "jumpstart",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP83_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP83_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	}
+};
+
+static struct resource ap83_040_spi_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ap83_040_spi_device = {
+	.name		= "ap83-spi",
+	.id		= 0,
+	.resource	= ap83_040_spi_resources,
+	.num_resources	= ARRAY_SIZE(ap83_040_spi_resources),
+};
+
+static struct spi_gpio_platform_data ap83_050_spi_data = {
+	.miso	= AP83_050_GPIO_VSC7385_MISO,
+	.mosi	= AP83_050_GPIO_VSC7385_MOSI,
+	.sck	= AP83_050_GPIO_VSC7385_SCK,
+	.num_chipselect = 1,
+};
+
+static struct platform_device ap83_050_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &ap83_050_spi_data,
+	}
+};
+
+static void ap83_vsc7385_reset(void)
+{
+	ar71xx_device_stop(RESET_MODULE_GE1_PHY);
+	udelay(10);
+	ar71xx_device_start(RESET_MODULE_GE1_PHY);
+	mdelay(50);
+}
+
+static struct vsc7385_platform_data ap83_vsc7385_data = {
+	.reset		= ap83_vsc7385_reset,
+	.ucode_name	= "vsc7385_ucode_ap83.bin",
+	.mac_cfg = {
+		.tx_ipg		= 6,
+		.bit2		= 0,
+		.clk_sel	= 3,
+	},
+};
+
+static struct spi_board_info ap83_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-vsc7385",
+		.platform_data	= &ap83_vsc7385_data,
+		.controller_data = (void *) AP83_050_GPIO_VSC7385_CS,
+	}
+};
+
+static void __init ap83_generic_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_mdio(0xfffffffe);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = 0x1;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_pll_data.pll_1000 = 0x1f000000;
+
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap83_leds_gpio),
+					ap83_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, AP83_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap83_gpio_keys),
+					 ap83_gpio_keys);
+
+	ar71xx_add_device_usb();
+
+	ar9xxx_add_device_wmac(eeprom, NULL);
+
+	platform_device_register(&ap83_flash_device);
+
+	spi_register_board_info(ap83_spi_info, ARRAY_SIZE(ap83_spi_info));
+}
+
+static void __init ap83_040_setup(void)
+{
+	ap83_flash_data.is_shared = 1;
+	ap83_generic_setup();
+	platform_device_register(&ap83_040_spi_device);
+}
+
+static void __init ap83_050_setup(void)
+{
+	ap83_generic_setup();
+	platform_device_register(&ap83_050_spi_device);
+}
+
+static void __init ap83_setup(void)
+{
+	u8 *board_id = (u8 *) KSEG1ADDR(0x1fff1244);
+	unsigned int board_version;
+
+	board_version = (unsigned int)(board_id[0] - '0');
+	board_version += ((unsigned int)(board_id[1] - '0')) * 10;
+
+	switch (board_version) {
+	case 40:
+		ap83_040_setup();
+		break;
+	case 50:
+		ap83_050_setup();
+		break;
+	default:
+		printk(KERN_WARNING "AP83-%03u board is not yet supported\n",
+		       board_version);
+	}
+}
+
+MIPS_MACHINE(AR71XX_MACH_AP83, "AP83", "Atheros AP83", ap83_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-ap96.c linux-2.6.39/arch/mips/ar71xx/mach-ap96.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-ap96.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-ap96.c	2011-08-24 02:41:55.477989660 +0200
@@ -0,0 +1,180 @@
+/*
+ *  Atheros AP96 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap94-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define AP96_GPIO_LED_12_GREEN		0
+#define AP96_GPIO_LED_3_GREEN		1
+#define AP96_GPIO_LED_2_GREEN		2
+#define AP96_GPIO_LED_WPS_GREEN		4
+#define AP96_GPIO_LED_5_GREEN		5
+#define AP96_GPIO_LED_4_ORANGE		6
+
+/* Reset button - next to the power connector */
+#define AP96_GPIO_BTN_RESET		3
+/* WPS button - next to a led on right */
+#define AP96_GPIO_BTN_WPS		8
+
+#define AP96_KEYS_POLL_INTERVAL		20	/* msecs */
+#define AP96_KEYS_DEBOUNCE_INTERVAL	(3 * AP96_KEYS_POLL_INTERVAL)
+
+#define AP96_WMAC0_MAC_OFFSET		0x120c
+#define AP96_WMAC1_MAC_OFFSET		0x520c
+#define AP96_CALDATA0_OFFSET		0x1000
+#define AP96_CALDATA1_OFFSET		0x5000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition ap96_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x030000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "env",
+		.offset		= 0x030000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x040000,
+		.size		= 0x600000,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x640000,
+		.size		= 0x1b0000,
+	}, {
+		.name		= "caldata",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data ap96_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= ap96_partitions,
+	.nr_parts	= ARRAY_SIZE(ap96_partitions),
+#endif
+};
+
+/*
+ * AP96 has 12 unlabeled leds in the front; these are numbered from 1 to 12
+ * below (from left to right on the board). Led 1 seems to be on whenever the
+ * board is powered. Led 11 shows LAN link activity actity. Led 3 is orange;
+ * others are green.
+ *
+ * In addition, there is one led next to a button on the right side for WPS.
+ */
+static struct gpio_led ap96_leds_gpio[] __initdata = {
+	{
+		.name		= "ap96:green:led2",
+		.gpio		= AP96_GPIO_LED_2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led3",
+		.gpio		= AP96_GPIO_LED_3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:orange:led4",
+		.gpio		= AP96_GPIO_LED_4_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led5",
+		.gpio		= AP96_GPIO_LED_5_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led12",
+		.gpio		= AP96_GPIO_LED_12_GREEN,
+		.active_low	= 1,
+	}, { /* next to a button on right */
+		.name		= "ap96:green:wps",
+		.gpio		= AP96_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap96_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+#define AP96_WAN_PHYMASK 0x10
+#define AP96_LAN_PHYMASK 0x0f
+
+static void __init ap96_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_add_device_mdio(~(AP96_WAN_PHYMASK | AP96_LAN_PHYMASK));
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, art, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = AP96_LAN_PHYMASK;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, art, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = AP96_WAN_PHYMASK;
+
+	ar71xx_eth1_pll_data.pll_1000 = 0x1f000000;
+
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&ap96_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ap96_leds_gpio),
+					ap96_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, AP96_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap96_gpio_keys),
+					 ap96_gpio_keys);
+
+	ap94_pci_init(art + AP96_CALDATA0_OFFSET,
+		      art + AP96_WMAC0_MAC_OFFSET,
+		      art + AP96_CALDATA1_OFFSET,
+		      art + AP96_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(AR71XX_MACH_AP96, "AP96", "Atheros AP96", ap96_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-aw-nr580.c linux-2.6.39/arch/mips/ar71xx/mach-aw-nr580.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-aw-nr580.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-aw-nr580.c	2011-08-24 02:41:55.487989871 +0200
@@ -0,0 +1,102 @@
+/*
+ *  AzureWave AW-NR580 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mips_machine.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-leds-gpio.h"
+
+#define AW_NR580_GPIO_LED_READY_RED	0
+#define AW_NR580_GPIO_LED_WLAN		1
+#define AW_NR580_GPIO_LED_READY_GREEN	2
+#define AW_NR580_GPIO_LED_WPS_GREEN	4
+#define AW_NR580_GPIO_LED_WPS_AMBER	5
+
+#define AW_NR580_GPIO_BTN_WPS		3
+#define AW_NR580_GPIO_BTN_RESET		11
+
+#define AW_NR580_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AW_NR580_KEYS_DEBOUNCE_INTERVAL	(3 * AW_NR580_KEYS_POLL_INTERVAL)
+
+static struct gpio_led aw_nr580_leds_gpio[] __initdata = {
+	{
+		.name		= "aw-nr580:red:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_RED,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:amber:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_AMBER,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wlan",
+		.gpio		= AW_NR580_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button aw_nr580_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AW_NR580_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AW_NR580_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init aw_nr580_setup(void)
+{
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+
+	pb42_pci_init();
+
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(aw_nr580_leds_gpio),
+					aw_nr580_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, AW_NR580_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(aw_nr580_gpio_keys),
+					 aw_nr580_gpio_keys);
+}
+
+MIPS_MACHINE(AR71XX_MACH_AW_NR580, "AW-NR580", "AzureWave AW-NR580",
+	     aw_nr580_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-db120.c linux-2.6.39/arch/mips/ar71xx/mach-db120.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-db120.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-db120.c	2011-08-24 02:41:55.487989871 +0200
@@ -0,0 +1,134 @@
+/*
+ *  Atheros DB120 board (WASP SoC) support
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-db120-pci.h"
+
+#define DB120_GPIO_LED_USB	11
+#define DB120_GPIO_LED_WLAN_5G	12
+#define DB120_GPIO_LED_WLAN_2G	13
+#define DB120_GPIO_LED_STATUS	14
+#define DB120_GPIO_LED_WPS	15
+
+#define DB120_GPIO_BTN_SW1	16
+
+#define DB120_CALDATA_OFFSET	0x1000
+#define DB120_WMAC_MAC_OFFSET	0x1002
+
+#define DB120_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DB120_KEYS_DEBOUNCE_INTERVAL	(3 * DB120_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition db120_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x630000,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x680000,
+		.size		= 0x160000,
+	}, {
+		.name		= "NVRAM",
+		.offset		= 0x7E0000,
+		.size		= 0x010000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x7F0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data db120_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= db120_partitions,
+	.nr_parts	= ARRAY_SIZE(db120_partitions),
+#endif
+};
+
+static struct gpio_led db120_leds_gpio[] __initdata = {
+	{
+		.name		= "db120:green:status",
+		.gpio		= DB120_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "db120:green:wps",
+		.gpio		= DB120_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "db120:green:wlan-5g",
+		.gpio		= DB120_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	}, {
+		.name		= "db120:green:wlan-2g",
+		.gpio		= DB120_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	}, {
+		.name		= "db120:green:usb",
+		.gpio		= DB120_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button db120_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = DB120_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DB120_GPIO_BTN_SW1,
+		.active_low	= 1,
+	}
+};
+
+static void __init db120_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&db120_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(db120_leds_gpio),
+					db120_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, DB120_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(db120_gpio_keys),
+					 db120_gpio_keys);
+
+	ar9xxx_add_device_wmac(art + DB120_CALDATA_OFFSET,
+				art + DB120_WMAC_MAC_OFFSET);
+
+	db120_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_DB120, "DB120", "Atheros DB120", db120_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-dir-600-a1.c linux-2.6.39/arch/mips/ar71xx/mach-dir-600-a1.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-dir-600-a1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-dir-600-a1.c	2011-08-24 02:41:55.487989871 +0200
@@ -0,0 +1,159 @@
+/*
+ *  D-Link DIR-600 rev. A1 board support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "nvram.h"
+
+#define DIR_600_A1_GPIO_LED_WPS			0
+#define DIR_600_A1_GPIO_LED_POWER_AMBER		1
+#define DIR_600_A1_GPIO_LED_POWER_GREEN		6
+
+#define DIR_600_A1_GPIO_BTN_RESET		8
+#define DIR_600_A1_GPIO_BTN_WPS			12
+
+#define DIR_600_A1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DIR_600_A1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_600_A1_KEYS_POLL_INTERVAL)
+
+#define DIR_600_A1_NVRAM_ADDR	0x1f030000
+#define DIR_600_A1_NVRAM_SIZE	0x10000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition dir_600_a1_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x030000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "nvram",
+		.offset		= 0x030000,
+		.size		= 0x010000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x040000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x120000,
+		.size		= 0x2c0000,
+	}, {
+		.name		= "mac",
+		.offset		= 0x3e0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x3a0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data dir_600_a1_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= dir_600_a1_partitions,
+	.nr_parts	= ARRAY_SIZE(dir_600_a1_partitions),
+#endif
+};
+
+static struct gpio_led dir_600_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "dir-600-a1:green:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_GREEN,
+	}, {
+		.name		= "dir-600-a1:amber:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_AMBER,
+	}, {
+		.name		= "dir-600-a1:blue:wps",
+		.gpio		= DIR_600_A1_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dir_600_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_600_A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_600_A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init dir_600_a1_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(DIR_600_A1_NVRAM_ADDR);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac_buff[6];
+	u8 *mac = NULL;
+
+	if (nvram_parse_mac_addr(nvram, DIR_600_A1_NVRAM_SIZE,
+				"lan_mac=", mac_buff) == 0) {
+		ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac_buff, 0);
+		ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac_buff, 1);
+		mac = mac_buff;
+	}
+
+	ar71xx_add_device_m25p80(&dir_600_a1_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(dir_600_a1_leds_gpio),
+					dir_600_a1_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, DIR_600_A1_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(dir_600_a1_gpio_keys),
+					 dir_600_a1_gpio_keys);
+
+	ar71xx_eth1_data.has_ar7240_switch = 1;
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	/* WAN port */
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = BIT(4);
+
+	/* LAN ports */
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_DIR_600_A1, "DIR-600-A1", "D-Link DIR-600 rev. A1",
+	     dir_600_a1_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-dir-615-c1.c linux-2.6.39/arch/mips/ar71xx/mach-dir-615-c1.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-dir-615-c1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-dir-615-c1.c	2011-08-24 02:41:55.487989871 +0200
@@ -0,0 +1,175 @@
+/*
+ *  D-Link DIR-615 rev C1 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "nvram.h"
+
+#define DIR_615C1_GPIO_LED_ORANGE_STATUS 1	/* ORANGE:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_BLUE_WPS	3	/* BLUE:WPS */
+#define DIR_615C1_GPIO_LED_GREEN_WAN	4       /* GREEN:WAN:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WANCPU	5       /* GREEN:WAN:CPU:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WLAN	6	/* GREEN:WLAN */
+#define DIR_615C1_GPIO_LED_GREEN_STATUS	14	/* GREEN:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_ORANGE_WAN	15	/* ORANGE:WAN:TRICOLOR */
+
+/* buttons may need refinement */
+
+#define DIR_615C1_GPIO_BTN_WPS		12
+#define DIR_615C1_GPIO_BTN_RESET	21
+
+#define DIR_615C1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DIR_615C1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_615C1_KEYS_POLL_INTERVAL)
+
+#define DIR_615C1_CONFIG_ADDR		0x1f020000
+#define DIR_615C1_CONFIG_SIZE		0x10000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition dir_615c1_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "config",
+		.offset		= 0x020000,
+		.size		= 0x010000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x030000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x110000,
+		.size		= 0x2e0000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x030000,
+		.size		= 0x3c0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data dir_615c1_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= dir_615c1_partitions,
+	.nr_parts	= ARRAY_SIZE(dir_615c1_partitions),
+#endif
+};
+
+static struct gpio_led dir_615c1_leds_gpio[] __initdata = {
+	{
+		.name		= "dir-615c1:orange:status",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "dir-615c1:blue:wps",
+		.gpio		= DIR_615C1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "dir-615c1:green:wan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "dir-615c1:green:wancpu",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WANCPU,
+		.active_low	= 1,
+	}, {
+		.name		= "dir-615c1:green:wlan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "dir-615c1:green:status",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_STATUS,
+		.active_low     = 1,
+	}, {
+		.name		= "dir-615c1:orange:wan",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_WAN,
+		.active_low	= 1,
+	}
+
+};
+
+static struct gpio_keys_button dir_615c1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615C1_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615C1_GPIO_BTN_WPS,
+	}
+};
+
+#define DIR_615C1_LAN_PHYMASK	BIT(0)
+#define DIR_615C1_WAN_PHYMASK	BIT(4)
+#define DIR_615C1_MDIO_MASK	(~(DIR_615C1_LAN_PHYMASK | \
+				   DIR_615C1_WAN_PHYMASK))
+
+static void __init dir_615c1_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(DIR_615C1_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+	u8 *wlan_mac = NULL;
+
+	if (nvram_parse_mac_addr(config, DIR_615C1_CONFIG_SIZE,
+					"lan_mac=", mac) == 0) {
+		ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+		ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+		wlan_mac = mac;
+	}
+
+	ar71xx_add_device_mdio(DIR_615C1_MDIO_MASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.phy_mask = DIR_615C1_LAN_PHYMASK;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = DIR_615C1_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&dir_615c1_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(dir_615c1_leds_gpio),
+					dir_615c1_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, DIR_615C1_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(dir_615c1_gpio_keys),
+					 dir_615c1_gpio_keys);
+
+	ar9xxx_add_device_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_DIR_615_C1, "DIR-615-C1", "D-Link DIR-615 rev. C1",
+	     dir_615c1_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-dir-825-b1.c linux-2.6.39/arch/mips/ar71xx/mach-dir-825-b1.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-dir-825-b1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-dir-825-b1.c	2011-08-24 02:41:55.487989871 +0200
@@ -0,0 +1,198 @@
+/*
+ *  D-Link DIR-825 rev. B1 board support
+ *
+ *  Copyright (C) 2009 Lukas Kuna, Evkanet, s.r.o.
+ *
+ *  based on mach-wndr3700.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap94-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define DIR825B1_GPIO_LED_BLUE_USB		0
+#define DIR825B1_GPIO_LED_ORANGE_POWER		1
+#define DIR825B1_GPIO_LED_BLUE_POWER		2
+#define DIR825B1_GPIO_LED_BLUE_WPS		4
+#define DIR825B1_GPIO_LED_ORANGE_PLANET		6
+#define DIR825B1_GPIO_LED_BLUE_PLANET		11
+
+#define DIR825B1_GPIO_BTN_RESET			3
+#define DIR825B1_GPIO_BTN_WPS			8
+
+#define DIR825B1_GPIO_RTL8366_SDA		5
+#define DIR825B1_GPIO_RTL8366_SCK		7
+
+#define DIR825B1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR825B1_KEYS_DEBOUNCE_INTERVAL		(3 * DIR825B1_KEYS_POLL_INTERVAL)
+
+#define DIR825B1_CAL_LOCATION_0			0x1f661000
+#define DIR825B1_CAL_LOCATION_1			0x1f665000
+
+#define DIR825B1_MAC_LOCATION_0			0x2ffa81b8
+#define DIR825B1_MAC_LOCATION_1			0x2ffa8370
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition dir825b1_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "config",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x050000,
+		.size		= 0x610000,
+	}, {
+		.name		= "caldata",
+		.offset		= 0x660000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "unknown",
+		.offset		= 0x670000,
+		.size		= 0x190000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data dir825b1_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts          = dir825b1_partitions,
+	.nr_parts       = ARRAY_SIZE(dir825b1_partitions),
+#endif
+};
+
+static struct gpio_led dir825b1_leds_gpio[] __initdata = {
+	{
+		.name		= "dir825b1:blue:usb",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:orange:power",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:blue:power",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:blue:wps",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:orange:planet",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_PLANET,
+		.active_low	= 1,
+	}, {
+		.name		= "dir825b1:blue:planet",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_PLANET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dir825b1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825B1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825B1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_initval dir825b1_rtl8366s_initvals[] = {
+	{ .reg = 0x06, .val = 0x0108 },
+};
+
+static struct rtl8366_platform_data dir825b1_rtl8366s_data = {
+	.gpio_sda	= DIR825B1_GPIO_RTL8366_SDA,
+	.gpio_sck	= DIR825B1_GPIO_RTL8366_SCK,
+	.num_initvals	= ARRAY_SIZE(dir825b1_rtl8366s_initvals),
+	.initvals	= dir825b1_rtl8366s_initvals,
+};
+
+static struct platform_device dir825b1_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &dir825b1_rtl8366s_data,
+	}
+};
+
+static void __init dir825b1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(DIR825B1_MAC_LOCATION_1);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 1);
+	ar71xx_eth0_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_pll_data.pll_1000 = 0x11110000;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 2);
+	ar71xx_eth1_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+	ar71xx_eth1_pll_data.pll_1000 = 0x11110000;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&dir825b1_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(dir825b1_leds_gpio),
+					dir825b1_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, DIR825B1_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(dir825b1_gpio_keys),
+					 dir825b1_gpio_keys);
+
+	ar71xx_add_device_usb();
+
+	platform_device_register(&dir825b1_rtl8366s_device);
+
+	ap94_pci_setup_wmac_led_pin(0, 5);
+	ap94_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init((u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_0),
+		      (u8 *) KSEG1ADDR(DIR825B1_MAC_LOCATION_0),
+		      (u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_1),
+		      (u8 *) KSEG1ADDR(DIR825B1_MAC_LOCATION_1));
+}
+
+MIPS_MACHINE(AR71XX_MACH_DIR_825_B1, "DIR-825-B1", "D-Link DIR-825 rev. B1",
+	     dir825b1_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-eap7660d.c linux-2.6.39/arch/mips/ar71xx/mach-eap7660d.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-eap7660d.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-eap7660d.c	2011-08-24 02:41:55.497990784 +0200
@@ -0,0 +1,180 @@
+/*
+ *  Senao EAP7660D board support
+ *
+ *  Copyright (C) 2010 Daniel Golle <daniel.golle@gmail.com>
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath5k_platform.h>
+#include <linux/delay.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+
+#define EAP7660D_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EAP7660D_KEYS_DEBOUNCE_INTERVAL	(3 * EAP7660D_KEYS_POLL_INTERVAL)
+
+#define EAP7660D_GPIO_DS4		7
+#define EAP7660D_GPIO_DS5		2
+#define EAP7660D_GPIO_DS7		0
+#define EAP7660D_GPIO_DS8		4
+#define EAP7660D_GPIO_SW1		3
+#define EAP7660D_GPIO_SW3		8
+#define EAP7660D_PHYMASK		BIT(20)
+#define EAP7660D_BOARDCONFIG		0x1F7F0000
+#define EAP7660D_GBIC_MAC_OFFSET	0x1000
+#define EAP7660D_WMAC0_MAC_OFFSET	0x1010
+#define EAP7660D_WMAC1_MAC_OFFSET	0x1016
+#define EAP7660D_WMAC0_CALDATA_OFFSET	0x2000
+#define EAP7660D_WMAC1_CALDATA_OFFSET	0x3000
+
+static struct ath5k_platform_data eap7660d_wmac0_data;
+static struct ath5k_platform_data eap7660d_wmac1_data;
+static char eap7660d_wmac0_mac[6];
+static char eap7660d_wmac1_mac[6];
+static u16 eap7660d_wmac0_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+static u16 eap7660d_wmac1_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+
+#ifdef CONFIG_PCI
+static struct ar71xx_pci_irq eap7660d_pci_irqs[] __initdata = {
+	{
+		.slot   = 0,
+		.pin    = 1,
+		.irq    = AR71XX_PCI_IRQ_DEV0,
+	}, {
+		.slot   = 1,
+		.pin    = 1,
+		.irq    = AR71XX_PCI_IRQ_DEV1,
+	}
+};
+
+static int eap7660d_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &eap7660d_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &eap7660d_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+void __init eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			      u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0 && *cal_data0 == 0xa55a) {
+		memcpy(eap7660d_wmac0_eeprom, cal_data0,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac0_data.eeprom_data = eap7660d_wmac0_eeprom;
+	}
+
+	if (cal_data1 && *cal_data1 == 0xa55a) {
+		memcpy(eap7660d_wmac1_eeprom, cal_data1,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac1_data.eeprom_data = eap7660d_wmac1_eeprom;
+	}
+
+	if (mac_addr0) {
+		memcpy(eap7660d_wmac0_mac, mac_addr0,
+			sizeof(eap7660d_wmac0_mac));
+		eap7660d_wmac0_data.macaddr = eap7660d_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(eap7660d_wmac1_mac, mac_addr1,
+			sizeof(eap7660d_wmac1_mac));
+		eap7660d_wmac1_data.macaddr = eap7660d_wmac1_mac;
+	}
+
+	ar71xx_pci_plat_dev_init = eap7660d_pci_plat_dev_init;
+	ar71xx_pci_init(ARRAY_SIZE(eap7660d_pci_irqs), eap7660d_pci_irqs);
+}
+#else
+static inline void eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				     u8 *cal_data1, u8 *mac_addr1)
+{
+}
+#endif /* CONFIG_PCI */
+
+static struct gpio_led eap7660d_leds_gpio[] __initdata = {
+	{
+		.name		= "eap7660d:green:ds8",
+		.gpio		= EAP7660D_GPIO_DS8,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds5",
+		.gpio		= EAP7660D_GPIO_DS5,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds7",
+		.gpio		= EAP7660D_GPIO_DS7,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds4",
+		.gpio		= EAP7660D_GPIO_DS4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button eap7660d_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW1,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW3,
+		.active_low	= 1,
+	}
+};
+
+static void __init eap7660d_setup(void)
+{
+	u8 *boardconfig = (u8 *) KSEG1ADDR(EAP7660D_BOARDCONFIG);
+
+	ar71xx_add_device_mdio(~EAP7660D_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr,
+			boardconfig + EAP7660D_GBIC_MAC_OFFSET, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = EAP7660D_PHYMASK;
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_m25p80(NULL);
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(eap7660d_leds_gpio),
+					eap7660d_leds_gpio);
+	ar71xx_register_gpio_keys_polled(-1, EAP7660D_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(eap7660d_gpio_keys),
+					 eap7660d_gpio_keys);
+	eap7660d_pci_init(boardconfig + EAP7660D_WMAC0_CALDATA_OFFSET,
+			boardconfig + EAP7660D_WMAC0_MAC_OFFSET,
+			boardconfig + EAP7660D_WMAC1_CALDATA_OFFSET,
+			boardconfig + EAP7660D_WMAC1_MAC_OFFSET);
+};
+
+MIPS_MACHINE(AR71XX_MACH_EAP7660D, "EAP7660D", "Senao EAP7660D",
+	     eap7660d_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-ja76pf.c linux-2.6.39/arch/mips/ar71xx/mach-ja76pf.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-ja76pf.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-ja76pf.c	2011-08-24 02:41:55.517989552 +0200
@@ -0,0 +1,102 @@
+/*
+ *  jjPlus JA76PF board support
+ */
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-usb.h"
+#include "dev-leds-gpio.h"
+
+#define JA76PF_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JA76PF_KEYS_DEBOUNCE_INTERVAL	(3 * JA76PF_KEYS_POLL_INTERVAL)
+
+#define JA76PF_GPIO_I2C_SCL		0
+#define JA76PF_GPIO_I2C_SDA		1
+#define JA76PF_GPIO_LED_1		5
+#define JA76PF_GPIO_LED_2		4
+#define JA76PF_GPIO_LED_3		3
+#define JA76PF_GPIO_BTN_RESET		11
+
+static struct gpio_led ja76pf_leds_gpio[] __initdata = {
+	{
+		.name		= "ja76pf:green:led1",
+		.gpio		= JA76PF_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "ja76pf:green:led2",
+		.gpio		= JA76PF_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "ja76pf:green:led3",
+		.gpio		= JA76PF_GPIO_LED_3,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ja76pf_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data ja76pf_i2c_gpio_data = {
+	.sda_pin	= JA76PF_GPIO_I2C_SDA,
+	.scl_pin	= JA76PF_GPIO_I2C_SCL,
+};
+
+static struct platform_device ja76pf_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &ja76pf_i2c_gpio_data,
+	}
+};
+
+#define JA76PF_WAN_PHYMASK	(1 << 4)
+#define JA76PF_LAN_PHYMASK	((1 << 0) | (1 << 1) | (1 << 2) | (1 < 3))
+#define JA76PF_MDIO_PHYMASK	(JA76PF_LAN_PHYMASK | JA76PF_WAN_PHYMASK)
+
+static void __init ja76pf_init(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(~JA76PF_MDIO_PHYMASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = JA76PF_LAN_PHYMASK;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = JA76PF_WAN_PHYMASK;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	platform_device_register(&ja76pf_i2c_gpio_device);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ja76pf_leds_gpio),
+					ja76pf_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, JA76PF_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ja76pf_gpio_keys),
+					 ja76pf_gpio_keys);
+
+	ar71xx_add_device_usb();
+	pb42_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_JA76PF, "JA76PF", "jjPlus JA76PF", ja76pf_init);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-jwap003.c linux-2.6.39/arch/mips/ar71xx/mach-jwap003.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-jwap003.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-jwap003.c	2011-08-24 02:41:55.517989552 +0200
@@ -0,0 +1,83 @@
+/*
+ *  jjPlus JWAP003 board support
+ *
+ */
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-usb.h"
+
+#define JWAP003_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JWAP003_KEYS_DEBOUNCE_INTERVAL	(3 * JWAP003_KEYS_POLL_INTERVAL)
+
+#define JWAP003_GPIO_WPS	11
+#define JWAP003_GPIO_I2C_SCL	0
+#define JWAP003_GPIO_I2C_SDA	1
+
+static struct gpio_keys_button jwap003_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = JWAP003_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JWAP003_GPIO_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data jwap003_i2c_gpio_data = {
+	.sda_pin	= JWAP003_GPIO_I2C_SDA,
+	.scl_pin	= JWAP003_GPIO_I2C_SCL,
+};
+
+static struct platform_device jwap003_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &jwap003_i2c_gpio_data,
+	}
+};
+
+#define JWAP003_WAN_PHYMASK	BIT(0)
+#define JWAP003_LAN_PHYMASK	BIT(4)
+
+static void __init jwap003_init(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.phy_mask = JWAP003_WAN_PHYMASK;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = JWAP003_LAN_PHYMASK;
+	ar71xx_eth1_data.speed = SPEED_100;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	platform_device_register(&jwap003_i2c_gpio_device);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_register_gpio_keys_polled(-1, JWAP003_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(jwap003_gpio_keys),
+					 jwap003_gpio_keys);
+
+	pb42_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_JWAP003, "JWAP003", "jjPlus JWAP003", jwap003_init);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-mzk-w04nu.c linux-2.6.39/arch/mips/ar71xx/mach-mzk-w04nu.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-mzk-w04nu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-mzk-w04nu.c	2011-08-24 02:41:55.517989552 +0200
@@ -0,0 +1,166 @@
+/*
+ *  Planex MZK-W04NU board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+
+#define MZK_W04NU_GPIO_LED_USB		0
+#define MZK_W04NU_GPIO_LED_STATUS	1
+#define MZK_W04NU_GPIO_LED_WPS		3
+#define MZK_W04NU_GPIO_LED_WLAN		6
+#define MZK_W04NU_GPIO_LED_AP		15
+#define MZK_W04NU_GPIO_LED_ROUTER	16
+
+#define MZK_W04NU_GPIO_BTN_APROUTER	5
+#define MZK_W04NU_GPIO_BTN_WPS		12
+#define MZK_W04NU_GPIO_BTN_RESET	21
+
+#define MZK_W04NU_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W04NU_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W04NU_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition mzk_w04nu_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x050000,
+		.size		= 0x160000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x1b0000,
+		.size		= 0x630000,
+	}, {
+		.name		= "art",
+		.offset		= 0x7e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x050000,
+		.size		= 0x790000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data mzk_w04nu_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts          = mzk_w04nu_partitions,
+	.nr_parts       = ARRAY_SIZE(mzk_w04nu_partitions),
+#endif
+};
+
+static struct gpio_led mzk_w04nu_leds_gpio[] __initdata = {
+	{
+		.name		= "mzk-w04nu:green:status",
+		.gpio		= MZK_W04NU_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:blue:wps",
+		.gpio		= MZK_W04NU_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:green:wlan",
+		.gpio		= MZK_W04NU_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:green:usb",
+		.gpio		= MZK_W04NU_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:green:ap",
+		.gpio		= MZK_W04NU_GPIO_LED_AP,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w04nu:green:router",
+		.gpio		= MZK_W04NU_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button mzk_w04nu_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W04NU_WAN_PHYMASK	BIT(4)
+#define MZK_W04NU_MDIO_MASK	(~MZK_W04NU_WAN_PHYMASK)
+
+static void __init mzk_w04nu_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_mdio(MZK_W04NU_MDIO_MASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = MZK_W04NU_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&mzk_w04nu_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(mzk_w04nu_leds_gpio),
+					mzk_w04nu_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, MZK_W04NU_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(mzk_w04nu_gpio_keys),
+					 mzk_w04nu_gpio_keys);
+	ar71xx_add_device_usb();
+
+	ar9xxx_add_device_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_MZK_W04NU, "MZK-W04NU", "Planex MZK-W04NU",
+	     mzk_w04nu_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-mzk-w300nh.c linux-2.6.39/arch/mips/ar71xx/mach-mzk-w300nh.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-mzk-w300nh.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-mzk-w300nh.c	2011-08-24 02:41:55.527982711 +0200
@@ -0,0 +1,159 @@
+/*
+ *  Planex MZK-W300NH board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define MZK_W300NH_GPIO_LED_STATUS	1
+#define MZK_W300NH_GPIO_LED_WPS		3
+#define MZK_W300NH_GPIO_LED_WLAN	6
+#define MZK_W300NH_GPIO_LED_AP		15
+#define MZK_W300NH_GPIO_LED_ROUTER	16
+
+#define MZK_W300NH_GPIO_BTN_APROUTER	5
+#define MZK_W300NH_GPIO_BTN_WPS		12
+#define MZK_W300NH_GPIO_BTN_RESET	21
+
+#define MZK_W300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W300NH_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W300NH_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition mzk_w300nh_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x050000,
+		.size		= 0x160000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x1b0000,
+		.size		= 0x630000,
+	}, {
+		.name		= "art",
+		.offset		= 0x7e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x050000,
+		.size		= 0x790000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data mzk_w300nh_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= mzk_w300nh_partitions,
+	.nr_parts	= ARRAY_SIZE(mzk_w300nh_partitions),
+#endif
+};
+
+static struct gpio_led mzk_w300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "mzk-w300nh:green:status",
+		.gpio		= MZK_W300NH_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w300nh:blue:wps",
+		.gpio		= MZK_W300NH_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w300nh:green:wlan",
+		.gpio		= MZK_W300NH_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w300nh:green:ap",
+		.gpio		= MZK_W300NH_GPIO_LED_AP,
+		.active_low	= 1,
+	}, {
+		.name		= "mzk-w300nh:green:router",
+		.gpio		= MZK_W300NH_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button mzk_w300nh_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W300NH_WAN_PHYMASK	BIT(4)
+#define MZK_W300NH_MDIO_MASK	(~MZK_W300NH_WAN_PHYMASK)
+
+static void __init mzk_w300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_mdio(MZK_W300NH_MDIO_MASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = MZK_W300NH_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&mzk_w300nh_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(mzk_w300nh_leds_gpio),
+					mzk_w300nh_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, MZK_W300NH_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(mzk_w300nh_gpio_keys),
+					 mzk_w300nh_gpio_keys);
+	ar9xxx_add_device_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_MZK_W300NH, "MZK-W300NH", "Planex MZK-W300NH",
+	     mzk_w300nh_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-nbg460n.c linux-2.6.39/arch/mips/ar71xx/mach-nbg460n.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-nbg460n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-nbg460n.c	2011-08-24 02:41:55.537990605 +0200
@@ -0,0 +1,225 @@
+/*
+ *  Zyxel NBG 460N/550N/550NH board support
+ *
+ *  Copyright (C) 2010 Michael Kurz <michi.kurz@googlemail.com>
+ *
+ *  based on mach-tl-wr1043nd.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+/* LEDs */
+#define NBG460N_GPIO_LED_WPS		3
+#define NBG460N_GPIO_LED_WAN		6
+#define NBG460N_GPIO_LED_POWER		14
+#define NBG460N_GPIO_LED_WLAN		15
+
+/* Buttons */
+#define NBG460N_GPIO_BTN_WPS		12
+#define NBG460N_GPIO_BTN_RESET		21
+
+#define NBG460N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define NBG460N_KEYS_DEBOUNCE_INTERVAL	(3 * NBG460N_KEYS_POLL_INTERVAL)
+
+/* RTC chip PCF8563 I2C interface */
+#define NBG460N_GPIO_PCF8563_SDA	8
+#define NBG460N_GPIO_PCF8563_SCK	7
+
+/* Switch configuration I2C interface */
+#define NBG460N_GPIO_RTL8366_SDA	16
+#define NBG460N_GPIO_RTL8366_SCK	18
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition nbg460n_partitions[] = {
+	{
+		.name		= "Bootbase",
+		.offset		= 0,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "U-Boot Config",
+		.offset		= 0x010000,
+		.size		= 0x030000,
+	}, {
+		.name		= "U-Boot",
+		.offset		= 0x040000,
+		.size		= 0x030000,
+	}, {
+		.name		= "linux",
+		.offset		= 0x070000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x150000,
+		.size		= 0x2a0000,
+	}, {
+		.name		= "CalibData",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x070000,
+		.size		= 0x380000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data nbg460n_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= nbg460n_partitions,
+	.nr_parts       = ARRAY_SIZE(nbg460n_partitions),
+#endif
+};
+
+static struct gpio_led nbg460n_leds_gpio[] __initdata = {
+	{
+		.name		= "nbg460n:green:power",
+		.gpio		= NBG460N_GPIO_LED_POWER,
+		.active_low	= 0,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "nbg460n:green:wps",
+		.gpio		= NBG460N_GPIO_LED_WPS,
+		.active_low	= 0,
+	}, {
+		.name		= "nbg460n:green:wlan",
+		.gpio		= NBG460N_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}, {
+		/* Not really for controlling the LED,
+		   when set low the LED blinks uncontrollable  */
+		.name		= "nbg460n:green:wan",
+		.gpio		= NBG460N_GPIO_LED_WAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button nbg460n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data nbg460n_i2c_device_platdata = {
+	.sda_pin	= NBG460N_GPIO_PCF8563_SDA,
+	.scl_pin	= NBG460N_GPIO_PCF8563_SCK,
+	.udelay		= 10,
+};
+
+static struct platform_device nbg460n_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= -1,
+	.num_resources	= 0,
+	.resource	= NULL,
+	.dev		= {
+		.platform_data	= &nbg460n_i2c_device_platdata,
+	},
+};
+
+static struct i2c_board_info nbg460n_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf8563", 0x51),
+	},
+};
+
+static void __devinit nbg460n_i2c_init(void)
+{
+	/* The gpio interface */
+	platform_device_register(&nbg460n_i2c_device);
+	/* I2C devices */
+	i2c_register_board_info(0, nbg460n_i2c_devs,
+				ARRAY_SIZE(nbg460n_i2c_devs));
+}
+
+
+static struct rtl8366_platform_data nbg460n_rtl8366s_data = {
+	.gpio_sda	= NBG460N_GPIO_RTL8366_SDA,
+	.gpio_sck	= NBG460N_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device nbg460n_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &nbg460n_rtl8366s_data,
+	}
+};
+
+static void __init nbg460n_setup(void)
+{
+	/* end of bootloader sector contains mac address */
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fc0fff8);
+	/* last sector contains wlan calib data */
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* LAN Port */
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_eth0_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	/* WAN Port */
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+	ar71xx_eth1_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	/* register the switch phy */
+	platform_device_register(&nbg460n_rtl8366s_device);
+
+	/* register flash */
+	ar71xx_add_device_m25p80(&nbg460n_flash_data);
+
+	ar9xxx_add_device_wmac(eeprom, mac);
+
+	/* register RTC chip */
+	nbg460n_i2c_init();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(nbg460n_leds_gpio),
+					nbg460n_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, NBG460N_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(nbg460n_gpio_keys),
+					 nbg460n_gpio_keys);
+}
+
+MIPS_MACHINE(AR71XX_MACH_NBG460N, "NBG460N", "Zyxel NBG460N/550N/550NH",
+	     nbg460n_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-pb42.c linux-2.6.39/arch/mips/ar71xx/mach-pb42.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-pb42.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-pb42.c	2011-08-24 02:41:55.537990605 +0200
@@ -0,0 +1,74 @@
+/*
+ *  Atheros PB42 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-usb.h"
+
+#define PB42_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB42_KEYS_DEBOUNCE_INTERVAL	(3 * PB42_KEYS_POLL_INTERVAL)
+
+#define PB42_GPIO_BTN_SW4	8
+#define PB42_GPIO_BTN_SW5	3
+
+static struct gpio_keys_button pb42_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB42_GPIO_BTN_SW4,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw5",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB42_GPIO_BTN_SW5,
+		.active_low	= 1,
+	}
+};
+
+#define PB42_WAN_PHYMASK	BIT(20)
+#define PB42_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
+#define PB42_MDIO_PHYMASK	(PB42_LAN_PHYMASK | PB42_WAN_PHYMASK)
+
+static void __init pb42_init(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(~PB42_MDIO_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = PB42_WAN_PHYMASK;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_100;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_register_gpio_keys_polled(-1, PB42_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(pb42_gpio_keys),
+					 pb42_gpio_keys);
+
+	pb42_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_PB42, "PB42", "Atheros PB42", pb42_init);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-pb44.c linux-2.6.39/arch/mips/ar71xx/mach-pb44.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-pb44.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-pb44.c	2011-08-24 02:41:55.537990605 +0200
@@ -0,0 +1,213 @@
+/*
+ *  Atheros PB44 board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/vsc7385.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/i2c/pcf857x.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-pb42-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define PB44_PCF8757_VSC7395_CS	0
+#define PB44_PCF8757_STEREO_CS	1
+#define PB44_PCF8757_SLIC_CS0	2
+#define PB44_PCF8757_SLIC_TEST	3
+#define PB44_PCF8757_SLIC_INT0	4
+#define PB44_PCF8757_SLIC_INT1	5
+#define PB44_PCF8757_SW_RESET	6
+#define PB44_PCF8757_SW_JUMP	8
+#define PB44_PCF8757_LED_JUMP1	9
+#define PB44_PCF8757_LED_JUMP2	10
+#define PB44_PCF8757_TP24	11
+#define PB44_PCF8757_TP25	12
+#define PB44_PCF8757_TP26	13
+#define PB44_PCF8757_TP27	14
+#define PB44_PCF8757_TP28	15
+
+#define PB44_GPIO_I2C_SCL	0
+#define PB44_GPIO_I2C_SDA	1
+
+#define PB44_GPIO_EXP_BASE	16
+#define PB44_GPIO_VSC7395_CS	(PB44_GPIO_EXP_BASE + PB44_PCF8757_VSC7395_CS)
+#define PB44_GPIO_SW_RESET	(PB44_GPIO_EXP_BASE + PB44_PCF8757_SW_RESET)
+#define PB44_GPIO_SW_JUMP	(PB44_GPIO_EXP_BASE + PB44_PCF8757_SW_JUMP)
+#define PB44_GPIO_LED_JUMP1	(PB44_GPIO_EXP_BASE + PB44_PCF8757_LED_JUMP1)
+#define PB44_GPIO_LED_JUMP2	(PB44_GPIO_EXP_BASE + PB44_PCF8757_LED_JUMP2)
+
+#define PB44_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB44_KEYS_DEBOUNCE_INTERVAL	(3 * PB44_KEYS_POLL_INTERVAL)
+
+static struct i2c_gpio_platform_data pb44_i2c_gpio_data = {
+	.sda_pin        = PB44_GPIO_I2C_SDA,
+	.scl_pin        = PB44_GPIO_I2C_SCL,
+};
+
+static struct platform_device pb44_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data	= &pb44_i2c_gpio_data,
+	}
+};
+
+static struct pcf857x_platform_data pb44_pcf857x_data = {
+	.gpio_base	= PB44_GPIO_EXP_BASE,
+};
+
+static struct i2c_board_info pb44_i2c_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf8575", 0x20),
+		.platform_data  = &pb44_pcf857x_data,
+	},
+};
+
+static struct gpio_led pb44_leds_gpio[] __initdata = {
+	{
+		.name		= "pb44:amber:jump1",
+		.gpio		= PB44_GPIO_LED_JUMP1,
+		.active_low	= 1,
+	}, {
+		.name		= "pb44:green:jump2",
+		.gpio		= PB44_GPIO_LED_JUMP2,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button pb44_gpio_keys[] __initdata = {
+	{
+		.desc		= "soft_reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = PB44_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB44_GPIO_SW_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "jumpstart",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = PB44_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB44_GPIO_SW_JUMP,
+		.active_low	= 1,
+	}
+};
+
+static void pb44_vsc7395_reset(void)
+{
+	ar71xx_device_stop(RESET_MODULE_GE1_PHY);
+	udelay(10);
+	ar71xx_device_start(RESET_MODULE_GE1_PHY);
+	mdelay(50);
+}
+
+static struct vsc7385_platform_data pb44_vsc7395_data = {
+	.reset		= pb44_vsc7395_reset,
+	.ucode_name	= "vsc7395_ucode_pb44.bin",
+	.mac_cfg = {
+		.tx_ipg		= 6,
+		.bit2		= 1,
+		.clk_sel	= 0,
+	},
+};
+
+static struct spi_board_info pb44_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-vsc7385",
+		.platform_data	= &pb44_vsc7395_data,
+		.controller_data = (void *) PB44_GPIO_VSC7395_CS,
+	},
+};
+
+static struct resource pb44_spi_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct ar71xx_spi_platform_data pb44_spi_data = {
+	.bus_num		= 0,
+	.num_chipselect		= 2,
+};
+
+static struct platform_device pb44_spi_device = {
+	.name		= "pb44-spi",
+	.id		= -1,
+	.resource	= pb44_spi_resources,
+	.num_resources	= ARRAY_SIZE(pb44_spi_resources),
+	.dev = {
+		.platform_data = &pb44_spi_data,
+	},
+};
+
+#define PB44_WAN_PHYMASK	BIT(0)
+#define PB44_LAN_PHYMASK	0
+#define PB44_MDIO_PHYMASK	(PB44_LAN_PHYMASK | PB44_WAN_PHYMASK)
+
+static void __init pb44_init(void)
+{
+	ar71xx_add_device_mdio(~PB44_MDIO_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = PB44_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+	ar71xx_eth1_pll_data.pll_1000 = 0x110000;
+
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	pb42_pci_init();
+
+	i2c_register_board_info(0, pb44_i2c_board_info,
+				ARRAY_SIZE(pb44_i2c_board_info));
+
+	platform_device_register(&pb44_i2c_gpio_device);
+
+	spi_register_board_info(pb44_spi_info, ARRAY_SIZE(pb44_spi_info));
+	platform_device_register(&pb44_spi_device);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(pb44_leds_gpio),
+					pb44_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, PB44_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(pb44_gpio_keys),
+					 pb44_gpio_keys);
+}
+
+MIPS_MACHINE(AR71XX_MACH_PB44, "PB44", "Atheros PB44", pb44_init);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-pb92.c linux-2.6.39/arch/mips/ar71xx/mach-pb92.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-pb92.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-pb92.c	2011-08-24 02:41:55.567991163 +0200
@@ -0,0 +1,105 @@
+/*
+ *  Atheros PB92 board support
+ *
+ *  Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb9x-pci.h"
+#include "dev-usb.h"
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition pb92_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x2b0000,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x300000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x3e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data pb92_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= pb92_partitions,
+	.nr_parts	= ARRAY_SIZE(pb92_partitions),
+#endif
+};
+
+#define PB92_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB92_KEYS_DEBOUNCE_INTERVAL	(3 * PB92_KEYS_POLL_INTERVAL)
+
+#define PB92_GPIO_BTN_SW4	8
+#define PB92_GPIO_BTN_SW5	3
+
+static struct gpio_keys_button pb92_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = PB92_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB92_GPIO_BTN_SW4,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw5",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = PB92_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB92_GPIO_BTN_SW5,
+		.active_low	= 1,
+	}
+};
+
+static void __init pb92_init(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_add_device_m25p80(&pb92_flash_data);
+
+	ar71xx_add_device_mdio(~BIT(0));
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = BIT(0);
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_register_gpio_keys_polled(-1, PB92_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(pb92_gpio_keys),
+					 pb92_gpio_keys);
+
+	pb9x_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_PB92, "PB92", "Atheros PB92", pb92_init);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-rb4xx.c linux-2.6.39/arch/mips/ar71xx/mach-rb4xx.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-rb4xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-rb4xx.c	2011-08-24 02:41:55.567991163 +0200
@@ -0,0 +1,344 @@
+/*
+ *  MikroTik RouterBOARD 4xx series support
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mmc/host.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/mmc_spi.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+#include <asm/mach-ar71xx/rb4xx_cpld.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define RB4XX_GPIO_USER_LED	4
+#define RB4XX_GPIO_RESET_SWITCH	7
+
+#define RB4XX_GPIO_CPLD_BASE	32
+#define RB4XX_GPIO_CPLD_LED1	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED1)
+#define RB4XX_GPIO_CPLD_LED2	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED2)
+#define RB4XX_GPIO_CPLD_LED3	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED3)
+#define RB4XX_GPIO_CPLD_LED4	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED4)
+#define RB4XX_GPIO_CPLD_LED5	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED5)
+
+#define RB4XX_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RB4XX_KEYS_DEBOUNCE_INTERVAL	(3 * RB4XX_KEYS_POLL_INTERVAL)
+
+static struct gpio_led rb4xx_leds_gpio[] __initdata = {
+	{
+		.name		= "rb4xx:yellow:user",
+		.gpio		= RB4XX_GPIO_USER_LED,
+		.active_low	= 0,
+	}, {
+		.name		= "rb4xx:green:led1",
+		.gpio		= RB4XX_GPIO_CPLD_LED1,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led2",
+		.gpio		= RB4XX_GPIO_CPLD_LED2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led3",
+		.gpio		= RB4XX_GPIO_CPLD_LED3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led4",
+		.gpio		= RB4XX_GPIO_CPLD_LED4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led5",
+		.gpio		= RB4XX_GPIO_CPLD_LED5,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button rb4xx_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset_switch",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RB4XX_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RB4XX_GPIO_RESET_SWITCH,
+		.active_low	= 1,
+	}
+};
+
+static struct platform_device rb4xx_nand_device = {
+	.name	= "rb4xx-nand",
+	.id	= -1,
+};
+
+static struct ar71xx_pci_irq rb4xx_pci_irqs[] __initdata = {
+	{
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV2,
+	}, {
+		.slot	= 1,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV0,
+	}, {
+		.slot	= 1,
+		.pin	= 2,
+		.irq	= AR71XX_PCI_IRQ_DEV1,
+	}, {
+		.slot	= 2,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV1,
+	}, {
+		.slot	= 3,
+		.pin	= 1,
+		.irq	= AR71XX_PCI_IRQ_DEV2,
+	}
+};
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition rb4xx_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= 0,
+		.size		= 0x0b000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.offset		= 0x0b000,
+		.size		= 0x01000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= 0x0d000,
+		.size		= 0x02000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.offset		= 0x0f000,
+		.size		= 0x01000,
+	}
+};
+#define rb4xx_num_partitions	ARRAY_SIZE(rb4xx_partitions)
+#else /* CONFIG_MTD_PARTITIONS */
+#define rb4xx_partitions	NULL
+#define rb4xx_num_partitions	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data rb4xx_flash_data = {
+	.type		= "pm25lv512",
+	.parts		= rb4xx_partitions,
+	.nr_parts	= rb4xx_num_partitions,
+};
+
+static struct rb4xx_cpld_platform_data rb4xx_cpld_data = {
+	.gpio_base	= RB4XX_GPIO_CPLD_BASE,
+};
+
+static struct mmc_spi_platform_data rb4xx_mmc_data = {
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+static struct spi_board_info rb4xx_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data	= &rb4xx_flash_data,
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-rb4xx-cpld",
+		.platform_data	= &rb4xx_cpld_data,
+	}
+};
+
+static struct spi_board_info rb4xx_microsd_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 2,
+		.max_speed_hz	= 25000000,
+		.modalias	= "mmc_spi",
+		.platform_data	= &rb4xx_mmc_data,
+	}
+};
+
+
+static struct resource rb4xx_spi_resources[] = {
+	{
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device rb4xx_spi_device = {
+	.name		= "rb4xx-spi",
+	.id		= -1,
+	.resource	= rb4xx_spi_resources,
+	.num_resources	= ARRAY_SIZE(rb4xx_spi_resources),
+};
+
+static void __init rb4xx_generic_setup(void)
+{
+	ar71xx_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+					AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
+					rb4xx_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, RB4XX_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(rb4xx_gpio_keys),
+					 rb4xx_gpio_keys);
+
+	spi_register_board_info(rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+	platform_device_register(&rb4xx_spi_device);
+	platform_device_register(&rb4xx_nand_device);
+}
+
+static void __init rb411_setup(void)
+{
+	rb4xx_generic_setup();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ar71xx_add_device_mdio(0xfffffffc);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = 0x00000003;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_pci_init(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_411, "411", "MikroTik RouterBOARD 411/A/AH",
+	     rb411_setup);
+
+static void __init rb411u_setup(void)
+{
+	rb411_setup();
+	ar71xx_add_device_usb();
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_411U, "411U", "MikroTik RouterBOARD 411U",
+	     rb411u_setup);
+
+#define RB433_LAN_PHYMASK	BIT(0)
+#define RB433_WAN_PHYMASK	BIT(4)
+#define RB433_MDIO_PHYMASK	(RB433_LAN_PHYMASK | RB433_WAN_PHYMASK)
+
+static void __init rb433_setup(void)
+{
+	rb4xx_generic_setup();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ar71xx_add_device_mdio(~RB433_MDIO_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 1);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = RB433_LAN_PHYMASK;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = RB433_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ar71xx_pci_init(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_433, "433", "MikroTik RouterBOARD 433/AH",
+	     rb433_setup);
+
+static void __init rb433u_setup(void)
+{
+	rb433_setup();
+	ar71xx_add_device_usb();
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_433U, "433U", "MikroTik RouterBOARD 433UAH",
+	     rb433u_setup);
+
+#define RB450_LAN_PHYMASK	BIT(0)
+#define RB450_WAN_PHYMASK	BIT(4)
+#define RB450_MDIO_PHYMASK	(RB450_LAN_PHYMASK | RB450_WAN_PHYMASK)
+
+static void __init rb450_generic_setup(int gige)
+{
+	rb4xx_generic_setup();
+	ar71xx_add_device_mdio(~RB450_MDIO_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 1);
+	ar71xx_eth0_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = RB450_LAN_PHYMASK;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth1_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = RB450_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+}
+
+static void __init rb450_setup(void)
+{
+	rb450_generic_setup(0);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_450, "450", "MikroTik RouterBOARD 450",
+	     rb450_setup);
+
+static void __init rb450g_setup(void)
+{
+	rb450_generic_setup(1);
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_450G, "450G", "MikroTik RouterBOARD 450G",
+	     rb450g_setup);
+
+static void __init rb493_setup(void)
+{
+	rb4xx_generic_setup();
+
+	ar71xx_add_device_mdio(0x3fffff00);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x00000001;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_pci_init(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_493, "493", "MikroTik RouterBOARD 493/AH",
+	     rb493_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-rb750.c linux-2.6.39/arch/mips/ar71xx/mach-rb750.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-rb750.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-rb750.c	2011-08-24 02:41:55.567991163 +0200
@@ -0,0 +1,144 @@
+/*
+ *  MikroTik RouterBOARD 750 support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/mach-rb750.h>
+
+#include "machtype.h"
+#include "devices.h"
+
+static struct rb750_led_data rb750_leds[] = {
+	{
+		.name		= "rb750:green:act",
+		.mask		= RB750_LED_ACT,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port1",
+		.mask		= RB750_LED_PORT5,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port2",
+		.mask		= RB750_LED_PORT4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port3",
+		.mask		= RB750_LED_PORT3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port4",
+		.mask		= RB750_LED_PORT2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port5",
+		.mask		= RB750_LED_PORT1,
+		.active_low	= 1,
+	}
+};
+
+static struct rb750_led_platform_data rb750_leds_data = {
+	.num_leds	= ARRAY_SIZE(rb750_leds),
+	.leds		= rb750_leds,
+};
+
+static struct platform_device rb750_leds_device = {
+	.name	= "leds-rb750",
+	.dev	= {
+		.platform_data = &rb750_leds_data,
+	}
+};
+
+static struct platform_device rb750_nand_device = {
+	.name	= "rb750-nand",
+	.id	= -1,
+};
+
+int rb750_latch_change(u32 mask_clr, u32 mask_set)
+{
+	static DEFINE_SPINLOCK(lock);
+	static u32 latch_set = RB750_LED_BITS | RB750_LVC573_LE;
+	static u32 latch_oe;
+	static u32 latch_clr;
+	unsigned long flags;
+	u32 t;
+	int ret = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	if ((mask_clr & BIT(31)) != 0 &&
+	    (latch_set & RB750_LVC573_LE) == 0) {
+		goto unlock;
+	}
+
+	latch_set = (latch_set | mask_set) & ~mask_clr;
+	latch_clr = (latch_clr | mask_clr) & ~mask_set;
+
+	if (latch_oe == 0)
+		latch_oe = __raw_readl(ar71xx_gpio_base + GPIO_REG_OE);
+
+	if (likely(latch_set & RB750_LVC573_LE)) {
+		void __iomem *base = ar71xx_gpio_base;
+
+		t = __raw_readl(base + GPIO_REG_OE);
+		t |= mask_clr | latch_oe | mask_set;
+
+		__raw_writel(t, base + GPIO_REG_OE);
+		__raw_writel(latch_clr, base + GPIO_REG_CLEAR);
+		__raw_writel(latch_set, base + GPIO_REG_SET);
+	} else if (mask_clr & RB750_LVC573_LE) {
+		void __iomem *base = ar71xx_gpio_base;
+
+		latch_oe = __raw_readl(base + GPIO_REG_OE);
+		__raw_writel(RB750_LVC573_LE, base + GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + GPIO_REG_CLEAR);
+	}
+
+	ret = 1;
+
+unlock:
+	spin_unlock_irqrestore(&lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(rb750_latch_change);
+
+static void __init rb750_setup(void)
+{
+	ar71xx_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, ar71xx_mac_base, 1);
+
+	/* WAN port */
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = BIT(4);
+
+	/* LAN ports */
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+	ar71xx_eth1_data.has_ar7240_switch = 1;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	platform_device_register(&rb750_leds_device);
+	platform_device_register(&rb750_nand_device);
+}
+
+MIPS_MACHINE(AR71XX_MACH_RB_750, "750i", "MikroTik RouterBOARD 750",
+	     rb750_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-tew-632brp.c linux-2.6.39/arch/mips/ar71xx/mach-tew-632brp.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-tew-632brp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-tew-632brp.c	2011-08-24 02:41:55.577989822 +0200
@@ -0,0 +1,151 @@
+/*
+ *  TrendNET TEW-632BRP board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "nvram.h"
+
+#define TEW_632BRP_GPIO_LED_STATUS	1
+#define TEW_632BRP_GPIO_LED_WPS		3
+#define TEW_632BRP_GPIO_LED_WLAN	6
+#define TEW_632BRP_GPIO_BTN_WPS		12
+#define TEW_632BRP_GPIO_BTN_RESET	21
+
+#define TEW_632BRP_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TEW_632BRP_KEYS_DEBOUNCE_INTERVAL (3 * TEW_632BRP_KEYS_POLL_INTERVAL)
+
+#define TEW_632BRP_CONFIG_ADDR	0x1f020000
+#define TEW_632BRP_CONFIG_SIZE	0x10000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tew_632brp_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "config",
+		.offset		= 0x020000,
+		.size		= 0x010000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x030000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x110000,
+		.size		= 0x2e0000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x030000,
+		.size		= 0x3c0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tew_632brp_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tew_632brp_partitions,
+	.nr_parts	= ARRAY_SIZE(tew_632brp_partitions),
+#endif
+};
+
+static struct gpio_led tew_632brp_leds_gpio[] __initdata = {
+	{
+		.name		= "tew-632brp:green:status",
+		.gpio		= TEW_632BRP_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:blue:wps",
+		.gpio		= TEW_632BRP_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:green:wlan",
+		.gpio		= TEW_632BRP_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tew_632brp_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_632BRP_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_632BRP_GPIO_BTN_WPS,
+	}
+};
+
+#define TEW_632BRP_LAN_PHYMASK	BIT(0)
+#define TEW_632BRP_WAN_PHYMASK	BIT(4)
+#define TEW_632BRP_MDIO_MASK	(~(TEW_632BRP_LAN_PHYMASK | \
+				   TEW_632BRP_WAN_PHYMASK))
+
+static void __init tew_632brp_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(TEW_632BRP_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+	u8 *wlan_mac = NULL;
+
+	if (nvram_parse_mac_addr(config, TEW_632BRP_CONFIG_SIZE,
+				"lan_mac=", mac) == 0) {
+		ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+		ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+		wlan_mac = mac;
+	}
+
+	ar71xx_add_device_mdio(TEW_632BRP_MDIO_MASK);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.phy_mask = TEW_632BRP_LAN_PHYMASK;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = TEW_632BRP_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&tew_632brp_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tew_632brp_leds_gpio),
+					tew_632brp_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TEW_632BRP_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tew_632brp_gpio_keys),
+					 tew_632brp_gpio_keys);
+
+	ar9xxx_add_device_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TEW_632BRP, "TEW-632BRP", "TRENDnet TEW-632BRP",
+	     tew_632brp_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-mr3x20.c linux-2.6.39/arch/mips/ar71xx/mach-tl-mr3x20.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-mr3x20.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-tl-mr3x20.c	2011-08-24 02:41:55.577989822 +0200
@@ -0,0 +1,166 @@
+/*
+ *  TP-LINK TL-MR3220/3420 board support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define TL_MR3X20_GPIO_LED_QSS		0
+#define TL_MR3X20_GPIO_LED_SYSTEM	1
+#define TL_MR3X20_GPIO_LED_3G		8
+
+#define TL_MR3X20_GPIO_BTN_RESET	11
+#define TL_MR3X20_GPIO_BTN_QSS		12
+
+#define TL_MR3X20_GPIO_USB_POWER	6
+
+#define TL_MR3X20_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR3X20_KEYS_DEBOUNCE_INTERVAL (3 * TL_MR3X20_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_mr3x20_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#define tl_mr3x20_num_partitions	ARRAY_SIZE(tl_mr3x20_partitions)
+#else
+#define tl_mr3x20_partitions		NULL
+#define tl_mr3x20_num_partitions	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_mr3x20_flash_data = {
+	.parts		= tl_mr3x20_partitions,
+	.nr_parts	= tl_mr3x20_num_partitions,
+};
+
+static struct gpio_led tl_mr3x20_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-mr3x20:green:system",
+		.gpio		= TL_MR3X20_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-mr3x20:green:qss",
+		.gpio		= TL_MR3X20_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-mr3x20:green:3g",
+		.gpio		= TL_MR3X20_GPIO_LED_3G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_mr3x20_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_mr3x20_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* enable power for the USB port */
+	gpio_request(TL_MR3X20_GPIO_USB_POWER, "USB power");
+	gpio_direction_output(TL_MR3X20_GPIO_USB_POWER, 1);
+
+	ar71xx_add_device_m25p80(&tl_mr3x20_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio),
+					tl_mr3x20_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_MR3X20_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_mr3x20_gpio_keys),
+					 tl_mr3x20_gpio_keys);
+
+	ar71xx_eth1_data.has_ar7240_switch = 1;
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	/* WAN port */
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = BIT(4);
+
+	/* LAN ports */
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_usb();
+
+	ap91_pci_init(ee, mac);
+}
+
+static void __init tl_mr3220_setup(void)
+{
+	tl_mr3x20_setup();
+	ap91_pci_setup_wmac_led_pin(1);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_MR3220, "TL-MR3220", "TP-LINK TL-MR3220",
+	     tl_mr3220_setup);
+
+static void __init tl_mr3420_setup(void)
+{
+	tl_mr3x20_setup();
+	ap91_pci_setup_wmac_led_pin(0);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_MR3420, "TL-MR3420", "TP-LINK TL-MR3420",
+	     tl_mr3420_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wa901nd.c linux-2.6.39/arch/mips/ar71xx/mach-tl-wa901nd.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wa901nd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-tl-wa901nd.c	2011-08-24 02:41:55.587990766 +0200
@@ -0,0 +1,130 @@
+/*
+ *  TP-LINK TL-WA901ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define TL_WA901ND_GPIO_LED_QSS		0
+#define TL_WA901ND_GPIO_LED_SYSTEM	1
+
+#define TL_WA901ND_GPIO_BTN_RESET	11
+#define TL_WA901ND_GPIO_BTN_QSS		12
+
+#define TL_WA901ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WA901ND_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wa901nd_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wa901nd_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tl_wa901nd_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wa901nd_partitions),
+#endif
+};
+
+static struct gpio_led tl_wa901nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wa901nd:green:system",
+		.gpio		= TL_WA901ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wa901nd:green:qss",
+		.gpio		= TL_WA901ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wa901nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/*
+	 * ar71xx_eth0 would be the WAN port, but is not connected on
+	 * the TL-WA901ND. ar71xx_eth1 connects to the internal switch chip,
+	 * however we have a single LAN port only.
+	 */
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 0);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed       = SPEED_1000;
+	ar71xx_eth1_data.duplex      = DUPLEX_FULL;
+	ar71xx_eth1_data.has_ar7240_switch = 1;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&tl_wa901nd_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_leds_gpio),
+					tl_wa901nd_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_WA901ND_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wa901nd_gpio_keys),
+					 tl_wa901nd_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WA901ND, "TL-WA901ND", "TP-LINK TL-WA901ND",
+	     tl_wa901nd_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wa901nd-v2.c linux-2.6.39/arch/mips/ar71xx/mach-tl-wa901nd-v2.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wa901nd-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-tl-wa901nd-v2.c	2011-08-24 02:41:55.587990766 +0200
@@ -0,0 +1,132 @@
+/*
+ *  TP-LINK TL-WA901ND v2 board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *  Copyright (C) 2011 Jonathan Bennett <jbscience87@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-ar9xxx-wmac.h"
+
+#define TL_WA901ND_V2_GPIO_LED_QSS		4
+#define TL_WA901ND_V2_GPIO_LED_SYSTEM		2
+#define TL_WA901ND_V2_GPIO_LED_WLAN		9
+
+
+#define TL_WA901ND_V2_GPIO_BTN_RESET		3
+#define TL_WA901ND_V2_GPIO_BTN_QSS		7
+
+#define TL_WA901ND_V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * TL_WA901ND_V2_KEYS_POLL_INTERVAL)
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wa901nd_v2_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wa901nd_v2_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tl_wa901nd_v2_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wa901nd_v2_partitions),
+#endif
+};
+
+static struct gpio_led tl_wa901nd_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wa901nd-v2:green:system",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wa901nd-v2:green:qss",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_QSS,
+	}, {
+		.name		= "tl-wa901nd-v2:green:wlan",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wa901nd_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = 0x00001000;
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.reset_bit = RESET_MODULE_GE0_MAC |
+				     RESET_MODULE_GE0_PHY;
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_m25p80(&tl_wa901nd_v2_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_v2_leds_gpio),
+					tl_wa901nd_v2_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_WA901ND_V2_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wa901nd_v2_gpio_keys),
+					 tl_wa901nd_v2_gpio_keys);
+
+        ar9xxx_add_device_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WA901ND_V2, "TL-WA901ND-v2",
+	     "TP-LINK TL-WA901ND v2", tl_wa901nd_v2_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wr1043nd.c linux-2.6.39/arch/mips/ar71xx/mach-tl-wr1043nd.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wr1043nd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-tl-wr1043nd.c	2011-08-24 02:41:55.587990766 +0200
@@ -0,0 +1,156 @@
+/*
+ *  TP-LINK TL-WR1043ND board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/rtl8366.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define TL_WR1043ND_GPIO_LED_USB        1
+#define TL_WR1043ND_GPIO_LED_SYSTEM     2
+#define TL_WR1043ND_GPIO_LED_QSS        5
+#define TL_WR1043ND_GPIO_LED_WLAN       9
+
+#define TL_WR1043ND_GPIO_BTN_RESET      3
+#define TL_WR1043ND_GPIO_BTN_QSS        7
+
+#define TL_WR1043ND_GPIO_RTL8366_SDA	18
+#define TL_WR1043ND_GPIO_RTL8366_SCK	19
+
+#define TL_WR1043ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR1043ND_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr1043nd_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x690000,
+	}, {
+		.name		= "art",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x7d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr1043nd_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tl_wr1043nd_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr1043nd_partitions),
+#endif
+};
+
+static struct gpio_led tl_wr1043nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr1043nd:green:usb",
+		.gpio		= TL_WR1043ND_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr1043nd:green:system",
+		.gpio		= TL_WR1043ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr1043nd:green:qss",
+		.gpio		= TL_WR1043ND_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tl-wr1043nd:green:wlan",
+		.gpio		= TL_WR1043ND_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr1043nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_platform_data tl_wr1043nd_rtl8366rb_data = {
+	.gpio_sda        = TL_WR1043ND_GPIO_RTL8366_SDA,
+	.gpio_sck        = TL_WR1043ND_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device tl_wr1043nd_rtl8366rb_device = {
+	.name		= RTL8366RB_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tl_wr1043nd_rtl8366rb_data,
+	}
+};
+
+static void __init tl_wr1043nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_eth0_data.mii_bus_dev = &tl_wr1043nd_rtl8366rb_device.dev;
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_pll_data.pll_1000 = 0x1a000000;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&tl_wr1043nd_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr1043nd_leds_gpio),
+					tl_wr1043nd_leds_gpio);
+
+	platform_device_register(&tl_wr1043nd_rtl8366rb_device);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_WR1043ND_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr1043nd_gpio_keys),
+					 tl_wr1043nd_gpio_keys);
+
+	ar9xxx_add_device_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WR1043ND, "TL-WR1043ND", "TP-LINK TL-WR1043ND",
+	     tl_wr1043nd_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wr741nd.c linux-2.6.39/arch/mips/ar71xx/mach-tl-wr741nd.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wr741nd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-tl-wr741nd.c	2011-08-24 02:41:55.587990766 +0200
@@ -0,0 +1,135 @@
+/*
+ *  TP-LINK TL-WR741ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define TL_WR741ND_GPIO_LED_QSS		0
+#define TL_WR741ND_GPIO_LED_SYSTEM	1
+
+#define TL_WR741ND_GPIO_BTN_RESET	11
+#define TL_WR741ND_GPIO_BTN_QSS		12
+
+#define TL_WR741ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR741ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR741ND_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr741nd_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr741nd_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tl_wr741nd_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr741nd_partitions),
+#endif
+};
+
+static struct gpio_led tl_wr741nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr741nd:green:system",
+		.gpio		= TL_WR741ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr741nd:green:qss",
+		.gpio		= TL_WR741ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr741nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wr741nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_m25p80(&tl_wr741nd_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr741nd_leds_gpio),
+					tl_wr741nd_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_WR741ND_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr741nd_gpio_keys),
+					 tl_wr741nd_gpio_keys);
+
+	ar71xx_eth1_data.has_ar7240_switch = 1;
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	/* WAN port */
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = BIT(4);
+
+	/* LAN ports */
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ap91_pci_setup_wmac_led_pin(1);
+
+	ap91_pci_init(ee, mac);
+}
+MIPS_MACHINE(AR71XX_MACH_TL_WR741ND, "TL-WR741ND", "TP-LINK TL-WR741ND",
+	     tl_wr741nd_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wr841n.c linux-2.6.39/arch/mips/ar71xx/mach-tl-wr841n.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wr841n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-tl-wr841n.c	2011-08-24 02:41:55.597982750 +0200
@@ -0,0 +1,144 @@
+/*
+ *  TP-LINK TL-WR841N board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-dsa.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-leds-gpio.h"
+
+#define TL_WR841ND_V1_GPIO_LED_SYSTEM		2
+#define TL_WR841ND_V1_GPIO_LED_QSS_GREEN	4
+#define TL_WR841ND_V1_GPIO_LED_QSS_RED		5
+
+#define TL_WR841ND_V1_GPIO_BTN_RESET	3
+#define TL_WR841ND_V1_GPIO_BTN_QSS	7
+
+#define TL_WR841ND_V1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL \
+				(3 * TL_WR841ND_V1_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr841n_v1_partitions[] = {
+	{
+		.name		= "redboot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x280000,
+	}, {
+		.name		= "config",
+		.offset		= 0x3e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3c0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr841n_v1_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tl_wr841n_v1_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr841n_v1_partitions),
+#endif
+};
+
+static struct gpio_led tl_wr841n_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr841n:green:system",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr841n:red:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tl-wr841n:green:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_GREEN,
+	}
+};
+
+static struct gpio_keys_button tl_wr841n_v1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr841n_v1_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr841n_v1_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr841n_v1_dsa_chip,
+};
+
+static void __init tl_wr841n_v1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_dsa(0, &tl_wr841n_v1_dsa_data);
+
+	ar71xx_add_device_m25p80(&tl_wr841n_v1_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v1_leds_gpio),
+					tl_wr841n_v1_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_WR841ND_V1_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr841n_v1_gpio_keys),
+					 tl_wr841n_v1_gpio_keys);
+
+	pb42_pci_init();
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WR841N_V1, "TL-WR841N-v1.5", "TP-LINK TL-WR841N v1",
+	     tl_wr841n_v1_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wr941nd.c linux-2.6.39/arch/mips/ar71xx/mach-tl-wr941nd.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-tl-wr941nd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-tl-wr941nd.c	2011-08-24 02:41:55.597982750 +0200
@@ -0,0 +1,147 @@
+/*
+ *  TP-LINK TL-WR941ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-dsa.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define TL_WR941ND_GPIO_LED_SYSTEM	2
+#define TL_WR941ND_GPIO_LED_QSS_RED	4
+#define TL_WR941ND_GPIO_LED_QSS_GREEN	5
+#define TL_WR941ND_GPIO_LED_WLAN	9
+
+#define TL_WR941ND_GPIO_BTN_RESET	3
+#define TL_WR941ND_GPIO_BTN_QSS		7
+
+#define TL_WR941ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR941ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR941ND_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_wr941nd_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_wr941nd_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= tl_wr941nd_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr941nd_partitions),
+#endif
+};
+
+static struct gpio_led tl_wr941nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-wr941nd:green:system",
+		.gpio		= TL_WR941ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-wr941nd:red:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tl-wr941nd:green:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_GREEN,
+	}, {
+		.name		= "tl-wr941nd:green:wlan",
+		.gpio		= TL_WR941ND_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr941nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr941nd_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr941nd_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr941nd_dsa_chip,
+};
+
+static void __init tl_wr941nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_dsa(0, &tl_wr941nd_dsa_data);
+
+	ar71xx_add_device_m25p80(&tl_wr941nd_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_leds_gpio),
+					tl_wr941nd_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, TL_WR941ND_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr941nd_gpio_keys),
+					 tl_wr941nd_gpio_keys);
+	ar9xxx_add_device_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_WR941ND, "TL-WR941ND", "TP-LINK TL-WR941ND",
+	     tl_wr941nd_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/machtype.h linux-2.6.39/arch/mips/ar71xx/machtype.h
--- linux-2.6.39.orig/arch/mips/ar71xx/machtype.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/machtype.h	2011-08-24 02:41:55.597982750 +0200
@@ -0,0 +1,75 @@
+/*
+ *  Atheros AR71xx machine type definitions
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_MACHTYPE_H
+#define _AR71XX_MACHTYPE_H
+
+#include <asm/mips_machine.h>
+
+enum ar71xx_mach_type {
+	AR71XX_MACH_GENERIC = 0,
+	AR71XX_MACH_AP121,	/* Atheros AP121 */
+	AR71XX_MACH_AP121_MINI,	/* Atheros AP121-MINI */
+	AR71XX_MACH_AP81,	/* Atheros AP81 */
+	AR71XX_MACH_AP83,	/* Atheros AP83 */
+	AR71XX_MACH_AW_NR580,	/* AzureWave AW-NR580 */
+	AR71XX_MACH_DIR_600_A1,	/* D-Link DIR-600 rev. A1 */
+	AR71XX_MACH_DIR_615_C1,	/* D-Link DIR-615 rev. C1 */
+	AR71XX_MACH_DIR_825_B1,	/* D-Link DIR-825 rev. B1 */
+	AR71XX_MACH_JA76PF,	/* jjPlus JA76PF */
+	AR71XX_MACH_JWAP003,	/* jjPlus JWAP003 */
+	AR71XX_MACH_RB_411,	/* MikroTik RouterBOARD 411/411A/411AH */
+	AR71XX_MACH_RB_411U,	/* MikroTik RouterBOARD 411U */
+	AR71XX_MACH_RB_433,	/* MikroTik RouterBOARD 433/433AH */
+	AR71XX_MACH_RB_433U,	/* MikroTik RouterBOARD 433UAH */
+	AR71XX_MACH_RB_450,	/* MikroTik RouterBOARD 450 */
+	AR71XX_MACH_RB_450G,	/* MikroTik RouterBOARD 450G */
+	AR71XX_MACH_RB_493,	/* Mikrotik RouterBOARD 493/493AH */
+	AR71XX_MACH_RB_750,	/* MikroTik RouterBOARD 750 */
+	AR71XX_MACH_PB42,	/* Atheros PB42 */
+	AR71XX_MACH_PB44,	/* Atheros PB44 */
+	AR71XX_MACH_PB92,	/* Atheros PB92 */
+	AR71XX_MACH_MZK_W04NU,	/* Planex MZK-W04NU */
+	AR71XX_MACH_MZK_W300NH,	/* Planex MZK-W300NH */
+	AR71XX_MACH_NBG460N,	/* Zyxel NBG460N/550N/550NH */
+	AR71XX_MACH_TEW_632BRP,	/* TRENDnet TEW-632BRP */
+	AR71XX_MACH_TL_MR3220,	/* TP-LINK TL-MR3220 */
+	AR71XX_MACH_TL_MR3420,	/* TP-LINK TL-MR3420 */
+	AR71XX_MACH_TL_WA901ND,	/* TP-LINK TL-WA901ND */
+	AR71XX_MACH_TL_WA901ND_V2, /* TP-LINK TL-WA901ND v2 */
+	AR71XX_MACH_TL_WR741ND,	/* TP-LINK TL-WR741ND */
+	AR71XX_MACH_TL_WR841N_V1, /* TP-LINK TL-WR841N v1 */
+	AR71XX_MACH_TL_WR941ND,	/* TP-LINK TL-WR941ND */
+	AR71XX_MACH_TL_WR1043ND, /* TP-LINK TL-WR1041ND */
+	AR71XX_MACH_UBNT_LSSR71, /* Ubiquiti LS-SR71 */
+	AR71XX_MACH_UBNT_LSX,	/* Ubiquiti LSX */
+	AR71XX_MACH_UBNT_RS,	/* Ubiquiti RouterStation */
+	AR71XX_MACH_UBNT_RSPRO,	/* Ubiquiti RouterStation Pro */
+	AR71XX_MACH_UBNT_BULLET_M, /* Ubiquiti Bullet M */
+	AR71XX_MACH_UBNT_ROCKET_M, /* Ubiquiti Rocket M */
+	AR71XX_MACH_UBNT_NANO_M, /* Ubiquiti NanoStation M */
+	AR71XX_MACH_WNDR3700,	/* NETGEAR WNDR3700 */
+	AR71XX_MACH_WNDR3700V2,	/* NETGEAR WNDR3700v2 */
+	AR71XX_MACH_WNR2000,	/* NETGEAR WNR2000 */
+	AR71XX_MACH_WP543,	/* Compex WP543 */
+	AR71XX_MACH_WRT160NL,	/* Linksys WRT160NL */
+	AR71XX_MACH_WRT400N,	/* Linksys WRT400N */
+	AR71XX_MACH_WZR_HP_AG300H, /* Buffalo WZR-HP-AG300H */
+	AR71XX_MACH_WZR_HP_G300NH, /* Buffalo WZR-HP-G300NH */
+	AR71XX_MACH_EAP7660D,	/* Senao EAP7660D */
+	AR71XX_MACH_ZCN_1523H_2, /* Zcomax ZCN-1523H-2-xx */
+	AR71XX_MACH_ZCN_1523H_5, /* Zcomax ZCN-1523H-5-xx */
+	AR71XX_MACH_AP96,	/* Atheros AP96 */
+	AR71XX_MACH_UBNT_UNIFI, /* Unifi */
+	AR71XX_MACH_DB120,      /* Atheros DB120 (AR934x based) */
+};
+
+#endif /* _AR71XX_MACHTYPE_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-ubnt.c linux-2.6.39/arch/mips/ar71xx/mach-ubnt.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-ubnt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-ubnt.c	2011-08-24 02:41:55.597982750 +0200
@@ -0,0 +1,333 @@
+/*
+ *  Ubiquiti RouterStation support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008 Ubiquiti <support@ubnt.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-pb42-pci.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define UBNT_RS_GPIO_LED_RF	2
+#define UBNT_RS_GPIO_SW4	8
+
+#define UBNT_LS_SR71_GPIO_LED_D25	0
+#define UBNT_LS_SR71_GPIO_LED_D26	1
+#define UBNT_LS_SR71_GPIO_LED_D24	2
+#define UBNT_LS_SR71_GPIO_LED_D23	4
+#define UBNT_LS_SR71_GPIO_LED_D22	5
+#define UBNT_LS_SR71_GPIO_LED_D27	6
+#define UBNT_LS_SR71_GPIO_LED_D28	7
+
+#define UBNT_M_GPIO_LED_L1	0
+#define UBNT_M_GPIO_LED_L2	1
+#define UBNT_M_GPIO_LED_L3	11
+#define UBNT_M_GPIO_LED_L4	7
+#define UBNT_M_GPIO_BTN_RESET	12
+
+#define UBNT_KEYS_POLL_INTERVAL		20	/* msecs */
+#define UBNT_KEYS_DEBOUNCE_INTERVAL	(3 * UBNT_KEYS_POLL_INTERVAL)
+
+static struct gpio_led ubnt_rs_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:rf",
+		.gpio		= UBNT_RS_GPIO_LED_RF,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led ubnt_ls_sr71_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:d22",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D22,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d23",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D23,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d24",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D24,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d25",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D25,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d26",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D26,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d27",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D27,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d28",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D28,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led ubnt_m_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:red:link1",
+		.gpio		= UBNT_M_GPIO_LED_L1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:orange:link2",
+		.gpio		= UBNT_M_GPIO_LED_L2,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link3",
+		.gpio		= UBNT_M_GPIO_LED_L3,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link4",
+		.gpio		= UBNT_M_GPIO_LED_L4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button ubnt_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = UBNT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= UBNT_RS_GPIO_SW4,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ubnt_m_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = UBNT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= UBNT_M_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init ubnt_generic_setup(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_register_gpio_keys_polled(-1, UBNT_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ubnt_gpio_keys),
+					 ubnt_gpio_keys);
+
+	pb42_pci_init();
+}
+
+/*
+ * There is Secondary MAC address duplicate problem with some UBNT HW batches.
+ * Do not increase Secondary MAC address by 1 but do workaround
+ * with 'Locally Administrated' bit.
+ */
+static void __init ubnt_init_secondary_mac(unsigned char *mac_base)
+{
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac_base, 0);
+	ar71xx_eth1_data.mac_addr[0] |= 0x02;
+}
+
+#define UBNT_RS_WAN_PHYMASK	BIT(20)
+#define UBNT_RS_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
+
+static void __init ubnt_rs_setup(void)
+{
+	ubnt_generic_setup();
+
+	ar71xx_add_device_mdio(~(UBNT_RS_WAN_PHYMASK | UBNT_RS_LAN_PHYMASK));
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = UBNT_RS_WAN_PHYMASK;
+
+	ubnt_init_secondary_mac(ar71xx_mac_base);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_100;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+					ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_RS, "UBNT-RS", "Ubiquiti RouterStation",
+	     ubnt_rs_setup);
+
+#define UBNT_RSPRO_WAN_PHYMASK	BIT(4)
+#define UBNT_RSPRO_LAN_PHYMASK	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+static void __init ubnt_rspro_setup(void)
+{
+	ubnt_generic_setup();
+
+	ar71xx_add_device_mdio(~(UBNT_RSPRO_WAN_PHYMASK |
+				 UBNT_RSPRO_LAN_PHYMASK));
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.phy_mask = UBNT_RSPRO_WAN_PHYMASK;
+
+	ubnt_init_secondary_mac(ar71xx_mac_base);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = UBNT_RSPRO_LAN_PHYMASK;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+					ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_RSPRO, "UBNT-RSPRO", "Ubiquiti RouterStation Pro",
+	     ubnt_rspro_setup);
+
+static void __init ubnt_lsx_setup(void)
+{
+	ubnt_generic_setup();
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_LSX, "UBNT-LSX", "Ubiquiti LSX", ubnt_lsx_setup);
+
+#define UBNT_LSSR71_PHY_MASK	BIT(1)
+
+static void __init ubnt_lssr71_setup(void)
+{
+	ubnt_generic_setup();
+
+	ar71xx_add_device_mdio(~UBNT_LSSR71_PHY_MASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = UBNT_LSSR71_PHY_MASK;
+
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_ls_sr71_leds_gpio),
+					ubnt_ls_sr71_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_LSSR71, "UBNT-LS-SR71", "Ubiquiti LS-SR71",
+	     ubnt_lssr71_setup);
+
+#define UBNT_M_WAN_PHYMASK	BIT(4)
+
+static void __init ubnt_m_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(~UBNT_M_WAN_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac1, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac2, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = UBNT_M_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+
+	ap91_pci_init(ee, NULL);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_m_leds_gpio),
+					ubnt_m_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, UBNT_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ubnt_m_gpio_keys),
+					 ubnt_m_gpio_keys);
+}
+
+static void __init ubnt_rocket_m_setup(void)
+{
+	ubnt_m_setup();
+	ar71xx_add_device_usb();
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_BULLET_M, "UBNT-BM", "Ubiquiti Bullet M",
+	     ubnt_m_setup);
+MIPS_MACHINE(AR71XX_MACH_UBNT_ROCKET_M, "UBNT-RM", "Ubiquiti Rocket M",
+	     ubnt_rocket_m_setup);
+
+/* TODO detect the second ethernet port and use one
+   init function for all Ubiquiti MIMO series products */
+static void __init ubnt_nano_m_setup(void)
+{
+	ubnt_m_setup();
+
+	ar71xx_eth1_data.has_ar7240_switch = 1;
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_eth(1);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_NANO_M, "UBNT-NM", "Ubiquiti Nanostation M",
+	     ubnt_nano_m_setup);
+
+static struct gpio_led ubnt_unifi_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:orange:dome",
+		.gpio		= 1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:dome",
+		.gpio		= 0,
+		.active_low	= 0,
+	}
+};
+
+static void __init ubnt_unifi_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(~UBNT_M_WAN_PHYMASK);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = UBNT_M_WAN_PHYMASK;
+
+	ar71xx_add_device_eth(0);
+
+	ap91_pci_init(ee, NULL);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(ubnt_unifi_leds_gpio),
+					ubnt_unifi_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_UBNT_UNIFI, "UBNT-XM", "Ubiquiti UniFi",
+	     ubnt_unifi_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-wndr3700.c linux-2.6.39/arch/mips/ar71xx/mach-wndr3700.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-wndr3700.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-wndr3700.c	2011-08-24 02:41:55.607980283 +0200
@@ -0,0 +1,290 @@
+/*
+ *  Netgear WNDR3700 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap94-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define WNDR3700_GPIO_LED_WPS_ORANGE	0
+#define WNDR3700_GPIO_LED_POWER_ORANGE	1
+#define WNDR3700_GPIO_LED_POWER_GREEN	2
+#define WNDR3700_GPIO_LED_WPS_GREEN	4
+#define WNDR3700_GPIO_LED_WAN_GREEN	6
+
+#define WNDR3700_GPIO_BTN_WPS		3
+#define WNDR3700_GPIO_BTN_RESET		8
+#define WNDR3700_GPIO_BTN_WIFI		11
+
+#define WNDR3700_GPIO_RTL8366_SDA	5
+#define WNDR3700_GPIO_RTL8366_SCK	7
+
+#define WNDR3700_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNDR3700_KEYS_DEBOUNCE_INTERVAL (3 * WNDR3700_KEYS_POLL_INTERVAL)
+
+#define WNDR3700_ETH0_MAC_OFFSET	0
+#define WNDR3700_ETH1_MAC_OFFSET	0x6
+
+#define WNDR3700_WMAC0_MAC_OFFSET	0
+#define WNDR3700_WMAC1_MAC_OFFSET	0xc
+#define WNDR3700_CALDATA0_OFFSET	0x1000
+#define WNDR3700_CALDATA1_OFFSET	0x5000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wndr3700_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x050000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "env",
+		.offset		= 0x050000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x070000,
+		.size		= 0x720000,
+	}, {
+		.name		= "config",
+		.offset		= 0x790000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "config_bak",
+		.offset		= 0x7a0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "pot",
+		.offset		= 0x7b0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "traffic_meter",
+		.offset		= 0x7c0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "language",
+		.offset		= 0x7d0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "caldata",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct mtd_partition wndr3700v2_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x050000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "env",
+		.offset		= 0x050000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x070000,
+		.size		= 0xe40000,
+	}, {
+		.name		= "config",
+		.offset		= 0xeb0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "config_bak",
+		.offset		= 0xec0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "pot",
+		.offset		= 0xed0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "traffic_meter",
+		.offset		= 0xee0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "language",
+		.offset		= 0xef0000,
+		.size		= 0x100000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "caldata",
+		.offset		= 0xff0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#define wndr3700_num_partitions		ARRAY_SIZE(wndr3700_partitions)
+#define wndr3700v2_num_partitions	ARRAY_SIZE(wndr3700v2_partitions)
+#else
+#define wndr3700_partitions		NULL
+#define wndr3700_num_partitions		0
+#define wndr3700v2_partitions		NULL
+#define wndr3700v2_num_partitions	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data wndr3700_flash_data;
+
+static struct gpio_led wndr3700_leds_gpio[] __initdata = {
+	{
+		.name		= "wndr3700:green:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:orange:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:green:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:orange:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "wndr3700:green:wan",
+		.gpio		= WNDR3700_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wndr3700_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "wifi",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_WIFI,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_platform_data wndr3700_rtl8366s_data = {
+	.gpio_sda	= WNDR3700_GPIO_RTL8366_SDA,
+	.gpio_sck	= WNDR3700_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wndr3700_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wndr3700_rtl8366s_data,
+	}
+};
+
+static void __init wndr3700_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr,
+			art + WNDR3700_ETH0_MAC_OFFSET, 0);
+	ar71xx_eth0_pll_data.pll_1000 = 0x11110000;
+	ar71xx_eth0_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr,
+			art + WNDR3700_ETH1_MAC_OFFSET, 0);
+	ar71xx_eth1_pll_data.pll_1000 = 0x11110000;
+	ar71xx_eth1_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+
+	ar71xx_add_device_m25p80(&wndr3700_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wndr3700_leds_gpio),
+					wndr3700_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, WNDR3700_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wndr3700_gpio_keys),
+					 wndr3700_gpio_keys);
+
+	platform_device_register(&wndr3700_rtl8366s_device);
+	platform_device_register_simple("wndr3700-led-usb", -1, NULL, 0);
+
+	ap94_pci_setup_wmac_led_pin(0, 5);
+	ap94_pci_setup_wmac_led_pin(1, 5);
+
+	/* 2.4 GHz uses the first fixed antenna group (1, 0, 1, 0) */
+	ap94_pci_setup_wmac_gpio(0, (0xf << 6), (0xa << 6));
+
+	/* 5 GHz uses the second fixed antenna group (0, 1, 1, 0) */
+	ap94_pci_setup_wmac_gpio(1, (0xf << 6), (0x6 << 6));
+
+	ap94_pci_init(art + WNDR3700_CALDATA0_OFFSET,
+		      art + WNDR3700_WMAC0_MAC_OFFSET,
+		      art + WNDR3700_CALDATA1_OFFSET,
+		      art + WNDR3700_WMAC1_MAC_OFFSET);
+}
+
+static void __init wndr3700_setup(void)
+{
+	wndr3700_flash_data.parts = wndr3700_partitions,
+	wndr3700_flash_data.nr_parts = wndr3700_num_partitions,
+	wndr3700_common_setup();
+}
+
+MIPS_MACHINE(AR71XX_MACH_WNDR3700, "WNDR3700", "NETGEAR WNDR3700",
+	     wndr3700_setup);
+
+static void __init wndr3700v2_setup(void)
+{
+	wndr3700_flash_data.parts = wndr3700v2_partitions,
+	wndr3700_flash_data.nr_parts = wndr3700v2_num_partitions,
+	wndr3700_common_setup();
+}
+
+MIPS_MACHINE(AR71XX_MACH_WNDR3700V2, "WNDR3700v2", "NETGEAR WNDR3700v2",
+	     wndr3700v2_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-wnr2000.c linux-2.6.39/arch/mips/ar71xx/mach-wnr2000.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-wnr2000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-wnr2000.c	2011-08-24 02:41:55.617990333 +0200
@@ -0,0 +1,150 @@
+/*
+ *  NETGEAR WNR2000 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008-2009 Andy Boyett <agb@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define WNR2000_GPIO_LED_PWR_GREEN	14
+#define WNR2000_GPIO_LED_PWR_AMBER	7
+#define WNR2000_GPIO_LED_WPS		4
+#define WNR2000_GPIO_LED_WLAN		6
+#define WNR2000_GPIO_BTN_RESET		21
+#define WNR2000_GPIO_BTN_WPS		8
+
+#define WNR2000_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNR2000_KEYS_DEBOUNCE_INTERVAL	(3 * WNR2000_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wnr2000_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x240000,
+	}, {
+		.name		= "user-config",
+		.offset		= 0x290000,
+		.size		= 0x010000,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x2a0000,
+		.size		= 0x120000,
+	}, {
+		.name		= "language_table",
+		.offset		= 0x3c0000,
+		.size		= 0x020000,
+	}, {
+		.name		= "rootfs_checksum",
+		.offset		= 0x3e0000,
+		.size		= 0x010000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data wnr2000_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= wnr2000_partitions,
+	.nr_parts	= ARRAY_SIZE(wnr2000_partitions),
+#endif
+};
+
+static struct gpio_led wnr2000_leds_gpio[] __initdata = {
+	{
+		.name		= "wnr2000:green:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000:amber:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000:green:wps",
+		.gpio		= WNR2000_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000:blue:wlan",
+		.gpio		= WNR2000_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr2000_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000_GPIO_BTN_WPS,
+	}
+};
+
+static void __init wnr2000_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, eeprom, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.has_ar8216 = 1;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, eeprom, 1);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&wnr2000_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wnr2000_leds_gpio),
+					wnr2000_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, WNR2000_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wnr2000_gpio_keys),
+					 wnr2000_gpio_keys);
+
+
+	ar9xxx_add_device_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WNR2000, "WNR2000", "NETGEAR WNR2000", wnr2000_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-wp543.c linux-2.6.39/arch/mips/ar71xx/mach-wp543.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-wp543.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-wp543.c	2011-08-24 02:41:55.617990333 +0200
@@ -0,0 +1,101 @@
+/*
+ *  Compex WP543/WPJ543 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-pb42-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define WP543_GPIO_SW6		2
+#define WP543_GPIO_LED_1	3
+#define WP543_GPIO_LED_2	4
+#define WP543_GPIO_LED_WLAN	5
+#define WP543_GPIO_LED_CONN	6
+#define WP543_GPIO_LED_DIAG	7
+#define WP543_GPIO_SW4		8
+
+#define WP543_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WP543_KEYS_DEBOUNCE_INTERVAL	(3 * WP543_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wp543_leds_gpio[] __initdata = {
+	{
+		.name		= "wp543:green:led1",
+		.gpio		= WP543_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:led2",
+		.gpio		= WP543_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:wlan",
+		.gpio		= WP543_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:conn",
+		.gpio		= WP543_GPIO_LED_CONN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:diag",
+		.gpio		= WP543_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wp543_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw6",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WP543_GPIO_SW6,
+	}, {
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WP543_GPIO_SW4,
+	}
+};
+
+static void __init wp543_setup(void)
+{
+	ar71xx_add_device_m25p80(NULL);
+
+	ar71xx_add_device_mdio(0xfffffff7);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, ar71xx_mac_base, 0);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ar71xx_eth0_data.phy_mask = 0x08;
+	ar71xx_eth0_data.reset_bit = RESET_MODULE_GE0_MAC |
+				     RESET_MODULE_GE0_PHY;
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_usb();
+
+	pb42_pci_init();
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wp543_leds_gpio),
+					wp543_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, WP543_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wp543_gpio_keys),
+					 wp543_gpio_keys);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WP543, "WP543", "Compex WP543", wp543_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-wrt160nl.c linux-2.6.39/arch/mips/ar71xx/mach-wrt160nl.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-wrt160nl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-wrt160nl.c	2011-08-24 02:41:55.617990333 +0200
@@ -0,0 +1,161 @@
+/*
+ *  Linksys WRT160NL board support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "nvram.h"
+
+#define WRT160NL_GPIO_LED_POWER		14
+#define WRT160NL_GPIO_LED_WPS_AMBER	9
+#define WRT160NL_GPIO_LED_WPS_BLUE	8
+#define WRT160NL_GPIO_LED_WLAN		6
+
+#define WRT160NL_GPIO_BTN_WPS		7
+#define WRT160NL_GPIO_BTN_RESET		21
+
+#define WRT160NL_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT160NL_KEYS_DEBOUNCE_INTERVAL	(3 * WRT160NL_KEYS_POLL_INTERVAL)
+
+#define WRT160NL_NVRAM_ADDR	0x1f7e0000
+#define WRT160NL_NVRAM_SIZE	0x10000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wrt160nl_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x040000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "filesytem",
+		.offset		= 0x120000,
+		.size		= 0x6c0000,
+	}, {
+		.name		= "nvram",
+		.offset		= 0x7e0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "ART",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x7a0000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data wrt160nl_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= wrt160nl_partitions,
+	.nr_parts	= ARRAY_SIZE(wrt160nl_partitions),
+#endif
+};
+
+static struct gpio_led wrt160nl_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt160nl:blue:power",
+		.gpio		= WRT160NL_GPIO_LED_POWER,
+		.active_low	= 1,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "wrt160nl:amber:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wlan",
+		.gpio		= WRT160NL_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wrt160nl_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WRT160NL_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WRT160NL_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt160nl_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(WRT160NL_NVRAM_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+
+	if (nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+				 "lan_hwaddr=", mac) == 0) {
+		ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+		ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+	}
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.phy_mask = 0x01;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&wrt160nl_flash_data);
+
+	ar71xx_add_device_usb();
+
+	if (nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+				 "wl0_hwaddr=", mac) == 0)
+		ar9xxx_add_device_wmac(eeprom, mac);
+	else
+		ar9xxx_add_device_wmac(eeprom, NULL);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wrt160nl_leds_gpio),
+					wrt160nl_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, WRT160NL_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wrt160nl_gpio_keys),
+					 wrt160nl_gpio_keys);
+
+}
+
+MIPS_MACHINE(AR71XX_MACH_WRT160NL, "WRT160NL", "Linksys WRT160NL",
+	     wrt160nl_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-wrt400n.c linux-2.6.39/arch/mips/ar71xx/mach-wrt400n.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-wrt400n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-wrt400n.c	2011-08-24 02:41:55.617990333 +0200
@@ -0,0 +1,164 @@
+/*
+ *  Linksys WRT400N board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2009 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ap94-pci.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define WRT400N_GPIO_LED_ORANGE	5
+#define WRT400N_GPIO_LED_GREEN	4
+#define WRT400N_GPIO_LED_POWER	1
+#define WRT400N_GPIO_LED_WLAN	0
+
+#define WRT400N_GPIO_BTN_RESET	8
+#define WRT400N_GPIO_BTN_WLSEC	3
+
+#define WRT400N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT400N_KEYS_DEBOUNE_INTERVAL	(3 * WRT400N_KEYS_POLL_INTERVAL)
+
+#define WRT400N_MAC_ADDR_OFFSET		0x120c
+#define WRT400N_CALDATA0_OFFSET		0x1000
+#define WRT400N_CALDATA1_OFFSET		0x5000
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wrt400n_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x030000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "env",
+		.offset		= 0x030000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "linux",
+		.offset		= 0x040000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x180000,
+		.size		= 0x630000,
+	}, {
+		.name		= "nvram",
+		.offset		= 0x7b0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "factory",
+		.offset		= 0x7c0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "language",
+		.offset		= 0x7d0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "caldata",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x770000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data wrt400n_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= wrt400n_partitions,
+	.nr_parts	= ARRAY_SIZE(wrt400n_partitions),
+#endif
+};
+
+static struct gpio_led wrt400n_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt400n:green:status",
+		.gpio		= WRT400N_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:amber:aoss",
+		.gpio		= WRT400N_GPIO_LED_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:green:wlan",
+		.gpio		= WRT400N_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:green:power",
+		.gpio		= WRT400N_GPIO_LED_POWER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wrt400n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
+		.gpio		= WRT400N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wlsec",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
+		.gpio		= WRT400N_GPIO_BTN_WLSEC,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt400n_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = art + WRT400N_MAC_ADDR_OFFSET;
+
+	ar71xx_add_device_mdio(0x0);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 1);
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 2);
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_m25p80(&wrt400n_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wrt400n_leds_gpio),
+					wrt400n_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, WRT400N_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wrt400n_gpio_keys),
+					 wrt400n_gpio_keys);
+
+	ap94_pci_init(art + WRT400N_CALDATA0_OFFSET, NULL,
+		      art + WRT400N_CALDATA1_OFFSET, NULL);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WRT400N, "WRT400N", "Linksys WRT400N", wrt400n_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-wzr-hp-ag300h.c linux-2.6.39/arch/mips/ar71xx/mach-wzr-hp-ag300h.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-wzr-hp-ag300h.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-wzr-hp-ag300h.c	2011-08-24 02:41:55.628193451 +0200
@@ -0,0 +1,231 @@
+/*
+ *  Buffalo WZR-HP-AG300H board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/concat.h>
+
+#include <asm/mips_machine.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/gpio.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ap94-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+
+#define WZRHPAG300H_MAC_OFFSET		0x20c
+#define WZRHPAG300H_KEYS_POLL_INTERVAL     20      /* msecs */
+#define WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPAG300H_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wzrhpag300h_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x0060000,
+		.size		= 0x0100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x0160000,
+		.size		= 0x1e90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f90000,
+	}
+};
+
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct mtd_info *concat_devs[2] = { NULL, NULL };
+static struct work_struct mtd_concat_work;
+
+static void mtd_concat_add_work(struct work_struct *work)
+{
+	struct mtd_info *mtd;
+
+	mtd = mtd_concat_create(concat_devs, ARRAY_SIZE(concat_devs), "flash");
+
+#ifdef CONFIG_MTD_PARTITIONS
+	add_mtd_partitions(mtd, wzrhpag300h_flash_partitions,
+			   ARRAY_SIZE(wzrhpag300h_flash_partitions));
+#else
+	add_mtd_device(mtd);
+#endif
+}
+
+static void mtd_concat_add(struct mtd_info *mtd)
+{
+	static bool registered = false;
+
+	if (registered)
+		return;
+
+	if (!strcmp(mtd->name, "spi0.0"))
+		concat_devs[0] = mtd;
+	else if (!strcmp(mtd->name, "spi0.1"))
+		concat_devs[1] = mtd;
+	else
+		return;
+
+	if (!concat_devs[0] || !concat_devs[1])
+		return;
+
+	registered = true;
+	INIT_WORK(&mtd_concat_work, mtd_concat_add_work);
+	schedule_work(&mtd_concat_work);
+}
+
+static void mtd_concat_remove(struct mtd_info *mtd)
+{
+}
+
+static void add_mtd_concat_notifier(void)
+{
+	static struct mtd_notifier not = {
+		.add = mtd_concat_add,
+		.remove = mtd_concat_remove,
+	};
+
+	register_mtd_user(&not);
+}
+
+static struct gpio_led wzrhpag300h_leds_gpio[] __initdata = {
+	{
+		.name		= "wzr-hp-ag300h:red:diag",
+		.gpio		= 1,
+		.active_low	= 1,
+	},
+};
+
+
+static struct gpio_keys_button wzrhpag300h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 3,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 5,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 6,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_off",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 1,
+	}
+};
+
+static struct spi_board_info ar71xx_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz   = 25000000,
+		.modalias   = "m25p80",
+	},
+	{
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz   = 25000000,
+		.modalias   = "m25p80",
+	}
+};
+
+static void __init wzrhpag300h_setup(void)
+{
+	u8 *eeprom1 = (u8 *) KSEG1ADDR(0x1f051000);
+	u8 *eeprom2 = (u8 *) KSEG1ADDR(0x1f055000);
+	u8 *mac1 = eeprom1 + WZRHPAG300H_MAC_OFFSET;
+	u8 *mac2 = eeprom2 + WZRHPAG300H_MAC_OFFSET;
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac1, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac2, 1);
+
+	ar71xx_add_device_mdio(~(BIT(0) | BIT(4)));
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+	ar71xx_eth0_data.phy_mask = BIT(0);
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = BIT(4);
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+	gpio_request(2, "usb");
+	gpio_direction_output(2, 1);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wzrhpag300h_leds_gpio),
+					wzrhpag300h_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, WZRHPAG300H_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpag300h_gpio_keys),
+					 wzrhpag300h_gpio_keys);
+
+	ar71xx_add_device_spi(NULL, ar71xx_spi_info,
+			      ARRAY_SIZE(ar71xx_spi_info));
+
+	add_mtd_concat_notifier();
+
+	ap94_pci_init(eeprom1, mac1, eeprom2, mac2);
+}
+
+MIPS_MACHINE(AR71XX_MACH_WZR_HP_AG300H, "WZR-HP-AG300H",
+	     "Buffalo WZR-HP-AG300H", wzrhpag300h_setup);
+
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-wzr-hp-g300nh.c linux-2.6.39/arch/mips/ar71xx/mach-wzr-hp-g300nh.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-wzr-hp-g300nh.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-wzr-hp-g300nh.c	2011-08-24 02:41:55.649418561 +0200
@@ -0,0 +1,292 @@
+/*
+ *  Buffalo WZR-HP-G300NH board support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/nxp_74hc153.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mips_machine.h>
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar91xx_flash.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-ar9xxx-wmac.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define WZRHPG300NH_GPIO_LED_USB	0
+#define WZRHPG300NH_GPIO_LED_DIAG	1
+#define WZRHPG300NH_GPIO_LED_WIRELESS	6
+#define WZRHPG300NH_GPIO_LED_SECURITY	17
+#define WZRHPG300NH_GPIO_LED_ROUTER	18
+
+#define WZRHPG300NH_GPIO_RTL8366_SDA	19
+#define WZRHPG300NH_GPIO_RTL8366_SCK	20
+
+#define WZRHPG300NH_GPIO_74HC153_S0	9
+#define WZRHPG300NH_GPIO_74HC153_S1	11
+#define WZRHPG300NH_GPIO_74HC153_1Y	12
+#define WZRHPG300NH_GPIO_74HC153_2Y	14
+
+#define WZRHPG300NH_GPIO_EXP_BASE	32
+#define WZRHPG300NH_GPIO_BTN_AOSS	(WZRHPG300NH_GPIO_EXP_BASE + 0)
+#define WZRHPG300NH_GPIO_BTN_RESET	(WZRHPG300NH_GPIO_EXP_BASE + 1)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_ON	(WZRHPG300NH_GPIO_EXP_BASE + 2)
+#define WZRHPG300NH_GPIO_BTN_QOS_ON	(WZRHPG300NH_GPIO_EXP_BASE + 3)
+#define WZRHPG300NH_GPIO_BTN_USB	(WZRHPG300NH_GPIO_EXP_BASE + 5)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_AUTO (WZRHPG300NH_GPIO_EXP_BASE + 6)
+#define WZRHPG300NH_GPIO_BTN_QOS_OFF	(WZRHPG300NH_GPIO_EXP_BASE + 7)
+
+#define WZRHPG300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG300NH_KEYS_POLL_INTERVAL)
+
+#define WZRHPG300NH_MAC_OFFSET		0x20c
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition wzrhpg300nh_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x0060000,
+		.size		= 0x0100000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x0160000,
+		.size		= 0x1e60000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1fc0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x1fe0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f60000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct ar91xx_flash_platform_data wzrhpg300nh_flash_data = {
+	.width		= 2,
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= wzrhpg300nh_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg300nh_flash_partitions),
+#endif
+};
+
+#define WZRHPG300NH_FLASH_BASE	0x1e000000
+#define WZRHPG300NH_FLASH_SIZE	(32 * 1024 * 1024)
+
+static struct resource wzrhpg300nh_flash_resources[] = {
+	[0] = {
+		.start	= WZRHPG300NH_FLASH_BASE,
+		.end	= WZRHPG300NH_FLASH_BASE + WZRHPG300NH_FLASH_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device wzrhpg300nh_flash_device = {
+	.name		= "ar91xx-flash",
+	.id		= -1,
+	.resource	= wzrhpg300nh_flash_resources,
+	.num_resources	= ARRAY_SIZE(wzrhpg300nh_flash_resources),
+	.dev		= {
+		.platform_data = &wzrhpg300nh_flash_data,
+	}
+};
+
+static struct gpio_led wzrhpg300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "wzr-hp-g300nh:orange:security",
+		.gpio		= WZRHPG300NH_GPIO_LED_SECURITY,
+		.active_low	= 1,
+	}, {
+		.name		= "wzr-hp-g300nh:green:wireless",
+		.gpio		= WZRHPG300NH_GPIO_LED_WIRELESS,
+		.active_low	= 1,
+	}, {
+		.name		= "wzr-hp-g300nh:green:router",
+		.gpio		= WZRHPG300NH_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}, {
+		.name		= "wzr-hp-g300nh:red:diag",
+		.gpio		= WZRHPG300NH_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "wzr-hp-g300nh:blue:usb",
+		.gpio		= WZRHPG300NH_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wzrhpg300nh_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_AOSS,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_USB,
+		.active_low	= 1,
+	}, {
+		.desc		= "qos_on",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "qos_off",
+		.type		= EV_KEY,
+		.code		= BTN_4,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_OFF,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_AUTO,
+		.active_low	= 0,
+	}
+};
+
+static struct nxp_74hc153_platform_data wzrhpg300nh_74hc153_data = {
+	.gpio_base	= WZRHPG300NH_GPIO_EXP_BASE,
+	.gpio_pin_s0	= WZRHPG300NH_GPIO_74HC153_S0,
+	.gpio_pin_s1	= WZRHPG300NH_GPIO_74HC153_S1,
+	.gpio_pin_1y	= WZRHPG300NH_GPIO_74HC153_1Y,
+	.gpio_pin_2y	= WZRHPG300NH_GPIO_74HC153_2Y,
+};
+
+static struct platform_device wzrhpg300nh_74hc153_device = {
+	.name		= NXP_74HC153_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_74hc153_data,
+	}
+};
+
+static struct rtl8366_platform_data wzrhpg300nh_rtl8366_data = {
+	.gpio_sda	= WZRHPG300NH_GPIO_RTL8366_SDA,
+	.gpio_sck	= WZRHPG300NH_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wzrhpg300nh_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_rtl8366_data,
+	}
+};
+
+static struct platform_device wzrhpg300nh_rtl8366rb_device = {
+	.name           = RTL8366RB_DRIVER_NAME,
+	.id             = -1,
+	.dev = {
+		.platform_data  = &wzrhpg300nh_rtl8366_data,
+	}
+};
+
+static void __init wzrhpg300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = eeprom + WZRHPG300NH_MAC_OFFSET;
+	bool hasrtl8366rb = false;
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	if (rtl8366_smi_detect(&wzrhpg300nh_rtl8366_data) == RTL8366_TYPE_RB)
+		hasrtl8366rb = true;
+
+	if (hasrtl8366rb) {
+		ar71xx_eth0_pll_data.pll_1000 = 0x1f000000;
+		ar71xx_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+		ar71xx_eth1_pll_data.pll_1000 = 0x100;
+		ar71xx_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+	} else {
+		ar71xx_eth0_pll_data.pll_1000 = 0x1e000100;
+		ar71xx_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+		ar71xx_eth1_pll_data.pll_1000 = 0x1e000100;
+		ar71xx_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+	}
+
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth0_data.speed = SPEED_1000;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ar71xx_eth1_data.phy_mask = 0x10;
+
+	ar71xx_add_device_eth(0);
+	ar71xx_add_device_eth(1);
+
+	ar71xx_add_device_usb();
+	ar9xxx_add_device_wmac(eeprom, NULL);
+
+	platform_device_register(&wzrhpg300nh_74hc153_device);
+	platform_device_register(&wzrhpg300nh_flash_device);
+
+	if (hasrtl8366rb)
+		platform_device_register(&wzrhpg300nh_rtl8366rb_device);
+	else
+		platform_device_register(&wzrhpg300nh_rtl8366s_device);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(wzrhpg300nh_leds_gpio),
+					wzrhpg300nh_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, WZRHPG300NH_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpg300nh_gpio_keys),
+					 wzrhpg300nh_gpio_keys);
+
+}
+
+MIPS_MACHINE(AR71XX_MACH_WZR_HP_G300NH, "WZR-HP-G300NH",
+	     "Buffalo WZR-HP-G300NH", wzrhpg300nh_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/mach-zcn-1523h.c linux-2.6.39/arch/mips/ar71xx/mach-zcn-1523h.c
--- linux-2.6.39.orig/arch/mips/ar71xx/mach-zcn-1523h.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/mach-zcn-1523h.c	2011-08-24 02:41:55.649418561 +0200
@@ -0,0 +1,214 @@
+/*
+ *  Zcomax ZCN-1523H-2-8/5-16 board support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+
+#define ZCN_1523H_GPIO_BTN_RESET	0
+#define ZCN_1523H_GPIO_LED_INIT		11
+#define ZCN_1523H_GPIO_LED_LAN1		17
+
+#define ZCN_1523H_2_GPIO_LED_WEAK	13
+#define ZCN_1523H_2_GPIO_LED_MEDIUM	14
+#define ZCN_1523H_2_GPIO_LED_STRONG	15
+
+#define ZCN_1523H_5_GPIO_LED_UNKNOWN	1
+#define ZCN_1523H_5_GPIO_LED_LAN2	13
+#define ZCN_1523H_5_GPIO_LED_WEAK	14
+#define ZCN_1523H_5_GPIO_LED_MEDIUM	15
+#define ZCN_1523H_5_GPIO_LED_STRONG	16
+
+#define ZCN_1523H_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ZCN_1523H_KEYS_DEBOUNCE_INTERVAL (3 * ZCN_1523H_KEYS_POLL_INTERVAL)
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition zcn_1523h_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x610000,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x660000,
+		.size		= 0x170000,
+	}, {
+		.name		= "configure",
+		.offset		= 0x7d0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "mfg",
+		.offset		= 0x7e0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "eeprom",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x050000,
+		.size		= 0x780000,
+	}
+};
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data zcn_1523h_flash_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts		= zcn_1523h_partitions,
+	.nr_parts	= ARRAY_SIZE(zcn_1523h_partitions),
+#endif
+};
+
+static struct gpio_keys_button zcn_1523h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ZCN_1523H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ZCN_1523H_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:amber:init",
+		.gpio		= ZCN_1523H_GPIO_LED_INIT,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan1",
+		.gpio		= ZCN_1523H_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_2_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_2_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_2_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_2_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_5_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_5_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_5_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_5_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan2",
+		.gpio		= ZCN_1523H_5_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:unknown",
+		.gpio		= ZCN_1523H_5_GPIO_LED_UNKNOWN,
+	}
+};
+
+static void __init zcn_1523h_generic_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7e0004);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ar71xx_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ar71xx_add_device_m25p80(&zcn_1523h_flash_data);
+
+	ar71xx_add_device_leds_gpio(0, ARRAY_SIZE(zcn_1523h_leds_gpio),
+					zcn_1523h_leds_gpio);
+
+	ar71xx_register_gpio_keys_polled(-1, ZCN_1523H_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(zcn_1523h_gpio_keys),
+					 zcn_1523h_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	/* LAN1 port */
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	/* LAN2 port */
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(0);
+}
+
+static void __init zcn_1523h_2_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap91_pci_setup_wmac_gpio(BIT(9), 0);
+
+	ar71xx_add_device_leds_gpio(1, ARRAY_SIZE(zcn_1523h_2_leds_gpio),
+					zcn_1523h_2_leds_gpio);
+}
+
+MIPS_MACHINE(AR71XX_MACH_ZCN_1523H_2, "ZCN-1523H-2", "Zcomax ZCN-1523H-2",
+	     zcn_1523h_2_setup);
+
+static void __init zcn_1523h_5_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap91_pci_setup_wmac_gpio(BIT(8), 0);
+
+	ar71xx_add_device_leds_gpio(1, ARRAY_SIZE(zcn_1523h_5_leds_gpio),
+					zcn_1523h_5_leds_gpio);
+	ar71xx_add_device_eth(1);
+}
+
+MIPS_MACHINE(AR71XX_MACH_ZCN_1523H_5, "ZCN-1523H-5", "Zcomax ZCN-1523H-5",
+	     zcn_1523h_5_setup);
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/Makefile linux-2.6.39/arch/mips/ar71xx/Makefile
--- linux-2.6.39.orig/arch/mips/ar71xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/Makefile	2011-08-24 02:41:55.677990354 +0200
@@ -0,0 +1,67 @@
+#
+# Makefile for the Atheros AR71xx SoC specific parts of the kernel
+#
+# Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+# Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 as published
+# by the Free Software Foundation.
+
+obj-y	:= prom.o irq.o setup.o devices.o gpio.o ar71xx.o
+
+obj-$(CONFIG_EARLY_PRINTK)		+= early_printk.o
+obj-$(CONFIG_PCI)			+= pci.o
+
+obj-$(CONFIG_AR71XX_DEV_AP91_PCI)	+= dev-ap91-pci.o
+obj-$(CONFIG_AR71XX_DEV_AP94_PCI)	+= dev-ap94-pci.o
+obj-$(CONFIG_AR71XX_DEV_AR9XXX_WMAC)	+= dev-ar9xxx-wmac.o
+obj-$(CONFIG_AR71XX_DEV_DB120_PCI)	+= dev-db120-pci.o
+obj-$(CONFIG_AR71XX_DEV_DSA)		+= dev-dsa.o
+obj-$(CONFIG_AR71XX_DEV_GPIO_BUTTONS)	+= dev-gpio-buttons.o
+obj-$(CONFIG_AR71XX_DEV_LEDS_GPIO)	+= dev-leds-gpio.o
+obj-$(CONFIG_AR71XX_DEV_M25P80)		+= dev-m25p80.o
+obj-$(CONFIG_AR71XX_DEV_PB42_PCI)	+= dev-pb42-pci.o
+obj-$(CONFIG_AR71XX_DEV_PB9X_PCI)	+= dev-pb9x-pci.o
+obj-$(CONFIG_AR71XX_DEV_USB)		+= dev-usb.o
+
+obj-$(CONFIG_AR71XX_NVRAM)		+= nvram.o
+obj-$(CONFIG_AR71XX_PCI_ATH9K_FIXUP)	+= pci-ath9k-fixup.o
+
+obj-$(CONFIG_AR71XX_MACH_AP121)		+= mach-ap121.o
+obj-$(CONFIG_AR71XX_MACH_AP81)		+= mach-ap81.o
+obj-$(CONFIG_AR71XX_MACH_AP83)		+= mach-ap83.o
+obj-$(CONFIG_AR71XX_MACH_AP96)		+= mach-ap96.o
+obj-$(CONFIG_AR71XX_MACH_AW_NR580)	+= mach-aw-nr580.o
+obj-$(CONFIG_AR71XX_MACH_DB120)		+= mach-db120.o
+obj-$(CONFIG_AR71XX_MACH_DIR_600_A1)	+= mach-dir-600-a1.o
+obj-$(CONFIG_AR71XX_MACH_DIR_615_C1)	+= mach-dir-615-c1.o
+obj-$(CONFIG_AR71XX_MACH_DIR_825_B1)	+= mach-dir-825-b1.o
+obj-$(CONFIG_AR71XX_MACH_EAP7660D)	+= mach-eap7660d.o
+obj-$(CONFIG_AR71XX_MACH_JA76PF)	+= mach-ja76pf.o
+obj-$(CONFIG_AR71XX_MACH_JWAP003)	+= mach-jwap003.o
+obj-$(CONFIG_AR71XX_MACH_MZK_W04NU)	+= mach-mzk-w04nu.o
+obj-$(CONFIG_AR71XX_MACH_MZK_W300NH)	+= mach-mzk-w300nh.o
+obj-$(CONFIG_AR71XX_MACH_NBG460N)	+= mach-nbg460n.o
+obj-$(CONFIG_AR71XX_MACH_PB42)		+= mach-pb42.o
+obj-$(CONFIG_AR71XX_MACH_PB44)		+= mach-pb44.o
+obj-$(CONFIG_AR71XX_MACH_PB92)		+= mach-pb92.o
+obj-$(CONFIG_AR71XX_MACH_RB4XX)		+= mach-rb4xx.o
+obj-$(CONFIG_AR71XX_MACH_RB750)		+= mach-rb750.o
+obj-$(CONFIG_AR71XX_MACH_TEW_632BRP)	+= mach-tew-632brp.o
+obj-$(CONFIG_AR71XX_MACH_TL_MR3X20)	+= mach-tl-mr3x20.o
+obj-$(CONFIG_AR71XX_MACH_TL_WA901ND)	+= mach-tl-wa901nd.o
+obj-$(CONFIG_AR71XX_MACH_TL_WA901ND_V2)	+= mach-tl-wa901nd-v2.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR741ND)	+= mach-tl-wr741nd.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR841N_V1)	+= mach-tl-wr841n.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR941ND)	+= mach-tl-wr941nd.o
+obj-$(CONFIG_AR71XX_MACH_TL_WR1043ND)	+= mach-tl-wr1043nd.o
+obj-$(CONFIG_AR71XX_MACH_UBNT)		+= mach-ubnt.o
+obj-$(CONFIG_AR71XX_MACH_WNDR3700)	+= mach-wndr3700.o
+obj-$(CONFIG_AR71XX_MACH_WNR2000)	+= mach-wnr2000.o
+obj-$(CONFIG_AR71XX_MACH_WP543)		+= mach-wp543.o
+obj-$(CONFIG_AR71XX_MACH_WRT160NL)	+= mach-wrt160nl.o
+obj-$(CONFIG_AR71XX_MACH_WRT400N)	+= mach-wrt400n.o
+obj-$(CONFIG_AR71XX_MACH_WZR_HP_G300NH)	+= mach-wzr-hp-g300nh.o
+obj-$(CONFIG_AR71XX_MACH_WZR_HP_AG300H)	+= mach-wzr-hp-ag300h.o
+obj-$(CONFIG_AR71XX_MACH_ZCN_1523H)	+= mach-zcn-1523h.o
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/nvram.c linux-2.6.39/arch/mips/ar71xx/nvram.c
--- linux-2.6.39.orig/arch/mips/ar71xx/nvram.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/nvram.c	2011-08-24 02:41:55.677990354 +0200
@@ -0,0 +1,75 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include "nvram.h"
+
+char *nvram_find_var(const char *name, const char *buf, unsigned buf_len)
+{
+	unsigned len = strlen(name);
+	char *cur, *last;
+
+	if (buf_len == 0 || len == 0)
+		return NULL;
+
+	if (buf_len < len)
+		return NULL;
+
+	if (len == 1)
+		return memchr(buf, (int) *name, buf_len);
+
+	last = (char *) buf + buf_len - len;
+	for (cur = (char *) buf; cur <= last; cur++)
+		if (cur[0] == name[0] && memcmp(cur, name, len) == 0)
+			return cur + len;
+
+	return NULL;
+}
+
+int nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			 const char *name, char *mac)
+{
+	char *buf;
+	char *mac_str;
+	int ret;
+	int t;
+
+	buf = vmalloc(nvram_len);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, nvram, nvram_len);
+	buf[nvram_len - 1] = '\0';
+
+	mac_str = nvram_find_var(name, buf, nvram_len);
+	if (!mac_str) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		   &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != 6) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	ret = 0;
+
+free:
+	vfree(buf);
+	return ret;
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/nvram.h linux-2.6.39/arch/mips/ar71xx/nvram.h
--- linux-2.6.39.orig/arch/mips/ar71xx/nvram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/nvram.h	2011-08-24 02:41:55.687991145 +0200
@@ -0,0 +1,19 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR71XX_NVRAM_H
+#define _AR71XX_NVRAM_H
+
+char *nvram_find_var(const char *name, const char *buf,
+		     unsigned buf_len) __init;
+int nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			 const char *name, char *mac) __init;
+
+#endif /* _AR71XX_NVRAM_H */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/pci-ath9k-fixup.c linux-2.6.39/arch/mips/ar71xx/pci-ath9k-fixup.c
--- linux-2.6.39.orig/arch/mips/ar71xx/pci-ath9k-fixup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/pci-ath9k-fixup.c	2011-08-24 02:41:55.697990606 +0200
@@ -0,0 +1,123 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+struct ath9k_fixup {
+	u16		*cal_data;
+	unsigned	slot;
+};
+
+static int ath9k_num_fixups;
+static struct ath9k_fixup ath9k_fixups[2];
+
+static void ath9k_pci_fixup(struct pci_dev *dev)
+{
+	void __iomem *mem;
+	u16 *cal_data = NULL;
+	u16 cmd;
+	u32 bar0;
+	u32 val;
+	unsigned i;
+
+	for (i = 0; i < ath9k_num_fixups; i++) {
+		if (ath9k_fixups[i].cal_data == NULL)
+			continue;
+
+		if (ath9k_fixups[i].slot != PCI_SLOT(dev->devfn))
+			continue;
+
+		cal_data = ath9k_fixups[i].cal_data;
+		break;
+	}
+
+	if (cal_data == NULL)
+		return;
+
+	if (*cal_data != 0xa55a) {
+		pr_err("pci %s: invalid calibration data\n", pci_name(dev));
+		return;
+	}
+
+	pr_info("pci %s: fixup device configuration\n", pci_name(dev));
+
+	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
+	if (!mem) {
+		pr_err("pci %s: ioremap error\n", pci_name(dev));
+		return;
+	}
+
+	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7161:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
+				       AR71XX_PCI_MEM_BASE);
+		break;
+	case AR71XX_SOC_AR7240:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
+		break;
+
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+
+	default:
+		BUG();
+	}
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	/* set pointer to first reg address */
+	cal_data += 3;
+	while (*cal_data != 0xffff) {
+		u32 reg;
+		reg = *cal_data++;
+		val = *cal_data++;
+		val |= (*cal_data++) << 16;
+
+		__raw_writel(val, mem + reg);
+		udelay(100);
+	}
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
+	dev->vendor = val & 0xffff;
+	dev->device = (val >> 16) & 0xffff;
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
+	dev->revision = val & 0xff;
+	dev->class = val >> 8; /* upper 3 bytes */
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
+
+	iounmap(mem);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ath9k_pci_fixup);
+
+void __init pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data)
+{
+	if (ath9k_num_fixups >= ARRAY_SIZE(ath9k_fixups))
+		return;
+
+	ath9k_fixups[ath9k_num_fixups].slot = slot;
+	ath9k_fixups[ath9k_num_fixups].cal_data = cal_data;
+	ath9k_num_fixups++;
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/pci-ath9k-fixup.h linux-2.6.39/arch/mips/ar71xx/pci-ath9k-fixup.h
--- linux-2.6.39.orig/arch/mips/ar71xx/pci-ath9k-fixup.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/pci-ath9k-fixup.h	2011-08-24 02:41:55.697990606 +0200
@@ -0,0 +1,6 @@
+#ifndef _PCI_ATH9K_FIXUP
+#define _PCI_ATH9K_FIXUP
+
+void pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data) __init;
+
+#endif /* _PCI_ATH9K_FIXUP */
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/pci.c linux-2.6.39/arch/mips/ar71xx/pci.c
--- linux-2.6.39.orig/arch/mips/ar71xx/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/pci.c	2011-08-24 02:41:55.697990606 +0200
@@ -0,0 +1,97 @@
+/*
+ *  Atheros AR71xx PCI setup code
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+
+#include <asm/traps.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+unsigned ar71xx_pci_nr_irqs __initdata;
+struct ar71xx_pci_irq *ar71xx_pci_irq_map __initdata;
+
+int (*ar71xx_pci_plat_dev_init)(struct pci_dev *dev);
+
+static int ar71xx_be_handler(struct pt_regs *regs, int is_fixup)
+{
+	int err = 0;
+
+	err = ar71xx_pci_be_handler(is_fixup);
+
+	return (is_fixup && !err) ? MIPS_BE_FIXUP : MIPS_BE_FATAL;
+}
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	if (ar71xx_pci_plat_dev_init)
+		return ar71xx_pci_plat_dev_init(dev);
+
+	return 0;
+}
+
+int __init pcibios_map_irq(const struct pci_dev *dev, uint8_t slot, uint8_t pin)
+{
+	int ret = 0;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ret = ar71xx_pcibios_map_irq(dev, slot, pin);
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ret = ar724x_pcibios_map_irq(dev, slot, pin);
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+int __init ar71xx_pci_init(unsigned nr_irqs, struct ar71xx_pci_irq *map)
+{
+	int ret = 0;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		board_be_handler = ar71xx_be_handler;
+		ret = ar71xx_pcibios_init();
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ret = ar724x_pcibios_init();
+		break;
+
+	default:
+		return 0;
+	}
+
+	ar71xx_pci_nr_irqs = nr_irqs;
+	ar71xx_pci_irq_map = map;
+
+	return ret;
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/prom.c linux-2.6.39/arch/mips/ar71xx/prom.c
--- linux-2.6.39.orig/arch/mips/ar71xx/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/prom.c	2011-08-24 02:41:55.737990425 +0200
@@ -0,0 +1,189 @@
+/*
+ *  Atheros AR71xx SoC specific prom routines
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+#include <asm/fw/myloader/myloader.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+static inline int is_valid_ram_addr(void *addr)
+{
+	if (((u32) addr > KSEG0) &&
+	    ((u32) addr < (KSEG0 + AR71XX_MEM_SIZE_MAX)))
+		return 1;
+
+	if (((u32) addr > KSEG1) &&
+	    ((u32) addr < (KSEG1 + AR71XX_MEM_SIZE_MAX)))
+		return 1;
+
+	return 0;
+}
+
+static void __init ar71xx_prom_append_cmdline(const char *name,
+					      const char *value)
+{
+	char buf[COMMAND_LINE_SIZE];
+
+	snprintf(buf, sizeof(buf), " %s=%s", name, value);
+	strlcat(arcs_cmdline, buf, sizeof(arcs_cmdline));
+}
+
+static const char * __init ar71xx_prom_find_env(char **envp, const char *name)
+{
+	const char *ret = NULL;
+	int len;
+	char **p;
+
+	if (!is_valid_ram_addr(envp))
+		return NULL;
+
+	len = strlen(name);
+	for (p = envp; is_valid_ram_addr(*p); p++) {
+		if (strncmp(name, *p, len) == 0 && (*p)[len] == '=') {
+			ret = *p + len + 1;
+			break;
+		}
+
+		/* RedBoot env comes in pointer pairs - key, value */
+		if (strncmp(name, *p, len) == 0 && (*p)[len] == 0)
+			if (is_valid_ram_addr(*(++p))) {
+				ret = *p;
+				break;
+			}
+	}
+
+	return ret;
+}
+
+static int __init ar71xx_prom_init_myloader(void)
+{
+	struct myloader_info *mylo;
+	char mac_buf[32];
+	char *mac;
+
+	mylo = myloader_get_info();
+	if (!mylo)
+		return 0;
+
+	switch (mylo->did) {
+	case DEVID_COMPEX_WP543:
+		ar71xx_prom_append_cmdline("board", "WP543");
+		break;
+	default:
+		printk(KERN_WARNING "prom: unknown device id: %x\n",
+				mylo->did);
+		return 0;
+	}
+
+	mac = mylo->macs[0];
+	snprintf(mac_buf, sizeof(mac_buf), "%02x:%02x:%02x:%02x:%02x:%02x",
+		 mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+	ar71xx_prom_append_cmdline("ethaddr", mac_buf);
+
+	return 1;
+}
+
+#ifdef CONFIG_IMAGE_CMDLINE_HACK
+extern char __image_cmdline[];
+
+static int __init ar71xx_use__image_cmdline(void)
+{
+	char *p = __image_cmdline;
+	int replace = 0;
+
+	if (*p == '-') {
+		replace = 1;
+		p++;
+	}
+
+	if (*p == '\0')
+		return 0;
+
+	if (replace) {
+		strlcpy(arcs_cmdline, p, sizeof(arcs_cmdline));
+	} else {
+		strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
+		strlcat(arcs_cmdline, p, sizeof(arcs_cmdline));
+	}
+
+	return 1;
+}
+#else
+static inline int ar71xx_use__image_cmdline(void) { return 0; }
+#endif
+
+static __init void ar71xx_prom_init_cmdline(int argc, char **argv)
+{
+	int i;
+
+	if (ar71xx_use__image_cmdline())
+		return;
+
+	if (!is_valid_ram_addr(argv))
+		return;
+
+	for (i = 0; i < argc; i++)
+		if (is_valid_ram_addr(argv[i])) {
+			strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
+			strlcat(arcs_cmdline, argv[i], sizeof(arcs_cmdline));
+		}
+}
+
+void __init prom_init(void)
+{
+	const char *env;
+	char **envp;
+
+	printk(KERN_DEBUG "prom: fw_arg0=%08x, fw_arg1=%08x, "
+			"fw_arg2=%08x, fw_arg3=%08x\n",
+			(unsigned int)fw_arg0, (unsigned int)fw_arg1,
+			(unsigned int)fw_arg2, (unsigned int)fw_arg3);
+
+
+	if (ar71xx_prom_init_myloader())
+		return;
+
+	ar71xx_prom_init_cmdline(fw_arg0, (char **)fw_arg1);
+
+	envp = (char **)fw_arg2;
+	if (!strstr(arcs_cmdline, "ethaddr=")) {
+		env = ar71xx_prom_find_env(envp, "ethaddr");
+		if (env)
+			ar71xx_prom_append_cmdline("ethaddr", env);
+	}
+
+	if (!strstr(arcs_cmdline, "board=")) {
+		env = ar71xx_prom_find_env(envp, "board");
+		if (env) {
+			/* Workaround for buggy bootloaders */
+			if (strcmp(env, "RouterStation") == 0 ||
+			    strcmp(env, "Ubiquiti AR71xx-based board") == 0)
+				env = "UBNT-RS";
+
+			if (strcmp(env, "RouterStation PRO") == 0)
+				env = "UBNT-RSPRO";
+
+			ar71xx_prom_append_cmdline("board", env);
+		}
+	}
+}
+
+void __init prom_free_prom_memory(void)
+{
+	/* We do not have to prom memory to free */
+}
diff -Nur linux-2.6.39.orig/arch/mips/ar71xx/setup.c linux-2.6.39/arch/mips/ar71xx/setup.c
--- linux-2.6.39.orig/arch/mips/ar71xx/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/ar71xx/setup.c	2011-08-24 02:41:55.737990425 +0200
@@ -0,0 +1,446 @@
+/*
+ *  Atheros AR71xx SoC specific setup
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/time.h>		/* for mips_hpt_frequency */
+#include <asm/reboot.h>		/* for _machine_{restart,halt} */
+#include <asm/mips_machine.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+
+#define AR71XX_SYS_TYPE_LEN	64
+
+u32 ar71xx_cpu_freq;
+EXPORT_SYMBOL_GPL(ar71xx_cpu_freq);
+
+u32 ar71xx_ahb_freq;
+EXPORT_SYMBOL_GPL(ar71xx_ahb_freq);
+
+u32 ar71xx_ddr_freq;
+EXPORT_SYMBOL_GPL(ar71xx_ddr_freq);
+
+u32 ar71xx_ref_freq;
+EXPORT_SYMBOL_GPL(ar71xx_ref_freq);
+
+enum ar71xx_soc_type ar71xx_soc;
+EXPORT_SYMBOL_GPL(ar71xx_soc);
+
+u32 ar71xx_soc_rev;
+EXPORT_SYMBOL_GPL(ar71xx_soc_rev);
+
+static char ar71xx_sys_type[AR71XX_SYS_TYPE_LEN];
+
+static void ar71xx_restart(char *command)
+{
+	ar71xx_device_stop(RESET_MODULE_FULL_CHIP);
+	for (;;)
+		if (cpu_wait)
+			cpu_wait();
+}
+
+static void ar71xx_halt(void)
+{
+	while (1)
+		cpu_wait();
+}
+
+static void __init ar71xx_detect_mem_size(void)
+{
+	unsigned long size;
+
+	for (size = AR71XX_MEM_SIZE_MIN; size < AR71XX_MEM_SIZE_MAX;
+	     size <<= 1) {
+		if (!memcmp(ar71xx_detect_mem_size,
+			    ar71xx_detect_mem_size + size, 1024))
+			break;
+	}
+
+	add_memory_region(0, size, BOOT_MEM_RAM);
+}
+
+static void __init ar71xx_detect_sys_type(void)
+{
+	char *chip = "????";
+	u32 id;
+	u32 major;
+	u32 minor;
+	u32 rev = 0;
+
+	id = ar71xx_reset_rr(AR71XX_RESET_REG_REV_ID);
+	major = id & REV_ID_MAJOR_MASK;
+
+	switch (major) {
+	case REV_ID_MAJOR_AR71XX:
+		minor = id & AR71XX_REV_ID_MINOR_MASK;
+		rev = id >> AR71XX_REV_ID_REVISION_SHIFT;
+		rev &= AR71XX_REV_ID_REVISION_MASK;
+		switch (minor) {
+		case AR71XX_REV_ID_MINOR_AR7130:
+			ar71xx_soc = AR71XX_SOC_AR7130;
+			chip = "7130";
+			break;
+
+		case AR71XX_REV_ID_MINOR_AR7141:
+			ar71xx_soc = AR71XX_SOC_AR7141;
+			chip = "7141";
+			break;
+
+		case AR71XX_REV_ID_MINOR_AR7161:
+			ar71xx_soc = AR71XX_SOC_AR7161;
+			chip = "7161";
+			break;
+		}
+		break;
+
+	case REV_ID_MAJOR_AR7240:
+		ar71xx_soc = AR71XX_SOC_AR7240;
+		chip = "7240";
+		rev = id & AR724X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_AR7241:
+		ar71xx_soc = AR71XX_SOC_AR7241;
+		chip = "7241";
+		rev = id & AR724X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_AR7242:
+		ar71xx_soc = AR71XX_SOC_AR7242;
+		chip = "7242";
+		rev = id & AR724X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_AR913X:
+		minor = id & AR91XX_REV_ID_MINOR_MASK;
+		rev = id >> AR91XX_REV_ID_REVISION_SHIFT;
+		rev &= AR91XX_REV_ID_REVISION_MASK;
+		switch (minor) {
+		case AR91XX_REV_ID_MINOR_AR9130:
+			ar71xx_soc = AR71XX_SOC_AR9130;
+			chip = "9130";
+			break;
+
+		case AR91XX_REV_ID_MINOR_AR9132:
+			ar71xx_soc = AR71XX_SOC_AR9132;
+			chip = "9132";
+			break;
+		}
+		break;
+
+	case REV_ID_MAJOR_AR9330:
+		ar71xx_soc = AR71XX_SOC_AR9330;
+		chip = "9330";
+		rev = id & AR933X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_AR9331:
+		ar71xx_soc = AR71XX_SOC_AR9331;
+		chip = "9331";
+		rev = id & AR933X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_AR9342:
+		ar71xx_soc = AR71XX_SOC_AR9342;
+		chip = "9342";
+		rev = id & AR934X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_AR9344:
+		ar71xx_soc = AR71XX_SOC_AR9344;
+		chip = "9344";
+		rev = id & AR934X_REV_ID_REVISION_MASK;
+		break;
+
+	default:
+		panic("ar71xx: unknown chip id:0x%08x\n", id);
+	}
+
+	ar71xx_soc_rev = rev;
+
+	sprintf(ar71xx_sys_type, "Atheros AR%s rev %u", chip, rev);
+	pr_info("SoC: %s\n", ar71xx_sys_type);
+}
+
+static void __init ar934x_detect_sys_frequency(void)
+{
+	u32 pll, out_div, ref_div, nint, frac, clk_ctrl, postdiv;
+
+	if (ar71xx_reset_rr(AR934X_RESET_REG_BOOTSTRAP) & AR934X_REF_CLK_40)
+		ar71xx_ref_freq = 40 * 1000 * 1000;
+	else
+		ar71xx_ref_freq = 25 * 1000 * 1000;
+
+	clk_ctrl = ar71xx_pll_rr(AR934X_PLL_REG_DDR_CTRL_CLOCK);
+
+	pll = ar71xx_pll_rr(AR934X_PLL_REG_CPU_CONFIG);
+	out_div	= AR934X_CPU_PLL_CFG_OUTDIV_GET(pll);
+	ref_div	= AR934X_CPU_PLL_CFG_REFDIV_GET(pll);
+	nint	= AR934X_CPU_PLL_CFG_NINT_GET(pll);
+	frac	= AR934X_CPU_PLL_CFG_NFRAC_GET(pll);
+	postdiv = AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_GET(clk_ctrl);
+	ar71xx_cpu_freq = ((nint * ar71xx_ref_freq / ref_div) >> out_div) /
+			  (postdiv + 1);
+
+	out_div	= AR934X_DDR_PLL_CFG_OUTDIV_GET(pll);
+	ref_div	= AR934X_DDR_PLL_CFG_REFDIV_GET(pll);
+	nint	= AR934X_DDR_PLL_CFG_NINT_GET(pll);
+	frac	= AR934X_DDR_PLL_CFG_NFRAC_GET(pll);
+	postdiv = AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_GET(clk_ctrl);
+	ar71xx_ddr_freq = ((nint * ar71xx_ref_freq / ref_div) >> out_div) /
+			  (postdiv + 1);
+
+	postdiv = AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_GET(clk_ctrl);
+
+	if (AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_GET(clk_ctrl)) {
+		ar71xx_ahb_freq = ar71xx_ddr_freq / (postdiv + 1);
+	} else {
+		ar71xx_ahb_freq = ar71xx_cpu_freq / (postdiv + 1);
+	}
+
+}
+
+static void __init ar91xx_detect_sys_frequency(void)
+{
+	u32 pll;
+	u32 freq;
+	u32 div;
+
+	ar71xx_ref_freq = 5 * 1000 * 1000;
+
+	pll = ar71xx_pll_rr(AR91XX_PLL_REG_CPU_CONFIG);
+
+	div = ((pll >> AR91XX_PLL_DIV_SHIFT) & AR91XX_PLL_DIV_MASK);
+	freq = div * ar71xx_ref_freq;
+
+	ar71xx_cpu_freq = freq;
+
+	div = ((pll >> AR91XX_DDR_DIV_SHIFT) & AR91XX_DDR_DIV_MASK) + 1;
+	ar71xx_ddr_freq = freq / div;
+
+	div = (((pll >> AR91XX_AHB_DIV_SHIFT) & AR91XX_AHB_DIV_MASK) + 1) * 2;
+	ar71xx_ahb_freq = ar71xx_cpu_freq / div;
+}
+
+static void __init ar71xx_detect_sys_frequency(void)
+{
+	u32 pll;
+	u32 freq;
+	u32 div;
+
+	ar71xx_ref_freq = 40 * 1000 * 1000;
+
+	pll = ar71xx_pll_rr(AR71XX_PLL_REG_CPU_CONFIG);
+
+	div = ((pll >> AR71XX_PLL_DIV_SHIFT) & AR71XX_PLL_DIV_MASK) + 1;
+	freq = div * ar71xx_ref_freq;
+
+	div = ((pll >> AR71XX_CPU_DIV_SHIFT) & AR71XX_CPU_DIV_MASK) + 1;
+	ar71xx_cpu_freq = freq / div;
+
+	div = ((pll >> AR71XX_DDR_DIV_SHIFT) & AR71XX_DDR_DIV_MASK) + 1;
+	ar71xx_ddr_freq = freq / div;
+
+	div = (((pll >> AR71XX_AHB_DIV_SHIFT) & AR71XX_AHB_DIV_MASK) + 1) * 2;
+	ar71xx_ahb_freq = ar71xx_cpu_freq / div;
+}
+
+static void __init ar724x_detect_sys_frequency(void)
+{
+	u32 pll;
+	u32 freq;
+	u32 div;
+
+	ar71xx_ref_freq = 5 * 1000 * 1000;
+
+	pll = ar71xx_pll_rr(AR724X_PLL_REG_CPU_CONFIG);
+
+	div = ((pll >> AR724X_PLL_DIV_SHIFT) & AR724X_PLL_DIV_MASK);
+	freq = div * ar71xx_ref_freq;
+
+	div = ((pll >> AR724X_PLL_REF_DIV_SHIFT) & AR724X_PLL_REF_DIV_MASK);
+	freq *= div;
+
+	ar71xx_cpu_freq = freq;
+
+	div = ((pll >> AR724X_DDR_DIV_SHIFT) & AR724X_DDR_DIV_MASK) + 1;
+	ar71xx_ddr_freq = freq / div;
+
+	div = (((pll >> AR724X_AHB_DIV_SHIFT) & AR724X_AHB_DIV_MASK) + 1) * 2;
+	ar71xx_ahb_freq = ar71xx_cpu_freq / div;
+}
+
+static void __init ar933x_detect_sys_frequency(void)
+{
+	u32 clock_ctrl;
+	u32 cpu_config;
+	u32 freq;
+	u32 t;
+
+	t = ar71xx_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	if (t & AR933X_BOOTSTRAP_REF_CLK_40)
+		ar71xx_ref_freq = (40 * 1000 * 1000);
+	else
+		ar71xx_ref_freq = (25 * 1000 * 1000);
+
+	clock_ctrl = ar71xx_pll_rr(AR933X_PLL_CLOCK_CTRL_REG);
+	if (clock_ctrl & AR933X_PLL_CLOCK_CTRL_BYPASS) {
+		ar71xx_cpu_freq = ar71xx_ref_freq;
+		ar71xx_ahb_freq = ar71xx_ref_freq;
+		ar71xx_ddr_freq = ar71xx_ref_freq;
+	} else {
+		cpu_config = ar71xx_pll_rr(AR933X_PLL_CPU_CONFIG_REG);
+
+		t = (cpu_config >> AR933X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
+		    AR933X_PLL_CPU_CONFIG_REFDIV_MASK;
+		freq = ar71xx_ref_freq / t;
+
+		t = (cpu_config >> AR933X_PLL_CPU_CONFIG_NINT_SHIFT) &
+		    AR933X_PLL_CPU_CONFIG_NINT_MASK;
+		freq *= t;
+
+		t = (cpu_config >> AR933X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+		    AR933X_PLL_CPU_CONFIG_OUTDIV_MASK;
+		if (t == 0)
+			t = 1;
+
+		freq >>= t;
+
+		t = ((clock_ctrl >> AR933X_PLL_CLOCK_CTRL_CPU_DIV_SHIFT) &
+		     AR933X_PLL_CLOCK_CTRL_CPU_DIV_MASK) + 1;
+		ar71xx_cpu_freq = freq / t;
+
+		t = ((clock_ctrl >> AR933X_PLL_CLOCK_CTRL_DDR_DIV_SHIFT) &
+		      AR933X_PLL_CLOCK_CTRL_DDR_DIV_MASK) + 1;
+		ar71xx_ddr_freq = freq / t;
+
+		t = ((clock_ctrl >> AR933X_PLL_CLOCK_CTRL_AHB_DIV_SHIFT) &
+		     AR933X_PLL_CLOCK_CTRL_AHB_DIV_MASK) + 1;
+		ar71xx_ahb_freq = freq / t;
+	}
+}
+
+static void __init detect_sys_frequency(void)
+{
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+		ar71xx_detect_sys_frequency();
+		break;
+
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		ar724x_detect_sys_frequency();
+		break;
+
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		ar91xx_detect_sys_frequency();
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+		ar933x_detect_sys_frequency();
+		break;
+
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		ar934x_detect_sys_frequency();
+		break;
+	default:
+		BUG();
+	}
+}
+
+const char *get_system_type(void)
+{
+	return ar71xx_sys_type;
+}
+
+unsigned int __cpuinit get_c0_compare_irq(void)
+{
+	return CP0_LEGACY_COMPARE_IRQ;
+}
+
+void __init plat_mem_setup(void)
+{
+	set_io_port_base(KSEG1);
+
+	ar71xx_ddr_base = ioremap_nocache(AR71XX_DDR_CTRL_BASE,
+						AR71XX_DDR_CTRL_SIZE);
+
+	ar71xx_pll_base = ioremap_nocache(AR71XX_PLL_BASE,
+						AR71XX_PLL_SIZE);
+
+	ar71xx_reset_base = ioremap_nocache(AR71XX_RESET_BASE,
+						AR71XX_RESET_SIZE);
+
+	ar71xx_gpio_base = ioremap_nocache(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE);
+
+	ar71xx_usb_ctrl_base = ioremap_nocache(AR71XX_USB_CTRL_BASE,
+						AR71XX_USB_CTRL_SIZE);
+
+	ar71xx_detect_mem_size();
+	ar71xx_detect_sys_type();
+	detect_sys_frequency();
+
+	pr_info("Clocks: CPU:%u.%03uMHz, DDR:%u.%03uMHz, AHB:%u.%03uMHz, "
+		"Ref:%u.%03uMHz",
+		ar71xx_cpu_freq / 1000000, (ar71xx_cpu_freq / 1000) % 1000,
+		ar71xx_ddr_freq / 1000000, (ar71xx_ddr_freq / 1000) % 1000,
+		ar71xx_ahb_freq / 1000000, (ar71xx_ahb_freq / 1000) % 1000,
+		ar71xx_ref_freq / 1000000, (ar71xx_ref_freq / 1000) % 1000);
+
+	_machine_restart = ar71xx_restart;
+	_machine_halt = ar71xx_halt;
+	pm_power_off = ar71xx_halt;
+}
+
+void __init plat_time_init(void)
+{
+	mips_hpt_frequency = ar71xx_cpu_freq / 2;
+}
+
+__setup("board=", mips_machtype_setup);
+
+static int __init ar71xx_machine_setup(void)
+{
+	ar71xx_gpio_init();
+
+	ar71xx_add_device_uart();
+	ar71xx_add_device_wdt();
+
+	mips_machine_setup();
+	return 0;
+}
+
+arch_initcall(ar71xx_machine_setup);
+
+static void __init ar71xx_generic_init(void)
+{
+	/* Nothing to do */
+}
+
+MIPS_MACHINE(AR71XX_MACH_GENERIC, "Generic", "Generic AR71xx board",
+	     ar71xx_generic_init);
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/checksum.h linux-2.6.39/arch/mips/include/asm/checksum.h
--- linux-2.6.39.orig/arch/mips/include/asm/checksum.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/arch/mips/include/asm/checksum.h	2011-08-24 05:53:21.109231561 +0200
@@ -12,6 +12,7 @@
 #define _ASM_CHECKSUM_H
 
 #include <linux/in6.h>
+#include <linux/unaligned/packed_struct.h>
 
 #include <asm/uaccess.h>
 
@@ -104,26 +105,30 @@
 	const unsigned int *stop = word + ihl;
 	unsigned int csum;
 	int carry;
+	unsigned int w;
 
-	csum = word[0];
-	csum += word[1];
-	carry = (csum < word[1]);
+	csum = __get_unaligned_cpu32(word++);
+
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[2];
-	carry = (csum < word[2]);
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[3];
-	carry = (csum < word[3]);
+	w = __get_unaligned_cpu32(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	word += 4;
 	do {
-		csum += *word;
-		carry = (csum < *word);
+		w = __get_unaligned_cpu32(word++);
+		csum += w;
+		carry = (csum < w);
 		csum += carry;
-		word++;
 	} while (word != stop);
 
 	return csum_fold(csum);
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/fw/myloader/myloader.h linux-2.6.39/arch/mips/include/asm/fw/myloader/myloader.h
--- linux-2.6.39.orig/arch/mips/include/asm/fw/myloader/myloader.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/fw/myloader/myloader.h	2011-04-27 12:19:21.887662064 +0200
@@ -0,0 +1,34 @@
+/*
+ *  Compex's MyLoader specific definitions
+ *
+ *  Copyright (C) 2006-2008 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ASM_MIPS_FW_MYLOADER_H
+#define _ASM_MIPS_FW_MYLOADER_H
+
+#include <linux/myloader.h>
+
+struct myloader_info {
+	uint32_t	vid;
+	uint32_t	did;
+	uint32_t	svid;
+	uint32_t	sdid;
+	uint8_t		macs[MYLO_ETHADDR_COUNT][6];
+};
+
+#ifdef CONFIG_MYLOADER
+extern struct myloader_info *myloader_get_info(void) __init;
+#else
+static inline struct myloader_info *myloader_get_info(void)
+{
+	return NULL;
+}
+#endif /* CONFIG_MYLOADER */
+
+#endif /* _ASM_MIPS_FW_MYLOADER_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/ar71xx.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/ar71xx.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/ar71xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/ar71xx.h	2011-08-06 09:32:36.758018150 +0200
@@ -0,0 +1,769 @@
+/*
+ *  Atheros AR71xx SoC specific definitions
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_AR71XX_H
+#define __ASM_MACH_AR71XX_H
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
+
+#ifndef __ASSEMBLER__
+
+#define AR71XX_PCI_MEM_BASE	0x10000000
+#define AR71XX_PCI_MEM_SIZE	0x08000000
+#define AR71XX_APB_BASE		0x18000000
+#define AR71XX_GE0_BASE		0x19000000
+#define AR71XX_GE0_SIZE		0x01000000
+#define AR71XX_GE1_BASE		0x1a000000
+#define AR71XX_GE1_SIZE		0x01000000
+#define AR71XX_EHCI_BASE	0x1b000000
+#define AR71XX_EHCI_SIZE	0x01000000
+#define AR71XX_OHCI_BASE	0x1c000000
+#define AR71XX_OHCI_SIZE	0x01000000
+#define AR7240_OHCI_BASE	0x1b000000
+#define AR7240_OHCI_SIZE	0x01000000
+#define AR71XX_SPI_BASE		0x1f000000
+#define AR71XX_SPI_SIZE		0x01000000
+
+#define AR71XX_DDR_CTRL_BASE	(AR71XX_APB_BASE + 0x00000000)
+#define AR71XX_DDR_CTRL_SIZE	0x10000
+#define AR71XX_CPU_BASE		(AR71XX_APB_BASE + 0x00010000)
+#define AR71XX_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
+#define AR71XX_UART_SIZE	0x10000
+#define AR71XX_USB_CTRL_BASE	(AR71XX_APB_BASE + 0x00030000)
+#define AR71XX_USB_CTRL_SIZE	0x10000
+#define AR71XX_GPIO_BASE	(AR71XX_APB_BASE + 0x00040000)
+#define AR71XX_GPIO_SIZE	0x10000
+#define AR71XX_PLL_BASE		(AR71XX_APB_BASE + 0x00050000)
+#define AR71XX_PLL_SIZE		0x10000
+#define AR71XX_RESET_BASE	(AR71XX_APB_BASE + 0x00060000)
+#define AR71XX_RESET_SIZE	0x10000
+#define AR71XX_MII_BASE		(AR71XX_APB_BASE + 0x00070000)
+#define AR71XX_MII_SIZE		0x10000
+#define AR71XX_SLIC_BASE	(AR71XX_APB_BASE + 0x00090000)
+#define AR71XX_SLIC_SIZE	0x10000
+#define AR71XX_DMA_BASE		(AR71XX_APB_BASE + 0x000A0000)
+#define AR71XX_DMA_SIZE		0x10000
+#define AR71XX_STEREO_BASE	(AR71XX_APB_BASE + 0x000B0000)
+#define AR71XX_STEREO_SIZE	0x10000
+
+#define AR724X_PCI_CRP_BASE	(AR71XX_APB_BASE + 0x000C0000)
+#define AR724X_PCI_CRP_SIZE	0x100
+
+#define AR724X_PCI_CTRL_BASE	(AR71XX_APB_BASE + 0x000F0000)
+#define AR724X_PCI_CTRL_SIZE	0x100
+
+#define AR91XX_WMAC_BASE	(AR71XX_APB_BASE + 0x000C0000)
+#define AR91XX_WMAC_SIZE	0x30000
+
+#define AR933X_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
+#define AR933X_UART_SIZE	0x14
+#define AR933X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+#define AR933X_WMAC_SIZE	0x20000
+
+#define AR934X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+#define AR934X_WMAC_SIZE	0x20000
+
+#define AR71XX_MEM_SIZE_MIN	0x0200000
+#define AR71XX_MEM_SIZE_MAX	0x10000000
+
+#define AR71XX_CPU_IRQ_BASE	0
+#define AR71XX_MISC_IRQ_BASE	8
+#define AR71XX_MISC_IRQ_COUNT	32
+#define AR71XX_GPIO_IRQ_BASE	40
+#define AR71XX_GPIO_IRQ_COUNT	32
+#define AR71XX_PCI_IRQ_BASE	72
+#define AR71XX_PCI_IRQ_COUNT	8
+
+#define AR71XX_CPU_IRQ_IP2	(AR71XX_CPU_IRQ_BASE + 2)
+#define AR71XX_CPU_IRQ_USB	(AR71XX_CPU_IRQ_BASE + 3)
+#define AR71XX_CPU_IRQ_GE0	(AR71XX_CPU_IRQ_BASE + 4)
+#define AR71XX_CPU_IRQ_GE1	(AR71XX_CPU_IRQ_BASE + 5)
+#define AR71XX_CPU_IRQ_MISC	(AR71XX_CPU_IRQ_BASE + 6)
+#define AR71XX_CPU_IRQ_TIMER	(AR71XX_CPU_IRQ_BASE + 7)
+
+#define AR71XX_MISC_IRQ_TIMER	(AR71XX_MISC_IRQ_BASE + 0)
+#define AR71XX_MISC_IRQ_ERROR	(AR71XX_MISC_IRQ_BASE + 1)
+#define AR71XX_MISC_IRQ_GPIO	(AR71XX_MISC_IRQ_BASE + 2)
+#define AR71XX_MISC_IRQ_UART	(AR71XX_MISC_IRQ_BASE + 3)
+#define AR71XX_MISC_IRQ_WDOG	(AR71XX_MISC_IRQ_BASE + 4)
+#define AR71XX_MISC_IRQ_PERFC	(AR71XX_MISC_IRQ_BASE + 5)
+#define AR71XX_MISC_IRQ_OHCI	(AR71XX_MISC_IRQ_BASE + 6)
+#define AR71XX_MISC_IRQ_DMA	(AR71XX_MISC_IRQ_BASE + 7)
+#define AR71XX_MISC_IRQ_TIMER2	(AR71XX_MISC_IRQ_BASE + 8)
+#define AR71XX_MISC_IRQ_TIMER3	(AR71XX_MISC_IRQ_BASE + 9)
+#define AR71XX_MISC_IRQ_TIMER4	(AR71XX_MISC_IRQ_BASE + 10)
+#define AR71XX_MISC_IRQ_DDR_PERF	(AR71XX_MISC_IRQ_BASE + 11)
+#define AR71XX_MISC_IRQ_ENET_LINK	(AR71XX_MISC_IRQ_BASE + 12)
+
+#define AR71XX_GPIO_IRQ(_x)	(AR71XX_GPIO_IRQ_BASE + (_x))
+
+#define AR71XX_PCI_IRQ_DEV0	(AR71XX_PCI_IRQ_BASE + 0)
+#define AR71XX_PCI_IRQ_DEV1	(AR71XX_PCI_IRQ_BASE + 1)
+#define AR71XX_PCI_IRQ_DEV2	(AR71XX_PCI_IRQ_BASE + 2)
+#define AR71XX_PCI_IRQ_CORE	(AR71XX_PCI_IRQ_BASE + 4)
+
+extern u32 ar71xx_ahb_freq;
+extern u32 ar71xx_cpu_freq;
+extern u32 ar71xx_ddr_freq;
+extern u32 ar71xx_ref_freq;
+
+enum ar71xx_soc_type {
+	AR71XX_SOC_UNKNOWN,
+	AR71XX_SOC_AR7130,
+	AR71XX_SOC_AR7141,
+	AR71XX_SOC_AR7161,
+	AR71XX_SOC_AR7240,
+	AR71XX_SOC_AR7241,
+	AR71XX_SOC_AR7242,
+	AR71XX_SOC_AR9130,
+	AR71XX_SOC_AR9132,
+	AR71XX_SOC_AR9330,
+	AR71XX_SOC_AR9331,
+	AR71XX_SOC_AR9341,
+	AR71XX_SOC_AR9342,
+	AR71XX_SOC_AR9344,
+};
+extern u32 ar71xx_soc_rev;
+
+extern enum ar71xx_soc_type ar71xx_soc;
+
+/*
+ * PLL block
+ */
+#define AR71XX_PLL_REG_CPU_CONFIG	0x00
+#define AR71XX_PLL_REG_SEC_CONFIG	0x04
+#define AR71XX_PLL_REG_ETH0_INT_CLOCK	0x10
+#define AR71XX_PLL_REG_ETH1_INT_CLOCK	0x14
+
+#define AR71XX_PLL_DIV_SHIFT		3
+#define AR71XX_PLL_DIV_MASK		0x1f
+#define AR71XX_CPU_DIV_SHIFT		16
+#define AR71XX_CPU_DIV_MASK		0x3
+#define AR71XX_DDR_DIV_SHIFT		18
+#define AR71XX_DDR_DIV_MASK		0x3
+#define AR71XX_AHB_DIV_SHIFT		20
+#define AR71XX_AHB_DIV_MASK		0x7
+
+#define AR71XX_ETH0_PLL_SHIFT		17
+#define AR71XX_ETH1_PLL_SHIFT		19
+
+#define AR724X_PLL_REG_CPU_CONFIG	0x00
+#define AR724X_PLL_REG_PCIE_CONFIG	0x18
+
+#define AR724X_PLL_DIV_SHIFT		0
+#define AR724X_PLL_DIV_MASK		0x3ff
+#define AR724X_PLL_REF_DIV_SHIFT	10
+#define AR724X_PLL_REF_DIV_MASK		0xf
+#define AR724X_AHB_DIV_SHIFT		19
+#define AR724X_AHB_DIV_MASK		0x1
+#define AR724X_DDR_DIV_SHIFT		22
+#define AR724X_DDR_DIV_MASK		0x3
+
+#define AR7242_PLL_REG_ETH0_INT_CLOCK	0x2c
+
+#define AR91XX_PLL_REG_CPU_CONFIG	0x00
+#define AR91XX_PLL_REG_ETH_CONFIG	0x04
+#define AR91XX_PLL_REG_ETH0_INT_CLOCK	0x14
+#define AR91XX_PLL_REG_ETH1_INT_CLOCK	0x18
+
+#define AR91XX_PLL_DIV_SHIFT		0
+#define AR91XX_PLL_DIV_MASK		0x3ff
+#define AR91XX_DDR_DIV_SHIFT		22
+#define AR91XX_DDR_DIV_MASK		0x3
+#define AR91XX_AHB_DIV_SHIFT		19
+#define AR91XX_AHB_DIV_MASK		0x1
+
+#define AR91XX_ETH0_PLL_SHIFT		20
+#define AR91XX_ETH1_PLL_SHIFT		22
+
+#define AR933X_PLL_CPU_CONFIG_REG	0x00
+#define AR933X_PLL_CLOCK_CTRL_REG	0x08
+
+#define AR933X_PLL_CPU_CONFIG_NINT_SHIFT	10
+#define AR933X_PLL_CPU_CONFIG_NINT_MASK		0x3f
+#define AR933X_PLL_CPU_CONFIG_REFDIV_SHIFT	16
+#define AR933X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
+#define AR933X_PLL_CPU_CONFIG_OUTDIV_SHIFT	23
+#define AR933X_PLL_CPU_CONFIG_OUTDIV_MASK	0x7
+
+#define AR933X_PLL_CLOCK_CTRL_BYPASS		BIT(2)
+#define AR933X_PLL_CLOCK_CTRL_CPU_DIV_SHIFT	5
+#define AR933X_PLL_CLOCK_CTRL_CPU_DIV_MASK	0x3
+#define AR933X_PLL_CLOCK_CTRL_DDR_DIV_SHIFT	10
+#define AR933X_PLL_CLOCK_CTRL_DDR_DIV_MASK	0x3
+#define AR933X_PLL_CLOCK_CTRL_AHB_DIV_SHIFT	15
+#define AR933X_PLL_CLOCK_CTRL_AHB_DIV_MASK	0x7
+
+#define AR934X_PLL_REG_CPU_CONFIG	0x00
+#define AR934X_PLL_REG_DDR_CTRL_CLOCK	0x8
+
+#define AR934X_CPU_PLL_CFG_OUTDIV_MSB	21
+#define AR934X_CPU_PLL_CFG_OUTDIV_LSB	19
+#define AR934X_CPU_PLL_CFG_OUTDIV_MASK	0x00380000
+
+#define AR934X_CPU_PLL_CFG_OUTDIV_GET(x)		\
+	(((x) & AR934X_CPU_PLL_CFG_OUTDIV_MASK) >>	\
+	AR934X_CPU_PLL_CFG_OUTDIV_LSB)
+
+#define AR934X_DDR_PLL_CFG_OUTDIV_MSB	25
+#define AR934X_DDR_PLL_CFG_OUTDIV_LSB	23
+#define AR934X_DDR_PLL_CFG_OUTDIV_MASK	0x03800000
+
+#define AR934X_DDR_PLL_CFG_OUTDIV_GET(x) 		\
+	(((x) & AR934X_DDR_PLL_CFG_OUTDIV_MASK) >> 	\
+	AR934X_DDR_PLL_CFG_OUTDIV_LSB)
+
+#define AR934X_DDR_PLL_CFG_OUTDIV_SET(x) 		\
+	(((x) << AR934X_DDR_PLL_CFG_OUTDIV_LSB) & 	\
+	AR934X_DDR_PLL_CFG_OUTDIV_MASK)
+
+#define AR934X_CPU_PLL_CFG_REFDIV_MSB	16
+#define AR934X_CPU_PLL_CFG_REFDIV_LSB	12
+#define AR934X_CPU_PLL_CFG_REFDIV_MASK	0x0001f000
+
+#define AR934X_CPU_PLL_CFG_REFDIV_GET(x) 		\
+	(((x) & AR934X_CPU_PLL_CFG_REFDIV_MASK) >> 	\
+	AR934X_CPU_PLL_CFG_REFDIV_LSB)
+
+#define AR934X_CPU_PLL_CFG_REFDIV_SET(x) 		\
+	(((x) << AR934X_CPU_PLL_CFG_REFDIV_LSB) & 	\
+	AR934X_CPU_PLL_CFG_REFDIV_MASK)
+
+#define AR934X_CPU_PLL_CFG_REFDIV_RESET	2
+
+#define AR934X_CPU_PLL_CFG_NINT_MSB	11
+#define AR934X_CPU_PLL_CFG_NINT_LSB	6
+#define AR934X_CPU_PLL_CFG_NINT_MASK	0x00000fc0
+
+#define AR934X_CPU_PLL_CFG_NINT_GET(x)			\
+	(((x) & AR934X_CPU_PLL_CFG_NINT_MASK) >> 	\
+	AR934X_CPU_PLL_CFG_NINT_LSB)
+
+#define AR934X_CPU_PLL_CFG_NINT_SET(x)			\
+	(((x) << AR934X_CPU_PLL_CFG_NINT_LSB) & 	\
+	AR934X_CPU_PLL_CFG_NINT_MASK)
+
+#define AR934X_CPU_PLL_CFG_NINT_RESET	20
+
+#define AR934X_CPU_PLL_CFG_NFRAC_MSB	5
+#define AR934X_CPU_PLL_CFG_NFRAC_LSB	0
+#define AR934X_CPU_PLL_CFG_NFRAC_MASK	0x0000003f
+
+#define AR934X_CPU_PLL_CFG_NFRAC_GET(x)		\
+	(((x) & AR934X_CPU_PLL_CFG_NFRAC_MASK) >> 	\
+	AR934X_CPU_PLL_CFG_NFRAC_LSB)
+
+#define AR934X_CPU_PLL_CFG_NFRAC_SET(x)		\
+	(((x) << AR934X_CPU_PLL_CFG_NFRAC_LSB) & 	\
+	AR934X_CPU_PLL_CFG_NFRAC_MASK)
+
+#define AR934X_DDR_PLL_CFG_REFDIV_MSB	20
+#define AR934X_DDR_PLL_CFG_REFDIV_LSB	16
+#define AR934X_DDR_PLL_CFG_REFDIV_MASK	0x001f0000
+
+#define AR934X_DDR_PLL_CFG_REFDIV_GET(x) 		\
+	(((x) & AR934X_DDR_PLL_CFG_REFDIV_MASK) >> 	\
+	AR934X_DDR_PLL_CFG_REFDIV_LSB)
+
+#define AR934X_DDR_PLL_CFG_REFDIV_SET(x) 		\
+	(((x) << AR934X_DDR_PLL_CFG_REFDIV_LSB) &	\
+	AR934X_DDR_PLL_CFG_REFDIV_MASK)
+
+#define AR934X_DDR_PLL_CFG_REFDIV_RESET	2
+
+#define AR934X_DDR_PLL_CFG_NINT_MSB	15
+#define AR934X_DDR_PLL_CFG_NINT_LSB	10
+#define AR934X_DDR_PLL_CFG_NINT_MASK	0x0000fc00
+
+#define AR934X_DDR_PLL_CFG_NINT_GET(x)			\
+	(((x) & AR934X_DDR_PLL_CFG_NINT_MASK) >> 	\
+	AR934X_DDR_PLL_CFG_NINT_LSB)
+
+#define AR934X_DDR_PLL_CFG_NINT_SET(x)			\
+	(((x) << AR934X_DDR_PLL_CFG_NINT_LSB) &		\
+	AR934X_DDR_PLL_CFG_NINT_MASK)
+
+#define AR934X_DDR_PLL_CFG_NINT_RESET	20
+
+#define AR934X_DDR_PLL_CFG_NFRAC_MSB	9
+#define AR934X_DDR_PLL_CFG_NFRAC_LSB	0
+#define AR934X_DDR_PLL_CFG_NFRAC_MASK	0x000003ff
+
+#define AR934X_DDR_PLL_CFG_NFRAC_GET(x)		\
+	(((x) & AR934X_DDR_PLL_CFG_NFRAC_MASK) >> 	\
+	AR934X_DDR_PLL_CFG_NFRAC_LSB)
+
+#define AR934X_DDR_PLL_CFG_NFRAC_SET(x)		\
+	(((x) << AR934X_DDR_PLL_CFG_NFRAC_LSB) & 	\
+	AR934X_DDR_PLL_CFG_NFRAC_MASK)
+
+#define AR934X_DDR_PLL_CFG_NFRAC_RESET	512
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MSB	19
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_LSB	15
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MASK	0x000f8000
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_GET(x)		\
+	(((x) & AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MASK) >>	\
+	AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_LSB)
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_SET(x)		\
+	(((x) << AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_LSB) & 	\
+	AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MASK)
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHB_POST_DIV_RESET		0
+
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MSB	14
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_LSB	10
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MASK	0x00007c00
+
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_GET(x)		\
+	(((x) & AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MASK) >> 	\
+	AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_LSB)
+
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_SET(x)		\
+	(((x) << AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_LSB) & 	\
+	AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MASK)
+
+#define AR934X_CPU_DDR_CLK_CTRL_DDR_POST_DIV_RESET 	0
+
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MSB	9
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_LSB	5
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MASK	0x000003e0
+
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_GET(x)		\
+	(((x) & AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MASK) >> 	\
+	AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_LSB)
+
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_SET(x)		\
+	(((x) << AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_LSB) & 	\
+	AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MASK)
+
+#define AR934X_CPU_DDR_CLK_CTRL_CPU_POST_DIV_RESET	0
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_MSB	24
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_LSB	24
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_MASK	0x01000000
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_GET(x) 	\
+	(((x) & AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_MASK) >> \
+	AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_LSB)
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_SET(x) 	\
+	(((x) << AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_LSB) & \
+	AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_MASK)
+
+#define AR934X_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL_RESET	1
+
+extern void __iomem *ar71xx_pll_base;
+
+static inline void ar71xx_pll_wr(unsigned reg, u32 val)
+{
+	__raw_writel(val, ar71xx_pll_base + reg);
+}
+
+static inline u32 ar71xx_pll_rr(unsigned reg)
+{
+	return __raw_readl(ar71xx_pll_base + reg);
+}
+
+/*
+ * USB_CONFIG block
+ */
+#define USB_CTRL_REG_FLADJ	0x00
+#define USB_CTRL_REG_CONFIG	0x04
+
+extern void __iomem *ar71xx_usb_ctrl_base;
+
+static inline void ar71xx_usb_ctrl_wr(unsigned reg, u32 val)
+{
+	__raw_writel(val, ar71xx_usb_ctrl_base + reg);
+}
+
+static inline u32 ar71xx_usb_ctrl_rr(unsigned reg)
+{
+	return __raw_readl(ar71xx_usb_ctrl_base + reg);
+}
+
+/*
+ * GPIO block
+ */
+#define GPIO_REG_OE		0x00
+#define GPIO_REG_IN		0x04
+#define GPIO_REG_OUT		0x08
+#define GPIO_REG_SET		0x0c
+#define GPIO_REG_CLEAR		0x10
+#define GPIO_REG_INT_MODE	0x14
+#define GPIO_REG_INT_TYPE	0x18
+#define GPIO_REG_INT_POLARITY	0x1c
+#define GPIO_REG_INT_PENDING	0x20
+#define GPIO_REG_INT_ENABLE	0x24
+#define GPIO_REG_FUNC		0x28
+
+#define AR71XX_GPIO_FUNC_STEREO_EN	BIT(17)
+#define AR71XX_GPIO_FUNC_SLIC_EN	BIT(16)
+#define AR71XX_GPIO_FUNC_SPI_CS2_EN	BIT(13)
+#define AR71XX_GPIO_FUNC_SPI_CS1_EN	BIT(12)
+#define AR71XX_GPIO_FUNC_UART_EN	BIT(8)
+#define AR71XX_GPIO_FUNC_USB_OC_EN	BIT(4)
+#define AR71XX_GPIO_FUNC_USB_CLK_EN	BIT(0)
+
+#define AR71XX_GPIO_COUNT	16
+
+#define AR724X_GPIO_FUNC_GE0_MII_CLK_EN		BIT(19)
+#define AR724X_GPIO_FUNC_SPI_EN			BIT(18)
+#define AR724X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
+#define AR724X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
+#define AR724X_GPIO_FUNC_CLK_OBS5_EN		BIT(12)
+#define AR724X_GPIO_FUNC_CLK_OBS4_EN		BIT(11)
+#define AR724X_GPIO_FUNC_CLK_OBS3_EN		BIT(10)
+#define AR724X_GPIO_FUNC_CLK_OBS2_EN		BIT(9)
+#define AR724X_GPIO_FUNC_CLK_OBS1_EN		BIT(8)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
+#define AR724X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
+#define AR724X_GPIO_FUNC_UART_EN		BIT(1)
+#define AR724X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
+
+#define AR724X_GPIO_COUNT	18
+
+#define AR91XX_GPIO_FUNC_WMAC_LED_EN	BIT(22)
+#define AR91XX_GPIO_FUNC_EXP_PORT_CS_EN	BIT(21)
+#define AR91XX_GPIO_FUNC_I2S_REFCLKEN	BIT(20)
+#define AR91XX_GPIO_FUNC_I2S_MCKEN	BIT(19)
+#define AR91XX_GPIO_FUNC_I2S1_EN	BIT(18)
+#define AR91XX_GPIO_FUNC_I2S0_EN	BIT(17)
+#define AR91XX_GPIO_FUNC_SLIC_EN	BIT(16)
+#define AR91XX_GPIO_FUNC_UART_RTSCTS_EN	BIT(9)
+#define AR91XX_GPIO_FUNC_UART_EN	BIT(8)
+#define AR91XX_GPIO_FUNC_USB_CLK_EN	BIT(4)
+
+#define AR91XX_GPIO_COUNT	22
+
+#define AR933X_GPIO_COUNT	30
+
+#define AR934X_GPIO_FUNC_SPI_CS_1_EN	BIT(14)
+#define AR934X_GPIO_FUNC_SPI_CS_0_EN	BIT(13)
+
+#define AR934X_GPIO_COUNT		32
+#define AR934X_GPIO_FUNC_DDR_DQOE_EN	BIT(17)
+
+extern void __iomem *ar71xx_gpio_base;
+
+static inline void ar71xx_gpio_wr(unsigned reg, u32 value)
+{
+	__raw_writel(value, ar71xx_gpio_base + reg);
+}
+
+static inline u32 ar71xx_gpio_rr(unsigned reg)
+{
+	return __raw_readl(ar71xx_gpio_base + reg);
+}
+
+void ar71xx_gpio_init(void) __init;
+void ar71xx_gpio_function_enable(u32 mask);
+void ar71xx_gpio_function_disable(u32 mask);
+void ar71xx_gpio_function_setup(u32 set, u32 clear);
+
+/*
+ * DDR_CTRL block
+ */
+#define AR71XX_DDR_REG_PCI_WIN0		0x7c
+#define AR71XX_DDR_REG_PCI_WIN1		0x80
+#define AR71XX_DDR_REG_PCI_WIN2		0x84
+#define AR71XX_DDR_REG_PCI_WIN3		0x88
+#define AR71XX_DDR_REG_PCI_WIN4		0x8c
+#define AR71XX_DDR_REG_PCI_WIN5		0x90
+#define AR71XX_DDR_REG_PCI_WIN6		0x94
+#define AR71XX_DDR_REG_PCI_WIN7		0x98
+#define AR71XX_DDR_REG_FLUSH_GE0	0x9c
+#define AR71XX_DDR_REG_FLUSH_GE1	0xa0
+#define AR71XX_DDR_REG_FLUSH_USB	0xa4
+#define AR71XX_DDR_REG_FLUSH_PCI	0xa8
+
+#define AR724X_DDR_REG_FLUSH_GE0	0x7c
+#define AR724X_DDR_REG_FLUSH_GE1	0x80
+#define AR724X_DDR_REG_FLUSH_USB	0x84
+#define AR724X_DDR_REG_FLUSH_PCIE	0x88
+
+#define AR91XX_DDR_REG_FLUSH_GE0	0x7c
+#define AR91XX_DDR_REG_FLUSH_GE1	0x80
+#define AR91XX_DDR_REG_FLUSH_USB	0x84
+#define AR91XX_DDR_REG_FLUSH_WMAC	0x88
+
+#define AR933X_DDR_REG_FLUSH_GE0	0x7c
+#define AR933X_DDR_REG_FLUSH_GE1	0x80
+#define AR933X_DDR_REG_FLUSH_USB	0x84
+#define AR933X_DDR_REG_FLUSH_WMAC	0x88
+
+#define AR934X_DDR_REG_FLUSH_GE0	0x9c
+#define AR934X_DDR_REG_FLUSH_GE1	0xa0
+#define AR934X_DDR_REG_FLUSH_USB	0xa4
+#define AR934X_DDR_REG_FLUSH_PCIE	0xa8
+
+
+#define PCI_WIN0_OFFS	0x10000000
+#define PCI_WIN1_OFFS	0x11000000
+#define PCI_WIN2_OFFS	0x12000000
+#define PCI_WIN3_OFFS	0x13000000
+#define PCI_WIN4_OFFS	0x14000000
+#define PCI_WIN5_OFFS	0x15000000
+#define PCI_WIN6_OFFS	0x16000000
+#define PCI_WIN7_OFFS	0x07000000
+
+extern void __iomem *ar71xx_ddr_base;
+
+static inline void ar71xx_ddr_wr(unsigned reg, u32 val)
+{
+	__raw_writel(val, ar71xx_ddr_base + reg);
+}
+
+static inline u32 ar71xx_ddr_rr(unsigned reg)
+{
+	return __raw_readl(ar71xx_ddr_base + reg);
+}
+
+void ar71xx_ddr_flush(u32 reg);
+
+/*
+ * PCI block
+ */
+#define AR71XX_PCI_CFG_BASE	(AR71XX_PCI_MEM_BASE + PCI_WIN7_OFFS + 0x10000)
+#define AR71XX_PCI_CFG_SIZE	0x100
+
+#define PCI_REG_CRP_AD_CBE	0x00
+#define PCI_REG_CRP_WRDATA	0x04
+#define PCI_REG_CRP_RDDATA	0x08
+#define PCI_REG_CFG_AD		0x0c
+#define PCI_REG_CFG_CBE		0x10
+#define PCI_REG_CFG_WRDATA	0x14
+#define PCI_REG_CFG_RDDATA	0x18
+#define PCI_REG_PCI_ERR		0x1c
+#define PCI_REG_PCI_ERR_ADDR	0x20
+#define PCI_REG_AHB_ERR		0x24
+#define PCI_REG_AHB_ERR_ADDR	0x28
+
+#define PCI_CRP_CMD_WRITE	0x00010000
+#define PCI_CRP_CMD_READ	0x00000000
+#define PCI_CFG_CMD_READ	0x0000000a
+#define PCI_CFG_CMD_WRITE	0x0000000b
+
+#define PCI_IDSEL_ADL_START	17
+
+#define AR724X_PCI_CFG_BASE	(AR71XX_PCI_MEM_BASE + 0x4000000)
+#define AR724X_PCI_CFG_SIZE	0x1000
+
+#define AR724X_PCI_REG_APP		0x00
+#define AR724X_PCI_REG_RESET		0x18
+#define AR724X_PCI_REG_INT_STATUS	0x4c
+#define AR724X_PCI_REG_INT_MASK		0x50
+
+#define AR724X_PCI_APP_LTSSM_ENABLE	BIT(0)
+#define AR724X_PCI_RESET_LINK_UP	BIT(0)
+
+#define AR724X_PCI_INT_DEV0		BIT(14)
+
+/*
+ * RESET block
+ */
+#define AR71XX_RESET_REG_TIMER			0x00
+#define AR71XX_RESET_REG_TIMER_RELOAD		0x04
+#define AR71XX_RESET_REG_WDOG_CTRL		0x08
+#define AR71XX_RESET_REG_WDOG			0x0c
+#define AR71XX_RESET_REG_MISC_INT_STATUS	0x10
+#define AR71XX_RESET_REG_MISC_INT_ENABLE	0x14
+#define AR71XX_RESET_REG_PCI_INT_STATUS		0x18
+#define AR71XX_RESET_REG_PCI_INT_ENABLE		0x1c
+#define AR71XX_RESET_REG_GLOBAL_INT_STATUS	0x20
+#define AR71XX_RESET_REG_RESET_MODULE		0x24
+#define AR71XX_RESET_REG_PERFC_CTRL		0x2c
+#define AR71XX_RESET_REG_PERFC0			0x30
+#define AR71XX_RESET_REG_PERFC1			0x34
+#define AR71XX_RESET_REG_REV_ID			0x90
+
+#define AR91XX_RESET_REG_GLOBAL_INT_STATUS	0x18
+#define AR91XX_RESET_REG_RESET_MODULE		0x1c
+#define AR91XX_RESET_REG_PERF_CTRL		0x20
+#define AR91XX_RESET_REG_PERFC0			0x24
+#define AR91XX_RESET_REG_PERFC1			0x28
+
+#define AR724X_RESET_REG_RESET_MODULE		0x1c
+
+#define AR933X_RESET_REG_RESET_MODULE		0x1c
+#define AR933X_RESET_REG_BOOTSTRAP		0xac
+#define AR933X_BOOTSTRAP_EEPBUSY		BIT(4)
+#define AR933X_BOOTSTRAP_REF_CLK_40		BIT(0)
+
+#define AR934X_RESET_REG_RESET_MODULE		0x1c
+#define AR934X_RESET_REG_BOOTSTRAP		0xb0
+/* 0 - 25MHz   1 - 40 MHz */
+#define AR934X_REF_CLK_40			(1 << 4)
+
+#define WDOG_CTRL_LAST_RESET		BIT(31)
+#define WDOG_CTRL_ACTION_MASK		3
+#define WDOG_CTRL_ACTION_NONE		0	/* no action */
+#define WDOG_CTRL_ACTION_GPI		1	/* general purpose interrupt */
+#define WDOG_CTRL_ACTION_NMI		2	/* NMI */
+#define WDOG_CTRL_ACTION_FCR		3	/* full chip reset */
+
+#define MISC_INT_ENET_LINK		BIT(12)
+#define MISC_INT_DDR_PERF		BIT(11)
+#define MISC_INT_TIMER4		BIT(10)
+#define MISC_INT_TIMER3		BIT(9)
+#define MISC_INT_TIMER2		BIT(8)
+#define MISC_INT_DMA			BIT(7)
+#define MISC_INT_OHCI			BIT(6)
+#define MISC_INT_PERFC			BIT(5)
+#define MISC_INT_WDOG			BIT(4)
+#define MISC_INT_UART			BIT(3)
+#define MISC_INT_GPIO			BIT(2)
+#define MISC_INT_ERROR			BIT(1)
+#define MISC_INT_TIMER			BIT(0)
+
+#define PCI_INT_CORE			BIT(4)
+#define PCI_INT_DEV2			BIT(2)
+#define PCI_INT_DEV1			BIT(1)
+#define PCI_INT_DEV0			BIT(0)
+
+#define RESET_MODULE_EXTERNAL		BIT(28)
+#define RESET_MODULE_FULL_CHIP		BIT(24)
+#define RESET_MODULE_AMBA2WMAC		BIT(22)
+#define RESET_MODULE_CPU_NMI		BIT(21)
+#define RESET_MODULE_CPU_COLD		BIT(20)
+#define RESET_MODULE_DMA		BIT(19)
+#define RESET_MODULE_SLIC		BIT(18)
+#define RESET_MODULE_STEREO		BIT(17)
+#define RESET_MODULE_DDR		BIT(16)
+#define RESET_MODULE_GE1_MAC		BIT(13)
+#define RESET_MODULE_GE1_PHY		BIT(12)
+#define RESET_MODULE_USBSUS_OVERRIDE	BIT(10)
+#define RESET_MODULE_GE0_MAC		BIT(9)
+#define RESET_MODULE_GE0_PHY		BIT(8)
+#define RESET_MODULE_USB_OHCI_DLL	BIT(6)
+#define RESET_MODULE_USB_HOST		BIT(5)
+#define RESET_MODULE_USB_PHY		BIT(4)
+#define RESET_MODULE_USB_OHCI_DLL_7240	BIT(3)
+#define RESET_MODULE_PCI_BUS		BIT(1)
+#define RESET_MODULE_PCI_CORE		BIT(0)
+
+#define AR724X_RESET_GE1_MDIO		BIT(23)
+#define AR724X_RESET_GE0_MDIO		BIT(22)
+#define AR724X_RESET_PCIE_PHY_SERIAL	BIT(10)
+#define AR724X_RESET_PCIE_PHY		BIT(7)
+#define AR724X_RESET_PCIE		BIT(6)
+#define AR724X_RESET_USB_HOST		BIT(5)
+#define AR724X_RESET_USB_PHY		BIT(4)
+#define AR724X_RESET_USBSUS_OVERRIDE	BIT(3)
+
+#define AR933X_RESET_WMAC		BIT(11)
+#define AR933X_RESET_GE1_MDIO		BIT(23)
+#define AR933X_RESET_GE0_MDIO		BIT(22)
+#define AR933X_RESET_GE1_MAC		BIT(13)
+#define AR933X_RESET_GE0_MAC		BIT(9)
+
+#define REV_ID_MAJOR_MASK	0xfff0
+#define REV_ID_MAJOR_AR71XX	0x00a0
+#define REV_ID_MAJOR_AR913X	0x00b0
+#define REV_ID_MAJOR_AR7240	0x00c0
+#define REV_ID_MAJOR_AR7241	0x0100
+#define REV_ID_MAJOR_AR7242	0x1100
+#define REV_ID_MAJOR_AR9330	0x0110
+#define REV_ID_MAJOR_AR9331	0x1110
+#define REV_ID_MAJOR_AR9341	0x0120
+#define REV_ID_MAJOR_AR9342	0x1120
+#define REV_ID_MAJOR_AR9344	0x2120
+
+#define AR71XX_REV_ID_MINOR_MASK	0x3
+#define AR71XX_REV_ID_MINOR_AR7130	0x0
+#define AR71XX_REV_ID_MINOR_AR7141	0x1
+#define AR71XX_REV_ID_MINOR_AR7161	0x2
+#define AR71XX_REV_ID_REVISION_MASK	0x3
+#define AR71XX_REV_ID_REVISION_SHIFT	2
+
+#define AR91XX_REV_ID_MINOR_MASK	0x3
+#define AR91XX_REV_ID_MINOR_AR9130	0x0
+#define AR91XX_REV_ID_MINOR_AR9132	0x1
+#define AR91XX_REV_ID_REVISION_MASK	0x3
+#define AR91XX_REV_ID_REVISION_SHIFT	2
+
+#define AR724X_REV_ID_REVISION_MASK	0x3
+
+#define AR933X_REV_ID_REVISION_MASK	0xf
+
+#define AR934X_REV_ID_REVISION_MASK	0xf
+
+extern void __iomem *ar71xx_reset_base;
+
+static inline void ar71xx_reset_wr(unsigned reg, u32 val)
+{
+	__raw_writel(val, ar71xx_reset_base + reg);
+}
+
+static inline u32 ar71xx_reset_rr(unsigned reg)
+{
+	return __raw_readl(ar71xx_reset_base + reg);
+}
+
+void ar71xx_device_stop(u32 mask);
+void ar71xx_device_start(u32 mask);
+int ar71xx_device_stopped(u32 mask);
+
+/*
+ * SPI block
+ */
+#define SPI_REG_FS		0x00	/* Function Select */
+#define SPI_REG_CTRL		0x04	/* SPI Control */
+#define SPI_REG_IOC		0x08	/* SPI I/O Control */
+#define SPI_REG_RDS		0x0c	/* Read Data Shift */
+
+#define SPI_FS_GPIO		BIT(0)	/* Enable GPIO mode */
+
+#define SPI_CTRL_RD		BIT(6)	/* Remap Disable */
+#define SPI_CTRL_DIV_MASK	0x3f
+
+#define SPI_IOC_DO		BIT(0)	/* Data Out pin */
+#define SPI_IOC_CLK		BIT(8)	/* CLK pin */
+#define SPI_IOC_CS(n)		BIT(16 + (n))
+#define SPI_IOC_CS0		SPI_IOC_CS(0)
+#define SPI_IOC_CS1		SPI_IOC_CS(1)
+#define SPI_IOC_CS2		SPI_IOC_CS(2)
+#define SPI_IOC_CS_ALL		(SPI_IOC_CS0 | SPI_IOC_CS1 | SPI_IOC_CS2)
+
+void ar71xx_flash_acquire(void);
+void ar71xx_flash_release(void);
+
+/*
+ * MII_CTRL block
+ */
+#define MII_REG_MII0_CTRL	0x00
+#define MII_REG_MII1_CTRL	0x04
+
+#define MII0_CTRL_IF_GMII	0
+#define MII0_CTRL_IF_MII	1
+#define MII0_CTRL_IF_RGMII	2
+#define MII0_CTRL_IF_RMII	3
+
+#define MII1_CTRL_IF_RGMII	0
+#define MII1_CTRL_IF_RMII	1
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* __ASM_MACH_AR71XX_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/ar91xx_flash.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/ar91xx_flash.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/ar91xx_flash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/ar91xx_flash.h	2011-04-27 12:19:21.867661560 +0200
@@ -0,0 +1,26 @@
+/*
+ *  AR91xx parallel flash driver platform data definitions
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __AR91XX_FLASH_H
+#define __AR91XX_FLASH_H
+
+struct mtd_partition;
+
+struct ar91xx_flash_platform_data {
+	unsigned int		width;
+	u8			is_shared:1;
+#ifdef CONFIG_MTD_PARTITIONS
+	unsigned int		nr_parts;
+	struct mtd_partition	*parts;
+#endif
+};
+
+#endif /* __AR91XX_FLASH_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/ar933x_uart.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/ar933x_uart.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/ar933x_uart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/ar933x_uart.h	2011-08-06 09:32:36.758018150 +0200
@@ -0,0 +1,67 @@
+/*
+ *  Atheros AR933X UART defines
+ *
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __AR933X_UART_H
+#define __AR933X_UART_H
+
+#define AR933X_UART_REGS_SIZE		20
+#define AR933X_UART_FIFO_SIZE		16
+
+#define AR933X_UART_DATA_REG		0x00
+#define AR933X_UART_CS_REG		0x04
+#define AR933X_UART_CLOCK_REG		0x08
+#define AR933X_UART_INT_REG		0x0c
+#define AR933X_UART_INT_EN_REG		0x10
+
+#define AR933X_UART_DATA_TX_RX_MASK	0xff
+#define AR933X_UART_DATA_RX_CSR		BIT(8)
+#define AR933X_UART_DATA_TX_CSR		BIT(9)
+
+#define AR933X_UART_CS_PARITY_S		0
+#define AR933X_UART_CS_PARITY_M		0x3
+#define   AR933X_UART_CS_PARITY_NONE	0
+#define   AR933X_UART_CS_PARITY_ODD	1
+#define   AR933X_UART_CS_PARITY_EVEN	2
+#define AR933X_UART_CS_IF_MODE_S	2
+#define AR933X_UART_CS_IF_MODE_M	0x3
+#define   AR933X_UART_CS_IF_MODE_NONE	0
+#define   AR933X_UART_CS_IF_MODE_DTE	1
+#define   AR933X_UART_CS_IF_MODE_DCE	2
+#define AR933X_UART_CS_FLOW_CTRL_S	4
+#define AR933X_UART_CS_FLOW_CTRL_M	0x3
+#define AR933X_UART_CS_DMA_EN		BIT(6)
+#define AR933X_UART_CS_TX_READY_ORIDE	BIT(7)
+#define AR933X_UART_CS_RX_READY_ORIDE	BIT(8)
+#define AR933X_UART_CS_TX_READY		BIT(9)
+#define AR933X_UART_CS_RX_BREAK		BIT(10)
+#define AR933X_UART_CS_TX_BREAK		BIT(11)
+#define AR933X_UART_CS_HOST_INT		BIT(12)
+#define AR933X_UART_CS_HOST_INT_EN	BIT(13)
+#define AR933X_UART_CS_TX_BUSY		BIT(14)
+#define AR933X_UART_CS_RX_BUSY		BIT(15)
+
+#define AR933X_UART_CLOCK_STEP_M	0xffff
+#define AR933X_UART_CLOCK_SCALE_M	0xfff
+#define AR933X_UART_CLOCK_SCALE_S	16
+#define AR933X_UART_CLOCK_STEP_M	0xffff
+
+#define AR933X_UART_INT_RX_VALID	BIT(0)
+#define AR933X_UART_INT_TX_READY	BIT(1)
+#define AR933X_UART_INT_RX_FRAMING_ERR	BIT(2)
+#define AR933X_UART_INT_RX_OFLOW_ERR	BIT(3)
+#define AR933X_UART_INT_TX_OFLOW_ERR	BIT(4)
+#define AR933X_UART_INT_RX_PARITY_ERR	BIT(5)
+#define AR933X_UART_INT_RX_BREAK_ON	BIT(6)
+#define AR933X_UART_INT_RX_BREAK_OFF	BIT(7)
+#define AR933X_UART_INT_RX_FULL		BIT(8)
+#define AR933X_UART_INT_TX_EMPTY	BIT(9)
+#define AR933X_UART_INT_ALLINTS		0x3ff
+
+#endif /* __AR933X_UART_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/ar933x_uart_platform.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/ar933x_uart_platform.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/ar933x_uart_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/ar933x_uart_platform.h	2011-08-06 09:32:36.758018150 +0200
@@ -0,0 +1,18 @@
+/*
+ *  Platform data definition for Atheros AR933X UART
+ *
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _AR933X_UART_PLATFORM_H
+#define _AR933X_UART_PLATFORM_H
+
+struct ar933x_uart_platform_data {
+	unsigned	uartclk;
+};
+
+#endif /* _AR933X_UART_PLATFORM_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/cpu-feature-overrides.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/cpu-feature-overrides.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/cpu-feature-overrides.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/cpu-feature-overrides.h	2011-04-27 12:19:21.877661867 +0200
@@ -0,0 +1,56 @@
+/*
+ *  Atheros AR71xx specific CPU feature overrides
+ *
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This file was derived from: include/asm-mips/cpu-features.h
+ *	Copyright (C) 2003, 2004 Ralf Baechle
+ *	Copyright (C) 2004 Maciej W. Rozycki
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+#ifndef __ASM_MACH_AR71XX_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_AR71XX_CPU_FEATURE_OVERRIDES_H
+
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_3k_cache	0
+#define cpu_has_4k_cache	1
+#define cpu_has_tx39_cache	0
+#define cpu_has_sb1_cache	0
+#define cpu_has_fpu		0
+#define cpu_has_32fpr		0
+#define cpu_has_counter		1
+#define cpu_has_watch		1
+#define cpu_has_divec		1
+
+#define cpu_has_prefetch	1
+#define cpu_has_ejtag		1
+#define cpu_has_llsc		1
+
+#define cpu_has_mips16		1
+#define cpu_has_mdmx		0
+#define cpu_has_mips3d		0
+#define cpu_has_smartmips	0
+
+#define cpu_has_mips32r1	1
+#define cpu_has_mips32r2	1
+#define cpu_has_mips64r1	0
+#define cpu_has_mips64r2	0
+
+#define cpu_has_dsp		0
+#define cpu_has_mipsmt		0
+
+#define cpu_has_64bits		0
+#define cpu_has_64bit_zero_reg	0
+#define cpu_has_64bit_gp_regs	0
+#define cpu_has_64bit_addresses	0
+
+#define cpu_dcache_line_size()	32
+#define cpu_icache_line_size()	32
+
+#endif /* __ASM_MACH_AR71XX_CPU_FEATURE_OVERRIDES_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/gpio.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/gpio.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/gpio.h	2011-04-27 12:19:21.877661867 +0200
@@ -0,0 +1,53 @@
+/*
+ *  Atheros AR71xx GPIO API definitions
+ *
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_MACH_AR71XX_GPIO_H
+#define __ASM_MACH_AR71XX_GPIO_H
+
+#define ARCH_NR_GPIOS	64
+#include <asm-generic/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+extern unsigned long ar71xx_gpio_count;
+extern void __ar71xx_gpio_set_value(unsigned gpio, int value);
+extern int __ar71xx_gpio_get_value(unsigned gpio);
+
+static inline int gpio_to_irq(unsigned gpio)
+{
+	return AR71XX_GPIO_IRQ(gpio);
+}
+
+static inline int irq_to_gpio(unsigned irq)
+{
+	return irq - AR71XX_GPIO_IRQ_BASE;
+}
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	if (gpio < ar71xx_gpio_count)
+		return __ar71xx_gpio_get_value(gpio);
+
+	return __gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	if (gpio < ar71xx_gpio_count)
+		__ar71xx_gpio_set_value(gpio, value);
+	else
+		__gpio_set_value(gpio, value);
+}
+
+#define gpio_cansleep	__gpio_cansleep
+
+#endif /* __ASM_MACH_AR71XX_GPIO_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/irq.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/irq.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/irq.h	2011-04-27 12:19:21.877661867 +0200
@@ -0,0 +1,17 @@
+/*
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#ifndef __ASM_MACH_AR71XX_IRQ_H
+#define __ASM_MACH_AR71XX_IRQ_H
+
+#define MIPS_CPU_IRQ_BASE	0
+#define NR_IRQS			80
+
+#include_next <irq.h>
+
+#endif /* __ASM_MACH_AR71XX_IRQ_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/kernel-entry-init.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/kernel-entry-init.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/kernel-entry-init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/kernel-entry-init.h	2011-04-27 12:19:21.877661867 +0200
@@ -0,0 +1,32 @@
+/*
+ *  Atheros AR71xx specific kernel entry setup
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+#ifndef __ASM_MACH_AR71XX_KERNEL_ENTRY_H
+#define __ASM_MACH_AR71XX_KERNEL_ENTRY_H
+
+	/*
+	 * Some bootloaders set the 'Kseg0 coherency algorithm' to
+	 * 'Cacheable, noncoherent, write-through, no write allocate'
+	 * and this cause performance issues. Let's go and change it to
+	 * 'Cacheable, noncoherent, write-back, write allocate'
+	 */
+	.macro	kernel_entry_setup
+	mfc0	t0, CP0_CONFIG
+	li	t1, ~CONF_CM_CMASK
+	and	t0, t1
+	ori	t0, CONF_CM_CACHABLE_NONCOHERENT
+	mtc0	t0, CP0_CONFIG
+	nop
+	.endm
+
+	.macro	smp_slave_setup
+	.endm
+
+#endif /* __ASM_MACH_AR71XX_KERNEL_ENTRY_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/mach-rb750.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/mach-rb750.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/mach-rb750.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/mach-rb750.h	2011-04-27 12:19:21.877661867 +0200
@@ -0,0 +1,66 @@
+/*
+ *  MikroTik RouterBOARD 750 definitions
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#ifndef _MACH_RB750_H
+#define _MACH_RB750_H
+
+#include <linux/bitops.h>
+
+#define RB750_GPIO_LVC573_LE	0	/* Latch enable on LVC573 */
+#define RB750_GPIO_NAND_IO0	1	/* NAND I/O 0 */
+#define RB750_GPIO_NAND_IO1	2	/* NAND I/O 1 */
+#define RB750_GPIO_NAND_IO2	3	/* NAND I/O 2 */
+#define RB750_GPIO_NAND_IO3	4	/* NAND I/O 3 */
+#define RB750_GPIO_NAND_IO4	5	/* NAND I/O 4 */
+#define RB750_GPIO_NAND_IO5	6	/* NAND I/O 5 */
+#define RB750_GPIO_NAND_IO6	7	/* NAND I/O 6 */
+#define RB750_GPIO_NAND_IO7	8	/* NAND I/O 7 */
+#define RB750_GPIO_NAND_NCE	11	/* NAND Chip Enable (active low) */
+#define RB750_GPIO_NAND_RDY	12	/* NAND Ready */
+#define RB750_GPIO_NAND_CLE	14	/* NAND Command Latch Enable */
+#define RB750_GPIO_NAND_ALE	15	/* NAND Address Latch Enable */
+#define RB750_GPIO_NAND_NRE	16	/* NAND Read Enable (active low) */
+#define RB750_GPIO_NAND_NWE	17	/* NAND Write Enable (active low) */
+
+#define RB750_GPIO_BTN_RESET	1
+#define RB750_GPIO_SPI_CS0	2
+#define RB750_GPIO_LED_ACT	12
+#define RB750_GPIO_LED_PORT1	13
+#define RB750_GPIO_LED_PORT2	14
+#define RB750_GPIO_LED_PORT3	15
+#define RB750_GPIO_LED_PORT4	16
+#define RB750_GPIO_LED_PORT5	17
+
+#define RB750_LED_ACT		BIT(RB750_GPIO_LED_ACT)
+#define RB750_LED_PORT1		BIT(RB750_GPIO_LED_PORT1)
+#define RB750_LED_PORT2		BIT(RB750_GPIO_LED_PORT2)
+#define RB750_LED_PORT3		BIT(RB750_GPIO_LED_PORT3)
+#define RB750_LED_PORT4		BIT(RB750_GPIO_LED_PORT4)
+#define RB750_LED_PORT5		BIT(RB750_GPIO_LED_PORT5)
+
+#define RB750_LVC573_LE		BIT(RB750_GPIO_LVC573_LE)
+
+#define RB750_LED_BITS	(RB750_LED_PORT1 | RB750_LED_PORT2 | RB750_LED_PORT3 | \
+			 RB750_LED_PORT4 | RB750_LED_PORT5 | RB750_LED_ACT)
+
+struct rb750_led_data {
+	char	*name;
+	char	*default_trigger;
+	u32	mask;
+	int	active_low;
+};
+
+struct rb750_led_platform_data {
+	int			num_leds;
+	struct rb750_led_data	*leds;
+};
+
+int rb750_latch_change(u32 mask_clr, u32 mask_set);
+
+#endif /* _MACH_RB750_H */
\ No newline at end of file
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/mangle-port.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/mangle-port.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/mangle-port.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/mangle-port.h	2011-04-27 12:19:21.877661867 +0200
@@ -0,0 +1,45 @@
+/*
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This file was derived from: inlude/asm-mips/mach-generic/mangle-port.h
+ *      Copyright (C) 2003, 2004 Ralf Baechle
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_AR71XX_MANGLE_PORT_H
+#define __ASM_MACH_AR71XX_MANGLE_PORT_H
+
+#define __swizzle_addr_b(port)	((port) ^ 3)
+#define __swizzle_addr_w(port)	((port) ^ 2)
+#define __swizzle_addr_l(port)	(port)
+#define __swizzle_addr_q(port)	(port)
+
+#if defined(CONFIG_SWAP_IO_SPACE)
+
+# define ioswabb(a, x)           (x)
+# define __mem_ioswabb(a, x)     (x)
+# define ioswabw(a, x)           le16_to_cpu(x)
+# define __mem_ioswabw(a, x)     (x)
+# define ioswabl(a, x)           le32_to_cpu(x)
+# define __mem_ioswabl(a, x)     (x)
+# define ioswabq(a, x)           le64_to_cpu(x)
+# define __mem_ioswabq(a, x)     (x)
+
+#else
+
+# define ioswabb(a, x)           (x)
+# define __mem_ioswabb(a, x)     (x)
+# define ioswabw(a, x)           (x)
+# define __mem_ioswabw(a, x)     cpu_to_le16(x)
+# define ioswabl(a, x)           (x)
+# define __mem_ioswabl(a, x)     cpu_to_le32(x)
+# define ioswabq(a, x)           (x)
+# define __mem_ioswabq(a, x)     cpu_to_le64(x)
+
+#endif
+
+#endif /* __ASM_MACH_AR71XX_MANGLE_PORT_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/pci.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/pci.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/pci.h	2011-04-27 12:19:21.877661867 +0200
@@ -0,0 +1,46 @@
+/*
+ *  Atheros AR71xx SoC specific PCI definitions
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_AR71XX_PCI_H
+#define __ASM_MACH_AR71XX_PCI_H
+
+struct pci_dev;
+
+struct ar71xx_pci_irq {
+	int	irq;
+	u8	slot;
+	u8	pin;
+};
+
+#ifdef CONFIG_PCI
+extern int (*ar71xx_pci_plat_dev_init)(struct pci_dev *dev);
+extern unsigned ar71xx_pci_nr_irqs __initdata;
+extern struct ar71xx_pci_irq *ar71xx_pci_irq_map __initdata;
+
+int ar71xx_pcibios_map_irq(const struct pci_dev *dev,
+			   uint8_t slot, uint8_t pin) __init;
+int ar71xx_pcibios_init(void) __init;
+
+int ar71xx_pci_be_handler(int is_fixup);
+
+int ar724x_pcibios_map_irq(const struct pci_dev *dev,
+			   uint8_t slot, uint8_t pin) __init;
+int ar724x_pcibios_init(void) __init;
+
+int ar71xx_pci_init(unsigned nr_irqs, struct ar71xx_pci_irq *map) __init;
+#else
+static inline int ar71xx_pci_init(unsigned nr_irqs, struct ar71xx_pci_irq *map)
+{
+	return 0;
+}
+#endif
+
+#endif /* __ASM_MACH_AR71XX_PCI_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/platform.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/platform.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/platform.h	2011-08-22 07:40:11.890481646 +0200
@@ -0,0 +1,63 @@
+/*
+ *  Atheros AR71xx SoC specific platform data definitions
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_AR71XX_PLATFORM_H
+#define __ASM_MACH_AR71XX_PLATFORM_H
+
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+#include <linux/spi/spi.h>
+
+struct ag71xx_platform_data {
+	phy_interface_t	phy_if_mode;
+	u32		phy_mask;
+	int		speed;
+	int		duplex;
+	u32		reset_bit;
+	u32		mii_if;
+	u8		mac_addr[ETH_ALEN];
+	struct device	*mii_bus_dev;
+
+	u8		has_gbit:1;
+	u8		is_ar91xx:1;
+	u8		is_ar7240:1;
+	u8		is_ar724x:1;
+	u8		has_ar8216:1;
+	u8		has_ar7240_switch:1;
+
+	void		(*ddr_flush)(void);
+	void		(*set_pll)(int speed);
+
+	u32		fifo_cfg1;
+	u32		fifo_cfg2;
+	u32		fifo_cfg3;
+};
+
+struct ag71xx_mdio_platform_data {
+	u32		phy_mask;
+	int		is_ar7240;
+};
+
+struct ar71xx_ehci_platform_data {
+	u8		is_ar91xx;
+};
+
+struct ar71xx_spi_platform_data {
+	unsigned	bus_num;
+	unsigned	num_chipselect;
+	u32		(*get_ioc_base)(u8 chip_select, int cs_high, int is_on);
+};
+
+#define AR71XX_SPI_CS_INACTIVE	0
+#define AR71XX_SPI_CS_ACTIVE	1
+
+#endif /* __ASM_MACH_AR71XX_PLATFORM_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/rb4xx_cpld.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/rb4xx_cpld.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/rb4xx_cpld.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/rb4xx_cpld.h	2011-04-27 12:19:21.867661560 +0200
@@ -0,0 +1,48 @@
+/*
+ * SPI driver definitions for the CPLD chip on the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#define CPLD_GPIO_nLED1		0
+#define CPLD_GPIO_nLED2		1
+#define CPLD_GPIO_nLED3		2
+#define CPLD_GPIO_nLED4		3
+#define CPLD_GPIO_FAN		4
+#define CPLD_GPIO_ALE		5
+#define CPLD_GPIO_CLE		6
+#define CPLD_GPIO_nCE		7
+#define CPLD_GPIO_nLED5		8
+
+#define CPLD_NUM_GPIOS		9
+
+#define CPLD_CFG_nLED1		BIT(CPLD_GPIO_nLED1)
+#define CPLD_CFG_nLED2		BIT(CPLD_GPIO_nLED2)
+#define CPLD_CFG_nLED3		BIT(CPLD_GPIO_nLED3)
+#define CPLD_CFG_nLED4		BIT(CPLD_GPIO_nLED4)
+#define CPLD_CFG_FAN		BIT(CPLD_GPIO_FAN)
+#define CPLD_CFG_ALE		BIT(CPLD_GPIO_ALE)
+#define CPLD_CFG_CLE		BIT(CPLD_GPIO_CLE)
+#define CPLD_CFG_nCE		BIT(CPLD_GPIO_nCE)
+#define CPLD_CFG_nLED5		BIT(CPLD_GPIO_nLED5)
+
+struct rb4xx_cpld_platform_data {
+	unsigned	gpio_base;
+};
+
+extern int rb4xx_cpld_change_cfg(unsigned mask, unsigned value);
+extern int rb4xx_cpld_read(unsigned char *rx_buf,
+			   const unsigned char *verify_buf,
+			   unsigned cnt);
+extern int rb4xx_cpld_read_from(unsigned addr,
+				unsigned char *rx_buf,
+				const unsigned char *verify_buf,
+				unsigned cnt);
+extern int rb4xx_cpld_write(const unsigned char *buf, unsigned count);
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/war.h linux-2.6.39/arch/mips/include/asm/mach-ar71xx/war.h
--- linux-2.6.39.orig/arch/mips/include/asm/mach-ar71xx/war.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/include/asm/mach-ar71xx/war.h	2011-04-27 12:19:21.867661560 +0200
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MACH_AR71XX_WAR_H
+#define __ASM_MACH_AR71XX_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MACH_AR71XX_WAR_H */
diff -Nur linux-2.6.39.orig/arch/mips/include/asm/time.h linux-2.6.39/arch/mips/include/asm/time.h
--- linux-2.6.39.orig/arch/mips/include/asm/time.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/arch/mips/include/asm/time.h	2011-08-24 05:53:05.239228886 +0200
@@ -52,6 +52,7 @@
  */
 #ifdef CONFIG_CEVT_R4K_LIB
 extern unsigned int __weak get_c0_compare_int(void);
+extern unsigned int __weak get_c0_compare_irq(void);
 extern int r4k_clockevent_init(void);
 #endif
 
diff -Nur linux-2.6.39.orig/arch/mips/Kconfig linux-2.6.39/arch/mips/Kconfig
--- linux-2.6.39.orig/arch/mips/Kconfig	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/arch/mips/Kconfig	2011-08-24 02:42:39.969240338 +0200
@@ -84,6 +84,23 @@
 	help
 	  Support for the Atheros AR71XX/AR724X/AR913X SoCs.
 
+config ATHEROS_AR71XX
+	bool "Atheros AR71xx based boards"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select ARCH_REQUIRE_GPIOLIB
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_HAS_EARLY_PRINTK
+	select MIPS_MACHINE
+	help
+	  Support for Atheros AR71xx based boards.
+
 config BCM47XX
 	bool "Broadcom BCM47XX based boards"
 	select CEVT_R4K
@@ -739,6 +756,7 @@
 endchoice
 
 source "arch/mips/alchemy/Kconfig"
+source "arch/mips/ar71xx/Kconfig"
 source "arch/mips/ath79/Kconfig"
 source "arch/mips/bcm63xx/Kconfig"
 source "arch/mips/jazz/Kconfig"
@@ -907,6 +925,9 @@
 config MIPS_DISABLE_OBSOLETE_IDE
 	bool
 
+config MYLOADER
+	bool
+
 config SYNC_R4K
 	bool
 
diff -Nur linux-2.6.39.orig/arch/mips/Kconfig.orig linux-2.6.39/arch/mips/Kconfig.orig
--- linux-2.6.39.orig/arch/mips/Kconfig.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/Kconfig.orig	2011-08-22 16:21:32.077979816 +0200
@@ -0,0 +1,2472 @@
+config MIPS
+	bool
+	default y
+	select HAVE_GENERIC_DMA_COHERENT
+	select HAVE_IDE
+	select HAVE_OPROFILE
+	select HAVE_IRQ_WORK
+	select HAVE_PERF_EVENTS
+	select PERF_USE_VMALLOC
+	select HAVE_ARCH_KGDB
+	select HAVE_FUNCTION_TRACER
+	select HAVE_FUNCTION_TRACE_MCOUNT_TEST
+	select HAVE_DYNAMIC_FTRACE
+	select HAVE_FTRACE_MCOUNT_RECORD
+	select HAVE_C_RECORDMCOUNT
+	select HAVE_FUNCTION_GRAPH_TRACER
+	select HAVE_KPROBES
+	select HAVE_KRETPROBES
+	select RTC_LIB if !MACH_LOONGSON
+	select GENERIC_ATOMIC64 if !64BIT
+	select HAVE_DMA_ATTRS
+	select HAVE_DMA_API_DEBUG
+	select HAVE_GENERIC_HARDIRQS
+	select GENERIC_IRQ_PROBE
+	select GENERIC_IRQ_SHOW
+	select HAVE_ARCH_JUMP_LABEL
+
+menu "Machine selection"
+
+config ZONE_DMA
+	bool
+
+choice
+	prompt "System type"
+	default SGI_IP22
+
+config MIPS_ALCHEMY
+	bool "Alchemy processor based machines"
+	select 64BIT_PHYS_ADDR
+	select CEVT_R4K_LIB
+	select CSRC_R4K_LIB
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_APM_EMULATION
+	select GENERIC_GPIO
+	select ARCH_WANT_OPTIONAL_GPIOLIB
+	select SYS_SUPPORTS_ZBOOT
+
+config AR7
+	bool "Texas Instruments AR7"
+	select BOOT_ELF32
+	select DMA_NONCOHERENT
+	select CEVT_R4K
+	select CSRC_R4K
+	select IRQ_CPU
+	select NO_EXCEPT_FILL
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_ZBOOT_UART16550
+	select ARCH_REQUIRE_GPIOLIB
+	select GCD
+	select VLYNQ
+	help
+	  Support for the Texas Instruments AR7 System-on-a-Chip
+	  family: TNETD7100, 7200 and 7300.
+
+config ATH79
+	bool "Atheros AR71XX/AR724X/AR913X based boards"
+	select ARCH_REQUIRE_GPIOLIB
+	select BOOT_RAW
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select MIPS_MACHINE
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	help
+	  Support for the Atheros AR71XX/AR724X/AR913X SoCs.
+
+config ATHEROS_AR71XX
+	bool "Atheros AR71xx based boards"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select ARCH_REQUIRE_GPIOLIB
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_HAS_EARLY_PRINTK
+	select MIPS_MACHINE
+	help
+	  Support for Atheros AR71xx based boards.
+
+config BCM47XX
+	bool "Broadcom BCM47XX based boards"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SSB
+	select SSB_DRIVER_MIPS
+	select SSB_DRIVER_EXTIF
+	select SSB_EMBEDDED
+	select SSB_B43_PCI_BRIDGE if PCI
+	select SSB_PCICORE_HOSTMODE if PCI
+	select GENERIC_GPIO
+	select SYS_HAS_EARLY_PRINTK
+	select CFE
+	help
+	 Support for BCM47XX based boards
+
+config BCM63XX
+	bool "Broadcom BCM63XX based boards"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_HAS_EARLY_PRINTK
+	select SWAP_IO_SPACE
+	select ARCH_REQUIRE_GPIOLIB
+	help
+	 Support for BCM63XX based boards
+
+config MIPS_COBALT
+	bool "Cobalt Server"
+	select CEVT_R4K
+	select CSRC_R4K
+	select CEVT_GT641XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select I8253
+	select I8259
+	select IRQ_CPU
+	select IRQ_GT641XX
+	select PCI_GT64XXX_PCI0
+	select PCI
+	select SYS_HAS_CPU_NEVADA
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config MACH_DECSTATION
+	bool "DECstations"
+	select BOOT_ELF32
+	select CEVT_DS1287
+	select CEVT_R4K
+	select CSRC_IOASIC
+	select CSRC_R4K
+	select CPU_DADDI_WORKAROUNDS if 64BIT
+	select CPU_R4000_WORKAROUNDS if 64BIT
+	select CPU_R4400_WORKAROUNDS if 64BIT
+	select DMA_NONCOHERENT
+	select NO_IOPORT
+	select IRQ_CPU
+	select SYS_HAS_CPU_R3000
+	select SYS_HAS_CPU_R4X00
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_128HZ
+	select SYS_SUPPORTS_256HZ
+	select SYS_SUPPORTS_1024HZ
+	help
+	  This enables support for DEC's MIPS based workstations.  For details
+	  see the Linux/MIPS FAQ on <http://www.linux-mips.org/> and the
+	  DECstation porting pages on <http://decstation.unix-ag.org/>.
+
+	  If you have one of the following DECstation Models you definitely
+	  want to choose R4xx0 for the CPU Type:
+
+		DECstation 5000/50
+		DECstation 5000/150
+		DECstation 5000/260
+		DECsystem 5900/260
+
+	  otherwise choose R3000.
+
+config MACH_JAZZ
+	bool "Jazz family of machines"
+	select ARC
+	select ARC32
+	select ARCH_MAY_HAVE_PC_FDC
+	select CEVT_R4K
+	select CSRC_R4K
+	select DEFAULT_SGI_PARTITION if CPU_BIG_ENDIAN
+	select GENERIC_ISA_DMA
+	select IRQ_CPU
+	select I8253
+	select I8259
+	select ISA
+	select SYS_HAS_CPU_R4X00
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_100HZ
+	help
+	 This a family of machines based on the MIPS R4030 chipset which was
+	 used by several vendors to build RISC/os and Windows NT workstations.
+	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millennium and
+	 Olivetti M700-10 workstations.
+
+config MACH_JZ4740
+	bool "Ingenic JZ4740 based machines"
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select GENERIC_GPIO
+	select ARCH_REQUIRE_GPIOLIB
+	select SYS_HAS_EARLY_PRINTK
+	select HAVE_PWM
+	select HAVE_CLK
+
+config LASAT
+	bool "LASAT Networks platforms"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select SYS_HAS_EARLY_PRINTK
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select PCI_GT64XXX_PCI0
+	select MIPS_NILE4
+	select R5000_CPU_SCACHE
+	select SYS_HAS_CPU_R5000
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if BROKEN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config MACH_LOONGSON
+	bool "Loongson family of machines"
+	select SYS_SUPPORTS_ZBOOT
+	help
+	  This enables the support of Loongson family of machines.
+
+	  Loongson is a family of general-purpose MIPS-compatible CPUs.
+	  developed at Institute of Computing Technology (ICT),
+	  Chinese Academy of Sciences (CAS) in the People's Republic
+	  of China. The chief architect is Professor Weiwu Hu.
+
+config MIPS_MALTA
+	bool "MIPS Malta board"
+	select ARCH_MAY_HAVE_PC_FDC
+	select BOOT_ELF32
+	select BOOT_RAW
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select GENERIC_ISA_DMA
+	select IRQ_CPU
+	select IRQ_GIC
+	select HW_HAS_PCI
+	select I8253
+	select I8259
+	select MIPS_BOARDS_GEN
+	select MIPS_BONITO64
+	select MIPS_CPU_SCACHE
+	select PCI_GT64XXX_PCI0
+	select MIPS_MSC
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS64_R1
+	select SYS_HAS_CPU_NEVADA
+	select SYS_HAS_CPU_RM7000
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_MIPS_CMP
+	select SYS_SUPPORTS_MULTITHREADING
+	select SYS_SUPPORTS_SMARTMIPS
+	select SYS_SUPPORTS_ZBOOT
+	help
+	  This enables support for the MIPS Technologies Malta evaluation
+	  board.
+
+config MIPS_SIM
+	bool 'MIPS simulator (MIPSsim)'
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select SYS_HAS_EARLY_PRINTK
+	select IRQ_CPU
+	select BOOT_RAW
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_MULTITHREADING
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  This option enables support for MIPS Technologies MIPSsim software
+	  emulator.
+
+config NEC_MARKEINS
+	bool "NEC EMMA2RH Mark-eins board"
+	select SOC_EMMA2RH
+	select HW_HAS_PCI
+	help
+	  This enables support for the NEC Electronics Mark-eins boards.
+
+config MACH_VR41XX
+	bool "NEC VR4100 series based machines"
+	select CEVT_R4K
+	select CSRC_R4K
+	select SYS_HAS_CPU_VR41XX
+	select ARCH_REQUIRE_GPIOLIB
+
+config NXP_STB220
+	bool "NXP STB220 board"
+	select SOC_PNX833X
+	help
+	 Support for NXP Semiconductors STB220 Development Board.
+
+config NXP_STB225
+	bool "NXP 225 board"
+	select SOC_PNX833X
+	select SOC_PNX8335
+	help
+	 Support for NXP Semiconductors STB225 Development Board.
+
+config PNX8550_JBS
+	bool "NXP PNX8550 based JBS board"
+	select PNX8550
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config PNX8550_STB810
+	bool "NXP PNX8550 based STB810 board"
+	select PNX8550
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config PMC_MSP
+	bool "PMC-Sierra MSP chipsets"
+	depends on EXPERIMENTAL
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select SWAP_IO_SPACE
+	select NO_EXCEPT_FILL
+	select BOOT_RAW
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select IRQ_CPU
+	select SERIAL_8250
+	select SERIAL_8250_CONSOLE
+	help
+	  This adds support for the PMC-Sierra family of Multi-Service
+	  Processor System-On-A-Chips.  These parts include a number
+	  of integrated peripherals, interfaces and DSPs in addition to
+	  a variety of MIPS cores.
+
+config PMC_YOSEMITE
+	bool "PMC-Sierra Yosemite eval board"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_COHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select IRQ_CPU_RM7K
+	select IRQ_CPU_RM9K
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_RM9000
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_SMP
+	help
+	  Yosemite is an evaluation board for the RM9000x2 processor
+	  manufactured by PMC-Sierra.
+
+config POWERTV
+	bool "Cisco PowerTV"
+	select BOOT_ELF32
+	select CEVT_R4K
+	select CPU_MIPSR2_IRQ_VI
+	select CPU_MIPSR2_IRQ_EI
+	select CSRC_POWERTV
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select USB_OHCI_LITTLE_ENDIAN
+	help
+	  This enables support for the Cisco PowerTV Platform.
+
+config SGI_IP22
+	bool "SGI IP22 (Indy/Indigo2)"
+	select ARC
+	select ARC32
+	select BOOT_ELF32
+	select CEVT_R4K
+	select CSRC_R4K
+	select DEFAULT_SGI_PARTITION
+	select DMA_NONCOHERENT
+	select HW_HAS_EISA
+	select I8253
+	select I8259
+	select IP22_CPU_SCACHE
+	select IRQ_CPU
+	select GENERIC_ISA_DMA_SUPPORT_BROKEN
+	select SGI_HAS_I8042
+	select SGI_HAS_INDYDOG
+	select SGI_HAS_HAL2
+	select SGI_HAS_SEEQ
+	select SGI_HAS_WD93
+	select SGI_HAS_ZILOG
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_R4X00
+	select SYS_HAS_CPU_R5000
+	#
+	# Disable EARLY_PRINTK for now since it leads to overwritten prom
+	# memory during early boot on some machines.
+	#
+	# See http://www.linux-mips.org/cgi-bin/mesg.cgi?a=linux-mips&i=20091119164009.GA15038%40deprecation.cyrius.com
+	# for a more details discussion
+	#
+	# select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	help
+	  This are the SGI Indy, Challenge S and Indigo2, as well as certain
+	  OEM variants like the Tandem CMN B006S. To compile a Linux kernel
+	  that runs on these, say Y here.
+
+config SGI_IP27
+	bool "SGI IP27 (Origin200/2000)"
+	select ARC
+	select ARC64
+	select BOOT_ELF64
+	select DEFAULT_SGI_PARTITION
+	select DMA_COHERENT
+	select SYS_HAS_EARLY_PRINTK
+	select HW_HAS_PCI
+	select NR_CPUS_DEFAULT_64
+	select SYS_HAS_CPU_R10000
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_NUMA
+	select SYS_SUPPORTS_SMP
+	help
+	  This are the SGI Origin 200, Origin 2000 and Onyx 2 Graphics
+	  workstations.  To compile a Linux kernel that runs on these, say Y
+	  here.
+
+config SGI_IP28
+	bool "SGI IP28 (Indigo2 R10k) (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	select ARC
+	select ARC64
+	select BOOT_ELF64
+	select CEVT_R4K
+	select CSRC_R4K
+	select DEFAULT_SGI_PARTITION
+	select DMA_NONCOHERENT
+	select GENERIC_ISA_DMA_SUPPORT_BROKEN
+	select IRQ_CPU
+	select HW_HAS_EISA
+	select I8253
+	select I8259
+	select SGI_HAS_I8042
+	select SGI_HAS_INDYDOG
+	select SGI_HAS_HAL2
+	select SGI_HAS_SEEQ
+	select SGI_HAS_WD93
+	select SGI_HAS_ZILOG
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_R10000
+	#
+	# Disable EARLY_PRINTK for now since it leads to overwritten prom
+	# memory during early boot on some machines.
+	#
+	# See http://www.linux-mips.org/cgi-bin/mesg.cgi?a=linux-mips&i=20091119164009.GA15038%40deprecation.cyrius.com
+	# for a more details discussion
+	#
+	# select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+      help
+        This is the SGI Indigo2 with R10000 processor.  To compile a Linux
+        kernel that runs on these, say Y here.
+
+config SGI_IP32
+	bool "SGI IP32 (O2)"
+	select ARC
+	select ARC32
+	select BOOT_ELF32
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select R5000_CPU_SCACHE
+	select RM7000_CPU_SCACHE
+	select SYS_HAS_CPU_R5000
+	select SYS_HAS_CPU_R10000 if BROKEN
+	select SYS_HAS_CPU_RM7000
+	select SYS_HAS_CPU_NEVADA
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	help
+	  If you want this kernel to run on SGI O2 workstation, say Y here.
+
+config SIBYTE_CRHINE
+	bool "Sibyte BCM91120C-CRhine"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
+	select SIBYTE_BCM1120
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config SIBYTE_CARMEL
+	bool "Sibyte BCM91120x-Carmel"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
+	select SIBYTE_BCM1120
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config SIBYTE_CRHONE
+	bool "Sibyte BCM91125C-CRhone"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
+	select SIBYTE_BCM1125
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config SIBYTE_RHONE
+	bool "Sibyte BCM91125E-Rhone"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
+	select SIBYTE_BCM1125H
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config SIBYTE_SWARM
+	bool "Sibyte BCM91250A-SWARM"
+	select BOOT_ELF32
+	select DMA_COHERENT
+	select HAVE_PATA_PLATFORM
+	select NR_CPUS_DEFAULT_2
+	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select ZONE_DMA32 if 64BIT
+
+config SIBYTE_LITTLESUR
+	bool "Sibyte BCM91250C2-LittleSur"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
+	select HAVE_PATA_PLATFORM
+	select NR_CPUS_DEFAULT_2
+	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config SIBYTE_SENTOSA
+	bool "Sibyte BCM91250E-Sentosa"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
+	select NR_CPUS_DEFAULT_2
+	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config SIBYTE_BIGSUR
+	bool "Sibyte BCM91480B-BigSur"
+	select BOOT_ELF32
+	select DMA_COHERENT
+	select NR_CPUS_DEFAULT_4
+	select SIBYTE_BCM1x80
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select ZONE_DMA32 if 64BIT
+
+config SNI_RM
+	bool "SNI RM200/300/400"
+	select ARC if CPU_LITTLE_ENDIAN
+	select ARC32 if CPU_LITTLE_ENDIAN
+	select SNIPROM if CPU_BIG_ENDIAN
+	select ARCH_MAY_HAVE_PC_FDC
+	select BOOT_ELF32
+	select CEVT_R4K
+	select CSRC_R4K
+	select DEFAULT_SGI_PARTITION if CPU_BIG_ENDIAN
+	select DMA_NONCOHERENT
+	select GENERIC_ISA_DMA
+	select HW_HAS_EISA
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select I8253
+	select I8259
+	select ISA
+	select SWAP_IO_SPACE if CPU_BIG_ENDIAN
+	select SYS_HAS_CPU_R4X00
+	select SYS_HAS_CPU_R5000
+	select SYS_HAS_CPU_R10000
+	select R5000_CPU_SCACHE
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  The SNI RM200/300/400 are MIPS-based machines manufactured by
+	  Siemens Nixdorf Informationssysteme (SNI), parent company of Pyramid
+	  Technology and now in turn merged with Fujitsu.  Say Y here to
+	  support this machine type.
+
+config MACH_TX39XX
+	bool "Toshiba TX39 series based machines"
+
+config MACH_TX49XX
+	bool "Toshiba TX49 series based machines"
+
+config MIKROTIK_RB532
+	bool "Mikrotik RB532 boards"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SWAP_IO_SPACE
+	select BOOT_RAW
+	select ARCH_REQUIRE_GPIOLIB
+	help
+	  Support the Mikrotik(tm) RouterBoard 532 series,
+	  based on the IDT RC32434 SoC.
+
+config WR_PPMC
+	bool "Wind River PPMC board"
+	select CEVT_R4K
+	select CSRC_R4K
+	select IRQ_CPU
+	select BOOT_ELF32
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select PCI_GT64XXX_PCI0
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS64_R1
+	select SYS_HAS_CPU_NEVADA
+	select SYS_HAS_CPU_RM7000
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  This enables support for the Wind River MIPS32 4KC PPMC evaluation
+	  board, which is based on GT64120 bridge chip.
+
+config CAVIUM_OCTEON_SIMULATOR
+	bool "Cavium Networks Octeon Simulator"
+	select CEVT_R4K
+	select 64BIT_PHYS_ADDR
+	select DMA_COHERENT
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_HOTPLUG_CPU
+	select SYS_HAS_CPU_CAVIUM_OCTEON
+	help
+	  The Octeon simulator is software performance model of the Cavium
+	  Octeon Processor. It supports simulating Octeon processors on x86
+	  hardware.
+
+config CAVIUM_OCTEON_REFERENCE_BOARD
+	bool "Cavium Networks Octeon reference board"
+	select CEVT_R4K
+	select 64BIT_PHYS_ADDR
+	select DMA_COHERENT
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_HOTPLUG_CPU
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_HAS_CPU_CAVIUM_OCTEON
+	select SWAP_IO_SPACE
+	select HW_HAS_PCI
+	select ARCH_SUPPORTS_MSI
+	select ZONE_DMA32
+	select USB_ARCH_HAS_OHCI
+	select USB_ARCH_HAS_EHCI
+	help
+	  This option supports all of the Octeon reference boards from Cavium
+	  Networks. It builds a kernel that dynamically determines the Octeon
+	  CPU type and supports all known board reference implementations.
+	  Some of the supported boards are:
+		EBT3000
+		EBH3000
+		EBH3100
+		Thunder
+		Kodama
+		Hikari
+	  Say Y here for most Octeon reference boards.
+
+endchoice
+
+source "arch/mips/alchemy/Kconfig"
+source "arch/mips/ar71xx/Kconfig"
+source "arch/mips/ath79/Kconfig"
+source "arch/mips/bcm63xx/Kconfig"
+source "arch/mips/jazz/Kconfig"
+source "arch/mips/jz4740/Kconfig"
+source "arch/mips/lasat/Kconfig"
+source "arch/mips/pmc-sierra/Kconfig"
+source "arch/mips/powertv/Kconfig"
+source "arch/mips/sgi-ip27/Kconfig"
+source "arch/mips/sibyte/Kconfig"
+source "arch/mips/txx9/Kconfig"
+source "arch/mips/vr41xx/Kconfig"
+source "arch/mips/cavium-octeon/Kconfig"
+source "arch/mips/loongson/Kconfig"
+
+endmenu
+
+config RWSEM_GENERIC_SPINLOCK
+	bool
+	default y
+
+config RWSEM_XCHGADD_ALGORITHM
+	bool
+
+config ARCH_HAS_ILOG2_U32
+	bool
+	default n
+
+config ARCH_HAS_ILOG2_U64
+	bool
+	default n
+
+config ARCH_SUPPORTS_OPROFILE
+	bool
+	default y if !MIPS_MT_SMTC
+
+config GENERIC_FIND_NEXT_BIT
+	bool
+	default y
+
+config GENERIC_FIND_BIT_LE
+	bool
+	default y
+
+config GENERIC_HWEIGHT
+	bool
+	default y
+
+config GENERIC_CALIBRATE_DELAY
+	bool
+	default y
+
+config GENERIC_CLOCKEVENTS
+	bool
+	default y
+
+config GENERIC_CMOS_UPDATE
+	bool
+	default y
+
+config SCHED_OMIT_FRAME_POINTER
+	bool
+	default y
+
+#
+# Select some configuration options automatically based on user selections.
+#
+config ARC
+	bool
+
+config ARCH_MAY_HAVE_PC_FDC
+	bool
+
+config BOOT_RAW
+	bool
+
+config CEVT_BCM1480
+	bool
+
+config CEVT_DS1287
+	bool
+
+config CEVT_GT641XX
+	bool
+
+config CEVT_R4K_LIB
+	bool
+
+config CEVT_R4K
+	select CEVT_R4K_LIB
+	bool
+
+config CEVT_SB1250
+	bool
+
+config CEVT_TXX9
+	bool
+
+config CSRC_BCM1480
+	bool
+
+config CSRC_IOASIC
+	bool
+
+config CSRC_POWERTV
+	bool
+
+config CSRC_R4K_LIB
+	bool
+
+config CSRC_R4K
+	select CSRC_R4K_LIB
+	bool
+
+config CSRC_SB1250
+	bool
+
+config GPIO_TXX9
+	select GENERIC_GPIO
+	select ARCH_REQUIRE_GPIOLIB
+	bool
+
+config CFE
+	bool
+
+config ARCH_DMA_ADDR_T_64BIT
+	def_bool (HIGHMEM && 64BIT_PHYS_ADDR) || 64BIT
+
+config DMA_COHERENT
+	bool
+
+config DMA_NONCOHERENT
+	bool
+	select NEED_DMA_MAP_STATE
+
+config NEED_DMA_MAP_STATE
+	bool
+
+config SYS_HAS_EARLY_PRINTK
+	bool
+
+config HOTPLUG_CPU
+	bool "Support for hot-pluggable CPUs"
+	depends on SMP && HOTPLUG && SYS_SUPPORTS_HOTPLUG_CPU
+	help
+	  Say Y here to allow turning CPUs off and on. CPUs can be
+	  controlled through /sys/devices/system/cpu.
+	  (Note: power management support will enable this option
+	    automatically on SMP systems. )
+	  Say N if you want to disable CPU hotplug.
+
+config SYS_SUPPORTS_HOTPLUG_CPU
+	bool
+
+config I8259
+	bool
+
+config MIPS_BONITO64
+	bool
+
+config MIPS_MSC
+	bool
+
+config MIPS_NILE4
+	bool
+
+config MIPS_DISABLE_OBSOLETE_IDE
+	bool
+
+config SYNC_R4K
+	bool
+
+config MIPS_MACHINE
+	def_bool n
+
+config NO_IOPORT
+	def_bool n
+
+config GENERIC_ISA_DMA
+	bool
+	select ZONE_DMA if GENERIC_ISA_DMA_SUPPORT_BROKEN=n
+	select ISA_DMA_API
+
+config GENERIC_ISA_DMA_SUPPORT_BROKEN
+	bool
+	select GENERIC_ISA_DMA
+
+config ISA_DMA_API
+	bool
+
+config GENERIC_GPIO
+	bool
+
+#
+# Endianess selection.  Sufficiently obscure so many users don't know what to
+# answer,so we try hard to limit the available choices.  Also the use of a
+# choice statement should be more obvious to the user.
+#
+choice
+	prompt "Endianess selection"
+	help
+	  Some MIPS machines can be configured for either little or big endian
+	  byte order. These modes require different kernels and a different
+	  Linux distribution.  In general there is one preferred byteorder for a
+	  particular system but some systems are just as commonly used in the
+	  one or the other endianness.
+
+config CPU_BIG_ENDIAN
+	bool "Big endian"
+	depends on SYS_SUPPORTS_BIG_ENDIAN
+
+config CPU_LITTLE_ENDIAN
+	bool "Little endian"
+	depends on SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+
+endchoice
+
+config EXPORT_UASM
+	bool
+
+config SYS_SUPPORTS_APM_EMULATION
+	bool
+
+config SYS_SUPPORTS_BIG_ENDIAN
+	bool
+
+config SYS_SUPPORTS_LITTLE_ENDIAN
+	bool
+
+config SYS_SUPPORTS_HUGETLBFS
+	bool
+	depends on CPU_SUPPORTS_HUGEPAGES && 64BIT
+	default y
+
+config IRQ_CPU
+	bool
+
+config IRQ_CPU_RM7K
+	bool
+
+config IRQ_CPU_RM9K
+	bool
+
+config IRQ_MSP_SLP
+	bool
+
+config IRQ_MSP_CIC
+	bool
+
+config IRQ_TXX9
+	bool
+
+config IRQ_GT641XX
+	bool
+
+config IRQ_GIC
+	bool
+
+config MIPS_BOARDS_GEN
+	bool
+
+config PCI_GT64XXX_PCI0
+	bool
+
+config NO_EXCEPT_FILL
+	bool
+
+config MIPS_RM9122
+	bool
+	select SERIAL_RM9000
+
+config SOC_EMMA2RH
+	bool
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_R5500
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+
+config SOC_PNX833X
+	bool
+	select CEVT_R4K
+	select CSRC_R4K
+	select IRQ_CPU
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select GENERIC_GPIO
+	select CPU_MIPSR2_IRQ_VI
+
+config SOC_PNX8335
+	bool
+	select SOC_PNX833X
+
+config PNX8550
+	bool
+	select SOC_PNX8550
+
+config SOC_PNX8550
+	bool
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select GENERIC_GPIO
+
+config SWAP_IO_SPACE
+	bool
+
+config SERIAL_RM9000
+	bool
+
+config SGI_HAS_INDYDOG
+	bool
+
+config SGI_HAS_HAL2
+	bool
+
+config SGI_HAS_SEEQ
+	bool
+
+config SGI_HAS_WD93
+	bool
+
+config SGI_HAS_ZILOG
+	bool
+
+config SGI_HAS_I8042
+	bool
+
+config DEFAULT_SGI_PARTITION
+	bool
+
+config ARC32
+	bool
+
+config SNIPROM
+	bool
+
+config BOOT_ELF32
+	bool
+
+config MIPS_L1_CACHE_SHIFT
+	int
+	default "4" if MACH_DECSTATION || MIKROTIK_RB532 || PMC_MSP4200_EVAL
+	default "6" if MIPS_CPU_SCACHE
+	default "7" if SGI_IP22 || SGI_IP27 || SGI_IP28 || SNI_RM || CPU_CAVIUM_OCTEON
+	default "5"
+
+config HAVE_STD_PC_SERIAL_PORT
+	bool
+
+config ARC_CONSOLE
+	bool "ARC console support"
+	depends on SGI_IP22 || SGI_IP28 || (SNI_RM && CPU_LITTLE_ENDIAN)
+
+config ARC_MEMORY
+	bool
+	depends on MACH_JAZZ || SNI_RM || SGI_IP32
+	default y
+
+config ARC_PROMLIB
+	bool
+	depends on MACH_JAZZ || SNI_RM || SGI_IP22 || SGI_IP28 || SGI_IP32
+	default y
+
+config ARC64
+	bool
+
+config BOOT_ELF64
+	bool
+
+menu "CPU selection"
+
+choice
+	prompt "CPU type"
+	default CPU_R4X00
+
+config CPU_LOONGSON2E
+	bool "Loongson 2E"
+	depends on SYS_HAS_CPU_LOONGSON2E
+	select CPU_LOONGSON2
+	help
+	  The Loongson 2E processor implements the MIPS III instruction set
+	  with many extensions.
+
+	  It has an internal FPGA northbridge, which is compatible to
+	  bonito64.
+
+config CPU_LOONGSON2F
+	bool "Loongson 2F"
+	depends on SYS_HAS_CPU_LOONGSON2F
+	select CPU_LOONGSON2
+	select GENERIC_GPIO
+	select ARCH_REQUIRE_GPIOLIB
+	help
+	  The Loongson 2F processor implements the MIPS III instruction set
+	  with many extensions.
+
+	  Loongson2F have built-in DDR2 and PCIX controller. The PCIX controller
+	  have a similar programming interface with FPGA northbridge used in
+	  Loongson2E.
+
+config CPU_MIPS32_R1
+	bool "MIPS32 Release 1"
+	depends on SYS_HAS_CPU_MIPS32_R1
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+	help
+	  Choose this option to build a kernel for release 1 or later of the
+	  MIPS32 architecture.  Most modern embedded systems with a 32-bit
+	  MIPS processor are based on a MIPS32 processor.  If you know the
+	  specific type of processor in your system, choose those that one
+	  otherwise CPU_MIPS32_R1 is a safe bet for any MIPS32 system.
+	  Release 2 of the MIPS32 architecture is available since several
+	  years so chances are you even have a MIPS32 Release 2 processor
+	  in which case you should choose CPU_MIPS32_R2 instead for better
+	  performance.
+
+config CPU_MIPS32_R2
+	bool "MIPS32 Release 2"
+	depends on SYS_HAS_CPU_MIPS32_R2
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+	help
+	  Choose this option to build a kernel for release 2 or later of the
+	  MIPS32 architecture.  Most modern embedded systems with a 32-bit
+	  MIPS processor are based on a MIPS32 processor.  If you know the
+	  specific type of processor in your system, choose those that one
+	  otherwise CPU_MIPS32_R1 is a safe bet for any MIPS32 system.
+
+config CPU_MIPS64_R1
+	bool "MIPS64 Release 1"
+	depends on SYS_HAS_CPU_MIPS64_R1
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+	select CPU_SUPPORTS_HUGEPAGES
+	help
+	  Choose this option to build a kernel for release 1 or later of the
+	  MIPS64 architecture.  Many modern embedded systems with a 64-bit
+	  MIPS processor are based on a MIPS64 processor.  If you know the
+	  specific type of processor in your system, choose those that one
+	  otherwise CPU_MIPS64_R1 is a safe bet for any MIPS64 system.
+	  Release 2 of the MIPS64 architecture is available since several
+	  years so chances are you even have a MIPS64 Release 2 processor
+	  in which case you should choose CPU_MIPS64_R2 instead for better
+	  performance.
+
+config CPU_MIPS64_R2
+	bool "MIPS64 Release 2"
+	depends on SYS_HAS_CPU_MIPS64_R2
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+	select CPU_SUPPORTS_HUGEPAGES
+	help
+	  Choose this option to build a kernel for release 2 or later of the
+	  MIPS64 architecture.  Many modern embedded systems with a 64-bit
+	  MIPS processor are based on a MIPS64 processor.  If you know the
+	  specific type of processor in your system, choose those that one
+	  otherwise CPU_MIPS64_R1 is a safe bet for any MIPS64 system.
+
+config CPU_R3000
+	bool "R3000"
+	depends on SYS_HAS_CPU_R3000
+	select CPU_HAS_WB
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+	help
+	  Please make sure to pick the right CPU type. Linux/MIPS is not
+	  designed to be generic, i.e. Kernels compiled for R3000 CPUs will
+	  *not* work on R4000 machines and vice versa.  However, since most
+	  of the supported machines have an R4000 (or similar) CPU, R4x00
+	  might be a safe bet.  If the resulting kernel does not work,
+	  try to recompile with R3000.
+
+config CPU_TX39XX
+	bool "R39XX"
+	depends on SYS_HAS_CPU_TX39XX
+	select CPU_SUPPORTS_32BIT_KERNEL
+
+config CPU_VR41XX
+	bool "R41xx"
+	depends on SYS_HAS_CPU_VR41XX
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	help
+	  The options selects support for the NEC VR4100 series of processors.
+	  Only choose this option if you have one of these processors as a
+	  kernel built with this option will not run on any other type of
+	  processor or vice versa.
+
+config CPU_R4300
+	bool "R4300"
+	depends on SYS_HAS_CPU_R4300
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	help
+	  MIPS Technologies R4300-series processors.
+
+config CPU_R4X00
+	bool "R4x00"
+	depends on SYS_HAS_CPU_R4X00
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	help
+	  MIPS Technologies R4000-series processors other than 4300, including
+	  the R4000, R4400, R4600, and 4700.
+
+config CPU_TX49XX
+	bool "R49XX"
+	depends on SYS_HAS_CPU_TX49XX
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+
+config CPU_R5000
+	bool "R5000"
+	depends on SYS_HAS_CPU_R5000
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	help
+	  MIPS Technologies R5000-series processors other than the Nevada.
+
+config CPU_R5432
+	bool "R5432"
+	depends on SYS_HAS_CPU_R5432
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+
+config CPU_R5500
+	bool "R5500"
+	depends on SYS_HAS_CPU_R5500
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HUGEPAGES
+	help
+	  NEC VR5500 and VR5500A series processors implement 64-bit MIPS IV
+	  instruction set.
+
+config CPU_R6000
+	bool "R6000"
+	depends on EXPERIMENTAL
+	depends on SYS_HAS_CPU_R6000
+	select CPU_SUPPORTS_32BIT_KERNEL
+	help
+	  MIPS Technologies R6000 and R6000A series processors.  Note these
+	  processors are extremely rare and the support for them is incomplete.
+
+config CPU_NEVADA
+	bool "RM52xx"
+	depends on SYS_HAS_CPU_NEVADA
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	help
+	  QED / PMC-Sierra RM52xx-series ("Nevada") processors.
+
+config CPU_R8000
+	bool "R8000"
+	depends on EXPERIMENTAL
+	depends on SYS_HAS_CPU_R8000
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_64BIT_KERNEL
+	help
+	  MIPS Technologies R8000 processors.  Note these processors are
+	  uncommon and the support for them is incomplete.
+
+config CPU_R10000
+	bool "R10000"
+	depends on SYS_HAS_CPU_R10000
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+	help
+	  MIPS Technologies R10000-series processors.
+
+config CPU_RM7000
+	bool "RM7000"
+	depends on SYS_HAS_CPU_RM7000
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+
+config CPU_RM9000
+	bool "RM9000"
+	depends on SYS_HAS_CPU_RM9000
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+	select WEAK_ORDERING
+
+config CPU_SB1
+	bool "SB1"
+	depends on SYS_HAS_CPU_SB1
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+	select WEAK_ORDERING
+
+config CPU_CAVIUM_OCTEON
+	bool "Cavium Octeon processor"
+	depends on SYS_HAS_CPU_CAVIUM_OCTEON
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_SMP
+	select NR_CPUS_DEFAULT_16
+	select WEAK_ORDERING
+	select CPU_SUPPORTS_HIGHMEM
+	select CPU_SUPPORTS_HUGEPAGES
+	help
+	  The Cavium Octeon processor is a highly integrated chip containing
+	  many ethernet hardware widgets for networking tasks. The processor
+	  can have up to 16 Mips64v2 cores and 8 integrated gigabit ethernets.
+	  Full details can be found at http://www.caviumnetworks.com.
+
+config CPU_BMIPS3300
+	bool "BMIPS3300"
+	depends on SYS_HAS_CPU_BMIPS3300
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select WEAK_ORDERING
+	help
+	  Broadcom BMIPS3300 processors.
+
+config CPU_BMIPS4350
+	bool "BMIPS4350"
+	depends on SYS_HAS_CPU_BMIPS4350
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_SMP
+	select SYS_SUPPORTS_HOTPLUG_CPU
+	select WEAK_ORDERING
+	help
+	  Broadcom BMIPS4350 ("VIPER") processors.
+
+config CPU_BMIPS4380
+	bool "BMIPS4380"
+	depends on SYS_HAS_CPU_BMIPS4380
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_SMP
+	select SYS_SUPPORTS_HOTPLUG_CPU
+	select WEAK_ORDERING
+	help
+	  Broadcom BMIPS4380 processors.
+
+config CPU_BMIPS5000
+	bool "BMIPS5000"
+	depends on SYS_HAS_CPU_BMIPS5000
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_SMP
+	select SYS_SUPPORTS_HOTPLUG_CPU
+	select WEAK_ORDERING
+	help
+	  Broadcom BMIPS5000 processors.
+
+endchoice
+
+if CPU_LOONGSON2F
+config CPU_NOP_WORKAROUNDS
+	bool
+
+config CPU_JUMP_WORKAROUNDS
+	bool
+
+config CPU_LOONGSON2F_WORKAROUNDS
+	bool "Loongson 2F Workarounds"
+	default y
+	select CPU_NOP_WORKAROUNDS
+	select CPU_JUMP_WORKAROUNDS
+	help
+	  Loongson 2F01 / 2F02 processors have the NOP & JUMP issues which
+	  require workarounds.  Without workarounds the system may hang
+	  unexpectedly.  For more information please refer to the gas
+	  -mfix-loongson2f-nop and -mfix-loongson2f-jump options.
+
+	  Loongson 2F03 and later have fixed these issues and no workarounds
+	  are needed.  The workarounds have no significant side effect on them
+	  but may decrease the performance of the system so this option should
+	  be disabled unless the kernel is intended to be run on 2F01 or 2F02
+	  systems.
+
+	  If unsure, please say Y.
+endif # CPU_LOONGSON2F
+
+config SYS_SUPPORTS_ZBOOT
+	bool
+	select HAVE_KERNEL_GZIP
+	select HAVE_KERNEL_BZIP2
+	select HAVE_KERNEL_LZMA
+	select HAVE_KERNEL_LZO
+
+config SYS_SUPPORTS_ZBOOT_UART16550
+	bool
+	select SYS_SUPPORTS_ZBOOT
+
+config CPU_LOONGSON2
+	bool
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+
+config SYS_HAS_CPU_LOONGSON2E
+	bool
+
+config SYS_HAS_CPU_LOONGSON2F
+	bool
+	select CPU_SUPPORTS_CPUFREQ
+	select CPU_SUPPORTS_ADDRWINCFG if 64BIT
+	select CPU_SUPPORTS_UNCACHED_ACCELERATED
+
+config SYS_HAS_CPU_MIPS32_R1
+	bool
+
+config SYS_HAS_CPU_MIPS32_R2
+	bool
+
+config SYS_HAS_CPU_MIPS64_R1
+	bool
+
+config SYS_HAS_CPU_MIPS64_R2
+	bool
+
+config SYS_HAS_CPU_R3000
+	bool
+
+config SYS_HAS_CPU_TX39XX
+	bool
+
+config SYS_HAS_CPU_VR41XX
+	bool
+
+config SYS_HAS_CPU_R4300
+	bool
+
+config SYS_HAS_CPU_R4X00
+	bool
+
+config SYS_HAS_CPU_TX49XX
+	bool
+
+config SYS_HAS_CPU_R5000
+	bool
+
+config SYS_HAS_CPU_R5432
+	bool
+
+config SYS_HAS_CPU_R5500
+	bool
+
+config SYS_HAS_CPU_R6000
+	bool
+
+config SYS_HAS_CPU_NEVADA
+	bool
+
+config SYS_HAS_CPU_R8000
+	bool
+
+config SYS_HAS_CPU_R10000
+	bool
+
+config SYS_HAS_CPU_RM7000
+	bool
+
+config SYS_HAS_CPU_RM9000
+	bool
+
+config SYS_HAS_CPU_SB1
+	bool
+
+config SYS_HAS_CPU_CAVIUM_OCTEON
+	bool
+
+config SYS_HAS_CPU_BMIPS3300
+	bool
+
+config SYS_HAS_CPU_BMIPS4350
+	bool
+
+config SYS_HAS_CPU_BMIPS4380
+	bool
+
+config SYS_HAS_CPU_BMIPS5000
+	bool
+
+#
+# CPU may reorder R->R, R->W, W->R, W->W
+# Reordering beyond LL and SC is handled in WEAK_REORDERING_BEYOND_LLSC
+#
+config WEAK_ORDERING
+	bool
+
+#
+# CPU may reorder reads and writes beyond LL/SC
+# CPU may reorder R->LL, R->LL, W->LL, W->LL, R->SC, R->SC, W->SC, W->SC
+#
+config WEAK_REORDERING_BEYOND_LLSC
+	bool
+endmenu
+
+#
+# These two indicate any level of the MIPS32 and MIPS64 architecture
+#
+config CPU_MIPS32
+	bool
+	default y if CPU_MIPS32_R1 || CPU_MIPS32_R2
+
+config CPU_MIPS64
+	bool
+	default y if CPU_MIPS64_R1 || CPU_MIPS64_R2
+
+#
+# These two indicate the revision of the architecture, either Release 1 or Release 2
+#
+config CPU_MIPSR1
+	bool
+	default y if CPU_MIPS32_R1 || CPU_MIPS64_R1
+
+config CPU_MIPSR2
+	bool
+	default y if CPU_MIPS32_R2 || CPU_MIPS64_R2 || CPU_CAVIUM_OCTEON
+
+config SYS_SUPPORTS_32BIT_KERNEL
+	bool
+config SYS_SUPPORTS_64BIT_KERNEL
+	bool
+config CPU_SUPPORTS_32BIT_KERNEL
+	bool
+config CPU_SUPPORTS_64BIT_KERNEL
+	bool
+config CPU_SUPPORTS_CPUFREQ
+	bool
+config CPU_SUPPORTS_ADDRWINCFG
+	bool
+config CPU_SUPPORTS_HUGEPAGES
+	bool
+config CPU_SUPPORTS_UNCACHED_ACCELERATED
+	bool
+config MIPS_PGD_C0_CONTEXT
+	bool
+	default y if 64BIT && CPU_MIPSR2
+
+#
+# Set to y for ptrace access to watch registers.
+#
+config HARDWARE_WATCHPOINTS
+       bool
+       default y if CPU_MIPSR1 || CPU_MIPSR2
+
+menu "Kernel type"
+
+choice
+
+	prompt "Kernel code model"
+	help
+	  You should only select this option if you have a workload that
+	  actually benefits from 64-bit processing or if your machine has
+	  large memory.  You will only be presented a single option in this
+	  menu if your system does not support both 32-bit and 64-bit kernels.
+
+config 32BIT
+	bool "32-bit kernel"
+	depends on CPU_SUPPORTS_32BIT_KERNEL && SYS_SUPPORTS_32BIT_KERNEL
+	select TRAD_SIGNALS
+	help
+	  Select this option if you want to build a 32-bit kernel.
+config 64BIT
+	bool "64-bit kernel"
+	depends on CPU_SUPPORTS_64BIT_KERNEL && SYS_SUPPORTS_64BIT_KERNEL
+	select HAVE_SYSCALL_WRAPPERS
+	help
+	  Select this option if you want to build a 64-bit kernel.
+
+endchoice
+
+choice
+	prompt "Kernel page size"
+	default PAGE_SIZE_4KB
+
+config PAGE_SIZE_4KB
+	bool "4kB"
+	depends on !CPU_LOONGSON2
+	help
+	 This option select the standard 4kB Linux page size.  On some
+	 R3000-family processors this is the only available page size.  Using
+	 4kB page size will minimize memory consumption and is therefore
+	 recommended for low memory systems.
+
+config PAGE_SIZE_8KB
+	bool "8kB"
+	depends on (EXPERIMENTAL && CPU_R8000) || CPU_CAVIUM_OCTEON
+	help
+	  Using 8kB page size will result in higher performance kernel at
+	  the price of higher memory consumption.  This option is available
+	  only on R8000 and cnMIPS processors.  Note that you will need a
+	  suitable Linux distribution to support this.
+
+config PAGE_SIZE_16KB
+	bool "16kB"
+	depends on !CPU_R3000 && !CPU_TX39XX
+	help
+	  Using 16kB page size will result in higher performance kernel at
+	  the price of higher memory consumption.  This option is available on
+	  all non-R3000 family processors.  Note that you will need a suitable
+	  Linux distribution to support this.
+
+config PAGE_SIZE_32KB
+	bool "32kB"
+	depends on CPU_CAVIUM_OCTEON
+	help
+	  Using 32kB page size will result in higher performance kernel at
+	  the price of higher memory consumption.  This option is available
+	  only on cnMIPS cores.  Note that you will need a suitable Linux
+	  distribution to support this.
+
+config PAGE_SIZE_64KB
+	bool "64kB"
+	depends on EXPERIMENTAL && !CPU_R3000 && !CPU_TX39XX
+	help
+	  Using 64kB page size will result in higher performance kernel at
+	  the price of higher memory consumption.  This option is available on
+	  all non-R3000 family processor.  Not that at the time of this
+	  writing this option is still high experimental.
+
+endchoice
+
+config FORCE_MAX_ZONEORDER
+	int "Maximum zone order"
+	range 13 64 if SYS_SUPPORTS_HUGETLBFS && PAGE_SIZE_32KB
+	default "13" if SYS_SUPPORTS_HUGETLBFS && PAGE_SIZE_32KB
+	range 12 64 if SYS_SUPPORTS_HUGETLBFS && PAGE_SIZE_16KB
+	default "12" if SYS_SUPPORTS_HUGETLBFS && PAGE_SIZE_16KB
+	range 11 64
+	default "11"
+	help
+	  The kernel memory allocator divides physically contiguous memory
+	  blocks into "zones", where each zone is a power of two number of
+	  pages.  This option selects the largest power of two that the kernel
+	  keeps in the memory allocator.  If you need to allocate very large
+	  blocks of physically contiguous memory, then you may need to
+	  increase this value.
+
+	  This config option is actually maximum order plus one. For example,
+	  a value of 11 means that the largest free memory block is 2^10 pages.
+
+	  The page size is not necessarily 4KB.  Keep this in mind
+	  when choosing a value for this option.
+
+config BOARD_SCACHE
+	bool
+
+config IP22_CPU_SCACHE
+	bool
+	select BOARD_SCACHE
+
+#
+# Support for a MIPS32 / MIPS64 style S-caches
+#
+config MIPS_CPU_SCACHE
+	bool
+	select BOARD_SCACHE
+
+config R5000_CPU_SCACHE
+	bool
+	select BOARD_SCACHE
+
+config RM7000_CPU_SCACHE
+	bool
+	select BOARD_SCACHE
+
+config SIBYTE_DMA_PAGEOPS
+	bool "Use DMA to clear/copy pages"
+	depends on CPU_SB1
+	help
+	  Instead of using the CPU to zero and copy pages, use a Data Mover
+	  channel.  These DMA channels are otherwise unused by the standard
+	  SiByte Linux port.  Seems to give a small performance benefit.
+
+config CPU_HAS_PREFETCH
+	bool
+
+choice
+	prompt "MIPS MT options"
+
+config MIPS_MT_DISABLED
+	bool "Disable multithreading support."
+	help
+	  Use this option if your workload can't take advantage of
+	  MIPS hardware multithreading support.  On systems that don't have
+	  the option of an MT-enabled processor this option will be the only
+	  option in this menu.
+
+config MIPS_MT_SMP
+	bool "Use 1 TC on each available VPE for SMP"
+	depends on SYS_SUPPORTS_MULTITHREADING
+	select CPU_MIPSR2_IRQ_VI
+	select CPU_MIPSR2_IRQ_EI
+	select MIPS_MT
+	select NR_CPUS_DEFAULT_2
+	select SMP
+	select SYS_SUPPORTS_SCHED_SMT if SMP
+	select SYS_SUPPORTS_SMP
+	select SMP_UP
+	help
+	  This is a kernel model which is known a VSMP but lately has been
+	  marketesed into SMVP.
+	  Virtual SMP uses the processor's VPEs  to implement virtual
+	  processors. In currently available configuration of the 34K processor
+	  this allows for a dual processor. Both processors will share the same
+	  primary caches; each will obtain the half of the TLB for it's own
+	  exclusive use. For a layman this model can be described as similar to
+	  what Intel calls Hyperthreading.
+
+	  For further information see http://www.linux-mips.org/wiki/34K#VSMP
+
+config MIPS_MT_SMTC
+	bool "SMTC: Use all TCs on all VPEs for SMP"
+	depends on CPU_MIPS32_R2
+	#depends on CPU_MIPS64_R2		# once there is hardware ...
+	depends on SYS_SUPPORTS_MULTITHREADING
+	select CPU_MIPSR2_IRQ_VI
+	select CPU_MIPSR2_IRQ_EI
+	select MIPS_MT
+	select NR_CPUS_DEFAULT_8
+	select SMP
+	select SYS_SUPPORTS_SMP
+	select SMP_UP
+	help
+	  This is a kernel model which is known a SMTC or lately has been
+	  marketesed into SMVP.
+	  is presenting the available TC's of the core as processors to Linux.
+	  On currently available 34K processors this means a Linux system will
+	  see up to 5 processors. The implementation of the SMTC kernel differs
+	  significantly from VSMP and cannot efficiently coexist in the same
+	  kernel binary so the choice between VSMP and SMTC is a compile time
+	  decision.
+
+	  For further information see http://www.linux-mips.org/wiki/34K#SMTC
+
+endchoice
+
+config MIPS_MT
+	bool
+
+config SCHED_SMT
+	bool "SMT (multithreading) scheduler support"
+	depends on SYS_SUPPORTS_SCHED_SMT
+	default n
+	help
+	  SMT scheduler support improves the CPU scheduler's decision making
+	  when dealing with MIPS MT enabled cores at a cost of slightly
+	  increased overhead in some places. If unsure say N here.
+
+config SYS_SUPPORTS_SCHED_SMT
+	bool
+
+
+config SYS_SUPPORTS_MULTITHREADING
+	bool
+
+config MIPS_MT_FPAFF
+	bool "Dynamic FPU affinity for FP-intensive threads"
+	default y
+	depends on MIPS_MT_SMP || MIPS_MT_SMTC
+
+config MIPS_VPE_LOADER
+	bool "VPE loader support."
+	depends on SYS_SUPPORTS_MULTITHREADING
+	select CPU_MIPSR2_IRQ_VI
+	select CPU_MIPSR2_IRQ_EI
+	select MIPS_MT
+	help
+	  Includes a loader for loading an elf relocatable object
+	  onto another VPE and running it.
+
+config MIPS_MT_SMTC_IM_BACKSTOP
+	bool "Use per-TC register bits as backstop for inhibited IM bits"
+	depends on MIPS_MT_SMTC
+	default n
+	help
+	  To support multiple TC microthreads acting as "CPUs" within
+	  a VPE, VPE-wide interrupt mask bits must be specially manipulated
+	  during interrupt handling. To support legacy drivers and interrupt
+	  controller management code, SMTC has a "backstop" to track and
+	  if necessary restore the interrupt mask. This has some performance
+	  impact on interrupt service overhead.
+
+config MIPS_MT_SMTC_IRQAFF
+	bool "Support IRQ affinity API"
+	depends on MIPS_MT_SMTC
+	default n
+	help
+	  Enables SMP IRQ affinity API (/proc/irq/*/smp_affinity, etc.)
+	  for SMTC Linux kernel. Requires platform support, of which
+	  an example can be found in the MIPS kernel i8259 and Malta
+	  platform code.  Adds some overhead to interrupt dispatch, and
+	  should be used only if you know what you are doing.
+
+config MIPS_VPE_LOADER_TOM
+	bool "Load VPE program into memory hidden from linux"
+	depends on MIPS_VPE_LOADER
+	default y
+	help
+	  The loader can use memory that is present but has been hidden from
+	  Linux using the kernel command line option "mem=xxMB". It's up to
+	  you to ensure the amount you put in the option and the space your
+	  program requires is less or equal to the amount physically present.
+
+# this should possibly be in drivers/char, but it is rather cpu related. Hmmm
+config MIPS_VPE_APSP_API
+	bool "Enable support for AP/SP API (RTLX)"
+	depends on MIPS_VPE_LOADER
+	help
+
+config MIPS_APSP_KSPD
+	bool "Enable KSPD"
+	depends on MIPS_VPE_APSP_API
+	default y
+	help
+	  KSPD is a kernel daemon that accepts syscall requests from the SP
+	  side, actions them and returns the results. It also handles the
+	  "exit" syscall notifying other kernel modules the SP program is
+	  exiting.  You probably want to say yes here.
+
+config MIPS_CMP
+	bool "MIPS CMP framework support"
+	depends on SYS_SUPPORTS_MIPS_CMP
+	select SYNC_R4K
+	select SYS_SUPPORTS_SMP
+	select SYS_SUPPORTS_SCHED_SMT if SMP
+	select WEAK_ORDERING
+	default n
+	help
+	  This is a placeholder option for the GCMP work. It will need to
+	  be handled differently...
+
+config SB1_PASS_1_WORKAROUNDS
+	bool
+	depends on CPU_SB1_PASS_1
+	default y
+
+config SB1_PASS_2_WORKAROUNDS
+	bool
+	depends on CPU_SB1 && (CPU_SB1_PASS_2_2 || CPU_SB1_PASS_2)
+	default y
+
+config SB1_PASS_2_1_WORKAROUNDS
+	bool
+	depends on CPU_SB1 && CPU_SB1_PASS_2
+	default y
+
+config 64BIT_PHYS_ADDR
+	bool
+
+config ARCH_PHYS_ADDR_T_64BIT
+       def_bool 64BIT_PHYS_ADDR
+
+config CPU_HAS_SMARTMIPS
+	depends on SYS_SUPPORTS_SMARTMIPS
+	bool "Support for the SmartMIPS ASE"
+	help
+	  SmartMIPS is a extension of the MIPS32 architecture aimed at
+	  increased security at both hardware and software level for
+	  smartcards.  Enabling this option will allow proper use of the
+	  SmartMIPS instructions by Linux applications.  However a kernel with
+	  this option will not work on a MIPS core without SmartMIPS core.  If
+	  you don't know you probably don't have SmartMIPS and should say N
+	  here.
+
+config CPU_HAS_WB
+	bool
+
+#
+# Vectored interrupt mode is an R2 feature
+#
+config CPU_MIPSR2_IRQ_VI
+	bool
+
+#
+# Extended interrupt mode is an R2 feature
+#
+config CPU_MIPSR2_IRQ_EI
+	bool
+
+config CPU_HAS_SYNC
+	bool
+	depends on !CPU_R3000
+	default y
+
+config GENERIC_CLOCKEVENTS_BROADCAST
+	bool
+
+#
+# CPU non-features
+#
+config CPU_DADDI_WORKAROUNDS
+	bool
+
+config CPU_R4000_WORKAROUNDS
+	bool
+	select CPU_R4400_WORKAROUNDS
+
+config CPU_R4400_WORKAROUNDS
+	bool
+
+#
+# - Highmem only makes sense for the 32-bit kernel.
+# - The current highmem code will only work properly on physically indexed
+#   caches such as R3000, SB1, R7000 or those that look like they're virtually
+#   indexed such as R4000/R4400 SC and MC versions or R10000.  So for the
+#   moment we protect the user and offer the highmem option only on machines
+#   where it's known to be safe.  This will not offer highmem on a few systems
+#   such as MIPS32 and MIPS64 CPUs which may have virtual and physically
+#   indexed CPUs but we're playing safe.
+# - We use SYS_SUPPORTS_HIGHMEM to offer highmem only for systems where we
+#   know they might have memory configurations that could make use of highmem
+#   support.
+#
+config HIGHMEM
+	bool "High Memory Support"
+	depends on 32BIT && CPU_SUPPORTS_HIGHMEM && SYS_SUPPORTS_HIGHMEM
+
+config CPU_SUPPORTS_HIGHMEM
+	bool
+
+config SYS_SUPPORTS_HIGHMEM
+	bool
+
+config SYS_SUPPORTS_SMARTMIPS
+	bool
+
+config ARCH_FLATMEM_ENABLE
+	def_bool y
+	depends on !NUMA && !CPU_LOONGSON2
+
+config ARCH_DISCONTIGMEM_ENABLE
+	bool
+	default y if SGI_IP27
+	help
+	  Say Y to support efficient handling of discontiguous physical memory,
+	  for architectures which are either NUMA (Non-Uniform Memory Access)
+	  or have huge holes in the physical address space for other reasons.
+	  See <file:Documentation/vm/numa> for more.
+
+config ARCH_POPULATES_NODE_MAP
+	def_bool y
+
+config ARCH_SPARSEMEM_ENABLE
+	bool
+	select SPARSEMEM_STATIC
+
+config NUMA
+	bool "NUMA Support"
+	depends on SYS_SUPPORTS_NUMA
+	help
+	  Say Y to compile the kernel to support NUMA (Non-Uniform Memory
+	  Access).  This option improves performance on systems with more
+	  than two nodes; on two node systems it is generally better to
+	  leave it disabled; on single node systems disable this option
+	  disabled.
+
+config SYS_SUPPORTS_NUMA
+	bool
+
+config NODES_SHIFT
+	int
+	default "6"
+	depends on NEED_MULTIPLE_NODES
+
+config HW_PERF_EVENTS
+	bool "Enable hardware performance counter support for perf events"
+	depends on PERF_EVENTS && !MIPS_MT_SMTC && OPROFILE=n && CPU_MIPS32
+	default y
+	help
+	  Enable hardware performance counter support for perf events. If
+	  disabled, perf events will use software events only.
+
+source "mm/Kconfig"
+
+config SMP
+	bool "Multi-Processing support"
+	depends on SYS_SUPPORTS_SMP
+	select IRQ_PER_CPU
+	select USE_GENERIC_SMP_HELPERS
+	help
+	  This enables support for systems with more than one CPU. If you have
+	  a system with only one CPU, like most personal computers, say N. If
+	  you have a system with more than one CPU, say Y.
+
+	  If you say N here, the kernel will run on single and multiprocessor
+	  machines, but will use only one CPU of a multiprocessor machine. If
+	  you say Y here, the kernel will run on many, but not all,
+	  singleprocessor machines. On a singleprocessor machine, the kernel
+	  will run faster if you say N here.
+
+	  People using multiprocessor machines who say Y here should also say
+	  Y to "Enhanced Real Time Clock Support", below.
+
+	  See also the SMP-HOWTO available at
+	  <http://www.tldp.org/docs.html#howto>.
+
+	  If you don't know what to do here, say N.
+
+config SMP_UP
+	bool
+
+config SYS_SUPPORTS_MIPS_CMP
+	bool
+
+config SYS_SUPPORTS_SMP
+	bool
+
+config NR_CPUS_DEFAULT_1
+	bool
+
+config NR_CPUS_DEFAULT_2
+	bool
+
+config NR_CPUS_DEFAULT_4
+	bool
+
+config NR_CPUS_DEFAULT_8
+	bool
+
+config NR_CPUS_DEFAULT_16
+	bool
+
+config NR_CPUS_DEFAULT_32
+	bool
+
+config NR_CPUS_DEFAULT_64
+	bool
+
+config NR_CPUS
+	int "Maximum number of CPUs (2-64)"
+	range 1 64 if NR_CPUS_DEFAULT_1
+	depends on SMP
+	default "1" if NR_CPUS_DEFAULT_1
+	default "2" if NR_CPUS_DEFAULT_2
+	default "4" if NR_CPUS_DEFAULT_4
+	default "8" if NR_CPUS_DEFAULT_8
+	default "16" if NR_CPUS_DEFAULT_16
+	default "32" if NR_CPUS_DEFAULT_32
+	default "64" if NR_CPUS_DEFAULT_64
+	help
+	  This allows you to specify the maximum number of CPUs which this
+	  kernel will support.  The maximum supported value is 32 for 32-bit
+	  kernel and 64 for 64-bit kernels; the minimum value which makes
+	  sense is 1 for Qemu (useful only for kernel debugging purposes)
+	  and 2 for all others.
+
+	  This is purely to save memory - each supported CPU adds
+	  approximately eight kilobytes to the kernel image.  For best
+	  performance should round up your number of processors to the next
+	  power of two.
+
+source "kernel/time/Kconfig"
+
+#
+# Timer Interrupt Frequency Configuration
+#
+
+choice
+	prompt "Timer frequency"
+	default HZ_250
+	help
+	 Allows the configuration of the timer frequency.
+
+	config HZ_48
+		bool "48 HZ" if SYS_SUPPORTS_48HZ || SYS_SUPPORTS_ARBIT_HZ
+
+	config HZ_100
+		bool "100 HZ" if SYS_SUPPORTS_100HZ || SYS_SUPPORTS_ARBIT_HZ
+
+	config HZ_128
+		bool "128 HZ" if SYS_SUPPORTS_128HZ || SYS_SUPPORTS_ARBIT_HZ
+
+	config HZ_250
+		bool "250 HZ" if SYS_SUPPORTS_250HZ || SYS_SUPPORTS_ARBIT_HZ
+
+	config HZ_256
+		bool "256 HZ" if SYS_SUPPORTS_256HZ || SYS_SUPPORTS_ARBIT_HZ
+
+	config HZ_1000
+		bool "1000 HZ" if SYS_SUPPORTS_1000HZ || SYS_SUPPORTS_ARBIT_HZ
+
+	config HZ_1024
+		bool "1024 HZ" if SYS_SUPPORTS_1024HZ || SYS_SUPPORTS_ARBIT_HZ
+
+endchoice
+
+config SYS_SUPPORTS_48HZ
+	bool
+
+config SYS_SUPPORTS_100HZ
+	bool
+
+config SYS_SUPPORTS_128HZ
+	bool
+
+config SYS_SUPPORTS_250HZ
+	bool
+
+config SYS_SUPPORTS_256HZ
+	bool
+
+config SYS_SUPPORTS_1000HZ
+	bool
+
+config SYS_SUPPORTS_1024HZ
+	bool
+
+config SYS_SUPPORTS_ARBIT_HZ
+	bool
+	default y if !SYS_SUPPORTS_48HZ && !SYS_SUPPORTS_100HZ && \
+		     !SYS_SUPPORTS_128HZ && !SYS_SUPPORTS_250HZ && \
+		     !SYS_SUPPORTS_256HZ && !SYS_SUPPORTS_1000HZ && \
+		     !SYS_SUPPORTS_1024HZ
+
+config HZ
+	int
+	default 48 if HZ_48
+	default 100 if HZ_100
+	default 128 if HZ_128
+	default 250 if HZ_250
+	default 256 if HZ_256
+	default 1000 if HZ_1000
+	default 1024 if HZ_1024
+
+source "kernel/Kconfig.preempt"
+
+config MIPS_INSANE_LARGE
+	bool "Support for large 64-bit configurations"
+	depends on CPU_R10000 && 64BIT
+	help
+	  MIPS R10000 does support a 44 bit / 16TB address space as opposed to
+	  previous 64-bit processors which only supported 40 bit / 1TB. If you
+	  need processes of more than 1TB virtual address space, say Y here.
+	  This will result in additional memory usage, so it is not
+	  recommended for normal users.
+
+config KEXEC
+	bool "Kexec system call (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  kexec is a system call that implements the ability to shutdown your
+	  current kernel, and to start another kernel.  It is like a reboot
+	  but it is independent of the system firmware.   And like a reboot
+	  you can start any kernel with it, not just Linux.
+
+	  The name comes from the similarity to the exec system call.
+
+	  It is an ongoing process to be certain the hardware in a machine
+	  is properly shutdown, so do not be surprised if this code does not
+	  initially work for you.  It may help to enable device hotplugging
+	  support.  As of this writing the exact hardware interface is
+	  strongly in flux, so no good recommendation can be made.
+
+config SECCOMP
+	bool "Enable seccomp to safely compute untrusted bytecode"
+	depends on PROC_FS
+	default y
+	help
+	  This kernel feature is useful for number crunching applications
+	  that may need to compute untrusted bytecode during their
+	  execution. By using pipes or other transports made available to
+	  the process as file descriptors supporting the read/write
+	  syscalls, it's possible to isolate those applications in
+	  their own address space using seccomp. Once seccomp is
+	  enabled via /proc/<pid>/seccomp, it cannot be disabled
+	  and the task is only allowed to execute a few safe syscalls
+	  defined by each seccomp mode.
+
+	  If unsure, say Y. Only embedded should say N here.
+
+config USE_OF
+	bool "Flattened Device Tree support"
+	select OF
+	select OF_EARLY_FLATTREE
+	help
+	  Include support for flattened device tree machine descriptions.
+
+endmenu
+
+config LOCKDEP_SUPPORT
+	bool
+	default y
+
+config STACKTRACE_SUPPORT
+	bool
+	default y
+
+source "init/Kconfig"
+
+source "kernel/Kconfig.freezer"
+
+menu "Bus options (PCI, PCMCIA, EISA, ISA, TC)"
+
+config HW_HAS_EISA
+	bool
+config HW_HAS_PCI
+	bool
+
+config PCI
+	bool "Support for PCI controller"
+	depends on HW_HAS_PCI
+	select PCI_DOMAINS
+	help
+	  Find out whether you have a PCI motherboard. PCI is the name of a
+	  bus system, i.e. the way the CPU talks to the other stuff inside
+	  your box. Other bus systems are ISA, EISA, or VESA. If you have PCI,
+	  say Y, otherwise N.
+
+config PCI_DOMAINS
+	bool
+
+source "drivers/pci/Kconfig"
+
+#
+# ISA support is now enabled via select.  Too many systems still have the one
+# or other ISA chip on the board that users don't know about so don't expect
+# users to choose the right thing ...
+#
+config ISA
+	bool
+
+config EISA
+	bool "EISA support"
+	depends on HW_HAS_EISA
+	select ISA
+	select GENERIC_ISA_DMA
+	---help---
+	  The Extended Industry Standard Architecture (EISA) bus was
+	  developed as an open alternative to the IBM MicroChannel bus.
+
+	  The EISA bus provided some of the features of the IBM MicroChannel
+	  bus while maintaining backward compatibility with cards made for
+	  the older ISA bus.  The EISA bus saw limited use between 1988 and
+	  1995 when it was made obsolete by the PCI bus.
+
+	  Say Y here if you are building a kernel for an EISA-based machine.
+
+	  Otherwise, say N.
+
+source "drivers/eisa/Kconfig"
+
+config TC
+	bool "TURBOchannel support"
+	depends on MACH_DECSTATION
+	help
+	  TURBOchannel is a DEC (now Compaq (now HP)) bus for Alpha and MIPS
+	  processors.  TURBOchannel programming specifications are available
+	  at:
+	  <ftp://ftp.hp.com/pub/alphaserver/archive/triadd/>
+	  and:
+	  <http://www.computer-refuge.org/classiccmp/ftp.digital.com/pub/DEC/TriAdd/>
+	  Linux driver support status is documented at:
+	  <http://www.linux-mips.org/wiki/DECstation>
+
+#config ACCESSBUS
+#	bool "Access.Bus support"
+#	depends on TC
+
+config MMU
+	bool
+	default y
+
+config I8253
+	bool
+	select MIPS_EXTERNAL_TIMER
+
+config ZONE_DMA32
+	bool
+
+source "drivers/pcmcia/Kconfig"
+
+source "drivers/pci/hotplug/Kconfig"
+
+config RAPIDIO
+	bool "RapidIO support"
+	depends on PCI
+	default n
+	help
+	  If you say Y here, the kernel will include drivers and
+	  infrastructure code to support RapidIO interconnect devices.
+
+source "drivers/rapidio/Kconfig"
+
+endmenu
+
+menu "Executable file formats"
+
+source "fs/Kconfig.binfmt"
+
+config TRAD_SIGNALS
+	bool
+
+config MIPS32_COMPAT
+	bool "Kernel support for Linux/MIPS 32-bit binary compatibility"
+	depends on 64BIT
+	help
+	  Select this option if you want Linux/MIPS 32-bit binary
+	  compatibility. Since all software available for Linux/MIPS is
+	  currently 32-bit you should say Y here.
+
+config COMPAT
+	bool
+	depends on MIPS32_COMPAT
+	default y
+
+config SYSVIPC_COMPAT
+	bool
+	depends on COMPAT && SYSVIPC
+	default y
+
+config MIPS32_O32
+	bool "Kernel support for o32 binaries"
+	depends on MIPS32_COMPAT
+	help
+	  Select this option if you want to run o32 binaries.  These are pure
+	  32-bit binaries as used by the 32-bit Linux/MIPS port.  Most of
+	  existing binaries are in this format.
+
+	  If unsure, say Y.
+
+config MIPS32_N32
+	bool "Kernel support for n32 binaries"
+	depends on MIPS32_COMPAT
+	help
+	  Select this option if you want to run n32 binaries.  These are
+	  64-bit binaries using 32-bit quantities for addressing and certain
+	  data that would normally be 64-bit.  They are used in special
+	  cases.
+
+	  If unsure, say N.
+
+config BINFMT_ELF32
+	bool
+	default y if MIPS32_O32 || MIPS32_N32
+
+endmenu
+
+menu "Power management options"
+
+config ARCH_HIBERNATION_POSSIBLE
+	def_bool y
+	depends on SYS_SUPPORTS_HOTPLUG_CPU || !SMP
+
+config ARCH_SUSPEND_POSSIBLE
+	def_bool y
+	depends on SYS_SUPPORTS_HOTPLUG_CPU || !SMP
+
+source "kernel/power/Kconfig"
+
+endmenu
+
+source "arch/mips/kernel/cpufreq/Kconfig"
+
+source "net/Kconfig"
+
+source "drivers/Kconfig"
+
+source "fs/Kconfig"
+
+source "arch/mips/Kconfig.debug"
+
+source "security/Kconfig"
+
+source "crypto/Kconfig"
+
+menuconfig VIRTUALIZATION
+	bool "Virtualization"
+	default n
+	---help---
+	  Say Y here to get to see options for using your Linux host to run other
+	  operating systems inside virtual machines (guests).
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and disabled.
+
+if VIRTUALIZATION
+
+source drivers/virtio/Kconfig
+
+endif # VIRTUALIZATION
+
+source "lib/Kconfig"
diff -Nur linux-2.6.39.orig/arch/mips/kernel/traps.c linux-2.6.39/arch/mips/kernel/traps.c
--- linux-2.6.39.orig/arch/mips/kernel/traps.c	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/arch/mips/kernel/traps.c	2011-08-24 05:53:05.179230891 +0200
@@ -54,6 +54,7 @@
 #include <asm/types.h>
 #include <asm/stacktrace.h>
 #include <asm/uasm.h>
+#include <asm/time.h>
 
 extern void check_wait(void);
 extern asmlinkage void r4k_wait(void);
@@ -1576,6 +1577,8 @@
 	if (cpu_has_mips_r2) {
 		cp0_compare_irq_shift = CAUSEB_TI - CAUSEB_IP;
 		cp0_compare_irq = (read_c0_intctl() >> INTCTLB_IPTI) & 7;
+		if (get_c0_compare_irq)
+			cp0_compare_irq = get_c0_compare_irq();
 		cp0_perfcount_irq = (read_c0_intctl() >> INTCTLB_IPPCI) & 7;
 		if (cp0_perfcount_irq == cp0_compare_irq)
 			cp0_perfcount_irq = -1;
diff -Nur linux-2.6.39.orig/arch/mips/Makefile linux-2.6.39/arch/mips/Makefile
--- linux-2.6.39.orig/arch/mips/Makefile	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/arch/mips/Makefile	2011-08-24 02:42:39.917989402 +0200
@@ -158,6 +158,13 @@
 endif
 cflags-$(CONFIG_CAVIUM_CN63XXP1) += -Wa,-mfix-cn63xxp1
 
+#
+# Atheros AR71xx
+#
+core-$(CONFIG_ATHEROS_AR71XX)	+= arch/mips/ar71xx/
+cflags-$(CONFIG_ATHEROS_AR71XX)	+= -I$(srctree)/arch/mips/include/asm/mach-ar71xx
+load-$(CONFIG_ATHEROS_AR71XX)	+= 0xffffffff80060000
+
 cflags-$(CONFIG_CPU_R4000_WORKAROUNDS)	+= $(call cc-option,-mfix-r4000,)
 cflags-$(CONFIG_CPU_R4400_WORKAROUNDS)	+= $(call cc-option,-mfix-r4400,)
 cflags-$(CONFIG_CPU_DADDI_WORKAROUNDS)	+= $(call cc-option,-mno-daddi,)
@@ -174,6 +181,7 @@
 #
 libs-$(CONFIG_ARC)		+= arch/mips/fw/arc/
 libs-$(CONFIG_CFE)		+= arch/mips/fw/cfe/
+libs-$(CONFIG_MYLOADER)		+= arch/mips/fw/myloader/
 libs-$(CONFIG_SNIPROM)		+= arch/mips/fw/sni/
 libs-y				+= arch/mips/fw/lib/
 
diff -Nur linux-2.6.39.orig/arch/mips/pci/Makefile linux-2.6.39/arch/mips/pci/Makefile
--- linux-2.6.39.orig/arch/mips/pci/Makefile	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/arch/mips/pci/Makefile	2011-08-22 16:21:37.437981205 +0200
@@ -18,6 +18,7 @@
 obj-$(CONFIG_BCM47XX)		+= pci-bcm47xx.o
 obj-$(CONFIG_BCM63XX)		+= pci-bcm63xx.o fixup-bcm63xx.o \
 					ops-bcm63xx.o
+obj-$(CONFIG_ATHEROS_AR71XX)	+= pci-ar71xx.o pci-ar724x.o
 
 #
 # These are still pretty much in the old state, watch, go blind.
diff -Nur linux-2.6.39.orig/arch/mips/pci/pci-ar71xx.c linux-2.6.39/arch/mips/pci/pci-ar71xx.c
--- linux-2.6.39.orig/arch/mips/pci/pci-ar71xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/pci/pci-ar71xx.c	2011-08-06 09:32:37.098016752 +0200
@@ -0,0 +1,415 @@
+/*
+ *  Atheros AR71xx PCI host controller driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/resource.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/interrupt.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define DBG(fmt, args...)	printk(KERN_DEBUG fmt, ## args)
+#else
+#define DBG(fmt, args...)
+#endif
+
+#define AR71XX_PCI_DELAY	100 /* msecs */
+
+#if 0
+#define PCI_IDSEL_BASE	PCI_IDSEL_ADL_START
+#else
+#define PCI_IDSEL_BASE	0
+#endif
+
+static void __iomem *ar71xx_pcicfg_base;
+static DEFINE_SPINLOCK(ar71xx_pci_lock);
+static int ar71xx_pci_fixup_enable;
+
+static inline void ar71xx_pci_delay(void)
+{
+	mdelay(AR71XX_PCI_DELAY);
+}
+
+/* Byte lane enable bits */
+static u8 ble_table[4][4] = {
+	{0x0, 0xf, 0xf, 0xf},
+	{0xe, 0xd, 0xb, 0x7},
+	{0xc, 0xf, 0x3, 0xf},
+	{0xf, 0xf, 0xf, 0xf},
+};
+
+static inline u32 ar71xx_pci_get_ble(int where, int size, int local)
+{
+	u32 t;
+
+	t = ble_table[size & 3][where & 3];
+	BUG_ON(t == 0xf);
+	t <<= (local) ? 20 : 4;
+	return t;
+}
+
+static inline u32 ar71xx_pci_bus_addr(struct pci_bus *bus, unsigned int devfn,
+					int where)
+{
+	u32 ret;
+
+	if (!bus->number) {
+		/* type 0 */
+		ret = (1 << (PCI_IDSEL_BASE + PCI_SLOT(devfn)))
+		    | (PCI_FUNC(devfn) << 8) | (where & ~3);
+	} else {
+		/* type 1 */
+		ret = (bus->number << 16) | (PCI_SLOT(devfn) << 11)
+		    | (PCI_FUNC(devfn) << 8) | (where & ~3) | 1;
+	}
+
+	return ret;
+}
+
+int ar71xx_pci_be_handler(int is_fixup)
+{
+	void __iomem *base = ar71xx_pcicfg_base;
+	u32 pci_err;
+	u32 ahb_err;
+
+	pci_err = __raw_readl(base + PCI_REG_PCI_ERR) & 3;
+	if (pci_err) {
+		if (!is_fixup)
+			printk(KERN_ALERT "PCI error %d at PCI addr 0x%x\n",
+				pci_err,
+				__raw_readl(base + PCI_REG_PCI_ERR_ADDR));
+
+		__raw_writel(pci_err, base + PCI_REG_PCI_ERR);
+	}
+
+	ahb_err = __raw_readl(base + PCI_REG_AHB_ERR) & 1;
+	if (ahb_err) {
+		if (!is_fixup)
+			printk(KERN_ALERT "AHB error at AHB address 0x%x\n",
+				__raw_readl(base + PCI_REG_AHB_ERR_ADDR));
+
+		__raw_writel(ahb_err, base + PCI_REG_AHB_ERR);
+	}
+
+	return (ahb_err | pci_err) ? 1 : 0;
+}
+
+static inline int ar71xx_pci_set_cfgaddr(struct pci_bus *bus,
+			unsigned int devfn, int where, int size, u32 cmd)
+{
+	void __iomem *base = ar71xx_pcicfg_base;
+	u32 addr;
+
+	addr = ar71xx_pci_bus_addr(bus, devfn, where);
+
+	DBG("PCI: set cfgaddr: %02x:%02x.%01x/%02x:%01d, addr=%08x\n",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, addr);
+
+	__raw_writel(addr, base + PCI_REG_CFG_AD);
+	__raw_writel(cmd | ar71xx_pci_get_ble(where, size, 0),
+		     base + PCI_REG_CFG_CBE);
+
+	return ar71xx_pci_be_handler(1);
+}
+
+static int ar71xx_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 *value)
+{
+	void __iomem *base = ar71xx_pcicfg_base;
+	static u32 mask[8] = {0, 0xff, 0xffff, 0, 0xffffffff, 0, 0, 0};
+	unsigned long flags;
+	u32 data;
+	int retry = 0;
+	int ret;
+
+	ret = PCIBIOS_SUCCESSFUL;
+
+	DBG("PCI: read config: %02x:%02x.%01x/%02x:%01d\n", bus->number,
+			PCI_SLOT(devfn), PCI_FUNC(devfn), where, size);
+
+retry:
+	spin_lock_irqsave(&ar71xx_pci_lock, flags);
+
+	if (bus->number == 0 && devfn == 0) {
+		u32 t;
+
+		t = PCI_CRP_CMD_READ | (where & ~3);
+
+		__raw_writel(t, base + PCI_REG_CRP_AD_CBE);
+		data = __raw_readl(base + PCI_REG_CRP_RDDATA);
+
+		DBG("PCI: rd local cfg, ad_cbe:%08x, data:%08x\n", t, data);
+
+	} else {
+		int err;
+
+		err = ar71xx_pci_set_cfgaddr(bus, devfn, where, size,
+						PCI_CFG_CMD_READ);
+
+		if (err == 0) {
+			data = __raw_readl(base + PCI_REG_CFG_RDDATA);
+		} else {
+			ret = PCIBIOS_DEVICE_NOT_FOUND;
+			data = ~0;
+		}
+	}
+
+	spin_unlock_irqrestore(&ar71xx_pci_lock, flags);
+
+	DBG("PCI: read config: data=%08x raw=%08x\n",
+		(data >> (8 * (where & 3))) & mask[size & 7], data);
+
+	*value = (data >> (8 * (where & 3))) & mask[size & 7];
+
+	/*
+	 * PCI controller bug: sometimes reads to the PCI_COMMAND register
+	 * return 0xffff, even though the PCI trace shows the correct value.
+	 * Work around this by retrying reads to this register
+	 */
+	if (where == PCI_COMMAND && (*value & 0xffff) == 0xffff && retry++ < 2)
+		goto retry;
+
+	return ret;
+}
+
+static int ar71xx_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+				   int where, int size, u32 value)
+{
+	void __iomem *base = ar71xx_pcicfg_base;
+	unsigned long flags;
+	int ret;
+
+	DBG("PCI: write config: %02x:%02x.%01x/%02x:%01d value=%08x\n",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, value);
+
+	value = value << (8 * (where & 3));
+	ret = PCIBIOS_SUCCESSFUL;
+
+	spin_lock_irqsave(&ar71xx_pci_lock, flags);
+	if (bus->number == 0 && devfn == 0) {
+		u32 t;
+
+		t = PCI_CRP_CMD_WRITE | (where & ~3);
+		t |= ar71xx_pci_get_ble(where, size, 1);
+
+		DBG("PCI: wr local cfg, ad_cbe:%08x, value:%08x\n", t, value);
+
+		__raw_writel(t, base + PCI_REG_CRP_AD_CBE);
+		__raw_writel(value, base + PCI_REG_CRP_WRDATA);
+	} else {
+		int err;
+
+		err = ar71xx_pci_set_cfgaddr(bus, devfn, where, size,
+						PCI_CFG_CMD_WRITE);
+
+		if (err == 0)
+			__raw_writel(value, base + PCI_REG_CFG_WRDATA);
+		else
+			ret = PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	spin_unlock_irqrestore(&ar71xx_pci_lock, flags);
+
+	return ret;
+}
+
+static void ar71xx_pci_fixup(struct pci_dev *dev)
+{
+	u32 t;
+
+	if (!ar71xx_pci_fixup_enable)
+		return;
+
+	if (dev->bus->number != 0 || dev->devfn != 0)
+		return;
+
+	DBG("PCI: fixup host controller %s (%04x:%04x)\n", pci_name(dev),
+		dev->vendor, dev->device);
+
+	/* setup COMMAND register */
+	t = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE
+	  | PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;
+
+	pci_write_config_word(dev, PCI_COMMAND, t);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, ar71xx_pci_fixup);
+
+int __init ar71xx_pcibios_map_irq(const struct pci_dev *dev, uint8_t slot,
+				  uint8_t pin)
+{
+	int irq = -1;
+	int i;
+
+	slot -= PCI_IDSEL_ADL_START - PCI_IDSEL_BASE;
+
+	for (i = 0; i < ar71xx_pci_nr_irqs; i++) {
+		struct ar71xx_pci_irq *entry;
+
+		entry = &ar71xx_pci_irq_map[i];
+		if (entry->slot == slot && entry->pin == pin) {
+			irq = entry->irq;
+			break;
+		}
+	}
+
+	if (irq < 0) {
+		printk(KERN_ALERT "PCI: no irq found for pin%u@%s\n",
+				pin, pci_name((struct pci_dev *)dev));
+	} else {
+		printk(KERN_INFO "PCI: mapping irq %d to pin%u@%s\n",
+				irq, pin, pci_name((struct pci_dev *)dev));
+	}
+
+	return irq;
+}
+
+static struct pci_ops ar71xx_pci_ops = {
+	.read	= ar71xx_pci_read_config,
+	.write	= ar71xx_pci_write_config,
+};
+
+static struct resource ar71xx_pci_io_resource = {
+	.name		= "PCI IO space",
+	.start		= 0,
+	.end		= 0,
+	.flags		= IORESOURCE_IO,
+};
+
+static struct resource ar71xx_pci_mem_resource = {
+	.name		= "PCI memory space",
+	.start		= AR71XX_PCI_MEM_BASE,
+	.end		= AR71XX_PCI_MEM_BASE + AR71XX_PCI_MEM_SIZE - 1,
+	.flags		= IORESOURCE_MEM
+};
+
+static struct pci_controller ar71xx_pci_controller = {
+	.pci_ops	= &ar71xx_pci_ops,
+	.mem_resource	= &ar71xx_pci_mem_resource,
+	.io_resource	= &ar71xx_pci_io_resource,
+};
+
+static void ar71xx_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	void __iomem *base = ar71xx_reset_base;
+	u32 pending;
+
+	pending = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_STATUS) &
+		  __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	if (pending & PCI_INT_DEV0)
+		generic_handle_irq(AR71XX_PCI_IRQ_DEV0);
+
+	else if (pending & PCI_INT_DEV1)
+		generic_handle_irq(AR71XX_PCI_IRQ_DEV1);
+
+	else if (pending & PCI_INT_DEV2)
+		generic_handle_irq(AR71XX_PCI_IRQ_DEV2);
+
+	else if (pending & PCI_INT_CORE)
+		generic_handle_irq(AR71XX_PCI_IRQ_CORE);
+
+	else
+		spurious_interrupt();
+}
+
+static void ar71xx_pci_irq_unmask(struct irq_data *d)
+{
+	unsigned int irq = d->irq - AR71XX_PCI_IRQ_BASE;
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+	__raw_writel(t | (1 << irq), base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+}
+
+static void ar71xx_pci_irq_mask(struct irq_data *d)
+{
+	unsigned int irq = d->irq - AR71XX_PCI_IRQ_BASE;
+	void __iomem *base = ar71xx_reset_base;
+	u32 t;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+	__raw_writel(t & ~(1 << irq), base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	/* flush write */
+	(void) __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+}
+
+static struct irq_chip ar71xx_pci_irq_chip = {
+	.name		= "AR71XX PCI ",
+	.irq_mask	= ar71xx_pci_irq_mask,
+	.irq_unmask	= ar71xx_pci_irq_unmask,
+	.irq_mask_ack	= ar71xx_pci_irq_mask,
+};
+
+static void __init ar71xx_pci_irq_init(void)
+{
+	void __iomem *base = ar71xx_reset_base;
+	int i;
+
+	__raw_writel(0, base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+	__raw_writel(0, base + AR71XX_RESET_REG_PCI_INT_STATUS);
+
+	for (i = AR71XX_PCI_IRQ_BASE;
+	     i < AR71XX_PCI_IRQ_BASE + AR71XX_PCI_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ar71xx_pci_irq_chip,
+					 handle_level_irq);
+
+	irq_set_chained_handler(AR71XX_CPU_IRQ_IP2, ar71xx_pci_irq_handler);
+}
+
+int __init ar71xx_pcibios_init(void)
+{
+	void __iomem *ddr_base = ar71xx_ddr_base;
+
+	ar71xx_device_stop(RESET_MODULE_PCI_BUS | RESET_MODULE_PCI_CORE);
+	ar71xx_pci_delay();
+
+	ar71xx_device_start(RESET_MODULE_PCI_BUS | RESET_MODULE_PCI_CORE);
+	ar71xx_pci_delay();
+
+	ar71xx_pcicfg_base = ioremap_nocache(AR71XX_PCI_CFG_BASE,
+						AR71XX_PCI_CFG_SIZE);
+	if (ar71xx_pcicfg_base == NULL)
+		return -ENOMEM;
+
+	__raw_writel(PCI_WIN0_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN0);
+	__raw_writel(PCI_WIN1_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN1);
+	__raw_writel(PCI_WIN2_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN2);
+	__raw_writel(PCI_WIN3_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN3);
+	__raw_writel(PCI_WIN4_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN4);
+	__raw_writel(PCI_WIN5_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN5);
+	__raw_writel(PCI_WIN6_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN6);
+	__raw_writel(PCI_WIN7_OFFS, ddr_base + AR71XX_DDR_REG_PCI_WIN7);
+
+	ar71xx_pci_delay();
+
+	/* clear bus errors */
+	(void)ar71xx_pci_be_handler(1);
+
+	ar71xx_pci_fixup_enable = 1;
+	ar71xx_pci_irq_init();
+	register_pci_controller(&ar71xx_pci_controller);
+
+	return 0;
+}
diff -Nur linux-2.6.39.orig/arch/mips/pci/pci-ar724x.c linux-2.6.39/arch/mips/pci/pci-ar724x.c
--- linux-2.6.39.orig/arch/mips/pci/pci-ar724x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/arch/mips/pci/pci-ar724x.c	2011-08-06 09:32:37.088017079 +0200
@@ -0,0 +1,389 @@
+/*
+ *  Atheros AR724x PCI host controller driver
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/resource.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/interrupt.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define DBG(fmt, args...)	printk(KERN_INFO fmt, ## args)
+#else
+#define DBG(fmt, args...)
+#endif
+
+static void __iomem *ar724x_pci_localcfg_base;
+static void __iomem *ar724x_pci_devcfg_base;
+static void __iomem *ar724x_pci_ctrl_base;
+static int ar724x_pci_fixup_enable;
+
+static DEFINE_SPINLOCK(ar724x_pci_lock);
+
+static void ar724x_pci_read(void __iomem *base, int where, int size, u32 *value)
+{
+	unsigned long flags;
+	u32 data;
+
+	spin_lock_irqsave(&ar724x_pci_lock, flags);
+	data = __raw_readl(base + (where & ~3));
+
+	switch (size) {
+	case 1:
+		if (where & 1)
+			data >>= 8;
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFF;
+		break;
+	case 2:
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFFFF;
+		break;
+	}
+
+	*value = data;
+	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
+}
+
+static void ar724x_pci_write(void __iomem *base, int where, int size, u32 value)
+{
+	unsigned long flags;
+	u32 data;
+	int s;
+
+	spin_lock_irqsave(&ar724x_pci_lock, flags);
+	data = __raw_readl(base + (where & ~3));
+
+	switch (size) {
+	case 1:
+		s = ((where & 3) << 3);
+		data &= ~(0xFF << s);
+		data |= ((value & 0xFF) << s);
+		break;
+	case 2:
+		s = ((where & 2) << 3);
+		data &= ~(0xFFFF << s);
+		data |= ((value & 0xFFFF) << s);
+		break;
+	case 4:
+		data = value;
+		break;
+	}
+
+	__raw_writel(data, base + (where & ~3));
+	/* flush write */
+	(void)__raw_readl(base + (where & ~3));
+	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
+}
+
+static int ar724x_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 *value)
+{
+
+	if (bus->number != 0 || devfn != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	ar724x_pci_read(ar724x_pci_devcfg_base, where, size, value);
+
+	DBG("PCI: read config: %02x:%02x.%01x/%02x:%01d, value=%08x\n",
+			bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+			where, size, *value);
+
+	/*
+	 * WAR for BAR issue - We are unable to access the PCI device space
+	 * if we set the BAR with proper base address
+	 */
+	if ((where == 0x10) && (size == 4)) {
+		u32 val;
+		val = (ar71xx_soc == AR71XX_SOC_AR7240) ? 0xffff : 0x1000ffff;
+		ar724x_pci_write(ar724x_pci_devcfg_base, where, size, val);
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ar724x_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+				   int where, int size, u32 value)
+{
+	if (bus->number != 0 || devfn != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	DBG("PCI: write config: %02x:%02x.%01x/%02x:%01d, value=%08x\n",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, value);
+
+	ar724x_pci_write(ar724x_pci_devcfg_base, where, size, value);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static void ar724x_pci_fixup(struct pci_dev *dev)
+{
+	u16 cmd;
+
+	if (!ar724x_pci_fixup_enable)
+		return;
+
+	if (dev->bus->number != 0 || dev->devfn != 0)
+		return;
+
+	/* setup COMMAND register */
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
+	       PCI_COMMAND_INVALIDATE | PCI_COMMAND_PARITY | PCI_COMMAND_SERR |
+	       PCI_COMMAND_FAST_BACK;
+
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, ar724x_pci_fixup);
+
+int __init ar724x_pcibios_map_irq(const struct pci_dev *dev, uint8_t slot,
+				  uint8_t pin)
+{
+	int irq = -1;
+	int i;
+
+	for (i = 0; i < ar71xx_pci_nr_irqs; i++) {
+		struct ar71xx_pci_irq *entry;
+		entry = &ar71xx_pci_irq_map[i];
+
+		if (entry->slot == slot && entry->pin == pin) {
+			irq = entry->irq;
+			break;
+		}
+	}
+
+	if (irq < 0)
+		printk(KERN_ALERT "PCI: no irq found for pin%u@%s\n",
+				pin, pci_name((struct pci_dev *)dev));
+	else
+		printk(KERN_INFO "PCI: mapping irq %d to pin%u@%s\n",
+				irq, pin, pci_name((struct pci_dev *)dev));
+
+	return irq;
+}
+
+static struct pci_ops ar724x_pci_ops = {
+	.read	= ar724x_pci_read_config,
+	.write	= ar724x_pci_write_config,
+};
+
+static struct resource ar724x_pci_io_resource = {
+	.name		= "PCI IO space",
+	.start		= 0,
+	.end		= 0,
+	.flags		= IORESOURCE_IO,
+};
+
+static struct resource ar724x_pci_mem_resource = {
+	.name		= "PCI memory space",
+	.start		= AR71XX_PCI_MEM_BASE,
+	.end		= AR71XX_PCI_MEM_BASE + AR71XX_PCI_MEM_SIZE - 1,
+	.flags		= IORESOURCE_MEM
+};
+
+static struct pci_controller ar724x_pci_controller = {
+	.pci_ops	= &ar724x_pci_ops,
+	.mem_resource	= &ar724x_pci_mem_resource,
+	.io_resource	= &ar724x_pci_io_resource,
+};
+
+static void __init ar724x_pci_reset(void)
+{
+	ar71xx_device_stop(AR724X_RESET_PCIE);
+	ar71xx_device_stop(AR724X_RESET_PCIE_PHY);
+	ar71xx_device_stop(AR724X_RESET_PCIE_PHY_SERIAL);
+	udelay(100);
+
+	ar71xx_device_start(AR724X_RESET_PCIE_PHY_SERIAL);
+	udelay(100);
+	ar71xx_device_start(AR724X_RESET_PCIE_PHY);
+	ar71xx_device_start(AR724X_RESET_PCIE);
+}
+
+static int __init ar724x_pci_setup(void)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 t;
+
+	/* setup COMMAND register */
+	t = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+	    PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+	ar724x_pci_write(ar724x_pci_localcfg_base, PCI_COMMAND, 4, t);
+	ar724x_pci_write(ar724x_pci_localcfg_base, 0x20, 4, 0x1ff01000);
+	ar724x_pci_write(ar724x_pci_localcfg_base, 0x24, 4, 0x1ff01000);
+
+	t = __raw_readl(base + AR724X_PCI_REG_RESET);
+	if (t != 0x7) {
+		udelay(100000);
+		__raw_writel(0, base + AR724X_PCI_REG_RESET);
+		udelay(100);
+		__raw_writel(4, base + AR724X_PCI_REG_RESET);
+		udelay(100000);
+	}
+
+	if (ar71xx_soc == AR71XX_SOC_AR7240)
+		t = AR724X_PCI_APP_LTSSM_ENABLE;
+	else
+		t = 0x1ffc1;
+	__raw_writel(t, base + AR724X_PCI_REG_APP);
+	/* flush write */
+	(void) __raw_readl(base + AR724X_PCI_REG_APP);
+	udelay(1000);
+
+	t = __raw_readl(base + AR724X_PCI_REG_RESET);
+	if ((t & AR724X_PCI_RESET_LINK_UP) == 0x0) {
+		printk(KERN_WARNING "PCI: no PCIe module found\n");
+		return -ENODEV;
+	}
+
+	if (ar71xx_soc == AR71XX_SOC_AR7241 ||
+	    ar71xx_soc == AR71XX_SOC_AR7242) {
+		t = __raw_readl(base + AR724X_PCI_REG_APP);
+		t |= BIT(16);
+		__raw_writel(t, base + AR724X_PCI_REG_APP);
+	}
+
+	return 0;
+}
+
+static void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 pending;
+
+	pending = __raw_readl(base + AR724X_PCI_REG_INT_STATUS) &
+		  __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+
+	if (pending & AR724X_PCI_INT_DEV0)
+		generic_handle_irq(AR71XX_PCI_IRQ_DEV0);
+
+	else
+		spurious_interrupt();
+}
+
+static void ar724x_pci_irq_unmask(struct irq_data *d)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 t;
+
+	switch (d->irq) {
+	case AR71XX_PCI_IRQ_DEV0:
+		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+		__raw_writel(t | AR724X_PCI_INT_DEV0,
+			     base + AR724X_PCI_REG_INT_MASK);
+		/* flush write */
+		(void) __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+	}
+}
+
+static void ar724x_pci_irq_mask(struct irq_data *d)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 t;
+
+	switch (d->irq) {
+	case AR71XX_PCI_IRQ_DEV0:
+		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+		__raw_writel(t & ~AR724X_PCI_INT_DEV0,
+			     base + AR724X_PCI_REG_INT_MASK);
+
+		/* flush write */
+		(void) __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+
+		t = __raw_readl(base + AR724X_PCI_REG_INT_STATUS);
+		__raw_writel(t | AR724X_PCI_INT_DEV0,
+			     base + AR724X_PCI_REG_INT_STATUS);
+
+		/* flush write */
+		(void) __raw_readl(base + AR724X_PCI_REG_INT_STATUS);
+	}
+}
+
+static struct irq_chip ar724x_pci_irq_chip = {
+	.name		= "AR724X PCI ",
+	.irq_mask	= ar724x_pci_irq_mask,
+	.irq_unmask	= ar724x_pci_irq_unmask,
+	.irq_mask_ack	= ar724x_pci_irq_mask,
+};
+
+static void __init ar724x_pci_irq_init(void)
+{
+	void __iomem *base = ar724x_pci_ctrl_base;
+	u32 t;
+	int i;
+
+	t = ar71xx_reset_rr(AR724X_RESET_REG_RESET_MODULE);
+	if (t & (AR724X_RESET_PCIE | AR724X_RESET_PCIE_PHY |
+		 AR724X_RESET_PCIE_PHY_SERIAL)) {
+		return;
+	}
+
+	__raw_writel(0, base + AR724X_PCI_REG_INT_MASK);
+	__raw_writel(0, base + AR724X_PCI_REG_INT_STATUS);
+
+	for (i = AR71XX_PCI_IRQ_BASE;
+	     i < AR71XX_PCI_IRQ_BASE + AR71XX_PCI_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ar724x_pci_irq_chip,
+					 handle_level_irq);
+
+	irq_set_chained_handler(AR71XX_CPU_IRQ_IP2, ar724x_pci_irq_handler);
+}
+
+int __init ar724x_pcibios_init(void)
+{
+	int ret = -ENOMEM;
+
+	ar724x_pci_localcfg_base = ioremap_nocache(AR724X_PCI_CRP_BASE,
+						   AR724X_PCI_CRP_SIZE);
+	if (ar724x_pci_localcfg_base == NULL)
+		goto err;
+
+	ar724x_pci_devcfg_base = ioremap_nocache(AR724X_PCI_CFG_BASE,
+						 AR724X_PCI_CFG_SIZE);
+	if (ar724x_pci_devcfg_base == NULL)
+		goto err_unmap_localcfg;
+
+	ar724x_pci_ctrl_base = ioremap_nocache(AR724X_PCI_CTRL_BASE,
+					       AR724X_PCI_CTRL_SIZE);
+	if (ar724x_pci_ctrl_base == NULL)
+		goto err_unmap_devcfg;
+
+	ar724x_pci_reset();
+	ret = ar724x_pci_setup();
+	if (ret)
+		goto err_unmap_ctrl;
+
+	ar724x_pci_fixup_enable = 1;
+	ar724x_pci_irq_init();
+	register_pci_controller(&ar724x_pci_controller);
+
+	return 0;
+
+err_unmap_ctrl:
+	iounmap(ar724x_pci_ctrl_base);
+err_unmap_devcfg:
+	iounmap(ar724x_pci_devcfg_base);
+err_unmap_localcfg:
+	iounmap(ar724x_pci_localcfg_base);
+err:
+	return ret;
+}
diff -Nur linux-2.6.39.orig/drivers/gpio/nxp_74hc153.c linux-2.6.39/drivers/gpio/nxp_74hc153.c
--- linux-2.6.39.orig/drivers/gpio/nxp_74hc153.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/gpio/nxp_74hc153.c	2011-04-27 12:19:22.327664626 +0200
@@ -0,0 +1,247 @@
+/*
+ *  NXP 74HC153 - Dual 4-input multiplexer GPIO driver
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/nxp_74hc153.h>
+
+#define NXP_74HC153_NUM_GPIOS	8
+#define NXP_74HC153_S0_MASK	0x1
+#define NXP_74HC153_S1_MASK	0x2
+#define NXP_74HC153_BANK_MASK	0x4
+
+struct nxp_74hc153_chip {
+	struct device		*parent;
+	struct gpio_chip	gpio_chip;
+	struct mutex		lock;
+};
+
+static struct nxp_74hc153_chip *gpio_to_nxp(struct gpio_chip *gc)
+{
+	return container_of(gc, struct nxp_74hc153_chip, gpio_chip);
+}
+
+static int nxp_74hc153_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	return 0;
+}
+
+static int nxp_74hc153_direction_output(struct gpio_chip *gc,
+					unsigned offset, int val)
+{
+	return -EINVAL;
+}
+
+static int nxp_74hc153_get_value(struct gpio_chip *gc, unsigned offset)
+{
+	struct nxp_74hc153_chip *nxp;
+	struct nxp_74hc153_platform_data *pdata;
+	unsigned s0;
+	unsigned s1;
+	unsigned pin;
+	int ret;
+
+	nxp = gpio_to_nxp(gc);
+	pdata = nxp->parent->platform_data;
+
+	s0 = !!(offset & NXP_74HC153_S0_MASK);
+	s1 = !!(offset & NXP_74HC153_S1_MASK);
+	pin = (offset & NXP_74HC153_BANK_MASK) ? pdata->gpio_pin_2y
+					       : pdata->gpio_pin_1y;
+
+	mutex_lock(&nxp->lock);
+	gpio_set_value(pdata->gpio_pin_s0, s0);
+	gpio_set_value(pdata->gpio_pin_s1, s1);
+	ret = gpio_get_value(pin);
+	mutex_unlock(&nxp->lock);
+
+	return ret;
+}
+
+static void nxp_74hc153_set_value(struct gpio_chip *gc,
+				  unsigned offset, int val)
+{
+	/* not supported */
+}
+
+static int __devinit nxp_74hc153_probe(struct platform_device *pdev)
+{
+	struct nxp_74hc153_platform_data *pdata;
+	struct nxp_74hc153_chip *nxp;
+	struct gpio_chip *gc;
+	int err;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) {
+		dev_dbg(&pdev->dev, "no platform data specified\n");
+		return -EINVAL;
+	}
+
+	nxp = kzalloc(sizeof(struct nxp_74hc153_chip), GFP_KERNEL);
+	if (nxp == NULL) {
+		dev_err(&pdev->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	err = gpio_request(pdata->gpio_pin_s0, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_s0, err);
+		goto err_free_nxp;
+	}
+
+	err = gpio_request(pdata->gpio_pin_s1, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_s1, err);
+		goto err_free_s0;
+	}
+
+	err = gpio_request(pdata->gpio_pin_1y, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_1y, err);
+		goto err_free_s1;
+	}
+
+	err = gpio_request(pdata->gpio_pin_2y, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_2y, err);
+		goto err_free_1y;
+	}
+
+	err = gpio_direction_output(pdata->gpio_pin_s0, 0);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_s0, err);
+		goto err_free_2y;
+	}
+
+	err = gpio_direction_output(pdata->gpio_pin_s1, 0);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_s1, err);
+		goto err_free_2y;
+	}
+
+	err = gpio_direction_input(pdata->gpio_pin_1y);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_1y, err);
+		goto err_free_2y;
+	}
+
+	err = gpio_direction_input(pdata->gpio_pin_2y);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_2y, err);
+		goto err_free_2y;
+	}
+
+	nxp->parent = &pdev->dev;
+	mutex_init(&nxp->lock);
+
+	gc = &nxp->gpio_chip;
+
+	gc->direction_input  = nxp_74hc153_direction_input;
+	gc->direction_output = nxp_74hc153_direction_output;
+	gc->get = nxp_74hc153_get_value;
+	gc->set = nxp_74hc153_set_value;
+	gc->can_sleep = 1;
+
+	gc->base = pdata->gpio_base;
+	gc->ngpio = NXP_74HC153_NUM_GPIOS;
+	gc->label = dev_name(nxp->parent);
+	gc->dev = nxp->parent;
+	gc->owner = THIS_MODULE;
+
+	err = gpiochip_add(&nxp->gpio_chip);
+	if (err) {
+		dev_err(&pdev->dev, "unable to add gpio chip, err=%d\n", err);
+		goto err_free_2y;
+	}
+
+	platform_set_drvdata(pdev, nxp);
+	return 0;
+
+err_free_2y:
+	gpio_free(pdata->gpio_pin_2y);
+err_free_1y:
+	gpio_free(pdata->gpio_pin_1y);
+err_free_s1:
+	gpio_free(pdata->gpio_pin_s1);
+err_free_s0:
+	gpio_free(pdata->gpio_pin_s0);
+err_free_nxp:
+	kfree(nxp);
+	return err;
+}
+
+static int nxp_74hc153_remove(struct platform_device *pdev)
+{
+	struct nxp_74hc153_chip *nxp = platform_get_drvdata(pdev);
+	struct nxp_74hc153_platform_data *pdata = pdev->dev.platform_data;
+
+	if (nxp) {
+		int err;
+
+		err = gpiochip_remove(&nxp->gpio_chip);
+		if (err) {
+			dev_err(&pdev->dev,
+				"unable to remove gpio chip, err=%d\n",
+				err);
+			return err;
+		}
+
+		gpio_free(pdata->gpio_pin_2y);
+		gpio_free(pdata->gpio_pin_1y);
+		gpio_free(pdata->gpio_pin_s1);
+		gpio_free(pdata->gpio_pin_s0);
+
+		kfree(nxp);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver nxp_74hc153_driver = {
+	.probe		= nxp_74hc153_probe,
+	.remove		= __devexit_p(nxp_74hc153_remove),
+	.driver = {
+		.name	= NXP_74HC153_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init nxp_74hc153_init(void)
+{
+	return platform_driver_register(&nxp_74hc153_driver);
+}
+subsys_initcall(nxp_74hc153_init);
+
+static void __exit nxp_74hc153_exit(void)
+{
+	platform_driver_unregister(&nxp_74hc153_driver);
+}
+module_exit(nxp_74hc153_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("GPIO expander driver for NXP 74HC153");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" NXP_74HC153_DRIVER_NAME);
diff -Nur linux-2.6.39.orig/drivers/leds/leds-rb750.c linux-2.6.39/drivers/leds/leds-rb750.c
--- linux-2.6.39.orig/drivers/leds/leds-rb750.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/leds/leds-rb750.c	2011-04-27 12:19:22.267661616 +0200
@@ -0,0 +1,141 @@
+/*
+ * LED driver for the RouterBOARD 750
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ar71xx/mach-rb750.h>
+
+#define DRV_NAME	"leds-rb750"
+
+struct rb750_led_dev {
+	struct led_classdev	cdev;
+	u32			mask;
+	int			active_low;
+};
+
+struct rb750_led_drvdata {
+	struct rb750_led_dev	*led_devs;
+	int			num_leds;
+};
+
+static inline struct rb750_led_dev *to_rbled(struct led_classdev *led_cdev)
+{
+	return (struct rb750_led_dev *)container_of(led_cdev,
+		struct rb750_led_dev, cdev);
+}
+
+static void rb750_led_brightness_set(struct led_classdev *led_cdev,
+				     enum led_brightness value)
+{
+	struct rb750_led_dev *rbled = to_rbled(led_cdev);
+	int level;
+
+	level = (value == LED_OFF) ? 0 : 1;
+	level ^= rbled->active_low;
+
+	if (level)
+		rb750_latch_change(0, rbled->mask);
+	else
+		rb750_latch_change(rbled->mask, 0);
+}
+
+static int __devinit rb750_led_probe(struct platform_device *pdev)
+{
+	struct rb750_led_platform_data *pdata;
+	struct rb750_led_drvdata *drvdata;
+	int ret = 0;
+	int i;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata)
+		return -EINVAL;
+
+	drvdata = kzalloc(sizeof(struct rb750_led_drvdata) +
+			  sizeof(struct rb750_led_dev) * pdata->num_leds,
+			  GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+
+	drvdata->num_leds = pdata->num_leds;
+	drvdata->led_devs = (struct rb750_led_dev *) &drvdata[1];
+
+	for (i = 0; i < drvdata->num_leds; i++) {
+		struct rb750_led_dev *rbled = &drvdata->led_devs[i];
+		struct rb750_led_data *led_data = &pdata->leds[i];
+
+		rbled->cdev.name = led_data->name;
+		rbled->cdev.default_trigger = led_data->default_trigger;
+		rbled->cdev.brightness_set = rb750_led_brightness_set;
+		rbled->cdev.brightness = LED_OFF;
+
+		rbled->mask = led_data->mask;
+		rbled->active_low = !!led_data->active_low;
+
+		ret = led_classdev_register(&pdev->dev, &rbled->cdev);
+		if (ret)
+			goto err;
+	}
+
+	platform_set_drvdata(pdev, drvdata);
+	return 0;
+
+err:
+	for (i = i - 1; i >= 0; i--)
+		led_classdev_unregister(&drvdata->led_devs[i].cdev);
+
+	kfree(drvdata);
+	return ret;
+}
+
+static int __devexit rb750_led_remove(struct platform_device *pdev)
+{
+	struct rb750_led_drvdata *drvdata;
+	int i;
+
+	drvdata = platform_get_drvdata(pdev);
+	for (i = 0; i < drvdata->num_leds; i++)
+		led_classdev_unregister(&drvdata->led_devs[i].cdev);
+
+	kfree(drvdata);
+	return 0;
+}
+
+static struct platform_driver rb750_led_driver = {
+	.probe		= rb750_led_probe,
+	.remove		= __devexit_p(rb750_led_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:leds-rb750");
+
+static int __init rb750_led_init(void)
+{
+	return platform_driver_register(&rb750_led_driver);
+}
+
+static void __exit rb750_led_exit(void)
+{
+	platform_driver_unregister(&rb750_led_driver);
+}
+
+module_init(rb750_led_init);
+module_exit(rb750_led_exit);
+
+MODULE_DESCRIPTION(DRV_NAME);
+MODULE_DESCRIPTION("LED driver for the RouterBOARD 750");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.39.orig/drivers/leds/leds-wndr3700-usb.c linux-2.6.39/drivers/leds/leds-wndr3700-usb.c
--- linux-2.6.39.orig/drivers/leds/leds-wndr3700-usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/leds/leds-wndr3700-usb.c	2011-04-27 12:19:22.267661616 +0200
@@ -0,0 +1,75 @@
+/*
+ *  USB LED driver for the NETGEAR WNDR3700
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#define DRIVER_NAME	"wndr3700-led-usb"
+
+static void wndr3700_usb_led_set(struct led_classdev *cdev,
+				 enum led_brightness brightness)
+{
+	if (brightness)
+		ar71xx_device_start(RESET_MODULE_GE1_PHY);
+	else
+		ar71xx_device_stop(RESET_MODULE_GE1_PHY);
+}
+
+static enum led_brightness wndr3700_usb_led_get(struct led_classdev *cdev)
+{
+	return ar71xx_device_stopped(RESET_MODULE_GE1_PHY) ? LED_OFF : LED_FULL;
+}
+
+static struct led_classdev wndr3700_usb_led = {
+	.name = "wndr3700:green:usb",
+	.brightness_set = wndr3700_usb_led_set,
+	.brightness_get = wndr3700_usb_led_get,
+};
+
+static int __devinit wndr3700_usb_led_probe(struct platform_device *pdev)
+{
+	return led_classdev_register(&pdev->dev, &wndr3700_usb_led);
+}
+
+static int __devexit wndr3700_usb_led_remove(struct platform_device *pdev)
+{
+	led_classdev_unregister(&wndr3700_usb_led);
+	return 0;
+}
+
+static struct platform_driver wndr3700_usb_led_driver = {
+	.probe = wndr3700_usb_led_probe,
+	.remove = __devexit_p(wndr3700_usb_led_remove),
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init wndr3700_usb_led_init(void)
+{
+	return platform_driver_register(&wndr3700_usb_led_driver);
+}
+
+static void __exit wndr3700_usb_led_exit(void)
+{
+	platform_driver_unregister(&wndr3700_usb_led_driver);
+}
+
+module_init(wndr3700_usb_led_init);
+module_exit(wndr3700_usb_led_exit);
+
+MODULE_DESCRIPTION("USB LED driver for the NETGEAR WNDR3700");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Nur linux-2.6.39.orig/drivers/Makefile linux-2.6.39/drivers/Makefile
--- linux-2.6.39.orig/drivers/Makefile	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/Makefile	2011-08-23 15:10:42.370478643 +0200
@@ -46,8 +46,8 @@
 obj-$(CONFIG_SCSI)		+= scsi/
 obj-$(CONFIG_ATA)		+= ata/
 obj-$(CONFIG_TARGET_CORE)	+= target/
-obj-$(CONFIG_MTD)		+= mtd/
 obj-$(CONFIG_SPI)		+= spi/
+obj-$(CONFIG_MTD)		+= mtd/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
diff -Nur linux-2.6.39.orig/drivers/mtd/chips/cfi_cmdset_0002.c linux-2.6.39/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-2.6.39.orig/drivers/mtd/chips/cfi_cmdset_0002.c	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/mtd/chips/cfi_cmdset_0002.c	2011-08-22 16:22:28.477979654 +0200
@@ -39,7 +39,7 @@
 #include <linux/mtd/xip.h>
 
 #define AMD_BOOTLOC_BUG
-#define FORCE_WORD_WRITE 0
+#define FORCE_WORD_WRITE 1
 
 #define MAX_WORD_RETRIES 3
 
@@ -50,7 +50,9 @@
 
 static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+#if !FORCE_WORD_WRITE
 static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+#endif
 static int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);
 static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
 static void cfi_amdstd_sync (struct mtd_info *);
@@ -186,6 +188,7 @@
 }
 #endif
 
+#if !FORCE_WORD_WRITE
 static void fixup_use_write_buffers(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
@@ -195,6 +198,7 @@
 		mtd->write = cfi_amdstd_write_buffers;
 	}
 }
+#endif /* !FORCE_WORD_WRITE */
 
 /* Atmel chips don't use the same PRI format as AMD chips */
 static void fixup_convert_atmel_pri(struct mtd_info *mtd)
@@ -1377,6 +1381,7 @@
 /*
  * FIXME: interleaved mode not tested, and probably not supported!
  */
+#if !FORCE_WORD_WRITE
 static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 				    unsigned long adr, const u_char *buf,
 				    int len)
@@ -1487,7 +1492,6 @@
 	return ret;
 }
 
-
 static int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,
 				    size_t *retlen, const u_char *buf)
 {
@@ -1566,6 +1570,7 @@
 
 	return 0;
 }
+#endif /* !FORCE_WORD_WRITE */
 
 
 /*
diff -Nur linux-2.6.39.orig/drivers/mtd/maps/ar91xx_flash.c linux-2.6.39/drivers/mtd/maps/ar91xx_flash.c
--- linux-2.6.39.orig/drivers/mtd/maps/ar91xx_flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/mtd/maps/ar91xx_flash.c	2011-04-27 12:19:22.177661504 +0200
@@ -0,0 +1,310 @@
+/*
+ * Parallel flash driver for the Atheros AR91xx SoC
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/io.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/ar91xx_flash.h>
+
+#define DRV_NAME	"ar91xx-flash"
+
+struct ar91xx_flash_info {
+	struct mtd_info		*mtd;
+	struct map_info		map;
+#ifdef CONFIG_MTD_PARTITIONS
+	int			nr_parts;
+	struct mtd_partition	*parts;
+#endif
+};
+
+static map_word ar91xx_flash_read(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+
+	if (map_bankwidth_is_1(map))
+		val.x[0] = __raw_readb(map->virt + (ofs ^ 3));
+	else if (map_bankwidth_is_2(map))
+		val.x[0] = __raw_readw(map->virt + (ofs ^ 2));
+	else
+		val = map_word_ff(map);
+
+	return val;
+}
+
+static void ar91xx_flash_write(struct map_info *map, map_word d,
+			       unsigned long ofs)
+{
+	if (map_bankwidth_is_1(map))
+		__raw_writeb(d.x[0], map->virt + (ofs ^ 3));
+	else if (map_bankwidth_is_2(map))
+		__raw_writew(d.x[0], map->virt + (ofs ^ 2));
+
+	mb();
+}
+
+static map_word ar91xx_flash_read_lock(struct map_info *map, unsigned long ofs)
+{
+	map_word ret;
+
+	ar71xx_flash_acquire();
+	ret = ar91xx_flash_read(map, ofs);
+	ar71xx_flash_release();
+
+	return ret;
+}
+
+static void ar91xx_flash_write_lock(struct map_info *map, map_word d,
+			       unsigned long ofs)
+{
+	ar71xx_flash_acquire();
+	ar91xx_flash_write(map, d, ofs);
+	ar71xx_flash_release();
+}
+
+static void ar91xx_flash_copy_from_lock(struct map_info *map, void *to,
+					unsigned long from, ssize_t len)
+{
+	ar71xx_flash_acquire();
+	inline_map_copy_from(map, to, from, len);
+	ar71xx_flash_release();
+}
+
+static void ar91xx_flash_copy_to_lock(struct map_info *map, unsigned long to,
+				      const void *from, ssize_t len)
+{
+	ar71xx_flash_acquire();
+	inline_map_copy_to(map, to, from, len);
+	ar71xx_flash_release();
+}
+
+static int ar91xx_flash_remove(struct platform_device *pdev)
+{
+	struct ar91xx_flash_platform_data *pdata;
+	struct ar91xx_flash_info *info;
+
+	info = platform_get_drvdata(pdev);
+	if (info == NULL)
+		return 0;
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (info->mtd == NULL)
+		return 0;
+
+	pdata = pdev->dev.platform_data;
+#ifdef CONFIG_MTD_PARTITIONS
+	if (info->nr_parts) {
+		del_mtd_partitions(info->mtd);
+		kfree(info->parts);
+	} else if (pdata->nr_parts) {
+		del_mtd_partitions(info->mtd);
+	} else {
+		del_mtd_device(info->mtd);
+	}
+#else
+	del_mtd_device(info->mtd);
+#endif
+	map_destroy(info->mtd);
+
+	return 0;
+}
+
+static const char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", NULL };
+#endif
+
+static int ar91xx_flash_probe(struct platform_device *pdev)
+{
+	struct ar91xx_flash_platform_data *pdata;
+	struct ar91xx_flash_info *info;
+	struct resource *res;
+	struct resource *region;
+	const char **probe_type;
+	int err = 0;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL)
+		return -EINVAL;
+
+	info = devm_kzalloc(&pdev->dev, sizeof(struct ar91xx_flash_info),
+			    GFP_KERNEL);
+	if (info == NULL) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	platform_set_drvdata(pdev, info);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		err = -ENOENT;
+		goto err_out;
+	}
+
+	dev_info(&pdev->dev, "%.8llx at %.8llx\n",
+		 (unsigned long long)(res->end - res->start + 1),
+		 (unsigned long long)res->start);
+
+	region = devm_request_mem_region(&pdev->dev,
+					 res->start, res->end - res->start + 1,
+					 dev_name(&pdev->dev));
+	if (region == NULL) {
+		dev_err(&pdev->dev, "could not reserve memory region\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	info->map.name = dev_name(&pdev->dev);
+	info->map.phys = res->start;
+	info->map.size = res->end - res->start + 1;
+	info->map.bankwidth = pdata->width;
+
+	info->map.virt = devm_ioremap(&pdev->dev, info->map.phys,
+				      info->map.size);
+	if (info->map.virt == NULL) {
+		dev_err(&pdev->dev, "failed to ioremap flash region\n");
+		err = -EIO;
+		goto err_out;
+	}
+
+	simple_map_init(&info->map);
+	if (pdata->is_shared) {
+		info->map.read = ar91xx_flash_read_lock;
+		info->map.write = ar91xx_flash_write_lock;
+		info->map.copy_from = ar91xx_flash_copy_from_lock;
+		info->map.copy_to = ar91xx_flash_copy_to_lock;
+	} else {
+		info->map.read = ar91xx_flash_read;
+		info->map.write = ar91xx_flash_write;
+	}
+
+	probe_type = rom_probe_types;
+	for (; info->mtd == NULL && *probe_type != NULL; probe_type++)
+		info->mtd = do_map_probe(*probe_type, &info->map);
+
+	if (info->mtd == NULL) {
+		dev_err(&pdev->dev, "map_probe failed\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	info->mtd->owner = THIS_MODULE;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (pdata->nr_parts) {
+		dev_info(&pdev->dev, "using static partition mapping\n");
+		add_mtd_partitions(info->mtd, pdata->parts, pdata->nr_parts);
+		return 0;
+	}
+
+	err = parse_mtd_partitions(info->mtd, part_probe_types,
+				   &info->parts, 0);
+	if (err > 0) {
+		add_mtd_partitions(info->mtd, info->parts, err);
+		return 0;
+	}
+#endif
+
+	add_mtd_device(info->mtd);
+	return 0;
+
+err_out:
+	ar91xx_flash_remove(pdev);
+	return err;
+}
+
+#ifdef CONFIG_PM
+static int ar91xx_flash_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct ar91xx_flash_info *info = platform_get_drvdata(dev);
+	int ret = 0;
+
+	if (info->mtd->suspend)
+		ret = info->mtd->suspend(info->mtd);
+
+	if (ret)
+		goto fail;
+
+	return 0;
+
+fail:
+	if (info->mtd->suspend) {
+		BUG_ON(!info->mtd->resume);
+		info->mtd->resume(info->mtd);
+	}
+
+	return ret;
+}
+
+static int ar91xx_flash_resume(struct platform_device *pdev)
+{
+	struct ar91xx_flash_info *info = platform_get_drvdata(pdev);
+
+	if (info->mtd->resume)
+		info->mtd->resume(info->mtd);
+
+	return 0;
+}
+
+static void ar91xx_flash_shutdown(struct platform_device *pdev)
+{
+	struct ar91xx_flash_info *info = platform_get_drvdata(pdev);
+
+	if (info->mtd->suspend && info->mtd->resume)
+		if (info->mtd->suspend(info->mtd) == 0)
+			info->mtd->resume(info->mtd);
+}
+#else
+#define ar91xx_flash_suspend	NULL
+#define ar91xx_flash_resume	NULL
+#define ar91xx_flash_shutdown	NULL
+#endif
+
+static struct platform_driver ar91xx_flash_driver = {
+	.probe		= ar91xx_flash_probe,
+	.remove		= ar91xx_flash_remove,
+	.suspend	= ar91xx_flash_suspend,
+	.resume		= ar91xx_flash_resume,
+	.shutdown	= ar91xx_flash_shutdown,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ar91xx_flash_init(void)
+{
+	return platform_driver_register(&ar91xx_flash_driver);
+}
+
+static void __exit ar91xx_flash_exit(void)
+{
+	platform_driver_unregister(&ar91xx_flash_driver);
+}
+
+module_init(ar91xx_flash_init);
+module_exit(ar91xx_flash_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("Parallel flash driver for the Atheros AR91xx SoC");
+MODULE_ALIAS("platform:" DRV_NAME);
diff -Nur linux-2.6.39.orig/drivers/mtd/maps/Kconfig linux-2.6.39/drivers/mtd/maps/Kconfig
--- linux-2.6.39.orig/drivers/mtd/maps/Kconfig	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/mtd/maps/Kconfig	2011-08-22 16:22:06.367979538 +0200
@@ -260,6 +260,13 @@
 	  Support for parsing CFE image tag and creating MTD partitions on
 	  Broadcom BCM63xx boards.
 
+config MTD_AR91XX_FLASH
+	tristate "Atheros AR91xx parallel flash support"
+	depends on ATHEROS_AR71XX
+	select MTD_COMPLEX_MAPPINGS
+	help
+	  Parallel flash driver for the Atheros AR91xx based boards.
+
 config MTD_DILNETPC
 	tristate "CFI Flash device mapped on DIL/Net PC"
 	depends on X86 && MTD_PARTITIONS && MTD_CFI_INTELEXT && BROKEN
diff -Nur linux-2.6.39.orig/drivers/mtd/maps/Makefile linux-2.6.39/drivers/mtd/maps/Makefile
--- linux-2.6.39.orig/drivers/mtd/maps/Makefile	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/mtd/maps/Makefile	2011-08-22 16:22:06.387979567 +0200
@@ -40,6 +40,7 @@
 obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
+obj-$(CONFIG_MTD_AR91XX_FLASH)	+= ar91xx_flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
diff -Nur linux-2.6.39.orig/drivers/mtd/nand/Kconfig linux-2.6.39/drivers/mtd/nand/Kconfig
--- linux-2.6.39.orig/drivers/mtd/nand/Kconfig	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/mtd/nand/Kconfig	2011-08-23 14:22:33.407989933 +0200
@@ -531,4 +531,9 @@
 	  Enables support for NAND Flash chips on the ST Microelectronics
 	  Flexible Static Memory Controller (FSMC)
 
+config MTD_NAND_RB4XX
+	tristate "NAND flash driver for RouterBoard 4xx series"
+	depends on MTD_NAND && AR71XX_MACH_RB4XX
+	select SPI_AR71XX
+
 endif # MTD_NAND
diff -Nur linux-2.6.39.orig/drivers/mtd/nand/Makefile linux-2.6.39/drivers/mtd/nand/Makefile
--- linux-2.6.39.orig/drivers/mtd/nand/Makefile	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/mtd/nand/Makefile	2011-08-22 16:22:41.217981942 +0200
@@ -34,6 +34,7 @@
 obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
 obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
 obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
+obj-$(CONFIG_MTD_NAND_RB4XX)		+= rb4xx_nand.o
 obj-$(CONFIG_MTD_ALAUDA)		+= alauda.o
 obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
 obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
diff -Nur linux-2.6.39.orig/drivers/mtd/nand/rb4xx_nand.c linux-2.6.39/drivers/mtd/nand/rb4xx_nand.c
--- linux-2.6.39.orig/drivers/mtd/nand/rb4xx_nand.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/mtd/nand/rb4xx_nand.c	2011-08-23 11:36:58.637983055 +0200
@@ -0,0 +1,311 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBoard 4xx series
+ *
+ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This file was based on the driver for Linux 2.6.22 published by
+ *  MikroTik for their RouterBoard 4xx series devices.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/rb4xx_cpld.h>
+
+#define DRV_NAME        "rb4xx-nand"
+#define DRV_VERSION     "0.2.0"
+#define DRV_DESC        "NAND flash driver for RouterBoard 4xx series"
+
+#define RB4XX_NAND_GPIO_READY	5
+#define RB4XX_NAND_GPIO_ALE	37
+#define RB4XX_NAND_GPIO_CLE	38
+#define RB4XX_NAND_GPIO_NCE	39
+
+struct rb4xx_nand_info {
+	struct nand_chip	chip;
+	struct mtd_info		mtd;
+};
+
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb4xx_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static struct mtd_partition rb4xx_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (6 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static int rb4xx_nand_dev_ready(struct mtd_info *mtd)
+{
+	return gpio_get_value_cansleep(RB4XX_NAND_GPIO_READY);
+}
+
+static void rb4xx_nand_write_cmd(unsigned char cmd)
+{
+	unsigned char data = cmd;
+	int err;
+
+	err = rb4xx_cpld_write(&data, 1);
+	if (err)
+		pr_err("rb4xx_nand: write cmd failed, err=%d\n", err);
+}
+
+static void rb4xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	if (ctrl & NAND_CTRL_CHANGE) {
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_CLE,
+					(ctrl & NAND_CLE) ? 1 : 0);
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_ALE,
+					(ctrl & NAND_ALE) ? 1 : 0);
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_NCE,
+					(ctrl & NAND_NCE) ? 0 : 1);
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		rb4xx_nand_write_cmd(cmd);
+}
+
+static unsigned char rb4xx_nand_read_byte(struct mtd_info *mtd)
+{
+	unsigned char data = 0;
+	int err;
+
+	err = rb4xx_cpld_read(&data, NULL, 1);
+	if (err) {
+		pr_err("rb4xx_nand: read data failed, err=%d\n", err);
+		data = 0xff;
+	}
+
+	return data;
+}
+
+static void rb4xx_nand_write_buf(struct mtd_info *mtd, const unsigned char *buf,
+				 int len)
+{
+	int err;
+
+	err = rb4xx_cpld_write(buf, len);
+	if (err)
+		pr_err("rb4xx_nand: write buf failed, err=%d\n", err);
+}
+
+static void rb4xx_nand_read_buf(struct mtd_info *mtd, unsigned char *buf,
+				int len)
+{
+	int err;
+
+	err = rb4xx_cpld_read(buf, NULL, len);
+	if (err)
+		pr_err("rb4xx_nand: read buf failed, err=%d\n", err);
+}
+
+static int __init rb4xx_nand_probe(struct platform_device *pdev)
+{
+	struct rb4xx_nand_info	*info;
+	int ret;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	ret = gpio_request(RB4XX_NAND_GPIO_READY, "NAND RDY");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_READY);
+		goto err;
+	}
+
+	ret = gpio_direction_input(RB4XX_NAND_GPIO_READY);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set input mode on gpio %d\n",
+			RB4XX_NAND_GPIO_READY);
+		goto err_free_gpio_ready;
+	}
+
+	ret = gpio_request(RB4XX_NAND_GPIO_ALE, "NAND ALE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_ready;
+	}
+
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_ALE, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_ale;
+	}
+
+	ret = gpio_request(RB4XX_NAND_GPIO_CLE, "NAND CLE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_CLE);
+		goto err_free_gpio_ale;
+	}
+
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_CLE, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_CLE);
+		goto err_free_gpio_cle;
+	}
+
+	ret = gpio_request(RB4XX_NAND_GPIO_NCE, "NAND NCE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_NCE);
+		goto err_free_gpio_cle;
+	}
+
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_NCE, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_nce;
+	}
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		dev_err(&pdev->dev, "rb4xx-nand: no memory for private data\n");
+		ret = -ENOMEM;
+		goto err_free_gpio_nce;
+	}
+
+	info->chip.priv	= &info;
+	info->mtd.priv	= &info->chip;
+	info->mtd.owner	= THIS_MODULE;
+
+	info->chip.cmd_ctrl	= rb4xx_nand_cmd_ctrl;
+	info->chip.dev_ready	= rb4xx_nand_dev_ready;
+	info->chip.read_byte	= rb4xx_nand_read_byte;
+	info->chip.write_buf	= rb4xx_nand_write_buf;
+	info->chip.read_buf	= rb4xx_nand_read_buf;
+#if 0
+	info->chip.verify_buf	= rb4xx_nand_verify_buf;
+#endif
+
+	info->chip.chip_delay	= 25;
+	info->chip.ecc.mode	= NAND_ECC_SOFT;
+	info->chip.options	|= NAND_NO_AUTOINCR;
+
+	platform_set_drvdata(pdev, info);
+
+	ret = nand_scan_ident(&info->mtd, 1, NULL);
+	if (ret) {
+		ret = -ENXIO;
+		goto err_free_info;
+	}
+
+	if (info->mtd.writesize == 512)
+		info->chip.ecc.layout = &rb4xx_nand_ecclayout;
+
+	ret = nand_scan_tail(&info->mtd);
+	if (ret) {
+		return -ENXIO;
+		goto err_set_drvdata;
+	}
+
+#ifdef CONFIG_MTD_PARTITIONS
+	ret = add_mtd_partitions(&info->mtd, rb4xx_nand_partitions,
+				ARRAY_SIZE(rb4xx_nand_partitions));
+#else
+	ret = add_mtd_device(&info->mtd);
+#endif
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+err_release_nand:
+	nand_release(&info->mtd);
+err_set_drvdata:
+	platform_set_drvdata(pdev, NULL);
+err_free_info:
+	kfree(info);
+err_free_gpio_nce:
+	gpio_free(RB4XX_NAND_GPIO_NCE);
+err_free_gpio_cle:
+	gpio_free(RB4XX_NAND_GPIO_CLE);
+err_free_gpio_ale:
+	gpio_free(RB4XX_NAND_GPIO_ALE);
+err_free_gpio_ready:
+	gpio_free(RB4XX_NAND_GPIO_READY);
+err:
+	return ret;
+}
+
+static int __devexit rb4xx_nand_remove(struct platform_device *pdev)
+{
+	struct rb4xx_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(&info->mtd);
+	platform_set_drvdata(pdev, NULL);
+	kfree(info);
+	gpio_free(RB4XX_NAND_GPIO_NCE);
+	gpio_free(RB4XX_NAND_GPIO_CLE);
+	gpio_free(RB4XX_NAND_GPIO_ALE);
+	gpio_free(RB4XX_NAND_GPIO_READY);
+
+	return 0;
+}
+
+static struct platform_driver rb4xx_nand_driver = {
+	.probe	= rb4xx_nand_probe,
+	.remove	= __devexit_p(rb4xx_nand_remove),
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb4xx_nand_init(void)
+{
+	return platform_driver_register(&rb4xx_nand_driver);
+}
+
+static void __exit rb4xx_nand_exit(void)
+{
+	platform_driver_unregister(&rb4xx_nand_driver);
+}
+
+module_init(rb4xx_nand_init);
+module_exit(rb4xx_nand_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.39.orig/drivers/mtd/nand/rb750_nand.c linux-2.6.39/drivers/mtd/nand/rb750_nand.c
--- linux-2.6.39.orig/drivers/mtd/nand/rb750_nand.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/mtd/nand/rb750_nand.c	2011-04-27 12:19:22.177661504 +0200
@@ -0,0 +1,361 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBOARD 750
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/mach-rb750.h>
+
+#define DRV_NAME	"rb750-nand"
+#define DRV_VERSION	"0.1.0"
+#define DRV_DESC	"NAND flash driver for the RouterBOARD 750"
+
+#define RB750_NAND_IO0		BIT(RB750_GPIO_NAND_IO0)
+#define RB750_NAND_ALE		BIT(RB750_GPIO_NAND_ALE)
+#define RB750_NAND_CLE		BIT(RB750_GPIO_NAND_CLE)
+#define RB750_NAND_NRE		BIT(RB750_GPIO_NAND_NRE)
+#define RB750_NAND_NWE		BIT(RB750_GPIO_NAND_NWE)
+#define RB750_NAND_RDY		BIT(RB750_GPIO_NAND_RDY)
+#define RB750_NAND_NCE		BIT(RB750_GPIO_NAND_NCE)
+
+#define RB750_NAND_DATA_SHIFT	1
+#define RB750_NAND_DATA_BITS	(0xff << RB750_NAND_DATA_SHIFT)
+#define RB750_NAND_INPUT_BITS	(RB750_NAND_DATA_BITS | RB750_NAND_RDY)
+#define RB750_NAND_OUTPUT_BITS	(RB750_NAND_ALE | RB750_NAND_CLE | \
+				 RB750_NAND_NRE | RB750_NAND_NWE | \
+				 RB750_NAND_NCE)
+
+struct rb750_nand_info {
+	struct nand_chip	chip;
+	struct mtd_info		mtd;
+};
+
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb750_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static struct mtd_partition rb750_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	}, {
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static void rb750_nand_write(const u8 *buf, unsigned len)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 out;
+	unsigned i;
+
+	/* set data lines to output mode */
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) | RB750_NAND_DATA_BITS,
+		     base + GPIO_REG_OE);
+
+	out = __raw_readl(base + GPIO_REG_OUT);
+	out &= ~(RB750_NAND_DATA_BITS | RB750_NAND_NWE);
+	for (i = 0; i != len; i++) {
+		u32 data;
+
+		data = buf[i];
+		data <<= RB750_NAND_DATA_SHIFT;
+		data |= out;
+		__raw_writel(data, base + GPIO_REG_OUT);
+
+		__raw_writel(data | RB750_NAND_NWE, base + GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + GPIO_REG_OUT);
+	}
+
+	/* set data lines to input mode */
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) & ~RB750_NAND_DATA_BITS,
+		     base + GPIO_REG_OE);
+	/* flush write */
+	__raw_readl(base + GPIO_REG_OE);
+}
+
+static int rb750_nand_read_verify(u8 *read_buf, unsigned len,
+				  const u8 *verify_buf)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	unsigned i;
+
+	for (i = 0; i < len; i++) {
+		u8 data;
+
+		/* activate RE line */
+		__raw_writel(RB750_NAND_NRE, base + GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + GPIO_REG_CLEAR);
+
+		/* read input lines */
+		data = __raw_readl(base + GPIO_REG_IN) >> RB750_NAND_DATA_SHIFT;
+
+		/* deactivate RE line */
+		__raw_writel(RB750_NAND_NRE, base + GPIO_REG_SET);
+
+		if (read_buf)
+			read_buf[i] = data;
+		else if (verify_buf && verify_buf[i] != data)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void rb750_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 func;
+
+	func = __raw_readl(base + GPIO_REG_FUNC);
+	if (chip >= 0) {
+		/* disable latch */
+		rb750_latch_change(RB750_LVC573_LE, 0);
+
+		/* disable alternate functions */
+		ar71xx_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+					   AR724X_GPIO_FUNC_SPI_EN);
+
+		/* set input mode for data lines */
+		__raw_writel(__raw_readl(base + GPIO_REG_OE) &
+			     ~RB750_NAND_INPUT_BITS,
+			     base + GPIO_REG_OE);
+
+		/* deactivate RE and WE lines */
+		__raw_writel(RB750_NAND_NRE | RB750_NAND_NWE,
+			     base + GPIO_REG_SET);
+		/* flush write */
+		(void) __raw_readl(base + GPIO_REG_SET);
+
+		/* activate CE line */
+		__raw_writel(RB750_NAND_NCE, base + GPIO_REG_CLEAR);
+	} else {
+		/* deactivate CE line */
+		__raw_writel(RB750_NAND_NCE, base + GPIO_REG_SET);
+		/* flush write */
+		(void) __raw_readl(base + GPIO_REG_SET);
+
+		__raw_writel(__raw_readl(base + GPIO_REG_OE) |
+			     RB750_NAND_IO0 | RB750_NAND_RDY,
+			     base + GPIO_REG_OE);
+
+		/* restore alternate functions */
+		ar71xx_gpio_function_setup(AR724X_GPIO_FUNC_SPI_EN,
+					   AR724X_GPIO_FUNC_JTAG_DISABLE);
+
+		/* enable latch */
+		rb750_latch_change(0, RB750_LVC573_LE);
+	}
+}
+
+static int rb750_nand_dev_ready(struct mtd_info *mtd)
+{
+	void __iomem *base = ar71xx_gpio_base;
+
+	return !!(__raw_readl(base + GPIO_REG_IN) & RB750_NAND_RDY);
+}
+
+static void rb750_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	if (ctrl & NAND_CTRL_CHANGE) {
+		void __iomem *base = ar71xx_gpio_base;
+		u32 t;
+
+		t = __raw_readl(base + GPIO_REG_OUT);
+
+		t &= ~(RB750_NAND_CLE | RB750_NAND_ALE);
+		t |= (ctrl & NAND_CLE) ? RB750_NAND_CLE : 0;
+		t |= (ctrl & NAND_ALE) ? RB750_NAND_ALE : 0;
+
+		__raw_writel(t, base + GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + GPIO_REG_OUT);
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		u8 t = cmd;
+		rb750_nand_write(&t, 1);
+	}
+}
+
+static u8 rb750_nand_read_byte(struct mtd_info *mtd)
+{
+	u8 data = 0;
+	rb750_nand_read_verify(&data, 1, NULL);
+	return data;
+}
+
+static void rb750_nand_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	rb750_nand_read_verify(buf, len, NULL);
+}
+
+static void rb750_nand_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	rb750_nand_write(buf, len);
+}
+
+static int rb750_nand_verify_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	return rb750_nand_read_verify(NULL, len, buf);
+}
+
+static void __init rb750_nand_gpio_init(void)
+{
+	void __iomem *base = ar71xx_gpio_base;
+	u32 out;
+
+	out = __raw_readl(base + GPIO_REG_OUT);
+
+	/* setup output levels */
+	__raw_writel(RB750_NAND_NCE | RB750_NAND_NRE | RB750_NAND_NWE,
+		     base + GPIO_REG_SET);
+
+	__raw_writel(RB750_NAND_ALE | RB750_NAND_CLE,
+		     base + GPIO_REG_CLEAR);
+
+	/* setup input lines */
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) & ~(RB750_NAND_INPUT_BITS),
+		     base + GPIO_REG_OE);
+
+	/* setup output lines */
+	__raw_writel(__raw_readl(base + GPIO_REG_OE) | RB750_NAND_OUTPUT_BITS,
+		     base + GPIO_REG_OE);
+
+	rb750_latch_change(~out & RB750_NAND_IO0, out & RB750_NAND_IO0);
+}
+
+static int __init rb750_nand_probe(struct platform_device *pdev)
+{
+	struct rb750_nand_info	*info;
+	int ret;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	rb750_nand_gpio_init();
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->chip.priv	= &info;
+	info->mtd.priv	= &info->chip;
+	info->mtd.owner	= THIS_MODULE;
+
+	info->chip.select_chip	= rb750_nand_select_chip;
+	info->chip.cmd_ctrl	= rb750_nand_cmd_ctrl;
+	info->chip.dev_ready	= rb750_nand_dev_ready;
+	info->chip.read_byte	= rb750_nand_read_byte;
+	info->chip.write_buf	= rb750_nand_write_buf;
+	info->chip.read_buf	= rb750_nand_read_buf;
+	info->chip.verify_buf	= rb750_nand_verify_buf;
+
+	info->chip.chip_delay	= 25;
+	info->chip.ecc.mode	= NAND_ECC_SOFT;
+	info->chip.options	|= NAND_NO_AUTOINCR;
+
+	platform_set_drvdata(pdev, info);
+
+	ret = nand_scan_ident(&info->mtd, 1);
+	if (ret) {
+		ret = -ENXIO;
+		goto err_free_info;
+	}
+
+	if (info->mtd.writesize == 512)
+		info->chip.ecc.layout = &rb750_nand_ecclayout;
+
+	ret = nand_scan_tail(&info->mtd);
+	if (ret) {
+		return -ENXIO;
+		goto err_set_drvdata;
+	}
+
+#ifdef CONFIG_MTD_PARTITIONS
+	ret = add_mtd_partitions(&info->mtd, rb750_nand_partitions,
+				 ARRAY_SIZE(rb750_nand_partitions));
+#else
+	ret = add_mtd_device(&info->mtd);
+#endif
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+err_release_nand:
+	nand_release(&info->mtd);
+err_set_drvdata:
+	platform_set_drvdata(pdev, NULL);
+err_free_info:
+	kfree(info);
+	return ret;
+}
+
+static int __devexit rb750_nand_remove(struct platform_device *pdev)
+{
+	struct rb750_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(&info->mtd);
+	platform_set_drvdata(pdev, NULL);
+	kfree(info);
+
+	return 0;
+}
+
+static struct platform_driver rb750_nand_driver = {
+	.probe	= rb750_nand_probe,
+	.remove	= __devexit_p(rb750_nand_remove),
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb750_nand_init(void)
+{
+	return platform_driver_register(&rb750_nand_driver);
+}
+
+static void __exit rb750_nand_exit(void)
+{
+	platform_driver_unregister(&rb750_nand_driver);
+}
+
+module_init(rb750_nand_init);
+module_exit(rb750_nand_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.39.orig/drivers/mtd/wrt160nl_part.c linux-2.6.39/drivers/mtd/wrt160nl_part.c
--- linux-2.6.39.orig/drivers/mtd/wrt160nl_part.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/mtd/wrt160nl_part.c	2011-08-06 09:32:37.138017083 +0200
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2009 Christian Daniel <cd@maintech.de>
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * TRX flash partition table.
+ * Based on ar7 map by Felix Fietkau <nbd@openwrt.org>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+struct cybertan_header {
+	char	magic[4];
+	u8	res1[4];
+	char	fw_date[3];
+	char	fw_ver[3];
+	char	id[4];
+	char	hw_ver;
+	char	unused;
+	u8	flags[2];
+	u8	res2[10];
+};
+
+#define TRX_PARTS	6
+#define TRX_MAGIC	0x30524448
+#define TRX_MAX_OFFSET	3
+
+struct trx_header {
+	uint32_t magic;           /* "HDR0" */
+	uint32_t len;             /* Length of file including header */
+	uint32_t crc32;           /* 32-bit CRC from flag_version to end of file */
+	uint32_t flag_version;    /* 0:15 flags, 16:31 version */
+	uint32_t offsets[TRX_MAX_OFFSET]; /* Offsets of partitions from start of header */
+};
+
+#define IH_MAGIC	0x27051956	/* Image Magic Number */
+#define IH_NMLEN	32		/* Image Name Length */
+
+struct uimage_header {
+	uint32_t	ih_magic;	/* Image Header Magic Number */
+	uint32_t	ih_hcrc;	/* Image Header CRC Checksum */
+	uint32_t	ih_time;	/* Image Creation Timestamp */
+	uint32_t	ih_size;	/* Image Data Size */
+	uint32_t	ih_load;	/* Data Load  Address */
+	uint32_t	ih_ep;		/* Entry Point Address */
+	uint32_t	ih_dcrc;	/* Image Data CRC Checksum */
+	uint8_t		ih_os;		/* Operating System */
+	uint8_t		ih_arch;	/* CPU architecture */
+	uint8_t		ih_type;	/* Image Type */
+	uint8_t		ih_comp;	/* Compression Type */
+	uint8_t		ih_name[IH_NMLEN];	/* Image Name */
+};
+
+struct wrt160nl_header {
+	struct cybertan_header	cybertan;
+	struct trx_header	trx;
+	struct uimage_header	uimage;
+} __attribute__ ((packed));
+
+static struct mtd_partition trx_parts[TRX_PARTS];
+
+#define WRT160NL_UBOOT_LEN	0x40000
+#define WRT160NL_ART_LEN	0x10000
+#define WRT160NL_NVRAM_LEN	0x10000
+
+static int wrt160nl_parse_partitions(struct mtd_info *master,
+				     struct mtd_partition **pparts,
+				     unsigned long origin)
+{
+	struct wrt160nl_header *header;
+	struct trx_header *theader;
+	struct uimage_header *uheader;
+	size_t retlen;
+	unsigned int kernel_len;
+	unsigned int uboot_len = max(master->erasesize, WRT160NL_UBOOT_LEN);
+	unsigned int nvram_len = max(master->erasesize, WRT160NL_NVRAM_LEN);
+	unsigned int art_len = max(master->erasesize, WRT160NL_ART_LEN);
+	int ret;
+
+	header = vmalloc(sizeof(*header));
+	if (!header) {
+		return -ENOMEM;
+		goto out;
+	}
+
+	ret = master->read(master, uboot_len, sizeof(*header),
+			   &retlen, (void *) header);
+	if (ret)
+		goto free_hdr;
+
+	if (retlen != sizeof(*header)) {
+		ret = -EIO;
+		goto free_hdr;
+	}
+
+	if (strncmp(header->cybertan.magic, "NL16", 4) != 0) {
+		printk(KERN_NOTICE "%s: no WRT160NL signature found\n",
+			master->name);
+		goto free_hdr;
+	}
+
+	theader = &header->trx;
+	if (le32_to_cpu(theader->magic) != TRX_MAGIC) {
+		printk(KERN_NOTICE "%s: no TRX header found\n", master->name);
+		goto free_hdr;
+	}
+
+	uheader = &header->uimage;
+	if (uheader->ih_magic != IH_MAGIC) {
+		printk(KERN_NOTICE "%s: no uImage found\n", master->name);
+		goto free_hdr;
+	}
+
+	kernel_len = le32_to_cpu(theader->offsets[1]) +
+		sizeof(struct cybertan_header);
+
+	trx_parts[0].name = "u-boot";
+	trx_parts[0].offset = 0;
+	trx_parts[0].size = uboot_len;
+	trx_parts[0].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[1].name = "kernel";
+	trx_parts[1].offset = trx_parts[0].offset + trx_parts[0].size;
+	trx_parts[1].size = kernel_len;
+	trx_parts[1].mask_flags = 0;
+
+	trx_parts[2].name = "rootfs";
+	trx_parts[2].offset = trx_parts[1].offset + trx_parts[1].size;
+	trx_parts[2].size = master->size - uboot_len - nvram_len - art_len -
+		trx_parts[1].size;
+	trx_parts[2].mask_flags = 0;
+
+	trx_parts[3].name = "nvram";
+	trx_parts[3].offset = master->size - nvram_len - art_len;
+	trx_parts[3].size = nvram_len;
+	trx_parts[3].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[4].name = "art";
+	trx_parts[4].offset = master->size - art_len;
+	trx_parts[4].size = art_len;
+	trx_parts[4].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[5].name = "firmware";
+	trx_parts[5].offset = uboot_len;
+	trx_parts[5].size = master->size - uboot_len - nvram_len - art_len;
+	trx_parts[5].mask_flags = 0;
+
+	*pparts = trx_parts;
+	ret = TRX_PARTS;
+
+free_hdr:
+	vfree(header);
+out:
+	return ret;
+}
+
+static struct mtd_part_parser wrt160nl_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= wrt160nl_parse_partitions,
+	.name		= "wrt160nl",
+};
+
+static int __init wrt160nl_parser_init(void)
+{
+	return register_mtd_parser(&wrt160nl_parser);
+}
+
+module_init(wrt160nl_parser_init);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Christian Daniel <cd@maintech.de>");
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_ar7240.c linux-2.6.39/drivers/net/ag71xx/ag71xx_ar7240.c
--- linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_ar7240.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/ag71xx_ar7240.c	2011-08-06 09:32:37.298018216 +0200
@@ -0,0 +1,913 @@
+/*
+ *  Driver for the built-in ethernet switch of the Atheros AR7240 SoC
+ *  Copyright (c) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (c) 2010 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <linux/mii.h>
+#include <linux/bitops.h>
+#include <linux/switch.h>
+#include "ag71xx.h"
+
+#define BITM(_count)	(BIT(_count) - 1)
+#define BITS(_shift, _count)	(BITM(_count) << _shift)
+
+#define AR7240_REG_MASK_CTRL		0x00
+#define AR7240_MASK_CTRL_REVISION_M	BITM(8)
+#define AR7240_MASK_CTRL_VERSION_M	BITM(8)
+#define AR7240_MASK_CTRL_VERSION_S	8
+#define AR7240_MASK_CTRL_SOFT_RESET	BIT(31)
+
+#define AR7240_REG_MAC_ADDR0		0x20
+#define AR7240_REG_MAC_ADDR1		0x24
+
+#define AR7240_REG_FLOOD_MASK		0x2c
+#define AR7240_FLOOD_MASK_BROAD_TO_CPU	BIT(26)
+
+#define AR7240_REG_GLOBAL_CTRL		0x30
+#define AR7240_GLOBAL_CTRL_MTU_M	BITM(12)
+
+#define AR7240_REG_VTU			0x0040
+#define   AR7240_VTU_OP			BITM(3)
+#define   AR7240_VTU_OP_NOOP		0x0
+#define   AR7240_VTU_OP_FLUSH		0x1
+#define   AR7240_VTU_OP_LOAD		0x2
+#define   AR7240_VTU_OP_PURGE		0x3
+#define   AR7240_VTU_OP_REMOVE_PORT	0x4
+#define   AR7240_VTU_ACTIVE		BIT(3)
+#define   AR7240_VTU_FULL		BIT(4)
+#define   AR7240_VTU_PORT		BITS(8, 4)
+#define   AR7240_VTU_PORT_S		8
+#define   AR7240_VTU_VID		BITS(16, 12)
+#define   AR7240_VTU_VID_S		16
+#define   AR7240_VTU_PRIO		BITS(28, 3)
+#define   AR7240_VTU_PRIO_S		28
+#define   AR7240_VTU_PRIO_EN		BIT(31)
+
+#define AR7240_REG_VTU_DATA		0x0044
+#define   AR7240_VTUDATA_MEMBER		BITS(0, 10)
+#define   AR7240_VTUDATA_VALID		BIT(11)
+
+#define AR7240_REG_ATU			0x50
+#define AR7240_ATU_FLUSH_ALL		0x1
+
+#define AR7240_REG_AT_CTRL		0x5c
+#define AR7240_AT_CTRL_AGE_TIME		BITS(0, 15)
+#define AR7240_AT_CTRL_AGE_EN		BIT(17)
+#define AR7240_AT_CTRL_LEARN_CHANGE	BIT(18)
+#define AR7240_AT_CTRL_ARP_EN		BIT(20)
+
+#define AR7240_REG_TAG_PRIORITY		0x70
+
+#define AR7240_REG_SERVICE_TAG		0x74
+#define AR7240_SERVICE_TAG_M		BITM(16)
+
+#define AR7240_REG_CPU_PORT		0x78
+#define AR7240_MIRROR_PORT_S		4
+#define AR7240_CPU_PORT_EN		BIT(8)
+
+#define AR7240_REG_MIB_FUNCTION0	0x80
+#define AR7240_MIB_TIMER_M		BITM(16)
+#define AR7240_MIB_AT_HALF_EN		BIT(16)
+#define AR7240_MIB_BUSY			BIT(17)
+#define AR7240_MIB_FUNC_S		24
+#define AR7240_MIB_FUNC_NO_OP		0x0
+#define AR7240_MIB_FUNC_FLUSH		0x1
+#define AR7240_MIB_FUNC_CAPTURE		0x3
+
+#define AR7240_REG_MDIO_CTRL		0x98
+#define AR7240_MDIO_CTRL_DATA_M		BITM(16)
+#define AR7240_MDIO_CTRL_REG_ADDR_S	16
+#define AR7240_MDIO_CTRL_PHY_ADDR_S	21
+#define AR7240_MDIO_CTRL_CMD_WRITE	0
+#define AR7240_MDIO_CTRL_CMD_READ	BIT(27)
+#define AR7240_MDIO_CTRL_MASTER_EN	BIT(30)
+#define AR7240_MDIO_CTRL_BUSY		BIT(31)
+
+#define AR7240_REG_PORT_BASE(_port)	(0x100 + (_port) * 0x100)
+
+#define AR7240_REG_PORT_STATUS(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x00)
+#define AR7240_PORT_STATUS_SPEED_M	BITM(2)
+#define AR7240_PORT_STATUS_SPEED_10	0
+#define AR7240_PORT_STATUS_SPEED_100	1
+#define AR7240_PORT_STATUS_SPEED_1000	2
+#define AR7240_PORT_STATUS_TXMAC	BIT(2)
+#define AR7240_PORT_STATUS_RXMAC	BIT(3)
+#define AR7240_PORT_STATUS_TXFLOW	BIT(4)
+#define AR7240_PORT_STATUS_RXFLOW	BIT(5)
+#define AR7240_PORT_STATUS_DUPLEX	BIT(6)
+#define AR7240_PORT_STATUS_LINK_UP	BIT(8)
+#define AR7240_PORT_STATUS_LINK_AUTO	BIT(9)
+#define AR7240_PORT_STATUS_LINK_PAUSE	BIT(10)
+
+#define AR7240_REG_PORT_CTRL(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x04)
+#define AR7240_PORT_CTRL_STATE_M	BITM(3)
+#define	AR7240_PORT_CTRL_STATE_DISABLED	0
+#define AR7240_PORT_CTRL_STATE_BLOCK	1
+#define AR7240_PORT_CTRL_STATE_LISTEN	2
+#define AR7240_PORT_CTRL_STATE_LEARN	3
+#define AR7240_PORT_CTRL_STATE_FORWARD	4
+#define AR7240_PORT_CTRL_LEARN_LOCK	BIT(7)
+#define AR7240_PORT_CTRL_VLAN_MODE_S	8
+#define AR7240_PORT_CTRL_VLAN_MODE_KEEP	0
+#define AR7240_PORT_CTRL_VLAN_MODE_STRIP 1
+#define AR7240_PORT_CTRL_VLAN_MODE_ADD	2
+#define AR7240_PORT_CTRL_VLAN_MODE_DOUBLE_TAG 3
+#define AR7240_PORT_CTRL_IGMP_SNOOP	BIT(10)
+#define AR7240_PORT_CTRL_HEADER		BIT(11)
+#define AR7240_PORT_CTRL_MAC_LOOP	BIT(12)
+#define AR7240_PORT_CTRL_SINGLE_VLAN	BIT(13)
+#define AR7240_PORT_CTRL_LEARN		BIT(14)
+#define AR7240_PORT_CTRL_DOUBLE_TAG	BIT(15)
+#define AR7240_PORT_CTRL_MIRROR_TX	BIT(16)
+#define AR7240_PORT_CTRL_MIRROR_RX	BIT(17)
+
+#define AR7240_REG_PORT_VLAN(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x08)
+
+#define AR7240_PORT_VLAN_DEFAULT_ID_S	0
+#define AR7240_PORT_VLAN_DEST_PORTS_S	16
+#define AR7240_PORT_VLAN_MODE_S		30
+#define AR7240_PORT_VLAN_MODE_PORT_ONLY	0
+#define AR7240_PORT_VLAN_MODE_PORT_FALLBACK	1
+#define AR7240_PORT_VLAN_MODE_VLAN_ONLY	2
+#define AR7240_PORT_VLAN_MODE_SECURE	3
+
+
+#define AR7240_REG_STATS_BASE(_port)	(0x20000 + (_port) * 0x100)
+
+#define AR7240_STATS_RXBROAD		0x00
+#define AR7240_STATS_RXPAUSE		0x04
+#define AR7240_STATS_RXMULTI		0x08
+#define AR7240_STATS_RXFCSERR		0x0c
+#define AR7240_STATS_RXALIGNERR		0x10
+#define AR7240_STATS_RXRUNT		0x14
+#define AR7240_STATS_RXFRAGMENT		0x18
+#define AR7240_STATS_RX64BYTE		0x1c
+#define AR7240_STATS_RX128BYTE		0x20
+#define AR7240_STATS_RX256BYTE		0x24
+#define AR7240_STATS_RX512BYTE		0x28
+#define AR7240_STATS_RX1024BYTE		0x2c
+#define AR7240_STATS_RX1518BYTE		0x30
+#define AR7240_STATS_RXMAXBYTE		0x34
+#define AR7240_STATS_RXTOOLONG		0x38
+#define AR7240_STATS_RXGOODBYTE		0x3c
+#define AR7240_STATS_RXBADBYTE		0x44
+#define AR7240_STATS_RXOVERFLOW		0x4c
+#define AR7240_STATS_FILTERED		0x50
+#define AR7240_STATS_TXBROAD		0x54
+#define AR7240_STATS_TXPAUSE		0x58
+#define AR7240_STATS_TXMULTI		0x5c
+#define AR7240_STATS_TXUNDERRUN		0x60
+#define AR7240_STATS_TX64BYTE		0x64
+#define AR7240_STATS_TX128BYTE		0x68
+#define AR7240_STATS_TX256BYTE		0x6c
+#define AR7240_STATS_TX512BYTE		0x70
+#define AR7240_STATS_TX1024BYTE		0x74
+#define AR7240_STATS_TX1518BYTE		0x78
+#define AR7240_STATS_TXMAXBYTE		0x7c
+#define AR7240_STATS_TXOVERSIZE		0x80
+#define AR7240_STATS_TXBYTE		0x84
+#define AR7240_STATS_TXCOLLISION	0x8c
+#define AR7240_STATS_TXABORTCOL		0x90
+#define AR7240_STATS_TXMULTICOL		0x94
+#define AR7240_STATS_TXSINGLECOL	0x98
+#define AR7240_STATS_TXEXCDEFER		0x9c
+#define AR7240_STATS_TXDEFER		0xa0
+#define AR7240_STATS_TXLATECOL		0xa4
+
+#define AR7240_PORT_CPU		0
+#define AR7240_NUM_PORTS	6
+#define AR7240_NUM_PHYS		5
+
+#define AR7240_PHY_ID1		0x004d
+#define AR7240_PHY_ID2		0xd041
+
+#define AR7240_PORT_MASK(_port)		BIT((_port))
+#define AR7240_PORT_MASK_ALL		BITM(AR7240_NUM_PORTS)
+#define AR7240_PORT_MASK_BUT(_port)	(AR7240_PORT_MASK_ALL & ~BIT((_port)))
+
+#define AR7240_MAX_VLANS	16
+
+#define sw_to_ar7240(_dev) container_of(_dev, struct ar7240sw, swdev)
+
+struct ar7240sw {
+	struct mii_bus	*mii_bus;
+	struct switch_dev swdev;
+	bool vlan;
+	u16 vlan_id[AR7240_MAX_VLANS];
+	u8 vlan_table[AR7240_MAX_VLANS];
+	u8 vlan_tagged;
+	u16 pvid[AR7240_NUM_PORTS];
+};
+
+struct ar7240sw_hw_stat {
+	char string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int reg;
+};
+
+static DEFINE_MUTEX(reg_mutex);
+
+static inline void ar7240sw_init(struct ar7240sw *as, struct mii_bus *mii)
+{
+	as->mii_bus = mii;
+}
+
+static inline u16 mk_phy_addr(u32 reg)
+{
+	return 0x17 & ((reg >> 4) | 0x10);
+}
+
+static inline u16 mk_phy_reg(u32 reg)
+{
+	return (reg << 1) & 0x1e;
+}
+
+static inline u16 mk_high_addr(u32 reg)
+{
+	return (reg >> 7) & 0x1ff;
+}
+
+static u32 __ar7240sw_reg_read(struct mii_bus *mii, u32 reg)
+{
+	unsigned long flags;
+	u16 phy_addr;
+	u16 phy_reg;
+	u32 hi, lo;
+
+	reg = (reg & 0xfffffffc) >> 2;
+	phy_addr = mk_phy_addr(reg);
+	phy_reg = mk_phy_reg(reg);
+
+	local_irq_save(flags);
+	ag71xx_mdio_mii_write(mii->priv, 0x1f, 0x10, mk_high_addr(reg));
+	lo = (u32) ag71xx_mdio_mii_read(mii->priv, phy_addr, phy_reg);
+	hi = (u32) ag71xx_mdio_mii_read(mii->priv, phy_addr, phy_reg + 1);
+	local_irq_restore(flags);
+
+	return (hi << 16) | lo;
+}
+
+static void __ar7240sw_reg_write(struct mii_bus *mii, u32 reg, u32 val)
+{
+	unsigned long flags;
+	u16 phy_addr;
+	u16 phy_reg;
+
+	reg = (reg & 0xfffffffc) >> 2;
+	phy_addr = mk_phy_addr(reg);
+	phy_reg = mk_phy_reg(reg);
+
+	local_irq_save(flags);
+	ag71xx_mdio_mii_write(mii->priv, 0x1f, 0x10, mk_high_addr(reg));
+	ag71xx_mdio_mii_write(mii->priv, phy_addr, phy_reg + 1, (val >> 16));
+	ag71xx_mdio_mii_write(mii->priv, phy_addr, phy_reg, (val & 0xffff));
+	local_irq_restore(flags);
+}
+
+static u32 ar7240sw_reg_read(struct mii_bus *mii, u32 reg_addr)
+{
+	u32 ret;
+
+	mutex_lock(&reg_mutex);
+	ret = __ar7240sw_reg_read(mii, reg_addr);
+	mutex_unlock(&reg_mutex);
+
+	return ret;
+}
+
+static void ar7240sw_reg_write(struct mii_bus *mii, u32 reg_addr, u32 reg_val)
+{
+	mutex_lock(&reg_mutex);
+	__ar7240sw_reg_write(mii, reg_addr, reg_val);
+	mutex_unlock(&reg_mutex);
+}
+
+static u32 ar7240sw_reg_rmw(struct mii_bus *mii, u32 reg, u32 mask, u32 val)
+{
+	u32 t;
+
+	mutex_lock(&reg_mutex);
+	t = __ar7240sw_reg_read(mii, reg);
+	t &= ~mask;
+	t |= val;
+	__ar7240sw_reg_write(mii, reg, t);
+	mutex_unlock(&reg_mutex);
+
+	return t;
+}
+
+static void ar7240sw_reg_set(struct mii_bus *mii, u32 reg, u32 val)
+{
+	u32 t;
+
+	mutex_lock(&reg_mutex);
+	t = __ar7240sw_reg_read(mii, reg);
+	t |= val;
+	__ar7240sw_reg_write(mii, reg, t);
+	mutex_unlock(&reg_mutex);
+}
+
+static int __ar7240sw_reg_wait(struct mii_bus *mii, u32 reg, u32 mask, u32 val,
+			       unsigned timeout)
+{
+	int i;
+
+	for (i = 0; i < timeout; i++) {
+		u32 t;
+
+		t = __ar7240sw_reg_read(mii, reg);
+		if ((t & mask) == val)
+			return 0;
+
+		msleep(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int ar7240sw_reg_wait(struct mii_bus *mii, u32 reg, u32 mask, u32 val,
+			     unsigned timeout)
+{
+	int ret;
+
+	mutex_lock(&reg_mutex);
+	ret = __ar7240sw_reg_wait(mii, reg, mask, val, timeout);
+	mutex_unlock(&reg_mutex);
+	return ret;
+}
+
+u16 ar7240sw_phy_read(struct mii_bus *mii, unsigned phy_addr,
+		      unsigned reg_addr)
+{
+	u32 t, val = 0xffff;
+	int err;
+
+	if (phy_addr >= AR7240_NUM_PHYS)
+		return 0xffff;
+
+	mutex_lock(&reg_mutex);
+	t = (reg_addr << AR7240_MDIO_CTRL_REG_ADDR_S) |
+	    (phy_addr << AR7240_MDIO_CTRL_PHY_ADDR_S) |
+	    AR7240_MDIO_CTRL_MASTER_EN |
+	    AR7240_MDIO_CTRL_BUSY |
+	    AR7240_MDIO_CTRL_CMD_READ;
+
+	__ar7240sw_reg_write(mii, AR7240_REG_MDIO_CTRL, t);
+	err = __ar7240sw_reg_wait(mii, AR7240_REG_MDIO_CTRL,
+				  AR7240_MDIO_CTRL_BUSY, 0, 5);
+	if (!err)
+		val = __ar7240sw_reg_read(mii, AR7240_REG_MDIO_CTRL);
+	mutex_unlock(&reg_mutex);
+
+	return val & AR7240_MDIO_CTRL_DATA_M;
+}
+
+int ar7240sw_phy_write(struct mii_bus *mii, unsigned phy_addr,
+		       unsigned reg_addr, u16 reg_val)
+{
+	u32 t;
+	int ret;
+
+	if (phy_addr >= AR7240_NUM_PHYS)
+		return -EINVAL;
+
+	mutex_lock(&reg_mutex);
+	t = (phy_addr << AR7240_MDIO_CTRL_PHY_ADDR_S) |
+	    (reg_addr << AR7240_MDIO_CTRL_REG_ADDR_S) |
+	    AR7240_MDIO_CTRL_MASTER_EN |
+	    AR7240_MDIO_CTRL_BUSY |
+	    AR7240_MDIO_CTRL_CMD_WRITE |
+	    reg_val;
+
+	__ar7240sw_reg_write(mii, AR7240_REG_MDIO_CTRL, t);
+	ret = __ar7240sw_reg_wait(mii, AR7240_REG_MDIO_CTRL,
+				  AR7240_MDIO_CTRL_BUSY, 0, 5);
+	mutex_unlock(&reg_mutex);
+
+	return ret;
+}
+
+static int ar7240sw_capture_stats(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+	int ret;
+
+	/* Capture the hardware statistics for all ports */
+	ar7240sw_reg_write(mii, AR7240_REG_MIB_FUNCTION0,
+			   (AR7240_MIB_FUNC_CAPTURE << AR7240_MIB_FUNC_S));
+
+	/* Wait for the capturing to complete. */
+	ret = ar7240sw_reg_wait(mii, AR7240_REG_MIB_FUNCTION0,
+				AR7240_MIB_BUSY, 0, 10);
+	return ret;
+}
+
+static void ar7240sw_disable_port(struct ar7240sw *as, unsigned port)
+{
+	ar7240sw_reg_write(as->mii_bus, AR7240_REG_PORT_CTRL(port),
+			   AR7240_PORT_CTRL_STATE_DISABLED);
+}
+
+static void ar7240sw_setup(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+
+	/* Enable CPU port, and disable mirror port */
+	ar7240sw_reg_write(mii, AR7240_REG_CPU_PORT,
+			   AR7240_CPU_PORT_EN |
+			   (15 << AR7240_MIRROR_PORT_S));
+
+	/* Setup TAG priority mapping */
+	ar7240sw_reg_write(mii, AR7240_REG_TAG_PRIORITY, 0xfa50);
+
+	/* Enable ARP frame acknowledge, aging, MAC replacing */
+	ar7240sw_reg_write(mii, AR7240_REG_AT_CTRL,
+		0x2b /* 5 min age time */ |
+		AR7240_AT_CTRL_AGE_EN |
+		AR7240_AT_CTRL_ARP_EN |
+		AR7240_AT_CTRL_LEARN_CHANGE);
+
+	/* Enable Broadcast frames transmitted to the CPU */
+	ar7240sw_reg_set(mii, AR7240_REG_FLOOD_MASK,
+			 AR7240_FLOOD_MASK_BROAD_TO_CPU);
+
+	/* setup MTU */
+	ar7240sw_reg_rmw(mii, AR7240_REG_GLOBAL_CTRL, AR7240_GLOBAL_CTRL_MTU_M,
+			 1536);
+
+	/* setup Service TAG */
+	ar7240sw_reg_rmw(mii, AR7240_REG_SERVICE_TAG, AR7240_SERVICE_TAG_M, 0);
+}
+
+static int ar7240sw_reset(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+	int ret;
+	int i;
+
+	/* Set all ports to disabled state. */
+	for (i = 0; i < AR7240_NUM_PORTS; i++)
+		ar7240sw_disable_port(as, i);
+
+	/* Wait for transmit queues to drain. */
+	msleep(2);
+
+	/* Reset the switch. */
+	ar7240sw_reg_write(mii, AR7240_REG_MASK_CTRL,
+			   AR7240_MASK_CTRL_SOFT_RESET);
+
+	ret = ar7240sw_reg_wait(mii, AR7240_REG_MASK_CTRL,
+				AR7240_MASK_CTRL_SOFT_RESET, 0, 1000);
+
+	ar7240sw_setup(as);
+	return ret;
+}
+
+static void ar7240sw_setup_port(struct ar7240sw *as, unsigned port, u8 portmask)
+{
+	struct mii_bus *mii = as->mii_bus;
+	u32 ctrl;
+	u32 dest_ports;
+	u32 vlan;
+
+	ctrl = AR7240_PORT_CTRL_STATE_FORWARD | AR7240_PORT_CTRL_LEARN |
+		AR7240_PORT_CTRL_SINGLE_VLAN;
+
+	if (port == AR7240_PORT_CPU) {
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_STATUS(port),
+				   AR7240_PORT_STATUS_SPEED_1000 |
+				   AR7240_PORT_STATUS_TXFLOW |
+				   AR7240_PORT_STATUS_RXFLOW |
+				   AR7240_PORT_STATUS_TXMAC |
+				   AR7240_PORT_STATUS_RXMAC |
+				   AR7240_PORT_STATUS_DUPLEX);
+	} else {
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_STATUS(port),
+				   AR7240_PORT_STATUS_LINK_AUTO);
+	}
+
+	/* Set the default VID for this port */
+	if (as->vlan) {
+		vlan = as->vlan_id[as->pvid[port]];
+		vlan |= AR7240_PORT_VLAN_MODE_SECURE <<
+			AR7240_PORT_VLAN_MODE_S;
+	} else {
+		vlan = port;
+		vlan |= AR7240_PORT_VLAN_MODE_PORT_ONLY <<
+			AR7240_PORT_VLAN_MODE_S;
+	}
+
+	if (as->vlan && (as->vlan_tagged & BIT(port))) {
+		ctrl |= AR7240_PORT_CTRL_VLAN_MODE_ADD <<
+			AR7240_PORT_CTRL_VLAN_MODE_S;
+	} else {
+		ctrl |= AR7240_PORT_CTRL_VLAN_MODE_STRIP <<
+			AR7240_PORT_CTRL_VLAN_MODE_S;
+	}
+
+	if (!portmask) {
+		if (port == AR7240_PORT_CPU)
+			portmask = AR7240_PORT_MASK_BUT(AR7240_PORT_CPU);
+		else
+			portmask = AR7240_PORT_MASK(AR7240_PORT_CPU);
+	}
+
+	/* allow the port to talk to all other ports, but exclude its
+	 * own ID to prevent frames from being reflected back to the
+	 * port that they came from */
+	dest_ports = AR7240_PORT_MASK_BUT(port);
+
+	/* set default VID and and destination ports for this VLAN */
+	vlan |= (portmask << AR7240_PORT_VLAN_DEST_PORTS_S);
+
+	ar7240sw_reg_write(mii, AR7240_REG_PORT_CTRL(port), ctrl);
+	ar7240sw_reg_write(mii, AR7240_REG_PORT_VLAN(port), vlan);
+}
+
+static int ar7240_set_addr(struct ar7240sw *as, u8 *addr)
+{
+	struct mii_bus *mii = as->mii_bus;
+	u32 t;
+
+	t = (addr[4] << 8) | addr[5];
+	ar7240sw_reg_write(mii, AR7240_REG_MAC_ADDR0, t);
+
+	t = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];
+	ar7240sw_reg_write(mii, AR7240_REG_MAC_ADDR1, t);
+
+	return 0;
+}
+
+static int
+ar7240_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	as->vlan_id[val->port_vlan] = val->value.i;
+	return 0;
+}
+
+static int
+ar7240_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	val->value.i = as->vlan_id[val->port_vlan];
+	return 0;
+}
+
+static int
+ar7240_set_pvid(struct switch_dev *dev, int port, int vlan)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+
+	/* make sure no invalid PVIDs get set */
+
+	if (vlan >= dev->vlans)
+		return -EINVAL;
+
+	as->pvid[port] = vlan;
+	return 0;
+}
+
+static int
+ar7240_get_pvid(struct switch_dev *dev, int port, int *vlan)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	*vlan = as->pvid[port];
+	return 0;
+}
+
+static int
+ar7240_get_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 ports = as->vlan_table[val->port_vlan];
+	int i;
+
+	val->len = 0;
+	for (i = 0; i < AR7240_NUM_PORTS; i++) {
+		struct switch_port *p;
+
+		if (!(ports & (1 << i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+		if (as->vlan_tagged & (1 << i))
+			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
+		else
+			p->flags = 0;
+	}
+	return 0;
+}
+
+static int
+ar7240_set_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 *vt = &as->vlan_table[val->port_vlan];
+	int i, j;
+
+	*vt = 0;
+	for (i = 0; i < val->len; i++) {
+		struct switch_port *p = &val->value.ports[i];
+
+		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED))
+			as->vlan_tagged |= (1 << p->id);
+		else {
+			as->vlan_tagged &= ~(1 << p->id);
+			as->pvid[p->id] = val->port_vlan;
+
+			/* make sure that an untagged port does not
+			 * appear in other vlans */
+			for (j = 0; j < AR7240_MAX_VLANS; j++) {
+				if (j == val->port_vlan)
+					continue;
+				as->vlan_table[j] &= ~(1 << p->id);
+			}
+		}
+
+		*vt |= 1 << p->id;
+	}
+	return 0;
+}
+
+static int
+ar7240_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	as->vlan = !!val->value.i;
+	return 0;
+}
+
+static int
+ar7240_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	val->value.i = as->vlan;
+	return 0;
+}
+
+
+static void
+ar7240_vtu_op(struct ar7240sw *as, u32 op, u32 val)
+{
+	struct mii_bus *mii = as->mii_bus;
+
+	if (ar7240sw_reg_wait(mii, AR7240_REG_VTU, AR7240_VTU_ACTIVE, 0, 5))
+		return;
+
+	if ((op & AR7240_VTU_OP) == AR7240_VTU_OP_LOAD) {
+		val &= AR7240_VTUDATA_MEMBER;
+		val |= AR7240_VTUDATA_VALID;
+		ar7240sw_reg_write(mii, AR7240_REG_VTU_DATA, val);
+	}
+	op |= AR7240_VTU_ACTIVE;
+	ar7240sw_reg_write(mii, AR7240_REG_VTU, op);
+}
+
+static int
+ar7240_hw_apply(struct switch_dev *dev)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 portmask[AR7240_NUM_PORTS];
+	int i, j;
+
+	/* flush all vlan translation unit entries */
+	ar7240_vtu_op(as, AR7240_VTU_OP_FLUSH, 0);
+
+	memset(portmask, 0, sizeof(portmask));
+	if (as->vlan) {
+		/* calculate the port destination masks and load vlans
+		 * into the vlan translation unit */
+		for (j = 0; j < AR7240_MAX_VLANS; j++) {
+			u8 vp = as->vlan_table[j];
+
+			if (!vp)
+				continue;
+
+			for (i = 0; i < AR7240_NUM_PORTS; i++) {
+				u8 mask = (1 << i);
+				if (vp & mask)
+					portmask[i] |= vp & ~mask;
+			}
+
+			ar7240_vtu_op(as,
+				AR7240_VTU_OP_LOAD |
+				(as->vlan_id[j] << AR7240_VTU_VID_S),
+				as->vlan_table[j]);
+		}
+	} else {
+		/* vlan disabled:
+		 * isolate all ports, but connect them to the cpu port */
+		for (i = 0; i < AR7240_NUM_PORTS; i++) {
+			if (i == AR7240_PORT_CPU)
+				continue;
+
+			portmask[i] = 1 << AR7240_PORT_CPU;
+			portmask[AR7240_PORT_CPU] |= (1 << i);
+		}
+	}
+
+	/* update the port destination mask registers and tag settings */
+	for (i = 0; i < AR7240_NUM_PORTS; i++)
+		ar7240sw_setup_port(as, i, portmask[i]);
+
+	return 0;
+}
+
+static int
+ar7240_reset_switch(struct switch_dev *dev)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	ar7240sw_reset(as);
+	return 0;
+}
+
+static struct switch_attr ar7240_globals[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = ar7240_set_vlan,
+		.get = ar7240_get_vlan,
+		.max = 1
+	},
+};
+
+static struct switch_attr ar7240_port[] = {
+};
+
+static struct switch_attr ar7240_vlan[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "vid",
+		.description = "VLAN ID",
+		.set = ar7240_set_vid,
+		.get = ar7240_get_vid,
+		.max = 4094,
+	},
+};
+
+static const struct switch_dev_ops ar7240_ops = {
+	.attr_global = {
+		.attr = ar7240_globals,
+		.n_attr = ARRAY_SIZE(ar7240_globals),
+	},
+	.attr_port = {
+		.attr = ar7240_port,
+		.n_attr = ARRAY_SIZE(ar7240_port),
+	},
+	.attr_vlan = {
+		.attr = ar7240_vlan,
+		.n_attr = ARRAY_SIZE(ar7240_vlan),
+	},
+	.get_port_pvid = ar7240_get_pvid,
+	.set_port_pvid = ar7240_set_pvid,
+	.get_vlan_ports = ar7240_get_ports,
+	.set_vlan_ports = ar7240_set_ports,
+	.apply_config = ar7240_hw_apply,
+	.reset_switch = ar7240_reset_switch,
+};
+
+static struct ar7240sw *ar7240_probe(struct ag71xx *ag)
+{
+	struct mii_bus *mii = ag->mii_bus;
+	struct ar7240sw *as;
+	struct switch_dev *swdev;
+	u32 ctrl;
+	u16 phy_id1;
+	u16 phy_id2;
+	u8 ver;
+	int i;
+
+	as = kzalloc(sizeof(*as), GFP_KERNEL);
+	if (!as)
+		return NULL;
+
+	ar7240sw_init(as, mii);
+
+	ctrl = ar7240sw_reg_read(mii, AR7240_REG_MASK_CTRL);
+
+	ver = (ctrl >> AR7240_MASK_CTRL_VERSION_S) & AR7240_MASK_CTRL_VERSION_M;
+	if (ver != 1) {
+		pr_err("%s: unsupported chip, ctrl=%08x\n",
+			ag->dev->name, ctrl);
+		return NULL;
+	}
+
+	phy_id1 = ar7240sw_phy_read(mii, 0, MII_PHYSID1);
+	phy_id2 = ar7240sw_phy_read(mii, 0, MII_PHYSID2);
+	if (phy_id1 != AR7240_PHY_ID1 || phy_id2 != AR7240_PHY_ID2) {
+		pr_err("%s: unknown phy id '%04x:%04x'\n",
+		       ag->dev->name, phy_id1, phy_id2);
+		return NULL;
+	}
+
+	swdev = &as->swdev;
+	swdev->name = "AR7240 built-in switch";
+	swdev->ports = AR7240_NUM_PORTS;
+	swdev->cpu_port = AR7240_PORT_CPU;
+	swdev->vlans = AR7240_MAX_VLANS;
+	swdev->ops = &ar7240_ops;
+
+	if (register_switch(&as->swdev, ag->dev) < 0) {
+		kfree(as);
+		return NULL;
+	}
+
+	pr_info("%s: Found an AR7240 built-in switch\n", ag->dev->name);
+
+	/* initialize defaults */
+	for (i = 0; i < AR7240_MAX_VLANS; i++)
+		as->vlan_id[i] = i;
+
+	as->vlan_table[0] = AR7240_PORT_MASK_ALL;
+
+	return as;
+}
+
+static void link_function(struct work_struct *work) {
+	struct ag71xx *ag = container_of(work, struct ag71xx, link_work.work);
+	unsigned long flags;
+	int i;
+	int status = 0;
+
+	for (i = 0; i < 4; i++) {
+		int link = ar7240sw_phy_read(ag->mii_bus, i, MII_BMSR);
+		if(link & BMSR_LSTATUS) {
+			status = 1;
+			break;
+		}
+	}
+
+	spin_lock_irqsave(&ag->lock, flags);
+	if(status != ag->link) {
+		ag->link = status;
+		ag71xx_link_adjust(ag);
+	}
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	schedule_delayed_work(&ag->link_work, HZ / 2);
+}
+
+void ag71xx_ar7240_start(struct ag71xx *ag)
+{
+	struct ar7240sw *as = ag->phy_priv;
+
+	ar7240sw_reset(as);
+
+	ag->speed = SPEED_1000;
+	ag->duplex = 1;
+
+	ar7240_set_addr(as, ag->dev->dev_addr);
+	ar7240_hw_apply(&as->swdev);
+
+	schedule_delayed_work(&ag->link_work, HZ / 10);
+}
+
+void ag71xx_ar7240_stop(struct ag71xx *ag)
+{
+	cancel_delayed_work_sync(&ag->link_work);
+}
+
+int __devinit ag71xx_ar7240_init(struct ag71xx *ag)
+{
+	struct ar7240sw *as;
+
+	as = ar7240_probe(ag);
+	if (!as)
+		return -ENODEV;
+
+	ag->phy_priv = as;
+	ar7240sw_reset(as);
+
+	INIT_DELAYED_WORK(&ag->link_work, link_function);
+
+	return 0;
+}
+
+void ag71xx_ar7240_cleanup(struct ag71xx *ag)
+{
+	struct ar7240sw *as = ag->phy_priv;
+
+	if (!as)
+		return;
+
+	unregister_switch(&as->swdev);
+	kfree(as);
+	ag->phy_priv = NULL;
+}
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_ar8216.c linux-2.6.39/drivers/net/ag71xx/ag71xx_ar8216.c
--- linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_ar8216.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/ag71xx_ar8216.c	2011-04-27 12:19:22.257663952 +0200
@@ -0,0 +1,44 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *  Special support for the Atheros ar8216 switch chip
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+#define AR8216_PACKET_TYPE_MASK		0xf
+#define AR8216_PACKET_TYPE_NORMAL	0
+
+#define AR8216_HEADER_LEN	2
+
+void ag71xx_add_ar8216_header(struct ag71xx *ag, struct sk_buff *skb)
+{
+	skb_push(skb, AR8216_HEADER_LEN);
+	skb->data[0] = 0x10;
+	skb->data[1] = 0x80;
+}
+
+int ag71xx_remove_ar8216_header(struct ag71xx *ag, struct sk_buff *skb,
+				int pktlen)
+{
+	u8 type;
+
+	type = skb->data[1] & AR8216_PACKET_TYPE_MASK;
+	switch (type) {
+	case AR8216_PACKET_TYPE_NORMAL:
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	skb_pull(skb, AR8216_HEADER_LEN);
+	return 0;
+}
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_debugfs.c linux-2.6.39/drivers/net/ag71xx/ag71xx_debugfs.c
--- linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_debugfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/ag71xx_debugfs.c	2011-08-06 09:32:37.298018216 +0200
@@ -0,0 +1,280 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/debugfs.h>
+
+#include "ag71xx.h"
+
+static struct dentry *ag71xx_debugfs_root;
+
+static int ag71xx_debugfs_generic_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+void ag71xx_debugfs_update_int_stats(struct ag71xx *ag, u32 status)
+{
+	if (status)
+		ag->debug.int_stats.total++;
+	if (status & AG71XX_INT_TX_PS)
+		ag->debug.int_stats.tx_ps++;
+	if (status & AG71XX_INT_TX_UR)
+		ag->debug.int_stats.tx_ur++;
+	if (status & AG71XX_INT_TX_BE)
+		ag->debug.int_stats.tx_be++;
+	if (status & AG71XX_INT_RX_PR)
+		ag->debug.int_stats.rx_pr++;
+	if (status & AG71XX_INT_RX_OF)
+		ag->debug.int_stats.rx_of++;
+	if (status & AG71XX_INT_RX_BE)
+		ag->debug.int_stats.rx_be++;
+}
+
+static ssize_t read_file_int_stats(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+#define PR_INT_STAT(_label, _field)					\
+	len += snprintf(buf + len, sizeof(buf) - len,			\
+		"%20s: %10lu\n", _label, ag->debug.int_stats._field);
+
+	struct ag71xx *ag = file->private_data;
+	char buf[256];
+	unsigned int len = 0;
+
+	PR_INT_STAT("TX Packet Sent", tx_ps);
+	PR_INT_STAT("TX Underrun", tx_ur);
+	PR_INT_STAT("TX Bus Error", tx_be);
+	PR_INT_STAT("RX Packet Received", rx_pr);
+	PR_INT_STAT("RX Overflow", rx_of);
+	PR_INT_STAT("RX Bus Error", rx_be);
+	len += snprintf(buf + len, sizeof(buf) - len, "\n");
+	PR_INT_STAT("Total", total);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+#undef PR_INT_STAT
+}
+
+static const struct file_operations ag71xx_fops_int_stats = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_int_stats,
+	.owner	= THIS_MODULE
+};
+
+void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag, int rx, int tx)
+{
+	struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;
+
+	if (rx) {
+		stats->rx_count++;
+		stats->rx_packets += rx;
+		if (rx <= AG71XX_NAPI_WEIGHT)
+			stats->rx[rx]++;
+		if (rx > stats->rx_packets_max)
+			stats->rx_packets_max = rx;
+	}
+
+	if (tx) {
+		stats->tx_count++;
+		stats->tx_packets += tx;
+		if (tx <= AG71XX_NAPI_WEIGHT)
+			stats->tx[tx]++;
+		if (tx > stats->tx_packets_max)
+			stats->tx_packets_max = tx;
+	}
+}
+
+static ssize_t read_file_napi_stats(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+	struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;
+	char *buf;
+	unsigned int buflen;
+	unsigned int len = 0;
+	unsigned long rx_avg = 0;
+	unsigned long tx_avg = 0;
+	int ret;
+	int i;
+
+	buflen = 2048;
+	buf = kmalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (stats->rx_count)
+		rx_avg = stats->rx_packets / stats->rx_count;
+
+	if (stats->tx_count)
+		tx_avg = stats->tx_packets / stats->tx_count;
+
+	len += snprintf(buf + len, buflen - len, "%3s  %10s %10s\n",
+			"len", "rx", "tx");
+
+	for (i = 1; i <= AG71XX_NAPI_WEIGHT; i++)
+		len += snprintf(buf + len, buflen - len,
+				"%3d: %10lu %10lu\n",
+				i, stats->rx[i], stats->tx[i]);
+
+	len += snprintf(buf + len, buflen - len, "\n");
+
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"sum", stats->rx_count, stats->tx_count);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"avg", rx_avg, tx_avg);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"max", stats->rx_packets_max, stats->tx_packets_max);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"pkt", stats->rx_packets, stats->tx_packets);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations ag71xx_fops_napi_stats = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_napi_stats,
+	.owner	= THIS_MODULE
+};
+
+#define DESC_PRINT_LEN	64
+
+static ssize_t read_file_ring(struct file *file, char __user *user_buf,
+			      size_t count, loff_t *ppos,
+			      struct ag71xx *ag,
+			      struct ag71xx_ring *ring,
+			      unsigned desc_reg)
+{
+	char *buf;
+	unsigned int buflen;
+	unsigned int len = 0;
+	unsigned long flags;
+	ssize_t ret;
+	int curr;
+	int dirty;
+	u32 desc_hw;
+	int i;
+
+	buflen = (ring->size * DESC_PRINT_LEN);
+	buf = kmalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	len += snprintf(buf + len, buflen - len,
+			"Idx ... %-8s %-8s %-8s %-8s . %-10s\n",
+			"desc", "next", "data", "ctrl", "timestamp");
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	curr = (ring->curr % ring->size);
+	dirty = (ring->dirty % ring->size);
+	desc_hw = ag71xx_rr(ag, desc_reg);
+	for (i = 0; i < ring->size; i++) {
+		struct ag71xx_buf *ab = &ring->buf[i];
+		u32 desc_dma = ((u32) ring->descs_dma) + i * ring->desc_size;
+
+		len += snprintf(buf + len, buflen - len,
+			"%3d %c%c%c %08x %08x %08x %08x %c %10lu\n",
+			i,
+			(i == curr) ? 'C' : ' ',
+			(i == dirty) ? 'D' : ' ',
+			(desc_hw == desc_dma) ? 'H' : ' ',
+			desc_dma,
+			ab->desc->next,
+			ab->desc->data,
+			ab->desc->ctrl,
+			(ab->desc->ctrl & DESC_EMPTY) ? 'E' : '*',
+			ab->timestamp);
+	}
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t read_file_tx_ring(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+
+	return read_file_ring(file, user_buf, count, ppos, ag, &ag->tx_ring,
+			      AG71XX_REG_TX_DESC);
+}
+
+static const struct file_operations ag71xx_fops_tx_ring = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_tx_ring,
+	.owner	= THIS_MODULE
+};
+
+static ssize_t read_file_rx_ring(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+
+	return read_file_ring(file, user_buf, count, ppos, ag, &ag->rx_ring,
+			      AG71XX_REG_RX_DESC);
+}
+
+static const struct file_operations ag71xx_fops_rx_ring = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_rx_ring,
+	.owner	= THIS_MODULE
+};
+
+void ag71xx_debugfs_exit(struct ag71xx *ag)
+{
+	debugfs_remove_recursive(ag->debug.debugfs_dir);
+}
+
+int ag71xx_debugfs_init(struct ag71xx *ag)
+{
+	ag->debug.debugfs_dir = debugfs_create_dir(ag->dev->name,
+						   ag71xx_debugfs_root);
+	if (!ag->debug.debugfs_dir)
+		return -ENOMEM;
+
+	debugfs_create_file("int_stats", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_int_stats);
+	debugfs_create_file("napi_stats", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_napi_stats);
+	debugfs_create_file("tx_ring", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_tx_ring);
+	debugfs_create_file("rx_ring", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_rx_ring);
+
+	return 0;
+}
+
+int ag71xx_debugfs_root_init(void)
+{
+	if (ag71xx_debugfs_root)
+		return -EBUSY;
+
+	ag71xx_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (!ag71xx_debugfs_root)
+		return -ENOENT;
+
+	return 0;
+}
+
+void ag71xx_debugfs_root_exit(void)
+{
+	debugfs_remove(ag71xx_debugfs_root);
+	ag71xx_debugfs_root = NULL;
+}
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_ethtool.c linux-2.6.39/drivers/net/ag71xx/ag71xx_ethtool.c
--- linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_ethtool.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/ag71xx_ethtool.c	2011-08-06 09:32:37.308017908 +0200
@@ -0,0 +1,124 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+static int ag71xx_ethtool_get_settings(struct net_device *dev,
+				       struct ethtool_cmd *cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int ag71xx_ethtool_set_settings(struct net_device *dev,
+				       struct ethtool_cmd *cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static void ag71xx_ethtool_get_drvinfo(struct net_device *dev,
+				       struct ethtool_drvinfo *info)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	strcpy(info->driver, ag->pdev->dev.driver->name);
+	strcpy(info->version, AG71XX_DRV_VERSION);
+	strcpy(info->bus_info, dev_name(&ag->pdev->dev));
+}
+
+static u32 ag71xx_ethtool_get_msglevel(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	return ag->msg_enable;
+}
+
+static void ag71xx_ethtool_set_msglevel(struct net_device *dev, u32 msg_level)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	ag->msg_enable = msg_level;
+}
+
+static void ag71xx_ethtool_get_ringparam(struct net_device *dev,
+					 struct ethtool_ringparam *er)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	er->tx_max_pending = AG71XX_TX_RING_SIZE_MAX;
+	er->rx_max_pending = AG71XX_RX_RING_SIZE_MAX;
+	er->rx_mini_max_pending = 0;
+	er->rx_jumbo_max_pending = 0;
+
+	er->tx_pending = ag->tx_ring.size;
+	er->rx_pending = ag->rx_ring.size;
+	er->rx_mini_pending = 0;
+	er->rx_jumbo_pending = 0;
+}
+
+static int ag71xx_ethtool_set_ringparam(struct net_device *dev,
+					struct ethtool_ringparam *er)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned tx_size;
+	unsigned rx_size;
+	int err;
+
+	if (er->rx_mini_pending != 0||
+	    er->rx_jumbo_pending != 0 ||
+	    er->rx_pending == 0 ||
+	    er->tx_pending == 0)
+		return -EINVAL;
+
+	tx_size = er->tx_pending < AG71XX_TX_RING_SIZE_MAX ?
+		  er->tx_pending : AG71XX_TX_RING_SIZE_MAX;
+
+	rx_size = er->rx_pending < AG71XX_RX_RING_SIZE_MAX ?
+		  er->rx_pending : AG71XX_RX_RING_SIZE_MAX;
+
+	if (netif_running(dev)) {
+		err = dev->netdev_ops->ndo_stop(dev);
+		if (err)
+			return err;
+	}
+
+	ag->tx_ring.size = tx_size;
+	ag->rx_ring.size = rx_size;
+
+	if (netif_running(dev))
+		err = dev->netdev_ops->ndo_open(dev);
+
+	return err;
+}
+
+struct ethtool_ops ag71xx_ethtool_ops = {
+	.set_settings	= ag71xx_ethtool_set_settings,
+	.get_settings	= ag71xx_ethtool_get_settings,
+	.get_drvinfo	= ag71xx_ethtool_get_drvinfo,
+	.get_msglevel	= ag71xx_ethtool_get_msglevel,
+	.set_msglevel	= ag71xx_ethtool_set_msglevel,
+	.get_ringparam	= ag71xx_ethtool_get_ringparam,
+	.set_ringparam	= ag71xx_ethtool_set_ringparam,
+	.get_link	= ethtool_op_get_link,
+};
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/ag71xx.h linux-2.6.39/drivers/net/ag71xx/ag71xx.h
--- linux-2.6.39.orig/drivers/net/ag71xx/ag71xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/ag71xx.h	2011-08-22 07:40:12.160480642 +0200
@@ -0,0 +1,518 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __AG71XX_H
+#define __AG71XX_H
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/random.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <linux/if_vlan.h>
+#include <linux/phy.h>
+#include <linux/skbuff.h>
+#include <linux/dma-mapping.h>
+#include <linux/workqueue.h>
+
+#include <linux/bitops.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/platform.h>
+
+#define AG71XX_DRV_NAME		"ag71xx"
+#define AG71XX_DRV_VERSION	"0.5.35"
+
+#define AG71XX_NAPI_WEIGHT	64
+#define AG71XX_OOM_REFILL	(1 + HZ/10)
+
+#define AG71XX_INT_ERR	(AG71XX_INT_RX_BE | AG71XX_INT_TX_BE)
+#define AG71XX_INT_TX	(AG71XX_INT_TX_PS)
+#define AG71XX_INT_RX	(AG71XX_INT_RX_PR | AG71XX_INT_RX_OF)
+
+#define AG71XX_INT_POLL	(AG71XX_INT_RX | AG71XX_INT_TX)
+#define AG71XX_INT_INIT	(AG71XX_INT_ERR | AG71XX_INT_POLL)
+
+#define AG71XX_TX_MTU_LEN	1540
+#define AG71XX_RX_PKT_RESERVE	64
+#define AG71XX_RX_PKT_SIZE	\
+	(AG71XX_RX_PKT_RESERVE + ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN)
+
+#define AG71XX_TX_RING_SIZE_DEFAULT	64
+#define AG71XX_RX_RING_SIZE_DEFAULT	128
+
+#define AG71XX_TX_RING_SIZE_MAX		256
+#define AG71XX_RX_RING_SIZE_MAX		256
+
+#ifdef CONFIG_AG71XX_DEBUG
+#define DBG(fmt, args...)	printk(KERN_DEBUG fmt, ## args)
+#else
+#define DBG(fmt, args...)	do {} while (0)
+#endif
+
+#define ag71xx_assert(_cond)						\
+do {									\
+	if (_cond)							\
+		break;							\
+	printk("%s,%d: assertion failed\n", __FILE__, __LINE__);	\
+	BUG();								\
+} while (0)
+
+struct ag71xx_desc {
+	u32	data;
+	u32	ctrl;
+#define DESC_EMPTY	BIT(31)
+#define DESC_MORE	BIT(24)
+#define DESC_PKTLEN_M	0xfff
+	u32	next;
+	u32	pad;
+} __attribute__((aligned(4)));
+
+struct ag71xx_buf {
+	struct sk_buff		*skb;
+	struct ag71xx_desc	*desc;
+	dma_addr_t		dma_addr;
+	unsigned long		timestamp;
+};
+
+struct ag71xx_ring {
+	struct ag71xx_buf	*buf;
+	u8			*descs_cpu;
+	dma_addr_t		descs_dma;
+	unsigned int		desc_size;
+	unsigned int		curr;
+	unsigned int		dirty;
+	unsigned int		size;
+};
+
+struct ag71xx_mdio {
+	struct mii_bus		*mii_bus;
+	int			mii_irq[PHY_MAX_ADDR];
+	void __iomem		*mdio_base;
+	struct ag71xx_mdio_platform_data *pdata;
+};
+
+struct ag71xx_int_stats {
+	unsigned long		rx_pr;
+	unsigned long		rx_be;
+	unsigned long		rx_of;
+	unsigned long		tx_ps;
+	unsigned long		tx_be;
+	unsigned long		tx_ur;
+	unsigned long		total;
+};
+
+struct ag71xx_napi_stats {
+	unsigned long		napi_calls;
+	unsigned long		rx_count;
+	unsigned long		rx_packets;
+	unsigned long		rx_packets_max;
+	unsigned long		tx_count;
+	unsigned long		tx_packets;
+	unsigned long		tx_packets_max;
+
+	unsigned long		rx[AG71XX_NAPI_WEIGHT + 1];
+	unsigned long		tx[AG71XX_NAPI_WEIGHT + 1];
+};
+
+struct ag71xx_debug {
+	struct dentry		*debugfs_dir;
+
+	struct ag71xx_int_stats int_stats;
+	struct ag71xx_napi_stats napi_stats;
+};
+
+struct ag71xx {
+	void __iomem		*mac_base;
+	void __iomem		*mii_ctrl;
+
+	spinlock_t		lock;
+	struct platform_device	*pdev;
+	struct net_device	*dev;
+	struct napi_struct	napi;
+	u32			msg_enable;
+
+	struct ag71xx_desc	*stop_desc;
+	dma_addr_t		stop_desc_dma;
+
+	struct ag71xx_ring	rx_ring;
+	struct ag71xx_ring	tx_ring;
+
+	struct mii_bus		*mii_bus;
+	struct phy_device	*phy_dev;
+	void			*phy_priv;
+
+	unsigned int		link;
+	unsigned int		speed;
+	int			duplex;
+
+	struct work_struct	restart_work;
+	struct delayed_work	link_work;
+	struct timer_list	oom_timer;
+
+#ifdef CONFIG_AG71XX_DEBUG_FS
+	struct ag71xx_debug	debug;
+#endif
+};
+
+extern struct ethtool_ops ag71xx_ethtool_ops;
+void ag71xx_link_adjust(struct ag71xx *ag);
+
+int ag71xx_mdio_driver_init(void) __init;
+void ag71xx_mdio_driver_exit(void);
+
+int ag71xx_phy_connect(struct ag71xx *ag);
+void ag71xx_phy_disconnect(struct ag71xx *ag);
+void ag71xx_phy_start(struct ag71xx *ag);
+void ag71xx_phy_stop(struct ag71xx *ag);
+
+static inline struct ag71xx_platform_data *ag71xx_get_pdata(struct ag71xx *ag)
+{
+	return ag->pdev->dev.platform_data;
+}
+
+static inline int ag71xx_desc_empty(struct ag71xx_desc *desc)
+{
+	return (desc->ctrl & DESC_EMPTY) != 0;
+}
+
+static inline int ag71xx_desc_pktlen(struct ag71xx_desc *desc)
+{
+	return desc->ctrl & DESC_PKTLEN_M;
+}
+
+/* Register offsets */
+#define AG71XX_REG_MAC_CFG1	0x0000
+#define AG71XX_REG_MAC_CFG2	0x0004
+#define AG71XX_REG_MAC_IPG	0x0008
+#define AG71XX_REG_MAC_HDX	0x000c
+#define AG71XX_REG_MAC_MFL	0x0010
+#define AG71XX_REG_MII_CFG	0x0020
+#define AG71XX_REG_MII_CMD	0x0024
+#define AG71XX_REG_MII_ADDR	0x0028
+#define AG71XX_REG_MII_CTRL	0x002c
+#define AG71XX_REG_MII_STATUS	0x0030
+#define AG71XX_REG_MII_IND	0x0034
+#define AG71XX_REG_MAC_IFCTL	0x0038
+#define AG71XX_REG_MAC_ADDR1	0x0040
+#define AG71XX_REG_MAC_ADDR2	0x0044
+#define AG71XX_REG_FIFO_CFG0	0x0048
+#define AG71XX_REG_FIFO_CFG1	0x004c
+#define AG71XX_REG_FIFO_CFG2	0x0050
+#define AG71XX_REG_FIFO_CFG3	0x0054
+#define AG71XX_REG_FIFO_CFG4	0x0058
+#define AG71XX_REG_FIFO_CFG5	0x005c
+#define AG71XX_REG_FIFO_RAM0	0x0060
+#define AG71XX_REG_FIFO_RAM1	0x0064
+#define AG71XX_REG_FIFO_RAM2	0x0068
+#define AG71XX_REG_FIFO_RAM3	0x006c
+#define AG71XX_REG_FIFO_RAM4	0x0070
+#define AG71XX_REG_FIFO_RAM5	0x0074
+#define AG71XX_REG_FIFO_RAM6	0x0078
+#define AG71XX_REG_FIFO_RAM7	0x007c
+
+#define AG71XX_REG_TX_CTRL	0x0180
+#define AG71XX_REG_TX_DESC	0x0184
+#define AG71XX_REG_TX_STATUS	0x0188
+#define AG71XX_REG_RX_CTRL	0x018c
+#define AG71XX_REG_RX_DESC	0x0190
+#define AG71XX_REG_RX_STATUS	0x0194
+#define AG71XX_REG_INT_ENABLE	0x0198
+#define AG71XX_REG_INT_STATUS	0x019c
+
+#define AG71XX_REG_FIFO_DEPTH	0x01a8
+#define AG71XX_REG_RX_SM	0x01b0
+#define AG71XX_REG_TX_SM	0x01b4
+
+#define MAC_CFG1_TXE		BIT(0)	/* Tx Enable */
+#define MAC_CFG1_STX		BIT(1)	/* Synchronize Tx Enable */
+#define MAC_CFG1_RXE		BIT(2)	/* Rx Enable */
+#define MAC_CFG1_SRX		BIT(3)	/* Synchronize Rx Enable */
+#define MAC_CFG1_TFC		BIT(4)	/* Tx Flow Control Enable */
+#define MAC_CFG1_RFC		BIT(5)	/* Rx Flow Control Enable */
+#define MAC_CFG1_LB		BIT(8)	/* Loopback mode */
+#define MAC_CFG1_SR		BIT(31)	/* Soft Reset */
+
+#define MAC_CFG2_FDX		BIT(0)
+#define MAC_CFG2_CRC_EN		BIT(1)
+#define MAC_CFG2_PAD_CRC_EN	BIT(2)
+#define MAC_CFG2_LEN_CHECK	BIT(4)
+#define MAC_CFG2_HUGE_FRAME_EN	BIT(5)
+#define MAC_CFG2_IF_1000	BIT(9)
+#define MAC_CFG2_IF_10_100	BIT(8)
+
+#define FIFO_CFG0_WTM		BIT(0)	/* Watermark Module */
+#define FIFO_CFG0_RXS		BIT(1)	/* Rx System Module */
+#define FIFO_CFG0_RXF		BIT(2)	/* Rx Fabric Module */
+#define FIFO_CFG0_TXS		BIT(3)	/* Tx System Module */
+#define FIFO_CFG0_TXF		BIT(4)	/* Tx Fabric Module */
+#define FIFO_CFG0_ALL	(FIFO_CFG0_WTM | FIFO_CFG0_RXS | FIFO_CFG0_RXF \
+			| FIFO_CFG0_TXS | FIFO_CFG0_TXF)
+
+#define FIFO_CFG0_ENABLE_SHIFT	8
+
+#define FIFO_CFG4_DE		BIT(0)	/* Drop Event */
+#define FIFO_CFG4_DV		BIT(1)	/* RX_DV Event */
+#define FIFO_CFG4_FC		BIT(2)	/* False Carrier */
+#define FIFO_CFG4_CE		BIT(3)	/* Code Error */
+#define FIFO_CFG4_CR		BIT(4)	/* CRC error */
+#define FIFO_CFG4_LM		BIT(5)	/* Length Mismatch */
+#define FIFO_CFG4_LO		BIT(6)	/* Length out of range */
+#define FIFO_CFG4_OK		BIT(7)	/* Packet is OK */
+#define FIFO_CFG4_MC		BIT(8)	/* Multicast Packet */
+#define FIFO_CFG4_BC		BIT(9)	/* Broadcast Packet */
+#define FIFO_CFG4_DR		BIT(10)	/* Dribble */
+#define FIFO_CFG4_LE		BIT(11)	/* Long Event */
+#define FIFO_CFG4_CF		BIT(12)	/* Control Frame */
+#define FIFO_CFG4_PF		BIT(13)	/* Pause Frame */
+#define FIFO_CFG4_UO		BIT(14)	/* Unsupported Opcode */
+#define FIFO_CFG4_VT		BIT(15)	/* VLAN tag detected */
+#define FIFO_CFG4_FT		BIT(16)	/* Frame Truncated */
+#define FIFO_CFG4_UC		BIT(17)	/* Unicast Packet */
+
+#define FIFO_CFG5_DE		BIT(0)	/* Drop Event */
+#define FIFO_CFG5_DV		BIT(1)	/* RX_DV Event */
+#define FIFO_CFG5_FC		BIT(2)	/* False Carrier */
+#define FIFO_CFG5_CE		BIT(3)	/* Code Error */
+#define FIFO_CFG5_LM		BIT(4)	/* Length Mismatch */
+#define FIFO_CFG5_LO		BIT(5)	/* Length Out of Range */
+#define FIFO_CFG5_OK		BIT(6)	/* Packet is OK */
+#define FIFO_CFG5_MC		BIT(7)	/* Multicast Packet */
+#define FIFO_CFG5_BC		BIT(8)	/* Broadcast Packet */
+#define FIFO_CFG5_DR		BIT(9)	/* Dribble */
+#define FIFO_CFG5_CF		BIT(10)	/* Control Frame */
+#define FIFO_CFG5_PF		BIT(11)	/* Pause Frame */
+#define FIFO_CFG5_UO		BIT(12)	/* Unsupported Opcode */
+#define FIFO_CFG5_VT		BIT(13)	/* VLAN tag detected */
+#define FIFO_CFG5_LE		BIT(14)	/* Long Event */
+#define FIFO_CFG5_FT		BIT(15)	/* Frame Truncated */
+#define FIFO_CFG5_16		BIT(16)	/* unknown */
+#define FIFO_CFG5_17		BIT(17)	/* unknown */
+#define FIFO_CFG5_SF		BIT(18)	/* Short Frame */
+#define FIFO_CFG5_BM		BIT(19)	/* Byte Mode */
+
+#define AG71XX_INT_TX_PS	BIT(0)
+#define AG71XX_INT_TX_UR	BIT(1)
+#define AG71XX_INT_TX_BE	BIT(3)
+#define AG71XX_INT_RX_PR	BIT(4)
+#define AG71XX_INT_RX_OF	BIT(6)
+#define AG71XX_INT_RX_BE	BIT(7)
+
+#define MAC_IFCTL_SPEED		BIT(16)
+
+#define MII_CFG_CLK_DIV_4	0
+#define MII_CFG_CLK_DIV_6	2
+#define MII_CFG_CLK_DIV_8	3
+#define MII_CFG_CLK_DIV_10	4
+#define MII_CFG_CLK_DIV_14	5
+#define MII_CFG_CLK_DIV_20	6
+#define MII_CFG_CLK_DIV_28	7
+#define MII_CFG_RESET		BIT(31)
+
+#define MII_CMD_WRITE		0x0
+#define MII_CMD_READ		0x1
+#define MII_ADDR_SHIFT		8
+#define MII_IND_BUSY		BIT(0)
+#define MII_IND_INVALID		BIT(2)
+
+#define TX_CTRL_TXE		BIT(0)	/* Tx Enable */
+
+#define TX_STATUS_PS		BIT(0)	/* Packet Sent */
+#define TX_STATUS_UR		BIT(1)	/* Tx Underrun */
+#define TX_STATUS_BE		BIT(3)	/* Bus Error */
+
+#define RX_CTRL_RXE		BIT(0)	/* Rx Enable */
+
+#define RX_STATUS_PR		BIT(0)	/* Packet Received */
+#define RX_STATUS_OF		BIT(2)	/* Rx Overflow */
+#define RX_STATUS_BE		BIT(3)	/* Bus Error */
+
+#define MII_CTRL_IF_MASK	3
+#define MII_CTRL_SPEED_SHIFT	4
+#define MII_CTRL_SPEED_MASK	3
+#define MII_CTRL_SPEED_10	0
+#define MII_CTRL_SPEED_100	1
+#define MII_CTRL_SPEED_1000	2
+
+static inline void ag71xx_check_reg_offset(struct ag71xx *ag, unsigned reg)
+{
+	switch (reg) {
+	case AG71XX_REG_MAC_CFG1 ... AG71XX_REG_MAC_MFL:
+	case AG71XX_REG_MAC_IFCTL ... AG71XX_REG_INT_STATUS:
+	case AG71XX_REG_MII_CFG:
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+static inline void ag71xx_wr(struct ag71xx *ag, unsigned reg, u32 value)
+{
+	ag71xx_check_reg_offset(ag, reg);
+
+	__raw_writel(value, ag->mac_base + reg);
+	/* flush write */
+	(void) __raw_readl(ag->mac_base + reg);
+}
+
+static inline u32 ag71xx_rr(struct ag71xx *ag, unsigned reg)
+{
+	ag71xx_check_reg_offset(ag, reg);
+
+	return __raw_readl(ag->mac_base + reg);
+}
+
+static inline void ag71xx_sb(struct ag71xx *ag, unsigned reg, u32 mask)
+{
+	void __iomem *r;
+
+	ag71xx_check_reg_offset(ag, reg);
+
+	r = ag->mac_base + reg;
+	__raw_writel(__raw_readl(r) | mask, r);
+	/* flush write */
+	(void)__raw_readl(r);
+}
+
+static inline void ag71xx_cb(struct ag71xx *ag, unsigned reg, u32 mask)
+{
+	void __iomem *r;
+
+	ag71xx_check_reg_offset(ag, reg);
+
+	r = ag->mac_base + reg;
+	__raw_writel(__raw_readl(r) & ~mask, r);
+	/* flush write */
+	(void) __raw_readl(r);
+}
+
+static inline void ag71xx_int_enable(struct ag71xx *ag, u32 ints)
+{
+	ag71xx_sb(ag, AG71XX_REG_INT_ENABLE, ints);
+}
+
+static inline void ag71xx_int_disable(struct ag71xx *ag, u32 ints)
+{
+	ag71xx_cb(ag, AG71XX_REG_INT_ENABLE, ints);
+}
+
+static inline void ag71xx_mii_ctrl_wr(struct ag71xx *ag, u32 value)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (pdata->is_ar724x)
+		return;
+
+	__raw_writel(value, ag->mii_ctrl);
+
+	/* flush write */
+	__raw_readl(ag->mii_ctrl);
+}
+
+static inline u32 ag71xx_mii_ctrl_rr(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (pdata->is_ar724x)
+		return 0xffffffff;
+
+	return __raw_readl(ag->mii_ctrl);
+}
+
+static inline void ag71xx_mii_ctrl_set_if(struct ag71xx *ag,
+					  unsigned int mii_if)
+{
+	u32 t;
+
+	t = ag71xx_mii_ctrl_rr(ag);
+	t &= ~(MII_CTRL_IF_MASK);
+	t |= (mii_if & MII_CTRL_IF_MASK);
+	ag71xx_mii_ctrl_wr(ag, t);
+}
+
+static inline void ag71xx_mii_ctrl_set_speed(struct ag71xx *ag,
+					     unsigned int speed)
+{
+	u32 t;
+
+	t = ag71xx_mii_ctrl_rr(ag);
+	t &= ~(MII_CTRL_SPEED_MASK << MII_CTRL_SPEED_SHIFT);
+	t |= (speed & MII_CTRL_SPEED_MASK) << MII_CTRL_SPEED_SHIFT;
+	ag71xx_mii_ctrl_wr(ag, t);
+}
+
+#ifdef CONFIG_AG71XX_AR8216_SUPPORT
+void ag71xx_add_ar8216_header(struct ag71xx *ag, struct sk_buff *skb);
+int ag71xx_remove_ar8216_header(struct ag71xx *ag, struct sk_buff *skb,
+				int pktlen);
+static inline int ag71xx_has_ar8216(struct ag71xx *ag)
+{
+	return ag71xx_get_pdata(ag)->has_ar8216;
+}
+#else
+static inline void ag71xx_add_ar8216_header(struct ag71xx *ag,
+					   struct sk_buff *skb)
+{
+}
+
+static inline int ag71xx_remove_ar8216_header(struct ag71xx *ag,
+					      struct sk_buff *skb,
+					      int pktlen)
+{
+	return 0;
+}
+static inline int ag71xx_has_ar8216(struct ag71xx *ag)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_AG71XX_DEBUG_FS
+int ag71xx_debugfs_root_init(void);
+void ag71xx_debugfs_root_exit(void);
+int ag71xx_debugfs_init(struct ag71xx *ag);
+void ag71xx_debugfs_exit(struct ag71xx *ag);
+void ag71xx_debugfs_update_int_stats(struct ag71xx *ag, u32 status);
+void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag, int rx, int tx);
+#else
+static inline int ag71xx_debugfs_root_init(void) { return 0; }
+static inline void ag71xx_debugfs_root_exit(void) {}
+static inline int ag71xx_debugfs_init(struct ag71xx *ag) { return 0; }
+static inline void ag71xx_debugfs_exit(struct ag71xx *ag) {}
+static inline void ag71xx_debugfs_update_int_stats(struct ag71xx *ag,
+						   u32 status) {}
+static inline void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag,
+						    int rx, int tx) {}
+#endif /* CONFIG_AG71XX_DEBUG_FS */
+
+void ag71xx_ar7240_start(struct ag71xx *ag);
+void ag71xx_ar7240_stop(struct ag71xx *ag);
+int ag71xx_ar7240_init(struct ag71xx *ag);
+void ag71xx_ar7240_cleanup(struct ag71xx *ag);
+
+int ag71xx_mdio_mii_read(struct ag71xx_mdio *am, int addr, int reg);
+void ag71xx_mdio_mii_write(struct ag71xx_mdio *am, int addr, int reg, u16 val);
+
+u16 ar7240sw_phy_read(struct mii_bus *mii, unsigned phy_addr,
+		      unsigned reg_addr);
+int ar7240sw_phy_write(struct mii_bus *mii, unsigned phy_addr,
+		       unsigned reg_addr, u16 reg_val);
+
+#endif /* _AG71XX_H */
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_main.c linux-2.6.39/drivers/net/ag71xx/ag71xx_main.c
--- linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/ag71xx_main.c	2011-08-22 07:40:12.160480642 +0200
@@ -0,0 +1,1291 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+#define AG71XX_DEFAULT_MSG_ENABLE	\
+	(NETIF_MSG_DRV			\
+	| NETIF_MSG_PROBE		\
+	| NETIF_MSG_LINK		\
+	| NETIF_MSG_TIMER		\
+	| NETIF_MSG_IFDOWN		\
+	| NETIF_MSG_IFUP		\
+	| NETIF_MSG_RX_ERR		\
+	| NETIF_MSG_TX_ERR)
+
+static int ag71xx_msg_level = -1;
+
+module_param_named(msg_level, ag71xx_msg_level, int, 0);
+MODULE_PARM_DESC(msg_level, "Message level (-1=defaults,0=none,...,16=all)");
+
+static void ag71xx_dump_dma_regs(struct ag71xx *ag)
+{
+	DBG("%s: dma_tx_ctrl=%08x, dma_tx_desc=%08x, dma_tx_status=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_TX_CTRL),
+		ag71xx_rr(ag, AG71XX_REG_TX_DESC),
+		ag71xx_rr(ag, AG71XX_REG_TX_STATUS));
+
+	DBG("%s: dma_rx_ctrl=%08x, dma_rx_desc=%08x, dma_rx_status=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_RX_CTRL),
+		ag71xx_rr(ag, AG71XX_REG_RX_DESC),
+		ag71xx_rr(ag, AG71XX_REG_RX_STATUS));
+}
+
+static void ag71xx_dump_regs(struct ag71xx *ag)
+{
+	DBG("%s: mac_cfg1=%08x, mac_cfg2=%08x, ipg=%08x, hdx=%08x, mfl=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG2),
+		ag71xx_rr(ag, AG71XX_REG_MAC_IPG),
+		ag71xx_rr(ag, AG71XX_REG_MAC_HDX),
+		ag71xx_rr(ag, AG71XX_REG_MAC_MFL));
+	DBG("%s: mac_ifctl=%08x, mac_addr1=%08x, mac_addr2=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL),
+		ag71xx_rr(ag, AG71XX_REG_MAC_ADDR1),
+		ag71xx_rr(ag, AG71XX_REG_MAC_ADDR2));
+	DBG("%s: fifo_cfg0=%08x, fifo_cfg1=%08x, fifo_cfg2=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG0),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG2));
+	DBG("%s: fifo_cfg3=%08x, fifo_cfg4=%08x, fifo_cfg5=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG3),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG4),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5));
+}
+
+static inline void ag71xx_dump_intr(struct ag71xx *ag, char *label, u32 intr)
+{
+	DBG("%s: %s intr=%08x %s%s%s%s%s%s\n",
+		ag->dev->name, label, intr,
+		(intr & AG71XX_INT_TX_PS) ? "TXPS " : "",
+		(intr & AG71XX_INT_TX_UR) ? "TXUR " : "",
+		(intr & AG71XX_INT_TX_BE) ? "TXBE " : "",
+		(intr & AG71XX_INT_RX_PR) ? "RXPR " : "",
+		(intr & AG71XX_INT_RX_OF) ? "RXOF " : "",
+		(intr & AG71XX_INT_RX_BE) ? "RXBE " : "");
+}
+
+static void ag71xx_ring_free(struct ag71xx_ring *ring)
+{
+	kfree(ring->buf);
+
+	if (ring->descs_cpu)
+		dma_free_coherent(NULL, ring->size * ring->desc_size,
+				  ring->descs_cpu, ring->descs_dma);
+}
+
+static int ag71xx_ring_alloc(struct ag71xx_ring *ring)
+{
+	int err;
+	int i;
+
+	ring->desc_size = sizeof(struct ag71xx_desc);
+	if (ring->desc_size % cache_line_size()) {
+		DBG("ag71xx: ring %p, desc size %u rounded to %u\n",
+			ring, ring->desc_size,
+			roundup(ring->desc_size, cache_line_size()));
+		ring->desc_size = roundup(ring->desc_size, cache_line_size());
+	}
+
+	ring->descs_cpu = dma_alloc_coherent(NULL, ring->size * ring->desc_size,
+					     &ring->descs_dma, GFP_ATOMIC);
+	if (!ring->descs_cpu) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+
+	ring->buf = kzalloc(ring->size * sizeof(*ring->buf), GFP_KERNEL);
+	if (!ring->buf) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+	for (i = 0; i < ring->size; i++) {
+		int idx = i * ring->desc_size;
+		ring->buf[i].desc = (struct ag71xx_desc *)&ring->descs_cpu[idx];
+		DBG("ag71xx: ring %p, desc %d at %p\n",
+			ring, i, ring->buf[i].desc);
+	}
+
+	return 0;
+
+err:
+	return err;
+}
+
+static void ag71xx_ring_tx_clean(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct net_device *dev = ag->dev;
+
+	while (ring->curr != ring->dirty) {
+		u32 i = ring->dirty % ring->size;
+
+		if (!ag71xx_desc_empty(ring->buf[i].desc)) {
+			ring->buf[i].desc->ctrl = 0;
+			dev->stats.tx_errors++;
+		}
+
+		if (ring->buf[i].skb)
+			dev_kfree_skb_any(ring->buf[i].skb);
+
+		ring->buf[i].skb = NULL;
+
+		ring->dirty++;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+}
+
+static void ag71xx_ring_tx_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	int i;
+
+	for (i = 0; i < ring->size; i++) {
+		ring->buf[i].desc->next = (u32) (ring->descs_dma +
+			ring->desc_size * ((i + 1) % ring->size));
+
+		ring->buf[i].desc->ctrl = DESC_EMPTY;
+		ring->buf[i].skb = NULL;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	ring->curr = 0;
+	ring->dirty = 0;
+}
+
+static void ag71xx_ring_rx_clean(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int i;
+
+	if (!ring->buf)
+		return;
+
+	for (i = 0; i < ring->size; i++)
+		if (ring->buf[i].skb) {
+			dma_unmap_single(&ag->dev->dev, ring->buf[i].dma_addr,
+					 AG71XX_RX_PKT_SIZE, DMA_FROM_DEVICE);
+			kfree_skb(ring->buf[i].skb);
+		}
+}
+
+static int ag71xx_rx_reserve(struct ag71xx *ag)
+{
+	int reserve = 0;
+
+	if (ag71xx_get_pdata(ag)->is_ar724x) {
+		if (!ag71xx_has_ar8216(ag))
+			reserve = 2;
+
+		if (ag->phy_dev)
+			reserve += 4 - (ag->phy_dev->pkt_align % 4);
+
+		reserve %= 4;
+	}
+
+	return reserve + AG71XX_RX_PKT_RESERVE;
+}
+
+
+static int ag71xx_ring_rx_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	unsigned int reserve = ag71xx_rx_reserve(ag);
+	unsigned int i;
+	int ret;
+
+	ret = 0;
+	for (i = 0; i < ring->size; i++) {
+		ring->buf[i].desc->next = (u32) (ring->descs_dma +
+			ring->desc_size * ((i + 1) % ring->size));
+
+		DBG("ag71xx: RX desc at %p, next is %08x\n",
+			ring->buf[i].desc,
+			ring->buf[i].desc->next);
+	}
+
+	for (i = 0; i < ring->size; i++) {
+		struct sk_buff *skb;
+		dma_addr_t dma_addr;
+
+		skb = dev_alloc_skb(AG71XX_RX_PKT_SIZE + reserve);
+		if (!skb) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		skb->dev = ag->dev;
+		skb_reserve(skb, reserve);
+
+		dma_addr = dma_map_single(&ag->dev->dev, skb->data,
+					  AG71XX_RX_PKT_SIZE,
+					  DMA_FROM_DEVICE);
+		ring->buf[i].skb = skb;
+		ring->buf[i].dma_addr = dma_addr;
+		ring->buf[i].desc->data = (u32) dma_addr;
+		ring->buf[i].desc->ctrl = DESC_EMPTY;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	ring->curr = 0;
+	ring->dirty = 0;
+
+	return ret;
+}
+
+static int ag71xx_ring_rx_refill(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	unsigned int reserve = ag71xx_rx_reserve(ag);
+	unsigned int count;
+
+	count = 0;
+	for (; ring->curr - ring->dirty > 0; ring->dirty++) {
+		unsigned int i;
+
+		i = ring->dirty % ring->size;
+
+		if (ring->buf[i].skb == NULL) {
+			dma_addr_t dma_addr;
+			struct sk_buff *skb;
+
+			skb = dev_alloc_skb(AG71XX_RX_PKT_SIZE + reserve);
+			if (skb == NULL)
+				break;
+
+			skb_reserve(skb, reserve);
+			skb->dev = ag->dev;
+
+			dma_addr = dma_map_single(&ag->dev->dev, skb->data,
+						  AG71XX_RX_PKT_SIZE,
+						  DMA_FROM_DEVICE);
+
+			ring->buf[i].skb = skb;
+			ring->buf[i].dma_addr = dma_addr;
+			ring->buf[i].desc->data = (u32) dma_addr;
+		}
+
+		ring->buf[i].desc->ctrl = DESC_EMPTY;
+		count++;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	DBG("%s: %u rx descriptors refilled\n", ag->dev->name, count);
+
+	return count;
+}
+
+static int ag71xx_rings_init(struct ag71xx *ag)
+{
+	int ret;
+
+	ret = ag71xx_ring_alloc(&ag->tx_ring);
+	if (ret)
+		return ret;
+
+	ag71xx_ring_tx_init(ag);
+
+	ret = ag71xx_ring_alloc(&ag->rx_ring);
+	if (ret)
+		return ret;
+
+	ret = ag71xx_ring_rx_init(ag);
+	return ret;
+}
+
+static void ag71xx_rings_cleanup(struct ag71xx *ag)
+{
+	ag71xx_ring_rx_clean(ag);
+	ag71xx_ring_free(&ag->rx_ring);
+
+	ag71xx_ring_tx_clean(ag);
+	ag71xx_ring_free(&ag->tx_ring);
+}
+
+static unsigned char *ag71xx_speed_str(struct ag71xx *ag)
+{
+	switch (ag->speed) {
+	case SPEED_1000:
+		return "1000";
+	case SPEED_100:
+		return "100";
+	case SPEED_10:
+		return "10";
+	}
+
+	return "?";
+}
+
+static void ag71xx_hw_set_macaddr(struct ag71xx *ag, unsigned char *mac)
+{
+	u32 t;
+
+	t = (((u32) mac[5]) << 24) | (((u32) mac[4]) << 16)
+	  | (((u32) mac[3]) << 8) | ((u32) mac[2]);
+
+	ag71xx_wr(ag, AG71XX_REG_MAC_ADDR1, t);
+
+	t = (((u32) mac[1]) << 24) | (((u32) mac[0]) << 16);
+	ag71xx_wr(ag, AG71XX_REG_MAC_ADDR2, t);
+}
+
+static void ag71xx_dma_reset(struct ag71xx *ag)
+{
+	u32 val;
+	int i;
+
+	ag71xx_dump_dma_regs(ag);
+
+	/* stop RX and TX */
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);
+
+	/*
+	 * give the hardware some time to really stop all rx/tx activity
+	 * clearing the descriptors too early causes random memory corruption
+	 */
+	mdelay(1);
+
+	/* clear descriptor addresses */
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->stop_desc_dma);
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->stop_desc_dma);
+
+	/* clear pending RX/TX interrupts */
+	for (i = 0; i < 256; i++) {
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);
+		ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
+	}
+
+	/* clear pending errors */
+	ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE | RX_STATUS_OF);
+	ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE | TX_STATUS_UR);
+
+	val = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
+	if (val)
+		printk(KERN_ALERT "%s: unable to clear DMA Rx status: %08x\n",
+			ag->dev->name, val);
+
+	val = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);
+
+	/* mask out reserved bits */
+	val &= ~0xff000000;
+
+	if (val)
+		printk(KERN_ALERT "%s: unable to clear DMA Tx status: %08x\n",
+			ag->dev->name, val);
+
+	ag71xx_dump_dma_regs(ag);
+}
+
+#define MAC_CFG1_INIT	(MAC_CFG1_RXE | MAC_CFG1_TXE | \
+			 MAC_CFG1_SRX | MAC_CFG1_STX)
+
+#define FIFO_CFG0_INIT	(FIFO_CFG0_ALL << FIFO_CFG0_ENABLE_SHIFT)
+
+#define FIFO_CFG4_INIT	(FIFO_CFG4_DE | FIFO_CFG4_DV | FIFO_CFG4_FC | \
+			 FIFO_CFG4_CE | FIFO_CFG4_CR | FIFO_CFG4_LM | \
+			 FIFO_CFG4_LO | FIFO_CFG4_OK | FIFO_CFG4_MC | \
+			 FIFO_CFG4_BC | FIFO_CFG4_DR | FIFO_CFG4_LE | \
+			 FIFO_CFG4_CF | FIFO_CFG4_PF | FIFO_CFG4_UO | \
+			 FIFO_CFG4_VT)
+
+#define FIFO_CFG5_INIT	(FIFO_CFG5_DE | FIFO_CFG5_DV | FIFO_CFG5_FC | \
+			 FIFO_CFG5_CE | FIFO_CFG5_LO | FIFO_CFG5_OK | \
+			 FIFO_CFG5_MC | FIFO_CFG5_BC | FIFO_CFG5_DR | \
+			 FIFO_CFG5_CF | FIFO_CFG5_PF | FIFO_CFG5_VT | \
+			 FIFO_CFG5_LE | FIFO_CFG5_FT | FIFO_CFG5_16 | \
+			 FIFO_CFG5_17 | FIFO_CFG5_SF)
+
+static void ag71xx_hw_stop(struct ag71xx *ag)
+{
+	/* disable all interrupts and stop the rx/tx engine */
+	ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, 0);
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);
+}
+
+static void ag71xx_hw_setup(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	/* setup MAC configuration registers */
+	ag71xx_wr(ag, AG71XX_REG_MAC_CFG1, MAC_CFG1_INIT);
+
+	ag71xx_sb(ag, AG71XX_REG_MAC_CFG2,
+		  MAC_CFG2_PAD_CRC_EN | MAC_CFG2_LEN_CHECK);
+
+	/* setup max frame length */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL, AG71XX_TX_MTU_LEN);
+
+	/* setup MII interface type */
+	ag71xx_mii_ctrl_set_if(ag, pdata->mii_if);
+
+	/* setup FIFO configuration registers */
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG0, FIFO_CFG0_INIT);
+	if (pdata->is_ar724x) {
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG1, pdata->fifo_cfg1);
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG2, pdata->fifo_cfg2);
+	} else {
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG1, 0x0fff0000);
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG2, 0x00001fff);
+	}
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG4, FIFO_CFG4_INIT);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, FIFO_CFG5_INIT);
+}
+
+static void ag71xx_hw_init(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	u32 reset_mask = pdata->reset_bit;
+
+	ag71xx_hw_stop(ag);
+
+	if (pdata->is_ar724x) {
+		u32 reset_phy = reset_mask;
+
+		reset_phy &= RESET_MODULE_GE0_PHY | RESET_MODULE_GE1_PHY;
+		reset_mask &= ~(RESET_MODULE_GE0_PHY | RESET_MODULE_GE1_PHY);
+
+		ar71xx_device_stop(reset_phy);
+		mdelay(50);
+		ar71xx_device_start(reset_phy);
+		mdelay(200);
+	}
+
+	ag71xx_sb(ag, AG71XX_REG_MAC_CFG1, MAC_CFG1_SR);
+	udelay(20);
+
+	ar71xx_device_stop(reset_mask);
+	mdelay(100);
+	ar71xx_device_start(reset_mask);
+	mdelay(200);
+
+	ag71xx_hw_setup(ag);
+
+	ag71xx_dma_reset(ag);
+}
+
+static void ag71xx_fast_reset(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct net_device *dev = ag->dev;
+	u32 reset_mask = pdata->reset_bit;
+	u32 rx_ds, tx_ds;
+	u32 mii_reg;
+
+	reset_mask &= RESET_MODULE_GE0_MAC | RESET_MODULE_GE1_MAC;
+
+	mii_reg = ag71xx_rr(ag, AG71XX_REG_MII_CFG);
+	rx_ds = ag71xx_rr(ag, AG71XX_REG_RX_DESC);
+	tx_ds = ag71xx_rr(ag, AG71XX_REG_TX_DESC);
+
+	ar71xx_device_stop(reset_mask);
+	udelay(10);
+	ar71xx_device_start(reset_mask);
+	udelay(10);
+
+	ag71xx_dma_reset(ag);
+	ag71xx_hw_setup(ag);
+
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, rx_ds);
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, tx_ds);
+	ag71xx_wr(ag, AG71XX_REG_MII_CFG, mii_reg);
+
+	ag71xx_hw_set_macaddr(ag, dev->dev_addr);
+}
+
+static void ag71xx_hw_start(struct ag71xx *ag)
+{
+	/* start RX engine */
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);
+
+	/* enable interrupts */
+	ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, AG71XX_INT_INIT);
+}
+
+void ag71xx_link_adjust(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	u32 cfg2;
+	u32 ifctl;
+	u32 fifo5;
+	u32 mii_speed;
+
+	if (!ag->link) {
+		ag71xx_hw_stop(ag);
+		netif_carrier_off(ag->dev);
+		if (netif_msg_link(ag))
+			printk(KERN_INFO "%s: link down\n", ag->dev->name);
+		return;
+	}
+
+	if (pdata->is_ar724x)
+		ag71xx_fast_reset(ag);
+
+	cfg2 = ag71xx_rr(ag, AG71XX_REG_MAC_CFG2);
+	cfg2 &= ~(MAC_CFG2_IF_1000 | MAC_CFG2_IF_10_100 | MAC_CFG2_FDX);
+	cfg2 |= (ag->duplex) ? MAC_CFG2_FDX : 0;
+
+	ifctl = ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL);
+	ifctl &= ~(MAC_IFCTL_SPEED);
+
+	fifo5 = ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5);
+	fifo5 &= ~FIFO_CFG5_BM;
+
+	switch (ag->speed) {
+	case SPEED_1000:
+		mii_speed =  MII_CTRL_SPEED_1000;
+		cfg2 |= MAC_CFG2_IF_1000;
+		fifo5 |= FIFO_CFG5_BM;
+		break;
+	case SPEED_100:
+		mii_speed = MII_CTRL_SPEED_100;
+		cfg2 |= MAC_CFG2_IF_10_100;
+		ifctl |= MAC_IFCTL_SPEED;
+		break;
+	case SPEED_10:
+		mii_speed = MII_CTRL_SPEED_10;
+		cfg2 |= MAC_CFG2_IF_10_100;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	if (pdata->is_ar91xx)
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG3, 0x00780fff);
+	else if (pdata->is_ar724x)
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG3, pdata->fifo_cfg3);
+	else
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG3, 0x008001ff);
+
+	if (pdata->set_pll)
+		pdata->set_pll(ag->speed);
+
+	ag71xx_mii_ctrl_set_speed(ag, mii_speed);
+
+	ag71xx_wr(ag, AG71XX_REG_MAC_CFG2, cfg2);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, fifo5);
+	ag71xx_wr(ag, AG71XX_REG_MAC_IFCTL, ifctl);
+	ag71xx_hw_start(ag);
+
+	netif_carrier_on(ag->dev);
+	if (netif_msg_link(ag))
+		printk(KERN_INFO "%s: link up (%sMbps/%s duplex)\n",
+			ag->dev->name,
+			ag71xx_speed_str(ag),
+			(DUPLEX_FULL == ag->duplex) ? "Full" : "Half");
+
+	DBG("%s: fifo_cfg0=%#x, fifo_cfg1=%#x, fifo_cfg2=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG0),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG2));
+
+	DBG("%s: fifo_cfg3=%#x, fifo_cfg4=%#x, fifo_cfg5=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG3),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG4),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5));
+
+	DBG("%s: mac_cfg2=%#x, mac_ifctl=%#x, mii_ctrl=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG2),
+		ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL),
+		ag71xx_mii_ctrl_rr(ag));
+}
+
+static int ag71xx_open(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	int ret;
+
+	ret = ag71xx_rings_init(ag);
+	if (ret)
+		goto err;
+
+	napi_enable(&ag->napi);
+
+	netif_carrier_off(dev);
+	ag71xx_phy_start(ag);
+
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->rx_ring.descs_dma);
+
+	ag71xx_hw_set_macaddr(ag, dev->dev_addr);
+
+	netif_start_queue(dev);
+
+	return 0;
+
+err:
+	ag71xx_rings_cleanup(ag);
+	return ret;
+}
+
+static int ag71xx_stop(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned long flags;
+
+	netif_carrier_off(dev);
+	ag71xx_phy_stop(ag);
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	netif_stop_queue(dev);
+
+	ag71xx_hw_stop(ag);
+	ag71xx_dma_reset(ag);
+
+	napi_disable(&ag->napi);
+	del_timer_sync(&ag->oom_timer);
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	ag71xx_rings_cleanup(ag);
+
+	return 0;
+}
+
+static netdev_tx_t ag71xx_hard_start_xmit(struct sk_buff *skb,
+					  struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct ag71xx_desc *desc;
+	dma_addr_t dma_addr;
+	int i;
+
+	i = ring->curr % ring->size;
+	desc = ring->buf[i].desc;
+
+	if (!ag71xx_desc_empty(desc))
+		goto err_drop;
+
+	if (ag71xx_has_ar8216(ag))
+		ag71xx_add_ar8216_header(ag, skb);
+
+	if (skb->len <= 0) {
+		DBG("%s: packet len is too small\n", ag->dev->name);
+		goto err_drop;
+	}
+
+	dma_addr = dma_map_single(&dev->dev, skb->data, skb->len,
+				  DMA_TO_DEVICE);
+
+	ring->buf[i].skb = skb;
+	ring->buf[i].timestamp = jiffies;
+
+	/* setup descriptor fields */
+	desc->data = (u32) dma_addr;
+	desc->ctrl = (skb->len & DESC_PKTLEN_M);
+
+	/* flush descriptor */
+	wmb();
+
+	ring->curr++;
+	if (ring->curr == (ring->dirty + ring->size)) {
+		DBG("%s: tx queue full\n", ag->dev->name);
+		netif_stop_queue(dev);
+	}
+
+	DBG("%s: packet injected into TX queue\n", ag->dev->name);
+
+	/* enable TX engine */
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, TX_CTRL_TXE);
+
+	return NETDEV_TX_OK;
+
+err_drop:
+	dev->stats.tx_dropped++;
+
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+static int ag71xx_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	int ret;
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		if (ag->phy_dev == NULL)
+			break;
+
+		spin_lock_irq(&ag->lock);
+		ret = phy_ethtool_ioctl(ag->phy_dev, (void *) ifr->ifr_data);
+		spin_unlock_irq(&ag->lock);
+		return ret;
+
+	case SIOCSIFHWADDR:
+		if (copy_from_user
+			(dev->dev_addr, ifr->ifr_data, sizeof(dev->dev_addr)))
+			return -EFAULT;
+		return 0;
+
+	case SIOCGIFHWADDR:
+		if (copy_to_user
+			(ifr->ifr_data, dev->dev_addr, sizeof(dev->dev_addr)))
+			return -EFAULT;
+		return 0;
+
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		if (ag->phy_dev == NULL)
+			break;
+
+		return phy_mii_ioctl(ag->phy_dev, ifr, cmd);
+
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static void ag71xx_oom_timer_handler(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct ag71xx *ag = netdev_priv(dev);
+
+	napi_schedule(&ag->napi);
+}
+
+static void ag71xx_tx_timeout(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	if (netif_msg_tx_err(ag))
+		printk(KERN_DEBUG "%s: tx timeout\n", ag->dev->name);
+
+	schedule_work(&ag->restart_work);
+}
+
+static void ag71xx_restart_work_func(struct work_struct *work)
+{
+	struct ag71xx *ag = container_of(work, struct ag71xx, restart_work);
+
+	if (ag71xx_get_pdata(ag)->is_ar724x) {
+		ag->link = 0;
+		ag71xx_link_adjust(ag);
+		return;
+	}
+
+	ag71xx_stop(ag->dev);
+	ag71xx_open(ag->dev);
+}
+
+static bool ag71xx_check_dma_stuck(struct ag71xx *ag, unsigned long timestamp)
+{
+	u32 rx_sm, tx_sm, rx_fd;
+
+	if (likely(time_before(jiffies, timestamp + HZ/10)))
+		return false;
+
+	if (!netif_carrier_ok(ag->dev))
+		return false;
+
+	rx_sm = ag71xx_rr(ag, AG71XX_REG_RX_SM);
+	if ((rx_sm & 0x7) == 0x3 && ((rx_sm >> 4) & 0x7) == 0x6)
+		return true;
+
+	tx_sm = ag71xx_rr(ag, AG71XX_REG_TX_SM);
+	rx_fd = ag71xx_rr(ag, AG71XX_REG_FIFO_DEPTH);
+	if (((tx_sm >> 4) & 0x7) == 0 && ((rx_sm & 0x7) == 0) &&
+	    ((rx_sm >> 4) & 0x7) == 0 && rx_fd == 0)
+		return true;
+
+	return false;
+}
+
+static int ag71xx_tx_packets(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	int sent;
+
+	DBG("%s: processing TX ring\n", ag->dev->name);
+
+	sent = 0;
+	while (ring->dirty != ring->curr) {
+		unsigned int i = ring->dirty % ring->size;
+		struct ag71xx_desc *desc = ring->buf[i].desc;
+		struct sk_buff *skb = ring->buf[i].skb;
+
+		if (!ag71xx_desc_empty(desc)) {
+			if (pdata->is_ar7240 &&
+			    ag71xx_check_dma_stuck(ag, ring->buf[i].timestamp))
+				schedule_work(&ag->restart_work);
+			break;
+		}
+
+		ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
+
+		ag->dev->stats.tx_bytes += skb->len;
+		ag->dev->stats.tx_packets++;
+
+		dev_kfree_skb_any(skb);
+		ring->buf[i].skb = NULL;
+
+		ring->dirty++;
+		sent++;
+	}
+
+	DBG("%s: %d packets sent out\n", ag->dev->name, sent);
+
+	if ((ring->curr - ring->dirty) < (ring->size * 3) / 4)
+		netif_wake_queue(ag->dev);
+
+	return sent;
+}
+
+static int ag71xx_rx_packets(struct ag71xx *ag, int limit)
+{
+	struct net_device *dev = ag->dev;
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int done = 0;
+
+	DBG("%s: rx packets, limit=%d, curr=%u, dirty=%u\n",
+			dev->name, limit, ring->curr, ring->dirty);
+
+	while (done < limit) {
+		unsigned int i = ring->curr % ring->size;
+		struct ag71xx_desc *desc = ring->buf[i].desc;
+		struct sk_buff *skb;
+		int pktlen;
+		int err = 0;
+
+		if (ag71xx_desc_empty(desc))
+			break;
+
+		if ((ring->dirty + ring->size) == ring->curr) {
+			ag71xx_assert(0);
+			break;
+		}
+
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);
+
+		skb = ring->buf[i].skb;
+		pktlen = ag71xx_desc_pktlen(desc);
+		pktlen -= ETH_FCS_LEN;
+
+		dma_unmap_single(&dev->dev, ring->buf[i].dma_addr,
+				 AG71XX_RX_PKT_SIZE, DMA_FROM_DEVICE);
+
+		dev->last_rx = jiffies;
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += pktlen;
+
+		skb_put(skb, pktlen);
+		if (ag71xx_has_ar8216(ag))
+			err = ag71xx_remove_ar8216_header(ag, skb, pktlen);
+
+		if (err) {
+			dev->stats.rx_dropped++;
+			kfree_skb(skb);
+		} else {
+			skb->dev = dev;
+			skb->ip_summed = CHECKSUM_NONE;
+			if (ag->phy_dev) {
+				ag->phy_dev->netif_receive_skb(skb);
+			} else {
+				skb->protocol = eth_type_trans(skb, dev);
+				netif_receive_skb(skb);
+			}
+		}
+
+		ring->buf[i].skb = NULL;
+		done++;
+
+		ring->curr++;
+	}
+
+	ag71xx_ring_rx_refill(ag);
+
+	DBG("%s: rx finish, curr=%u, dirty=%u, done=%d\n",
+		dev->name, ring->curr, ring->dirty, done);
+
+	return done;
+}
+
+static int ag71xx_poll(struct napi_struct *napi, int limit)
+{
+	struct ag71xx *ag = container_of(napi, struct ag71xx, napi);
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct net_device *dev = ag->dev;
+	struct ag71xx_ring *rx_ring;
+	unsigned long flags;
+	u32 status;
+	int tx_done;
+	int rx_done;
+
+	pdata->ddr_flush();
+	tx_done = ag71xx_tx_packets(ag);
+
+	DBG("%s: processing RX ring\n", dev->name);
+	rx_done = ag71xx_rx_packets(ag, limit);
+
+	ag71xx_debugfs_update_napi_stats(ag, rx_done, tx_done);
+
+	rx_ring = &ag->rx_ring;
+	if (rx_ring->buf[rx_ring->dirty % rx_ring->size].skb == NULL)
+		goto oom;
+
+	status = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
+	if (unlikely(status & RX_STATUS_OF)) {
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_OF);
+		dev->stats.rx_fifo_errors++;
+
+		/* restart RX */
+		ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);
+	}
+
+	if (rx_done < limit) {
+		if (status & RX_STATUS_PR)
+			goto more;
+
+		status = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);
+		if (status & TX_STATUS_PS)
+			goto more;
+
+		DBG("%s: disable polling mode, rx=%d, tx=%d,limit=%d\n",
+			dev->name, rx_done, tx_done, limit);
+
+		napi_complete(napi);
+
+		/* enable interrupts */
+		spin_lock_irqsave(&ag->lock, flags);
+		ag71xx_int_enable(ag, AG71XX_INT_POLL);
+		spin_unlock_irqrestore(&ag->lock, flags);
+		return rx_done;
+	}
+
+more:
+	DBG("%s: stay in polling mode, rx=%d, tx=%d, limit=%d\n",
+			dev->name, rx_done, tx_done, limit);
+	return rx_done;
+
+oom:
+	if (netif_msg_rx_err(ag))
+		printk(KERN_DEBUG "%s: out of memory\n", dev->name);
+
+	mod_timer(&ag->oom_timer, jiffies + AG71XX_OOM_REFILL);
+	napi_complete(napi);
+	return 0;
+}
+
+static irqreturn_t ag71xx_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct ag71xx *ag = netdev_priv(dev);
+	u32 status;
+
+	status = ag71xx_rr(ag, AG71XX_REG_INT_STATUS);
+	ag71xx_dump_intr(ag, "raw", status);
+
+	if (unlikely(!status))
+		return IRQ_NONE;
+
+	if (unlikely(status & AG71XX_INT_ERR)) {
+		if (status & AG71XX_INT_TX_BE) {
+			ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE);
+			dev_err(&dev->dev, "TX BUS error\n");
+		}
+		if (status & AG71XX_INT_RX_BE) {
+			ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE);
+			dev_err(&dev->dev, "RX BUS error\n");
+		}
+	}
+
+	if (likely(status & AG71XX_INT_POLL)) {
+		ag71xx_int_disable(ag, AG71XX_INT_POLL);
+		DBG("%s: enable polling mode\n", dev->name);
+		napi_schedule(&ag->napi);
+	}
+
+	ag71xx_debugfs_update_int_stats(ag, status);
+
+	return IRQ_HANDLED;
+}
+
+static void ag71xx_set_multicast_list(struct net_device *dev)
+{
+	/* TODO */
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void ag71xx_netpoll(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	ag71xx_interrupt(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+#endif
+
+static const struct net_device_ops ag71xx_netdev_ops = {
+	.ndo_open		= ag71xx_open,
+	.ndo_stop		= ag71xx_stop,
+	.ndo_start_xmit		= ag71xx_hard_start_xmit,
+	.ndo_set_multicast_list	= ag71xx_set_multicast_list,
+	.ndo_do_ioctl		= ag71xx_do_ioctl,
+	.ndo_tx_timeout		= ag71xx_tx_timeout,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= ag71xx_netpoll,
+#endif
+};
+
+static int __devinit ag71xx_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct resource *res;
+	struct ag71xx *ag;
+	struct ag71xx_platform_data *pdata;
+	int err;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data specified\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	if (pdata->mii_bus_dev == NULL) {
+		dev_err(&pdev->dev, "no MII bus device specified\n");
+		err = -EINVAL;
+		goto err_out;
+	}
+
+	dev = alloc_etherdev(sizeof(*ag));
+	if (!dev) {
+		dev_err(&pdev->dev, "alloc_etherdev failed\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	ag = netdev_priv(dev);
+	ag->pdev = pdev;
+	ag->dev = dev;
+	ag->msg_enable = netif_msg_init(ag71xx_msg_level,
+					AG71XX_DEFAULT_MSG_ENABLE);
+	spin_lock_init(&ag->lock);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mac_base");
+	if (!res) {
+		dev_err(&pdev->dev, "no mac_base resource found\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	ag->mac_base = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!ag->mac_base) {
+		dev_err(&pdev->dev, "unable to ioremap mac_base\n");
+		err = -ENOMEM;
+		goto err_free_dev;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mii_ctrl");
+	if (!res) {
+		dev_err(&pdev->dev, "no mii_ctrl resource found\n");
+		err = -ENXIO;
+		goto err_unmap_base;
+	}
+
+	ag->mii_ctrl = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!ag->mii_ctrl) {
+		dev_err(&pdev->dev, "unable to ioremap mii_ctrl\n");
+		err = -ENOMEM;
+		goto err_unmap_base;
+	}
+
+	dev->irq = platform_get_irq(pdev, 0);
+	err = request_irq(dev->irq, ag71xx_interrupt,
+			  IRQF_DISABLED,
+			  dev->name, dev);
+	if (err) {
+		dev_err(&pdev->dev, "unable to request IRQ %d\n", dev->irq);
+		goto err_unmap_mii_ctrl;
+	}
+
+	dev->base_addr = (unsigned long)ag->mac_base;
+	dev->netdev_ops = &ag71xx_netdev_ops;
+	dev->ethtool_ops = &ag71xx_ethtool_ops;
+
+	INIT_WORK(&ag->restart_work, ag71xx_restart_work_func);
+
+	init_timer(&ag->oom_timer);
+	ag->oom_timer.data = (unsigned long) dev;
+	ag->oom_timer.function = ag71xx_oom_timer_handler;
+
+	ag->tx_ring.size = AG71XX_TX_RING_SIZE_DEFAULT;
+	ag->rx_ring.size = AG71XX_RX_RING_SIZE_DEFAULT;
+
+	ag->stop_desc = dma_alloc_coherent(NULL,
+		sizeof(struct ag71xx_desc), &ag->stop_desc_dma, GFP_KERNEL);
+
+	if (!ag->stop_desc)
+		goto err_free_irq;
+
+	ag->stop_desc->data = 0;
+	ag->stop_desc->ctrl = 0;
+	ag->stop_desc->next = (u32) ag->stop_desc_dma;
+
+	memcpy(dev->dev_addr, pdata->mac_addr, ETH_ALEN);
+
+	netif_napi_add(dev, &ag->napi, ag71xx_poll, AG71XX_NAPI_WEIGHT);
+
+	err = register_netdev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "unable to register net device\n");
+		goto err_free_desc;
+	}
+
+	printk(KERN_INFO "%s: Atheros AG71xx at 0x%08lx, irq %d\n",
+	       dev->name, dev->base_addr, dev->irq);
+
+	ag71xx_dump_regs(ag);
+
+	ag71xx_hw_init(ag);
+
+	ag71xx_dump_regs(ag);
+
+	err = ag71xx_phy_connect(ag);
+	if (err)
+		goto err_unregister_netdev;
+
+	err = ag71xx_debugfs_init(ag);
+	if (err)
+		goto err_phy_disconnect;
+
+	platform_set_drvdata(pdev, dev);
+
+	return 0;
+
+err_phy_disconnect:
+	ag71xx_phy_disconnect(ag);
+err_unregister_netdev:
+	unregister_netdev(dev);
+err_free_desc:
+	dma_free_coherent(NULL, sizeof(struct ag71xx_desc), ag->stop_desc,
+			  ag->stop_desc_dma);
+err_free_irq:
+	free_irq(dev->irq, dev);
+err_unmap_mii_ctrl:
+	iounmap(ag->mii_ctrl);
+err_unmap_base:
+	iounmap(ag->mac_base);
+err_free_dev:
+	kfree(dev);
+err_out:
+	platform_set_drvdata(pdev, NULL);
+	return err;
+}
+
+static int __devexit ag71xx_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+
+	if (dev) {
+		struct ag71xx *ag = netdev_priv(dev);
+
+		ag71xx_debugfs_exit(ag);
+		ag71xx_phy_disconnect(ag);
+		unregister_netdev(dev);
+		free_irq(dev->irq, dev);
+		iounmap(ag->mii_ctrl);
+		iounmap(ag->mac_base);
+		kfree(dev);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ag71xx_driver = {
+	.probe		= ag71xx_probe,
+	.remove		= __exit_p(ag71xx_remove),
+	.driver = {
+		.name	= AG71XX_DRV_NAME,
+	}
+};
+
+static int __init ag71xx_module_init(void)
+{
+	int ret;
+
+	ret = ag71xx_debugfs_root_init();
+	if (ret)
+		goto err_out;
+
+	ret = ag71xx_mdio_driver_init();
+	if (ret)
+		goto err_debugfs_exit;
+
+	ret = platform_driver_register(&ag71xx_driver);
+	if (ret)
+		goto err_mdio_exit;
+
+	return 0;
+
+err_mdio_exit:
+	ag71xx_mdio_driver_exit();
+err_debugfs_exit:
+	ag71xx_debugfs_root_exit();
+err_out:
+	return ret;
+}
+
+static void __exit ag71xx_module_exit(void)
+{
+	platform_driver_unregister(&ag71xx_driver);
+	ag71xx_mdio_driver_exit();
+	ag71xx_debugfs_root_exit();
+}
+
+module_init(ag71xx_module_init);
+module_exit(ag71xx_module_exit);
+
+MODULE_VERSION(AG71XX_DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" AG71XX_DRV_NAME);
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_mdio.c linux-2.6.39/drivers/net/ag71xx/ag71xx_mdio.c
--- linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_mdio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/ag71xx_mdio.c	2011-04-27 12:19:22.257663952 +0200
@@ -0,0 +1,248 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+#define AG71XX_MDIO_RETRY	1000
+#define AG71XX_MDIO_DELAY	5
+
+static inline void ag71xx_mdio_wr(struct ag71xx_mdio *am, unsigned reg,
+				  u32 value)
+{
+	void __iomem *r;
+
+	r = am->mdio_base + reg;
+	__raw_writel(value, r);
+
+	/* flush write */
+	(void) __raw_readl(r);
+}
+
+static inline u32 ag71xx_mdio_rr(struct ag71xx_mdio *am, unsigned reg)
+{
+	return __raw_readl(am->mdio_base + reg);
+}
+
+static void ag71xx_mdio_dump_regs(struct ag71xx_mdio *am)
+{
+	DBG("%s: mii_cfg=%08x, mii_cmd=%08x, mii_addr=%08x\n",
+		am->mii_bus->name,
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_CFG),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_CMD),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_ADDR));
+	DBG("%s: mii_ctrl=%08x, mii_status=%08x, mii_ind=%08x\n",
+		am->mii_bus->name,
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_CTRL),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_STATUS),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_IND));
+}
+
+int ag71xx_mdio_mii_read(struct ag71xx_mdio *am, int addr, int reg)
+{
+	int ret;
+	int i;
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CMD, MII_CMD_WRITE);
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_ADDR,
+			((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CMD, MII_CMD_READ);
+
+	i = AG71XX_MDIO_RETRY;
+	while (ag71xx_mdio_rr(am, AG71XX_REG_MII_IND) & MII_IND_BUSY) {
+		if (i-- == 0) {
+			printk(KERN_ERR "%s: mii_read timed out\n",
+				am->mii_bus->name);
+			ret = 0xffff;
+			goto out;
+		}
+		udelay(AG71XX_MDIO_DELAY);
+	}
+
+	ret = ag71xx_mdio_rr(am, AG71XX_REG_MII_STATUS) & 0xffff;
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CMD, MII_CMD_WRITE);
+
+	DBG("mii_read: addr=%04x, reg=%04x, value=%04x\n", addr, reg, ret);
+
+out:
+	return ret;
+}
+
+void ag71xx_mdio_mii_write(struct ag71xx_mdio *am, int addr, int reg, u16 val)
+{
+	int i;
+
+	DBG("mii_write: addr=%04x, reg=%04x, value=%04x\n", addr, reg, val);
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_ADDR,
+			((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CTRL, val);
+
+	i = AG71XX_MDIO_RETRY;
+	while (ag71xx_mdio_rr(am, AG71XX_REG_MII_IND) & MII_IND_BUSY) {
+		if (i-- == 0) {
+			printk(KERN_ERR "%s: mii_write timed out\n",
+				am->mii_bus->name);
+			break;
+		}
+		udelay(AG71XX_MDIO_DELAY);
+	}
+}
+
+static int ag71xx_mdio_reset(struct mii_bus *bus)
+{
+	struct ag71xx_mdio *am = bus->priv;
+	u32 t;
+
+	if (am->pdata->is_ar7240)
+		t = MII_CFG_CLK_DIV_6;
+	else
+		t = MII_CFG_CLK_DIV_28;
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CFG, t | MII_CFG_RESET);
+	udelay(100);
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CFG, t);
+	udelay(100);
+
+	return 0;
+}
+
+static int ag71xx_mdio_read(struct mii_bus *bus, int addr, int reg)
+{
+	struct ag71xx_mdio *am = bus->priv;
+
+	if (am->pdata->is_ar7240)
+		return ar7240sw_phy_read(bus, addr, reg);
+	else
+		return ag71xx_mdio_mii_read(am, addr, reg);
+}
+
+static int ag71xx_mdio_write(struct mii_bus *bus, int addr, int reg, u16 val)
+{
+	struct ag71xx_mdio *am = bus->priv;
+
+	if (am->pdata->is_ar7240)
+		ar7240sw_phy_write(bus, addr, reg, val);
+	else
+		ag71xx_mdio_mii_write(am, addr, reg, val);
+	return 0;
+}
+
+static int __devinit ag71xx_mdio_probe(struct platform_device *pdev)
+{
+	struct ag71xx_mdio_platform_data *pdata;
+	struct ag71xx_mdio *am;
+	struct resource *res;
+	int i;
+	int err;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data specified\n");
+		return -EINVAL;
+	}
+
+	am = kzalloc(sizeof(*am), GFP_KERNEL);
+	if (!am) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	am->pdata = pdata;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no iomem resource found\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	am->mdio_base = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!am->mdio_base) {
+		dev_err(&pdev->dev, "unable to ioremap registers\n");
+		err = -ENOMEM;
+		goto err_free_mdio;
+	}
+
+	am->mii_bus = mdiobus_alloc();
+	if (am->mii_bus == NULL) {
+		err = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	am->mii_bus->name = "ag71xx_mdio";
+	am->mii_bus->read = ag71xx_mdio_read;
+	am->mii_bus->write = ag71xx_mdio_write;
+	am->mii_bus->reset = ag71xx_mdio_reset;
+	am->mii_bus->irq = am->mii_irq;
+	am->mii_bus->priv = am;
+	am->mii_bus->parent = &pdev->dev;
+	snprintf(am->mii_bus->id, MII_BUS_ID_SIZE, "%s", dev_name(&pdev->dev));
+	am->mii_bus->phy_mask = pdata->phy_mask;
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		am->mii_irq[i] = PHY_POLL;
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MAC_CFG1, 0);
+
+	err = mdiobus_register(am->mii_bus);
+	if (err)
+		goto err_free_bus;
+
+	ag71xx_mdio_dump_regs(am);
+
+	platform_set_drvdata(pdev, am);
+	return 0;
+
+err_free_bus:
+	mdiobus_free(am->mii_bus);
+err_iounmap:
+	iounmap(am->mdio_base);
+err_free_mdio:
+	kfree(am);
+err_out:
+	return err;
+}
+
+static int __devexit ag71xx_mdio_remove(struct platform_device *pdev)
+{
+	struct ag71xx_mdio *am = platform_get_drvdata(pdev);
+
+	if (am) {
+		mdiobus_unregister(am->mii_bus);
+		mdiobus_free(am->mii_bus);
+		iounmap(am->mdio_base);
+		kfree(am);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ag71xx_mdio_driver = {
+	.probe		= ag71xx_mdio_probe,
+	.remove		= __exit_p(ag71xx_mdio_remove),
+	.driver = {
+		.name	= "ag71xx-mdio",
+	}
+};
+
+int __init ag71xx_mdio_driver_init(void)
+{
+	return platform_driver_register(&ag71xx_mdio_driver);
+}
+
+void ag71xx_mdio_driver_exit(void)
+{
+	platform_driver_unregister(&ag71xx_mdio_driver);
+}
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_phy.c linux-2.6.39/drivers/net/ag71xx/ag71xx_phy.c
--- linux-2.6.39.orig/drivers/net/ag71xx/ag71xx_phy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/ag71xx_phy.c	2011-08-06 09:32:37.298018216 +0200
@@ -0,0 +1,228 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+static void ag71xx_phy_link_adjust(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+	unsigned long flags;
+	int status_change = 0;
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	if (phydev->link) {
+		if (ag->duplex != phydev->duplex
+		    || ag->speed != phydev->speed) {
+			status_change = 1;
+		}
+	}
+
+	if (phydev->link != ag->link)
+		status_change = 1;
+
+	ag->link = phydev->link;
+	ag->duplex = phydev->duplex;
+	ag->speed = phydev->speed;
+
+	if (status_change)
+		ag71xx_link_adjust(ag);
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+}
+
+void ag71xx_phy_start(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (ag->phy_dev) {
+		phy_start(ag->phy_dev);
+	} else if (pdata->has_ar7240_switch) {
+		ag71xx_ar7240_start(ag);
+	} else {
+		ag->link = 1;
+		ag71xx_link_adjust(ag);
+	}
+}
+
+void ag71xx_phy_stop(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (ag->phy_dev) {
+		phy_stop(ag->phy_dev);
+	} else {
+		if (pdata->has_ar7240_switch)
+			ag71xx_ar7240_stop(ag);
+		ag->link = 0;
+		ag71xx_link_adjust(ag);
+	}
+}
+
+static int ag71xx_phy_connect_fixed(struct ag71xx *ag)
+{
+	struct net_device *dev = ag->dev;
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	int ret = 0;
+
+	/* use fixed settings */
+	switch (pdata->speed) {
+	case SPEED_10:
+	case SPEED_100:
+	case SPEED_1000:
+		break;
+	default:
+		printk(KERN_ERR "%s: invalid speed specified\n", dev->name);
+		ret = -EINVAL;
+		break;
+	}
+
+	printk(KERN_DEBUG "%s: using fixed link parameters\n", dev->name);
+
+	ag->duplex = pdata->duplex;
+	ag->speed = pdata->speed;
+
+	return ret;
+}
+
+static int ag71xx_phy_connect_multi(struct ag71xx *ag)
+{
+	struct net_device *dev = ag->dev;
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct phy_device *phydev = NULL;
+	int phy_addr;
+	int ret = 0;
+
+	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
+		if (!(pdata->phy_mask & (1 << phy_addr)))
+			continue;
+
+		if (ag->mii_bus->phy_map[phy_addr] == NULL)
+			continue;
+
+		DBG("%s: PHY found at %s, uid=%08x\n",
+			dev->name,
+			dev_name(&ag->mii_bus->phy_map[phy_addr]->dev),
+			ag->mii_bus->phy_map[phy_addr]->phy_id);
+
+		if (phydev == NULL)
+			phydev = ag->mii_bus->phy_map[phy_addr];
+	}
+
+	if (!phydev) {
+		printk(KERN_ERR "%s: no PHY found with phy_mask=%08x\n",
+			dev->name, pdata->phy_mask);
+		return -ENODEV;
+	}
+
+	ag->phy_dev = phy_connect(dev, dev_name(&phydev->dev),
+				  &ag71xx_phy_link_adjust, 0,
+				  pdata->phy_if_mode);
+
+	if (IS_ERR(ag->phy_dev)) {
+		printk(KERN_ERR "%s: could not connect to PHY at %s\n",
+			dev->name, dev_name(&phydev->dev));
+		return PTR_ERR(ag->phy_dev);
+	}
+
+	/* mask with MAC supported features */
+	if (pdata->has_gbit)
+		phydev->supported &= PHY_GBIT_FEATURES;
+	else
+		phydev->supported &= PHY_BASIC_FEATURES;
+
+	phydev->advertising = phydev->supported;
+
+	printk(KERN_DEBUG "%s: connected to PHY at %s [uid=%08x, driver=%s]\n",
+		dev->name, dev_name(&phydev->dev),
+		phydev->phy_id, phydev->drv->name);
+
+	ag->link = 0;
+	ag->speed = 0;
+	ag->duplex = -1;
+
+	return ret;
+}
+
+static int dev_is_class(struct device *dev, void *class)
+{
+	if (dev->class != NULL && !strcmp(dev->class->name, class))
+		return 1;
+
+	return 0;
+}
+
+static struct device *dev_find_class(struct device *parent, char *class)
+{
+	if (dev_is_class(parent, class)) {
+		get_device(parent);
+		return parent;
+	}
+
+	return device_find_child(parent, class, dev_is_class);
+}
+
+static struct mii_bus *dev_to_mii_bus(struct device *dev)
+{
+	struct device *d;
+
+	d = dev_find_class(dev, "mdio_bus");
+	if (d != NULL) {
+		struct mii_bus *bus;
+
+		bus = to_mii_bus(d);
+		put_device(d);
+
+		return bus;
+	}
+
+	return NULL;
+}
+
+int __devinit ag71xx_phy_connect(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	ag->mii_bus = dev_to_mii_bus(pdata->mii_bus_dev);
+	if (ag->mii_bus == NULL) {
+		printk(KERN_ERR "%s: unable to find MII bus on device '%s'\n",
+			ag->dev->name, dev_name(pdata->mii_bus_dev));
+		return -ENODEV;
+	}
+
+	/* Reset the mdio bus explicitly */
+	if (ag->mii_bus->reset) {
+		mutex_lock(&ag->mii_bus->mdio_lock);
+		ag->mii_bus->reset(ag->mii_bus);
+		mutex_unlock(&ag->mii_bus->mdio_lock);
+	}
+
+	if (pdata->has_ar7240_switch)
+		return ag71xx_ar7240_init(ag);
+
+	if (pdata->phy_mask)
+		return ag71xx_phy_connect_multi(ag);
+
+	return ag71xx_phy_connect_fixed(ag);
+}
+
+void ag71xx_phy_disconnect(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (pdata->has_ar7240_switch)
+		ag71xx_ar7240_cleanup(ag);
+	else if (ag->phy_dev)
+		phy_disconnect(ag->phy_dev);
+}
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/Kconfig linux-2.6.39/drivers/net/ag71xx/Kconfig
--- linux-2.6.39.orig/drivers/net/ag71xx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/Kconfig	2011-04-27 12:19:22.247664026 +0200
@@ -0,0 +1,33 @@
+config AG71XX
+	tristate "Atheros AR71xx built-in ethernet mac support"
+	depends on ATHEROS_AR71XX
+	select PHYLIB
+	help
+	  If you wish to compile a kernel for AR71xx/91xx and enable
+	  ethernet support, then you should always answer Y to this.
+
+if AG71XX
+
+config AG71XX_DEBUG
+	bool "Atheros AR71xx built-in ethernet driver debugging"
+	default n
+	help
+	  Atheros AR71xx built-in ethernet driver debugging messages.
+
+config AG71XX_DEBUG_FS
+	bool "Atheros AR71xx built-in ethernet driver debugfs support"
+	depends on DEBUG_FS
+	default n
+	help
+	  Say Y, if you need access to various statistics provided by
+	  the ag71xx driver.
+
+config AG71XX_AR8216_SUPPORT
+	bool "special support for the Atheros AR8216 switch"
+	default n
+	default y if AR71XX_MACH_WNR2000 || AR71XX_MACH_MZK_W04NU
+	help
+	  Say 'y' here if you want to enable special support for the
+	  Atheros AR8216 switch found on some boards.
+
+endif
diff -Nur linux-2.6.39.orig/drivers/net/ag71xx/Makefile linux-2.6.39/drivers/net/ag71xx/Makefile
--- linux-2.6.39.orig/drivers/net/ag71xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/ag71xx/Makefile	2011-04-27 12:19:22.257663952 +0200
@@ -0,0 +1,15 @@
+#
+# Makefile for the Atheros AR71xx built-in ethernet macs
+#
+
+ag71xx-y	+= ag71xx_main.o
+ag71xx-y	+= ag71xx_ethtool.o
+ag71xx-y	+= ag71xx_phy.o
+ag71xx-y	+= ag71xx_mdio.o
+ag71xx-y	+= ag71xx_ar7240.o
+
+ag71xx-$(CONFIG_AG71XX_DEBUG_FS)	+= ag71xx_debugfs.o
+ag71xx-$(CONFIG_AG71XX_AR8216_SUPPORT)	+= ag71xx_ar8216.o
+
+obj-$(CONFIG_AG71XX)	+= ag71xx.o
+
diff -Nur linux-2.6.39.orig/drivers/net/Kconfig linux-2.6.39/drivers/net/Kconfig
--- linux-2.6.39.orig/drivers/net/Kconfig	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/net/Kconfig	2011-08-22 16:21:54.787979739 +0200
@@ -2071,6 +2071,8 @@
 
 	  The safe and default value for this is N.
 
+source drivers/net/ag71xx/Kconfig
+
 config DL2K
 	tristate "DL2000/TC902x-based Gigabit Ethernet support"
 	depends on PCI
diff -Nur linux-2.6.39.orig/drivers/net/Makefile linux-2.6.39/drivers/net/Makefile
--- linux-2.6.39.orig/drivers/net/Makefile	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/net/Makefile	2011-08-22 16:21:54.797980120 +0200
@@ -112,6 +112,7 @@
 # end link order section
 #
 
+obj-$(CONFIG_AG71XX) += ag71xx/
 obj-$(CONFIG_SUNDANCE) += sundance.o
 obj-$(CONFIG_HAMACHI) += hamachi.o
 obj-$(CONFIG_NET) += Space.o loopback.o
diff -Nur linux-2.6.39.orig/drivers/net/phy/Kconfig linux-2.6.39/drivers/net/phy/Kconfig
--- linux-2.6.39.orig/drivers/net/phy/Kconfig	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/net/phy/Kconfig	2011-08-22 22:19:34.339230055 +0200
@@ -13,6 +13,12 @@
 
 if PHYLIB
 
+config SWCONFIG
+	tristate "Switch configuration API"
+	---help---
+	  Switch configuration API using netlink. This allows
+	  you to configure the VLAN features of certain switches.
+
 comment "MII PHY device drivers"
 
 config MARVELL_PHY
diff -Nur linux-2.6.39.orig/drivers/net/phy/Makefile linux-2.6.39/drivers/net/phy/Makefile
--- linux-2.6.39.orig/drivers/net/phy/Makefile	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/net/phy/Makefile	2011-08-22 22:19:34.339230055 +0200
@@ -3,6 +3,7 @@
 libphy-objs			:= phy.o phy_device.o mdio_bus.o
 
 obj-$(CONFIG_PHYLIB)		+= libphy.o
+obj-$(CONFIG_SWCONFIG)		+= swconfig.o
 obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
 obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
 obj-$(CONFIG_CICADA_PHY)	+= cicada.o
diff -Nur linux-2.6.39.orig/drivers/net/phy/micrel.c linux-2.6.39/drivers/net/phy/micrel.c
--- linux-2.6.39.orig/drivers/net/phy/micrel.c	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/net/phy/micrel.c	2011-04-27 12:19:22.257663952 +0200
@@ -1,251 +1,82 @@
 /*
- * drivers/net/phy/micrel.c
+ *  Driver for Micrel/Kendin PHYs
  *
- * Driver for Micrel PHYs
+ *  Copyright (c) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
  *
- * Author: David J. Choi
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
  *
- * Copyright (c) 2010 Micrel, Inc.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
- * Support : ksz9021 1000/100/10 phy from Micrel
- *		ks8001, ks8737, ks8721, ks8041, ks8051 100/10 phy
  */
 
-#include <linux/kernel.h>
-#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
 #include <linux/phy.h>
-#include <linux/micrel_phy.h>
 
-/* general Interrupt control/status reg in vendor specific block. */
-#define MII_KSZPHY_INTCS			0x1B
-#define	KSZPHY_INTCS_JABBER			(1 << 15)
-#define	KSZPHY_INTCS_RECEIVE_ERR		(1 << 14)
-#define	KSZPHY_INTCS_PAGE_RECEIVE		(1 << 13)
-#define	KSZPHY_INTCS_PARELLEL			(1 << 12)
-#define	KSZPHY_INTCS_LINK_PARTNER_ACK		(1 << 11)
-#define	KSZPHY_INTCS_LINK_DOWN			(1 << 10)
-#define	KSZPHY_INTCS_REMOTE_FAULT		(1 << 9)
-#define	KSZPHY_INTCS_LINK_UP			(1 << 8)
-#define	KSZPHY_INTCS_ALL			(KSZPHY_INTCS_LINK_UP |\
-						KSZPHY_INTCS_LINK_DOWN)
-
-/* general PHY control reg in vendor specific block. */
-#define	MII_KSZPHY_CTRL			0x1F
-/* bitmap of PHY register to set interrupt mode */
-#define KSZPHY_CTRL_INT_ACTIVE_HIGH		(1 << 9)
-#define KSZ9021_CTRL_INT_ACTIVE_HIGH		(1 << 14)
-#define KS8737_CTRL_INT_ACTIVE_HIGH		(1 << 14)
-#define KSZ8051_RMII_50MHZ_CLK			(1 << 7)
+#define KSZ_REG_INT_CTRL	0x1b
 
-static int kszphy_ack_interrupt(struct phy_device *phydev)
-{
-	/* bit[7..0] int status, which is a read and clear register. */
-	int rc;
+#define KSZ_INT_LU_EN	(1 << 8)	/* enable Link Up interrupt */
+#define KSZ_INT_RF_EN	(1 << 9)	/* enable Remote Fault interrupt */
+#define KSZ_INT_LD_EN	(1 << 10)	/* enable Link Down interrupt */
 
-	rc = phy_read(phydev, MII_KSZPHY_INTCS);
-
-	return (rc < 0) ? rc : 0;
-}
+#define KSZ_INT_INIT	(KSZ_INT_LU_EN | KSZ_INT_LD_EN)
 
-static int kszphy_set_interrupt(struct phy_device *phydev)
+static int ksz8041_ack_interrupt(struct phy_device *phydev)
 {
-	int temp;
-	temp = (PHY_INTERRUPT_ENABLED == phydev->interrupts) ?
-		KSZPHY_INTCS_ALL : 0;
-	return phy_write(phydev, MII_KSZPHY_INTCS, temp);
-}
+	int err;
 
-static int kszphy_config_intr(struct phy_device *phydev)
-{
-	int temp, rc;
+	err = phy_read(phydev, KSZ_REG_INT_CTRL);
 
-	/* set the interrupt pin active low */
-	temp = phy_read(phydev, MII_KSZPHY_CTRL);
-	temp &= ~KSZPHY_CTRL_INT_ACTIVE_HIGH;
-	phy_write(phydev, MII_KSZPHY_CTRL, temp);
-	rc = kszphy_set_interrupt(phydev);
-	return rc < 0 ? rc : 0;
+	return (err < 0) ? err : 0;
 }
 
-static int ksz9021_config_intr(struct phy_device *phydev)
+static int ksz8041_config_intr(struct phy_device *phydev)
 {
-	int temp, rc;
+	int err;
 
-	/* set the interrupt pin active low */
-	temp = phy_read(phydev, MII_KSZPHY_CTRL);
-	temp &= ~KSZ9021_CTRL_INT_ACTIVE_HIGH;
-	phy_write(phydev, MII_KSZPHY_CTRL, temp);
-	rc = kszphy_set_interrupt(phydev);
-	return rc < 0 ? rc : 0;
-}
-
-static int ks8737_config_intr(struct phy_device *phydev)
-{
-	int temp, rc;
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+		err = phy_write(phydev, KSZ_REG_INT_CTRL,
+				KSZ_INT_INIT);
+	else
+		err = phy_write(phydev, KSZ_REG_INT_CTRL, 0);
 
-	/* set the interrupt pin active low */
-	temp = phy_read(phydev, MII_KSZPHY_CTRL);
-	temp &= ~KS8737_CTRL_INT_ACTIVE_HIGH;
-	phy_write(phydev, MII_KSZPHY_CTRL, temp);
-	rc = kszphy_set_interrupt(phydev);
-	return rc < 0 ? rc : 0;
+	return err;
 }
 
-static int kszphy_config_init(struct phy_device *phydev)
-{
-	return 0;
-}
-
-static int ks8051_config_init(struct phy_device *phydev)
-{
-	int regval;
-
-	if (phydev->dev_flags & MICREL_PHY_50MHZ_CLK) {
-		regval = phy_read(phydev, MII_KSZPHY_CTRL);
-		regval |= KSZ8051_RMII_50MHZ_CLK;
-		phy_write(phydev, MII_KSZPHY_CTRL, regval);
-	}
-
-	return 0;
-}
-
-static struct phy_driver ks8737_driver = {
-	.phy_id		= PHY_ID_KS8737,
-	.phy_id_mask	= 0x00fffff0,
-	.name		= "Micrel KS8737",
-	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
-	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
-	.config_init	= kszphy_config_init,
+static struct phy_driver ksz8041_phy_driver = {
+	.phy_id		= 0x00221512,
+	.name		= "Micrel KSZ8041",
+	.phy_id_mask	= 0x001fffff,
+	.features	= PHY_BASIC_FEATURES,
+	.flags		= PHY_HAS_INTERRUPT,
 	.config_aneg	= genphy_config_aneg,
 	.read_status	= genphy_read_status,
-	.ack_interrupt	= kszphy_ack_interrupt,
-	.config_intr	= ks8737_config_intr,
-	.driver		= { .owner = THIS_MODULE,},
+	.ack_interrupt	= ksz8041_ack_interrupt,
+	.config_intr	= ksz8041_config_intr,
+	.driver	= {
+		.owner	= THIS_MODULE,
+	},
 };
 
-static struct phy_driver ks8041_driver = {
-	.phy_id		= PHY_ID_KS8041,
-	.phy_id_mask	= 0x00fffff0,
-	.name		= "Micrel KS8041",
-	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
-				| SUPPORTED_Asym_Pause),
-	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
-	.config_init	= kszphy_config_init,
-	.config_aneg	= genphy_config_aneg,
-	.read_status	= genphy_read_status,
-	.ack_interrupt	= kszphy_ack_interrupt,
-	.config_intr	= kszphy_config_intr,
-	.driver		= { .owner = THIS_MODULE,},
-};
-
-static struct phy_driver ks8051_driver = {
-	.phy_id		= PHY_ID_KS8051,
-	.phy_id_mask	= 0x00fffff0,
-	.name		= "Micrel KS8051",
-	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
-				| SUPPORTED_Asym_Pause),
-	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
-	.config_init	= ks8051_config_init,
-	.config_aneg	= genphy_config_aneg,
-	.read_status	= genphy_read_status,
-	.ack_interrupt	= kszphy_ack_interrupt,
-	.config_intr	= kszphy_config_intr,
-	.driver		= { .owner = THIS_MODULE,},
-};
-
-static struct phy_driver ks8001_driver = {
-	.phy_id		= PHY_ID_KS8001,
-	.name		= "Micrel KS8001 or KS8721",
-	.phy_id_mask	= 0x00fffff0,
-	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
-	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
-	.config_init	= kszphy_config_init,
-	.config_aneg	= genphy_config_aneg,
-	.read_status	= genphy_read_status,
-	.ack_interrupt	= kszphy_ack_interrupt,
-	.config_intr	= kszphy_config_intr,
-	.driver		= { .owner = THIS_MODULE,},
-};
-
-static struct phy_driver ksz9021_driver = {
-	.phy_id		= PHY_ID_KSZ9021,
-	.phy_id_mask	= 0x000fff10,
-	.name		= "Micrel KSZ9021 Gigabit PHY",
-	.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause
-				| SUPPORTED_Asym_Pause),
-	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
-	.config_init	= kszphy_config_init,
-	.config_aneg	= genphy_config_aneg,
-	.read_status	= genphy_read_status,
-	.ack_interrupt	= kszphy_ack_interrupt,
-	.config_intr	= ksz9021_config_intr,
-	.driver		= { .owner = THIS_MODULE, },
-};
-
-static int __init ksphy_init(void)
+static int __init micrel_phy_init(void)
 {
-	int ret;
-
-	ret = phy_driver_register(&ks8001_driver);
-	if (ret)
-		goto err1;
-
-	ret = phy_driver_register(&ksz9021_driver);
-	if (ret)
-		goto err2;
-
-	ret = phy_driver_register(&ks8737_driver);
-	if (ret)
-		goto err3;
-	ret = phy_driver_register(&ks8041_driver);
-	if (ret)
-		goto err4;
-	ret = phy_driver_register(&ks8051_driver);
-	if (ret)
-		goto err5;
-
-	return 0;
-
-err5:
-	phy_driver_unregister(&ks8041_driver);
-err4:
-	phy_driver_unregister(&ks8737_driver);
-err3:
-	phy_driver_unregister(&ksz9021_driver);
-err2:
-	phy_driver_unregister(&ks8001_driver);
-err1:
-	return ret;
+	return phy_driver_register(&ksz8041_phy_driver);
 }
 
-static void __exit ksphy_exit(void)
+static void __exit micrel_phy_exit(void)
 {
-	phy_driver_unregister(&ks8001_driver);
-	phy_driver_unregister(&ks8737_driver);
-	phy_driver_unregister(&ksz9021_driver);
-	phy_driver_unregister(&ks8041_driver);
-	phy_driver_unregister(&ks8051_driver);
+	phy_driver_unregister(&ksz8041_phy_driver);
 }
 
-module_init(ksphy_init);
-module_exit(ksphy_exit);
-
-MODULE_DESCRIPTION("Micrel PHY driver");
-MODULE_AUTHOR("David J. Choi");
-MODULE_LICENSE("GPL");
-
-static struct mdio_device_id __maybe_unused micrel_tbl[] = {
-	{ PHY_ID_KSZ9021, 0x000fff10 },
-	{ PHY_ID_KS8001, 0x00fffff0 },
-	{ PHY_ID_KS8737, 0x00fffff0 },
-	{ PHY_ID_KS8041, 0x00fffff0 },
-	{ PHY_ID_KS8051, 0x00fffff0 },
-	{ }
-};
+#ifdef MODULE
+module_init(micrel_phy_init);
+module_exit(micrel_phy_exit);
+#else
+subsys_initcall(micrel_phy_init);
+#endif
 
-MODULE_DEVICE_TABLE(mdio, micrel_tbl);
+MODULE_DESCRIPTION("Micrel/Kendin PHY driver");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.39.orig/drivers/net/phy/phy.c linux-2.6.39/drivers/net/phy/phy.c
--- linux-2.6.39.orig/drivers/net/phy/phy.c	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/net/phy/phy.c	2011-08-22 22:00:02.067980292 +0200
@@ -297,6 +297,50 @@
 }
 EXPORT_SYMBOL(phy_ethtool_gset);
 
+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr)
+{
+	u32 cmd;
+	int tmp;
+	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
+	struct ethtool_value edata = { ETHTOOL_GLINK };
+
+	if (get_user(cmd, (u32 *) useraddr))
+		return -EFAULT;
+
+	switch (cmd) {
+	case ETHTOOL_GSET:
+		phy_ethtool_gset(phydev, &ecmd);
+		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
+			return -EFAULT;
+		return 0;
+
+	case ETHTOOL_SSET:
+		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
+			return -EFAULT;
+		return phy_ethtool_sset(phydev, &ecmd);
+
+	case ETHTOOL_NWAY_RST:
+		/* if autoneg is off, it's an error */
+		tmp = phy_read(phydev, MII_BMCR);
+		if (tmp & BMCR_ANENABLE) {
+			tmp |= (BMCR_ANRESTART);
+			phy_write(phydev, MII_BMCR, tmp);
+			return 0;
+		}
+		return -EINVAL;
+
+	case ETHTOOL_GLINK:
+		edata.data = (phy_read(phydev,
+				MII_BMSR) & BMSR_LSTATUS) ? 1 : 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+
+	return -EOPNOTSUPP;
+}
+EXPORT_SYMBOL(phy_ethtool_ioctl);
+
 /**
  * phy_mii_ioctl - generic PHY MII ioctl interface
  * @phydev: the phy_device struct
@@ -472,7 +516,7 @@
 	int idx;
 
 	idx = phy_find_setting(phydev->speed, phydev->duplex);
-	
+
 	idx++;
 
 	idx = phy_find_valid(idx, phydev->supported);
diff -Nur linux-2.6.39.orig/drivers/net/phy/phy_device.c linux-2.6.39/drivers/net/phy/phy_device.c
--- linux-2.6.39.orig/drivers/net/phy/phy_device.c	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/net/phy/phy_device.c	2011-08-22 22:00:06.817981347 +0200
@@ -149,6 +149,18 @@
 }
 EXPORT_SYMBOL(phy_scan_fixups);
 
+static int generic_receive_skb(struct sk_buff *skb)
+{
+	skb->protocol = eth_type_trans(skb, skb->dev);
+	return netif_receive_skb(skb);
+}
+
+static int generic_rx(struct sk_buff *skb)
+{
+	skb->protocol = eth_type_trans(skb, skb->dev);
+	return netif_rx(skb);
+}
+
 static struct phy_device* phy_device_create(struct mii_bus *bus,
 					    int addr, int phy_id)
 {
@@ -180,6 +192,8 @@
 	dev_set_name(&dev->dev, PHY_ID_FMT, bus->id, addr);
 
 	dev->state = PHY_DOWN;
+	dev->netif_receive_skb = &generic_receive_skb;
+	dev->netif_rx = &generic_rx;
 
 	mutex_init(&dev->lock);
 	INIT_DELAYED_WORK(&dev->state_queue, phy_state_machine);
diff -Nur linux-2.6.39.orig/drivers/net/phy/swconfig.c linux-2.6.39/drivers/net/phy/swconfig.c
--- linux-2.6.39.orig/drivers/net/phy/swconfig.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/net/phy/swconfig.c	2011-08-22 22:18:58.887990974 +0200
@@ -0,0 +1,954 @@
+/*
+ * swconfig.c: Switch configuration API
+ *
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/if.h>
+#include <linux/if_ether.h>
+#include <linux/capability.h>
+#include <linux/skbuff.h>
+#include <linux/switch.h>
+
+//#define DEBUG 1
+#ifdef DEBUG
+#define DPRINTF(format, ...) printk("%s: " format, __func__, ##__VA_ARGS__)
+#else
+#define DPRINTF(...) do {} while(0)
+#endif
+
+#define SWCONFIG_DEVNAME	"switch%d"
+
+MODULE_AUTHOR("Felix Fietkau <nbd@openwrt.org>");
+MODULE_LICENSE("GPL");
+
+static int swdev_id = 0;
+static struct list_head swdevs;
+static DEFINE_SPINLOCK(swdevs_lock);
+struct swconfig_callback;
+
+struct swconfig_callback
+{
+	struct sk_buff *msg;
+	struct genlmsghdr *hdr;
+	struct genl_info *info;
+	int cmd;
+
+	/* callback for filling in the message data */
+	int (*fill)(struct swconfig_callback *cb, void *arg);
+
+	/* callback for closing the message before sending it */
+	int (*close)(struct swconfig_callback *cb, void *arg);
+
+	struct nlattr *nest[4];
+	int args[4];
+};
+
+/* defaults */
+
+static int
+swconfig_get_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	int ret;
+	if (val->port_vlan >= dev->vlans)
+		return -EINVAL;
+
+	if (!dev->ops->get_vlan_ports)
+		return -EOPNOTSUPP;
+
+	ret = dev->ops->get_vlan_ports(dev, val);
+	return ret;
+}
+
+static int
+swconfig_set_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	struct switch_port *ports = val->value.ports;
+	const struct switch_dev_ops *ops = dev->ops;
+	int i;
+
+	if (val->port_vlan >= dev->vlans)
+		return -EINVAL;
+
+	/* validate ports */
+	if (val->len > dev->ports)
+		return -EINVAL;
+
+	if (!ops->set_vlan_ports)
+		return -EOPNOTSUPP;
+
+	for (i = 0; i < val->len; i++) {
+		if (ports[i].id >= dev->ports)
+			return -EINVAL;
+
+		if (ops->set_port_pvid &&
+		    !(ports[i].flags & (1 << SWITCH_PORT_FLAG_TAGGED)))
+			ops->set_port_pvid(dev, ports[i].id, val->port_vlan);
+	}
+
+	return ops->set_vlan_ports(dev, val);
+}
+
+static int
+swconfig_set_pvid(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	if (val->port_vlan >= dev->ports)
+		return -EINVAL;
+
+	if (!dev->ops->set_port_pvid)
+		return -EOPNOTSUPP;
+
+	return dev->ops->set_port_pvid(dev, val->port_vlan, val->value.i);
+}
+
+static int
+swconfig_get_pvid(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	if (val->port_vlan >= dev->ports)
+		return -EINVAL;
+
+	if (!dev->ops->get_port_pvid)
+		return -EOPNOTSUPP;
+
+	return dev->ops->get_port_pvid(dev, val->port_vlan, &val->value.i);
+}
+
+static int
+swconfig_apply_config(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	/* don't complain if not supported by the switch driver */
+	if (!dev->ops->apply_config)
+		return 0;
+
+	return dev->ops->apply_config(dev);
+}
+
+static int
+swconfig_reset_switch(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	/* don't complain if not supported by the switch driver */
+	if (!dev->ops->reset_switch)
+		return 0;
+
+	return dev->ops->reset_switch(dev);
+}
+
+enum global_defaults {
+	GLOBAL_APPLY,
+	GLOBAL_RESET,
+};
+
+enum vlan_defaults {
+	VLAN_PORTS,
+};
+
+enum port_defaults {
+	PORT_PVID,
+};
+
+static struct switch_attr default_global[] = {
+	[GLOBAL_APPLY] = {
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "apply",
+		.description = "Activate changes in the hardware",
+		.set = swconfig_apply_config,
+	},
+	[GLOBAL_RESET] = {
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset",
+		.description = "Reset the switch",
+		.set = swconfig_reset_switch,
+	}
+};
+
+static struct switch_attr default_port[] = {
+	[PORT_PVID] = {
+		.type = SWITCH_TYPE_INT,
+		.name = "pvid",
+		.description = "Primary VLAN ID",
+		.set = swconfig_set_pvid,
+		.get = swconfig_get_pvid,
+	}
+};
+
+static struct switch_attr default_vlan[] = {
+	[VLAN_PORTS] = {
+		.type = SWITCH_TYPE_PORTS,
+		.name = "ports",
+		.description = "VLAN port mapping",
+		.set = swconfig_set_vlan_ports,
+		.get = swconfig_get_vlan_ports,
+	},
+};
+
+
+static void swconfig_defaults_init(struct switch_dev *dev)
+{
+	const struct switch_dev_ops *ops = dev->ops;
+
+	dev->def_global = 0;
+	dev->def_vlan = 0;
+	dev->def_port = 0;
+
+	if (ops->get_vlan_ports || ops->set_vlan_ports)
+		set_bit(VLAN_PORTS, &dev->def_vlan);
+
+	if (ops->get_port_pvid || ops->set_port_pvid)
+		set_bit(PORT_PVID, &dev->def_port);
+
+	/* always present, can be no-op */
+	set_bit(GLOBAL_APPLY, &dev->def_global);
+	set_bit(GLOBAL_RESET, &dev->def_global);
+}
+
+
+static struct genl_family switch_fam = {
+	.id = GENL_ID_GENERATE,
+	.name = "switch",
+	.hdrsize = 0,
+	.version = 1,
+	.maxattr = SWITCH_ATTR_MAX,
+};
+
+static const struct nla_policy switch_policy[SWITCH_ATTR_MAX+1] = {
+	[SWITCH_ATTR_ID] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_ID] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_PORT] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_VLAN] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_VALUE_INT] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_VALUE_STR] = { .type = NLA_NUL_STRING },
+	[SWITCH_ATTR_OP_VALUE_PORTS] = { .type = NLA_NESTED },
+	[SWITCH_ATTR_TYPE] = { .type = NLA_U32 },
+};
+
+static const struct nla_policy port_policy[SWITCH_PORT_ATTR_MAX+1] = {
+	[SWITCH_PORT_ID] = { .type = NLA_U32 },
+	[SWITCH_PORT_FLAG_TAGGED] = { .type = NLA_FLAG },
+};
+
+static inline void
+swconfig_lock(void)
+{
+	spin_lock(&swdevs_lock);
+}
+
+static inline void
+swconfig_unlock(void)
+{
+	spin_unlock(&swdevs_lock);
+}
+
+static struct switch_dev *
+swconfig_get_dev(struct genl_info *info)
+{
+	struct switch_dev *dev = NULL;
+	struct switch_dev *p;
+	int id;
+
+	if (!info->attrs[SWITCH_ATTR_ID])
+		goto done;
+
+	id = nla_get_u32(info->attrs[SWITCH_ATTR_ID]);
+	swconfig_lock();
+	list_for_each_entry(p, &swdevs, dev_list) {
+		if (id != p->id)
+			continue;
+
+		dev = p;
+		break;
+	}
+	if (dev)
+		spin_lock(&dev->lock);
+	else
+		DPRINTF("device %d not found\n", id);
+	swconfig_unlock();
+done:
+	return dev;
+}
+
+static inline void
+swconfig_put_dev(struct switch_dev *dev)
+{
+	spin_unlock(&dev->lock);
+}
+
+static int
+swconfig_dump_attr(struct swconfig_callback *cb, void *arg)
+{
+	struct switch_attr *op = arg;
+	struct genl_info *info = cb->info;
+	struct sk_buff *msg = cb->msg;
+	int id = cb->args[0];
+	void *hdr;
+
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq, &switch_fam,
+			NLM_F_MULTI, SWITCH_CMD_NEW_ATTR);
+	if (IS_ERR(hdr))
+		return -1;
+
+	NLA_PUT_U32(msg, SWITCH_ATTR_OP_ID, id);
+	NLA_PUT_U32(msg, SWITCH_ATTR_OP_TYPE, op->type);
+	NLA_PUT_STRING(msg, SWITCH_ATTR_OP_NAME, op->name);
+	if (op->description)
+		NLA_PUT_STRING(msg, SWITCH_ATTR_OP_DESCRIPTION,
+			op->description);
+
+	return genlmsg_end(msg, hdr);
+nla_put_failure:
+	genlmsg_cancel(msg, hdr);
+	return -EMSGSIZE;
+}
+
+/* spread multipart messages across multiple message buffers */
+static int
+swconfig_send_multipart(struct swconfig_callback *cb, void *arg)
+{
+	struct genl_info *info = cb->info;
+	int restart = 0;
+	int err;
+
+	do {
+		if (!cb->msg) {
+			cb->msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+			if (cb->msg == NULL)
+				goto error;
+		}
+
+		if (!(cb->fill(cb, arg) < 0))
+			break;
+
+		/* fill failed, check if this was already the second attempt */
+		if (restart)
+			goto error;
+
+		/* try again in a new message, send the current one */
+		restart = 1;
+		if (cb->close) {
+			if (cb->close(cb, arg) < 0)
+				goto error;
+		}
+		err = genlmsg_reply(cb->msg, info);
+		cb->msg = NULL;
+		if (err < 0)
+			goto error;
+
+	} while (restart);
+
+	return 0;
+
+error:
+	if (cb->msg)
+		nlmsg_free(cb->msg);
+	return -1;
+}
+
+static int
+swconfig_list_attrs(struct sk_buff *skb, struct genl_info *info)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct switch_attrlist *alist;
+	struct switch_dev *dev;
+	struct swconfig_callback cb;
+	int err = -EINVAL;
+	int i;
+
+	/* defaults */
+	struct switch_attr *def_list;
+	unsigned long *def_active;
+	int n_def;
+
+	dev = swconfig_get_dev(info);
+	if (!dev)
+		return -EINVAL;
+
+	switch(hdr->cmd) {
+	case SWITCH_CMD_LIST_GLOBAL:
+		alist = &dev->ops->attr_global;
+		def_list = default_global;
+		def_active = &dev->def_global;
+		n_def = ARRAY_SIZE(default_global);
+		break;
+	case SWITCH_CMD_LIST_VLAN:
+		alist = &dev->ops->attr_vlan;
+		def_list = default_vlan;
+		def_active = &dev->def_vlan;
+		n_def = ARRAY_SIZE(default_vlan);
+		break;
+	case SWITCH_CMD_LIST_PORT:
+		alist = &dev->ops->attr_port;
+		def_list = default_port;
+		def_active = &dev->def_port;
+		n_def = ARRAY_SIZE(default_port);
+		break;
+	default:
+		WARN_ON(1);
+		goto out;
+	}
+
+	memset(&cb, 0, sizeof(cb));
+	cb.info = info;
+	cb.fill = swconfig_dump_attr;
+	for (i = 0; i < alist->n_attr; i++) {
+		if (alist->attr[i].disabled)
+			continue;
+		cb.args[0] = i;
+		err = swconfig_send_multipart(&cb, (void *) &alist->attr[i]);
+		if (err < 0)
+			goto error;
+	}
+
+	/* defaults */
+	for (i = 0; i < n_def; i++) {
+		if (!test_bit(i, def_active))
+			continue;
+		cb.args[0] = SWITCH_ATTR_DEFAULTS_OFFSET + i;
+		err = swconfig_send_multipart(&cb, (void *) &def_list[i]);
+		if (err < 0)
+			goto error;
+	}
+	swconfig_put_dev(dev);
+
+	if (!cb.msg)
+		return 0;
+
+	return genlmsg_reply(cb.msg, info);
+
+error:
+	if (cb.msg)
+		nlmsg_free(cb.msg);
+out:
+	swconfig_put_dev(dev);
+	return err;
+}
+
+static const struct switch_attr *
+swconfig_lookup_attr(struct switch_dev *dev, struct genl_info *info,
+		struct switch_val *val)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct switch_attrlist *alist;
+	const struct switch_attr *attr = NULL;
+	int attr_id;
+
+	/* defaults */
+	struct switch_attr *def_list;
+	unsigned long *def_active;
+	int n_def;
+
+	if (!info->attrs[SWITCH_ATTR_OP_ID])
+		goto done;
+
+	switch(hdr->cmd) {
+	case SWITCH_CMD_SET_GLOBAL:
+	case SWITCH_CMD_GET_GLOBAL:
+		alist = &dev->ops->attr_global;
+		def_list = default_global;
+		def_active = &dev->def_global;
+		n_def = ARRAY_SIZE(default_global);
+		break;
+	case SWITCH_CMD_SET_VLAN:
+	case SWITCH_CMD_GET_VLAN:
+		alist = &dev->ops->attr_vlan;
+		def_list = default_vlan;
+		def_active = &dev->def_vlan;
+		n_def = ARRAY_SIZE(default_vlan);
+		if (!info->attrs[SWITCH_ATTR_OP_VLAN])
+			goto done;
+		val->port_vlan = nla_get_u32(info->attrs[SWITCH_ATTR_OP_VLAN]);
+		if (val->port_vlan >= dev->vlans)
+			goto done;
+		break;
+	case SWITCH_CMD_SET_PORT:
+	case SWITCH_CMD_GET_PORT:
+		alist = &dev->ops->attr_port;
+		def_list = default_port;
+		def_active = &dev->def_port;
+		n_def = ARRAY_SIZE(default_port);
+		if (!info->attrs[SWITCH_ATTR_OP_PORT])
+			goto done;
+		val->port_vlan = nla_get_u32(info->attrs[SWITCH_ATTR_OP_PORT]);
+		if (val->port_vlan >= dev->ports)
+			goto done;
+		break;
+	default:
+		WARN_ON(1);
+		goto done;
+	}
+
+	if (!alist)
+		goto done;
+
+	attr_id = nla_get_u32(info->attrs[SWITCH_ATTR_OP_ID]);
+	if (attr_id >= SWITCH_ATTR_DEFAULTS_OFFSET) {
+		attr_id -= SWITCH_ATTR_DEFAULTS_OFFSET;
+		if (attr_id >= n_def)
+			goto done;
+		if (!test_bit(attr_id, def_active))
+			goto done;
+		attr = &def_list[attr_id];
+	} else {
+		if (attr_id >= alist->n_attr)
+			goto done;
+		attr = &alist->attr[attr_id];
+	}
+
+	if (attr->disabled)
+		attr = NULL;
+
+done:
+	if (!attr)
+		DPRINTF("attribute lookup failed\n");
+	val->attr = attr;
+	return attr;
+}
+
+static int
+swconfig_parse_ports(struct sk_buff *msg, struct nlattr *head,
+		struct switch_val *val, int max)
+{
+	struct nlattr *nla;
+	int rem;
+
+	val->len = 0;
+	nla_for_each_nested(nla, head, rem) {
+		struct nlattr *tb[SWITCH_PORT_ATTR_MAX+1];
+		struct switch_port *port = &val->value.ports[val->len];
+
+		if (val->len >= max)
+			return -EINVAL;
+
+		if (nla_parse_nested(tb, SWITCH_PORT_ATTR_MAX, nla,
+				port_policy))
+			return -EINVAL;
+
+		if (!tb[SWITCH_PORT_ID])
+			return -EINVAL;
+
+		port->id = nla_get_u32(tb[SWITCH_PORT_ID]);
+		if (tb[SWITCH_PORT_FLAG_TAGGED])
+			port->flags |= (1 << SWITCH_PORT_FLAG_TAGGED);
+		val->len++;
+	}
+
+	return 0;
+}
+
+static int
+swconfig_set_attr(struct sk_buff *skb, struct genl_info *info)
+{
+	const struct switch_attr *attr;
+	struct switch_dev *dev;
+	struct switch_val val;
+	int err = -EINVAL;
+
+	dev = swconfig_get_dev(info);
+	if (!dev)
+		return -EINVAL;
+
+	memset(&val, 0, sizeof(val));
+	attr = swconfig_lookup_attr(dev, info, &val);
+	if (!attr || !attr->set)
+		goto error;
+
+	val.attr = attr;
+	switch(attr->type) {
+	case SWITCH_TYPE_NOVAL:
+		break;
+	case SWITCH_TYPE_INT:
+		if (!info->attrs[SWITCH_ATTR_OP_VALUE_INT])
+			goto error;
+		val.value.i =
+			nla_get_u32(info->attrs[SWITCH_ATTR_OP_VALUE_INT]);
+		break;
+	case SWITCH_TYPE_STRING:
+		if (!info->attrs[SWITCH_ATTR_OP_VALUE_STR])
+			goto error;
+		val.value.s =
+			nla_data(info->attrs[SWITCH_ATTR_OP_VALUE_STR]);
+		break;
+	case SWITCH_TYPE_PORTS:
+		val.value.ports = dev->portbuf;
+		memset(dev->portbuf, 0,
+			sizeof(struct switch_port) * dev->ports);
+
+		/* TODO: implement multipart? */
+		if (info->attrs[SWITCH_ATTR_OP_VALUE_PORTS]) {
+			err = swconfig_parse_ports(skb,
+				info->attrs[SWITCH_ATTR_OP_VALUE_PORTS], &val, dev->ports);
+			if (err < 0)
+				goto error;
+		} else {
+			val.len = 0;
+			err = 0;
+		}
+		break;
+	default:
+		goto error;
+	}
+
+	err = attr->set(dev, attr, &val);
+error:
+	swconfig_put_dev(dev);
+	return err;
+}
+
+static int
+swconfig_close_portlist(struct swconfig_callback *cb, void *arg)
+{
+	if (cb->nest[0])
+		nla_nest_end(cb->msg, cb->nest[0]);
+	return 0;
+}
+
+static int
+swconfig_send_port(struct swconfig_callback *cb, void *arg)
+{
+	const struct switch_port *port = arg;
+	struct nlattr *p = NULL;
+
+	if (!cb->nest[0]) {
+		cb->nest[0] = nla_nest_start(cb->msg, cb->cmd);
+		if (!cb->nest[0])
+			return -1;
+	}
+
+	p = nla_nest_start(cb->msg, SWITCH_ATTR_PORT);
+	if (!p)
+		goto error;
+
+	NLA_PUT_U32(cb->msg, SWITCH_PORT_ID, port->id);
+	if (port->flags & (1 << SWITCH_PORT_FLAG_TAGGED))
+		NLA_PUT_FLAG(cb->msg, SWITCH_PORT_FLAG_TAGGED);
+
+	nla_nest_end(cb->msg, p);
+	return 0;
+
+nla_put_failure:
+		nla_nest_cancel(cb->msg, p);
+error:
+	nla_nest_cancel(cb->msg, cb->nest[0]);
+	return -1;
+}
+
+static int
+swconfig_send_ports(struct sk_buff **msg, struct genl_info *info, int attr,
+		const struct switch_val *val)
+{
+	struct swconfig_callback cb;
+	int err = 0;
+	int i;
+
+	if (!val->value.ports)
+		return -EINVAL;
+
+	memset(&cb, 0, sizeof(cb));
+	cb.cmd = attr;
+	cb.msg = *msg;
+	cb.info = info;
+	cb.fill = swconfig_send_port;
+	cb.close = swconfig_close_portlist;
+
+	cb.nest[0] = nla_nest_start(cb.msg, cb.cmd);
+	for (i = 0; i < val->len; i++) {
+		err = swconfig_send_multipart(&cb, &val->value.ports[i]);
+		if (err)
+			goto done;
+	}
+	err = val->len;
+	swconfig_close_portlist(&cb, NULL);
+	*msg = cb.msg;
+
+done:
+	return err;
+}
+
+static int
+swconfig_get_attr(struct sk_buff *skb, struct genl_info *info)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct switch_attr *attr;
+	struct switch_dev *dev;
+	struct sk_buff *msg = NULL;
+	struct switch_val val;
+	int err = -EINVAL;
+	int cmd = hdr->cmd;
+
+	dev = swconfig_get_dev(info);
+	if (!dev)
+		return -EINVAL;
+
+	memset(&val, 0, sizeof(val));
+	attr = swconfig_lookup_attr(dev, info, &val);
+	if (!attr || !attr->get)
+		goto error;
+
+	if (attr->type == SWITCH_TYPE_PORTS) {
+		val.value.ports = dev->portbuf;
+		memset(dev->portbuf, 0,
+			sizeof(struct switch_port) * dev->ports);
+	}
+
+	err = attr->get(dev, attr, &val);
+	if (err)
+		goto error;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		goto error;
+
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq, &switch_fam,
+			0, cmd);
+	if (IS_ERR(hdr))
+		goto nla_put_failure;
+
+	switch(attr->type) {
+	case SWITCH_TYPE_INT:
+		NLA_PUT_U32(msg, SWITCH_ATTR_OP_VALUE_INT, val.value.i);
+		break;
+	case SWITCH_TYPE_STRING:
+		NLA_PUT_STRING(msg, SWITCH_ATTR_OP_VALUE_STR, val.value.s);
+		break;
+	case SWITCH_TYPE_PORTS:
+		err = swconfig_send_ports(&msg, info,
+				SWITCH_ATTR_OP_VALUE_PORTS, &val);
+		if (err < 0)
+			goto nla_put_failure;
+		break;
+	default:
+		DPRINTF("invalid type in attribute\n");
+		err = -EINVAL;
+		goto error;
+	}
+	err = genlmsg_end(msg, hdr);
+	if (err < 0)
+		goto nla_put_failure;
+
+	swconfig_put_dev(dev);
+	return genlmsg_reply(msg, info);
+
+nla_put_failure:
+	if (msg)
+		nlmsg_free(msg);
+error:
+	swconfig_put_dev(dev);
+	if (!err)
+		err = -ENOMEM;
+	return err;
+}
+
+static int
+swconfig_send_switch(struct sk_buff *msg, u32 pid, u32 seq, int flags,
+		const struct switch_dev *dev)
+{
+	void *hdr;
+
+	hdr = genlmsg_put(msg, pid, seq, &switch_fam, flags,
+			SWITCH_CMD_NEW_ATTR);
+	if (IS_ERR(hdr))
+		return -1;
+
+	NLA_PUT_U32(msg, SWITCH_ATTR_ID, dev->id);
+	NLA_PUT_STRING(msg, SWITCH_ATTR_DEV_NAME, dev->devname);
+	NLA_PUT_STRING(msg, SWITCH_ATTR_ALIAS, dev->alias);
+	NLA_PUT_STRING(msg, SWITCH_ATTR_NAME, dev->name);
+	NLA_PUT_U32(msg, SWITCH_ATTR_VLANS, dev->vlans);
+	NLA_PUT_U32(msg, SWITCH_ATTR_PORTS, dev->ports);
+	NLA_PUT_U32(msg, SWITCH_ATTR_CPU_PORT, dev->cpu_port);
+
+	return genlmsg_end(msg, hdr);
+nla_put_failure:
+	genlmsg_cancel(msg, hdr);
+	return -EMSGSIZE;
+}
+
+static int swconfig_dump_switches(struct sk_buff *skb,
+		struct netlink_callback *cb)
+{
+	struct switch_dev *dev;
+	int start = cb->args[0];
+	int idx = 0;
+
+	swconfig_lock();
+	list_for_each_entry(dev, &swdevs, dev_list) {
+		if (++idx <= start)
+			continue;
+		if (swconfig_send_switch(skb, NETLINK_CB(cb->skb).pid,
+				cb->nlh->nlmsg_seq, NLM_F_MULTI,
+				dev) < 0)
+			break;
+	}
+	swconfig_unlock();
+	cb->args[0] = idx;
+
+	return skb->len;
+}
+
+static int
+swconfig_done(struct netlink_callback *cb)
+{
+	return 0;
+}
+
+static struct genl_ops swconfig_ops[] = {
+	{
+		.cmd = SWITCH_CMD_LIST_GLOBAL,
+		.doit = swconfig_list_attrs,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_LIST_VLAN,
+		.doit = swconfig_list_attrs,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_LIST_PORT,
+		.doit = swconfig_list_attrs,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_GLOBAL,
+		.doit = swconfig_get_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_VLAN,
+		.doit = swconfig_get_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_PORT,
+		.doit = swconfig_get_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_SET_GLOBAL,
+		.doit = swconfig_set_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_SET_VLAN,
+		.doit = swconfig_set_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_SET_PORT,
+		.doit = swconfig_set_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_SWITCH,
+		.dumpit = swconfig_dump_switches,
+		.policy = switch_policy,
+		.done = swconfig_done,
+	}
+};
+
+int
+register_switch(struct switch_dev *dev, struct net_device *netdev)
+{
+	struct switch_dev *sdev;
+	const int max_switches = 8 * sizeof(unsigned long);
+	unsigned long in_use = 0;
+	int i;
+
+	INIT_LIST_HEAD(&dev->dev_list);
+	if (netdev) {
+		dev->netdev = netdev;
+		if (!dev->alias)
+			dev->alias = netdev->name;
+	}
+	BUG_ON(!dev->alias);
+
+	if (dev->ports > 0) {
+		dev->portbuf = kzalloc(sizeof(struct switch_port) * dev->ports,
+				GFP_KERNEL);
+		if (!dev->portbuf)
+			return -ENOMEM;
+	}
+	swconfig_defaults_init(dev);
+	spin_lock_init(&dev->lock);
+	swconfig_lock();
+	dev->id = ++swdev_id;
+
+	list_for_each_entry(sdev, &swdevs, dev_list) {
+		if (!sscanf(sdev->devname, SWCONFIG_DEVNAME, &i))
+			continue;
+		if (i < 0 || i > max_switches)
+			continue;
+
+		set_bit(i, &in_use);
+	}
+	i = find_first_zero_bit(&in_use, max_switches);
+
+	if (i == max_switches)
+		return -ENFILE;
+
+	/* fill device name */
+	snprintf(dev->devname, IFNAMSIZ, SWCONFIG_DEVNAME, i);
+
+	list_add(&dev->dev_list, &swdevs);
+	swconfig_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(register_switch);
+
+void
+unregister_switch(struct switch_dev *dev)
+{
+	kfree(dev->portbuf);
+	spin_lock(&dev->lock);
+	swconfig_lock();
+	list_del(&dev->dev_list);
+	swconfig_unlock();
+	spin_unlock(&dev->lock);
+}
+EXPORT_SYMBOL_GPL(unregister_switch);
+
+
+static int __init
+swconfig_init(void)
+{
+	int i, err;
+
+	INIT_LIST_HEAD(&swdevs);
+	err = genl_register_family(&switch_fam);
+	if (err)
+		return err;
+
+	for (i = 0; i < ARRAY_SIZE(swconfig_ops); i++) {
+		err = genl_register_ops(&switch_fam, &swconfig_ops[i]);
+		if (err)
+			goto unregister;
+	}
+
+	return 0;
+
+unregister:
+	genl_unregister_family(&switch_fam);
+	return err;
+}
+
+static void __exit
+swconfig_exit(void)
+{
+	genl_unregister_family(&switch_fam);
+}
+
+module_init(swconfig_init);
+module_exit(swconfig_exit);
+
diff -Nur linux-2.6.39.orig/drivers/spi/ap83_spi.c linux-2.6.39/drivers/spi/ap83_spi.c
--- linux-2.6.39.orig/drivers/spi/ap83_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/spi/ap83_spi.c	2011-04-27 12:19:22.317665385 +0200
@@ -0,0 +1,283 @@
+/*
+ * Atheros AP83 board specific SPI Controller driver
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/platform.h>
+
+#define DRV_DESC	"Atheros AP83 board SPI Controller driver"
+#define DRV_VERSION	"0.1.0"
+#define DRV_NAME	"ap83-spi"
+
+#define AP83_SPI_CLK_HIGH	(1 << 23)
+#define AP83_SPI_CLK_LOW	0
+#define AP83_SPI_MOSI_HIGH	(1 << 22)
+#define AP83_SPI_MOSI_LOW	0
+
+#define AP83_SPI_GPIO_CS	1
+#define AP83_SPI_GPIO_MISO	3
+
+struct ap83_spi {
+	struct	spi_bitbang	bitbang;
+	void __iomem		*base;
+	u32			addr;
+
+	struct platform_device	*pdev;
+};
+
+static inline u32 ap83_spi_rr(struct ap83_spi *sp, u32 reg)
+{
+	return __raw_readl(sp->base + reg);
+}
+
+static inline struct ap83_spi *spidev_to_sp(struct spi_device *spi)
+{
+	return spi_master_get_devdata(spi->master);
+}
+
+static inline void setsck(struct spi_device *spi, int val)
+{
+	struct ap83_spi *sp = spidev_to_sp(spi);
+
+	if (val)
+		sp->addr |= AP83_SPI_CLK_HIGH;
+	else
+		sp->addr &= ~AP83_SPI_CLK_HIGH;
+
+	dev_dbg(&spi->dev, "addr=%08x,  SCK set to %s\n",
+		sp->addr, (val) ? "HIGH" : "LOW");
+
+	ap83_spi_rr(sp, sp->addr);
+}
+
+static inline void setmosi(struct spi_device *spi, int val)
+{
+	struct ap83_spi *sp = spidev_to_sp(spi);
+
+	if (val)
+		sp->addr |= AP83_SPI_MOSI_HIGH;
+	else
+		sp->addr &= ~AP83_SPI_MOSI_HIGH;
+
+	dev_dbg(&spi->dev, "addr=%08x, MOSI set to %s\n",
+		sp->addr, (val) ? "HIGH" : "LOW");
+
+	ap83_spi_rr(sp, sp->addr);
+}
+
+static inline u32 getmiso(struct spi_device *spi)
+{
+	u32 ret;
+
+	ret = gpio_get_value(AP83_SPI_GPIO_MISO) ? 1 : 0;
+	dev_dbg(&spi->dev, "get MISO: %d\n", ret);
+
+	return ret;
+}
+
+static inline void do_spidelay(struct spi_device *spi, unsigned nsecs)
+{
+	ndelay(nsecs);
+}
+
+static void ap83_spi_chipselect(struct spi_device *spi, int on)
+{
+	struct ap83_spi *sp = spidev_to_sp(spi);
+
+	dev_dbg(&spi->dev, "set CS to %d\n", (on) ? 0 : 1);
+
+	if (on) {
+		ar71xx_flash_acquire();
+
+		sp->addr = 0;
+		ap83_spi_rr(sp, sp->addr);
+
+		gpio_set_value(AP83_SPI_GPIO_CS, 0);
+	} else {
+		gpio_set_value(AP83_SPI_GPIO_CS, 1);
+		ar71xx_flash_release();
+	}
+}
+
+#define spidelay(nsecs)							\
+	do {								\
+		/* Steal the spi_device pointer from our caller.	\
+		 * The bitbang-API should probably get fixed here... */	\
+		do_spidelay(spi, nsecs);				\
+	} while (0)
+
+#define EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+#include "spi_bitbang_txrx.h"
+
+static u32 ap83_spi_txrx_mode0(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX0 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);
+}
+
+static u32 ap83_spi_txrx_mode1(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX1 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, 0, word, bits);
+}
+
+static u32 ap83_spi_txrx_mode2(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX2 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, 0, word, bits);
+}
+
+static u32 ap83_spi_txrx_mode3(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX3 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, 0, word, bits);
+}
+
+static int ap83_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct ap83_spi *sp;
+	struct ap83_spi_platform_data *pdata;
+	struct resource	*r;
+	int ret;
+
+	ret = gpio_request(AP83_SPI_GPIO_MISO, "spi-miso");
+	if (ret) {
+		dev_err(&pdev->dev, "gpio request failed for MISO\n");
+		return ret;
+	}
+
+	ret = gpio_request(AP83_SPI_GPIO_CS, "spi-cs");
+	if (ret) {
+		dev_err(&pdev->dev, "gpio request failed for CS\n");
+		goto err_free_miso;
+	}
+
+	ret = gpio_direction_input(AP83_SPI_GPIO_MISO);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set direction of MISO\n");
+		goto err_free_cs;
+	}
+
+	ret = gpio_direction_output(AP83_SPI_GPIO_CS, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set direction of CS\n");
+		goto err_free_cs;
+	}
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi master\n");
+		return -ENOMEM;
+	}
+
+	sp = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, sp);
+
+	pdata = pdev->dev.platform_data;
+
+	sp->bitbang.master = spi_master_get(master);
+	sp->bitbang.chipselect = ap83_spi_chipselect;
+	sp->bitbang.txrx_word[SPI_MODE_0] = ap83_spi_txrx_mode0;
+	sp->bitbang.txrx_word[SPI_MODE_1] = ap83_spi_txrx_mode1;
+	sp->bitbang.txrx_word[SPI_MODE_2] = ap83_spi_txrx_mode2;
+	sp->bitbang.txrx_word[SPI_MODE_3] = ap83_spi_txrx_mode3;
+
+	sp->bitbang.master->bus_num = pdev->id;
+	sp->bitbang.master->num_chipselect = 1;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENOENT;
+		goto err_spi_put;
+	}
+
+	sp->base = ioremap_nocache(r->start, r->end - r->start + 1);
+	if (!sp->base) {
+		ret = -ENXIO;
+		goto err_spi_put;
+	}
+
+	ret = spi_bitbang_start(&sp->bitbang);
+	if (!ret)
+		goto err_unmap;
+
+	dev_info(&pdev->dev, "AP83 SPI adapter at %08x\n", r->start);
+
+	return 0;
+
+err_unmap:
+	iounmap(sp->base);
+err_spi_put:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+err_free_cs:
+	gpio_free(AP83_SPI_GPIO_CS);
+err_free_miso:
+	gpio_free(AP83_SPI_GPIO_MISO);
+	return ret;
+}
+
+static int ap83_spi_remove(struct platform_device *pdev)
+{
+	struct ap83_spi *sp = platform_get_drvdata(pdev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	iounmap(sp->base);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver ap83_spi_drv = {
+	.probe		= ap83_spi_probe,
+	.remove		= ap83_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ap83_spi_init(void)
+{
+	return platform_driver_register(&ap83_spi_drv);
+}
+module_init(ap83_spi_init);
+
+static void __exit ap83_spi_exit(void)
+{
+	platform_driver_unregister(&ap83_spi_drv);
+}
+module_exit(ap83_spi_exit);
+
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.39.orig/drivers/spi/ar71xx_spi.c linux-2.6.39/drivers/spi/ar71xx_spi.c
--- linux-2.6.39.orig/drivers/spi/ar71xx_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/spi/ar71xx_spi.c	2011-04-27 12:19:22.317665385 +0200
@@ -0,0 +1,283 @@
+/*
+ * Atheros AR71xx SPI Controller driver
+ *
+ * Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/bitops.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/platform.h>
+
+#define DRV_DESC	"Atheros AR71xx SPI Controller driver"
+#define DRV_VERSION	"0.2.4"
+#define DRV_NAME	"ar71xx-spi"
+
+#undef PER_BIT_READ
+
+struct ar71xx_spi {
+	struct	spi_bitbang	bitbang;
+	u32			ioc_base;
+	u32			reg_ctrl;
+
+	void __iomem		*base;
+
+	struct platform_device	*pdev;
+	u32			(*get_ioc_base)(u8 chip_select, int cs_high,
+						int is_on);
+};
+
+static inline u32 ar71xx_spi_rr(struct ar71xx_spi *sp, unsigned reg)
+{
+	return __raw_readl(sp->base + reg);
+}
+
+static inline void ar71xx_spi_wr(struct ar71xx_spi *sp, unsigned reg, u32 val)
+{
+	__raw_writel(val, sp->base + reg);
+}
+
+static inline struct ar71xx_spi *spidev_to_sp(struct spi_device *spi)
+{
+	return spi_master_get_devdata(spi->master);
+}
+
+static u32 ar71xx_spi_get_ioc_base(u8 chip_select, int cs_high, int is_on)
+{
+	u32 ret;
+
+	if (is_on == AR71XX_SPI_CS_INACTIVE)
+		ret = SPI_IOC_CS_ALL;
+	else
+		ret = SPI_IOC_CS_ALL & ~SPI_IOC_CS(chip_select);
+
+	return ret;
+}
+
+static void ar71xx_spi_chipselect(struct spi_device *spi, int value)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+	void __iomem *base = sp->base;
+	u32 ioc_base;
+
+	switch (value) {
+	case BITBANG_CS_INACTIVE:
+		ioc_base = sp->get_ioc_base(spi->chip_select,
+					(spi->mode & SPI_CS_HIGH) != 0,
+					AR71XX_SPI_CS_INACTIVE);
+		__raw_writel(ioc_base, base + SPI_REG_IOC);
+		break;
+
+	case BITBANG_CS_ACTIVE:
+		ioc_base = sp->get_ioc_base(spi->chip_select,
+					(spi->mode & SPI_CS_HIGH) != 0,
+					AR71XX_SPI_CS_ACTIVE);
+
+		__raw_writel(ioc_base, base + SPI_REG_IOC);
+		sp->ioc_base = ioc_base;
+		break;
+	}
+}
+
+static void ar71xx_spi_setup_regs(struct spi_device *spi)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+
+	/* enable GPIO mode */
+	ar71xx_spi_wr(sp, SPI_REG_FS, SPI_FS_GPIO);
+
+	/* save CTRL register */
+	sp->reg_ctrl = ar71xx_spi_rr(sp, SPI_REG_CTRL);
+
+	/* TODO: setup speed? */
+	ar71xx_spi_wr(sp, SPI_REG_CTRL, 0x43);
+}
+
+static void ar71xx_spi_restore_regs(struct spi_device *spi)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+
+	/* restore CTRL register */
+	ar71xx_spi_wr(sp, SPI_REG_CTRL, sp->reg_ctrl);
+	/* disable GPIO mode */
+	ar71xx_spi_wr(sp, SPI_REG_FS, 0);
+}
+
+static int ar71xx_spi_setup(struct spi_device *spi)
+{
+	int status;
+
+	if (spi->bits_per_word > 32)
+		return -EINVAL;
+
+	if (!spi->controller_state)
+		ar71xx_spi_setup_regs(spi);
+
+	status = spi_bitbang_setup(spi);
+	if (status && !spi->controller_state)
+		ar71xx_spi_restore_regs(spi);
+
+	return status;
+}
+
+static void ar71xx_spi_cleanup(struct spi_device *spi)
+{
+	ar71xx_spi_restore_regs(spi);
+	spi_bitbang_cleanup(spi);
+}
+
+static u32 ar71xx_spi_txrx_mode0(struct spi_device *spi, unsigned nsecs,
+					u32 word, u8 bits)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+	void __iomem *base = sp->base;
+	u32 ioc = sp->ioc_base;
+	u32 ret;
+
+	/* clock starts at inactive polarity */
+	for (word <<= (32 - bits); likely(bits); bits--) {
+		u32 out;
+
+		if (word & (1 << 31))
+			out = ioc | SPI_IOC_DO;
+		else
+			out = ioc & ~SPI_IOC_DO;
+
+		/* setup MSB (to slave) on trailing edge */
+		__raw_writel(out, base + SPI_REG_IOC);
+
+		__raw_writel(out | SPI_IOC_CLK, base + SPI_REG_IOC);
+
+		word <<= 1;
+
+#ifdef PER_BIT_READ
+		/* sample MSB (from slave) on leading edge */
+		ret = __raw_readl(base + SPI_REG_RDS);
+		__raw_writel(out, base + SPI_REG_IOC);
+#endif
+
+	}
+
+#ifndef PER_BIT_READ
+	ret = __raw_readl(base + SPI_REG_RDS);
+#endif
+	return ret;
+}
+
+static int ar71xx_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct ar71xx_spi *sp;
+	struct ar71xx_spi_platform_data *pdata;
+	struct resource	*r;
+	int ret;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi master\n");
+		return -ENOMEM;
+	}
+
+	sp = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, sp);
+
+	pdata = pdev->dev.platform_data;
+
+	master->setup = ar71xx_spi_setup;
+	master->cleanup = ar71xx_spi_cleanup;
+
+	sp->bitbang.master = spi_master_get(master);
+	sp->bitbang.chipselect = ar71xx_spi_chipselect;
+	sp->bitbang.txrx_word[SPI_MODE_0] = ar71xx_spi_txrx_mode0;
+	sp->bitbang.setup_transfer = spi_bitbang_setup_transfer;
+
+	sp->get_ioc_base = ar71xx_spi_get_ioc_base;
+	if (pdata) {
+		sp->bitbang.master->bus_num = pdata->bus_num;
+		sp->bitbang.master->num_chipselect = pdata->num_chipselect;
+		if (pdata->get_ioc_base)
+			sp->get_ioc_base = pdata->get_ioc_base;
+	} else {
+		sp->bitbang.master->bus_num = 0;
+		sp->bitbang.master->num_chipselect = 3;
+	}
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENOENT;
+		goto err1;
+	}
+
+	sp->base = ioremap_nocache(r->start, r->end - r->start + 1);
+	if (!sp->base) {
+		ret = -ENXIO;
+		goto err1;
+	}
+
+	ret = spi_bitbang_start(&sp->bitbang);
+	if (!ret)
+		return 0;
+
+	iounmap(sp->base);
+err1:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return ret;
+}
+
+static int ar71xx_spi_remove(struct platform_device *pdev)
+{
+	struct ar71xx_spi *sp = platform_get_drvdata(pdev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	iounmap(sp->base);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver ar71xx_spi_drv = {
+	.probe		= ar71xx_spi_probe,
+	.remove		= ar71xx_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ar71xx_spi_init(void)
+{
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+	return platform_driver_register(&ar71xx_spi_drv);
+}
+module_init(ar71xx_spi_init);
+
+static void __exit ar71xx_spi_exit(void)
+{
+	platform_driver_unregister(&ar71xx_spi_drv);
+}
+module_exit(ar71xx_spi_exit);
+
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.39.orig/drivers/spi/Kconfig linux-2.6.39/drivers/spi/Kconfig
--- linux-2.6.39.orig/drivers/spi/Kconfig	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/spi/Kconfig	2011-08-23 15:10:24.167989908 +0200
@@ -67,6 +67,13 @@
 	  This enables support for the SPI controller present on the
 	  Atheros AR71XX/AR724X/AR913X SoCs.
 
+config SPI_AR71XX
+	tristate "Atheros AR71xx SPI Controller"
+	depends on SPI_MASTER && ATHEROS_AR71XX
+	select SPI_BITBANG
+	help
+	  This is the SPI contoller driver for Atheros AR71xx.
+
 config SPI_ATMEL
 	tristate "Atmel SPI Controller"
 	depends on (ARCH_AT91 || AVR32)
@@ -301,6 +308,12 @@
 config SPI_PXA2XX_PCI
 	def_bool SPI_PXA2XX && X86_32 && PCI
 
+config SPI_RB4XX
+	tristate "Mikrotik RB4XX SPI master"
+	depends on SPI_MASTER && AR71XX_MACH_RB4XX
+	help
+	  SPI controller driver for the Mikrotik RB4xx series boards.
+
 config SPI_S3C24XX
 	tristate "Samsung S3C24XX series SPI"
 	depends on ARCH_S3C2410 && EXPERIMENTAL
@@ -457,6 +470,13 @@
 	  sysfs interface, with each line presented as a kind of GPIO
 	  exposing both switch control and diagnostic feedback.
 
+config SPI_RB4XX_CPLD
+	tristate "MikroTik RB4XX CPLD driver"
+	depends on AR71XX_MACH_RB4XX
+	help
+	  SPI driver for the Xilinx CPLD chip present on the
+	  MikroTik RB4xx boards.
+
 #
 # Add new SPI protocol masters in alphabetical order above this line
 #
diff -Nur linux-2.6.39.orig/drivers/spi/Kconfig.orig linux-2.6.39/drivers/spi/Kconfig.orig
--- linux-2.6.39.orig/drivers/spi/Kconfig.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/spi/Kconfig.orig	2011-08-23 15:10:11.277991848 +0200
@@ -0,0 +1,482 @@
+#
+# SPI driver configuration
+#
+# NOTE:  the reason this doesn't show SPI slave support is mostly that
+# nobody's needed a slave side API yet.  The master-role API is not
+# fully appropriate there, so it'd need some thought to do well.
+#
+menuconfig SPI
+	bool "SPI support"
+	depends on HAS_IOMEM
+	help
+	  The "Serial Peripheral Interface" is a low level synchronous
+	  protocol.  Chips that support SPI can have data transfer rates
+	  up to several tens of Mbit/sec.  Chips are addressed with a
+	  controller and a chipselect.  Most SPI slaves don't support
+	  dynamic device discovery; some are even write-only or read-only.
+
+	  SPI is widely used by microcontrollers to talk with sensors,
+	  eeprom and flash memory, codecs and various other controller
+	  chips, analog to digital (and d-to-a) converters, and more.
+	  MMC and SD cards can be accessed using SPI protocol; and for
+	  DataFlash cards used in MMC sockets, SPI must always be used.
+
+	  SPI is one of a family of similar protocols using a four wire
+	  interface (select, clock, data in, data out) including Microwire
+	  (half duplex), SSP, SSI, and PSP.  This driver framework should
+	  work with most such devices and controllers.
+
+if SPI
+
+config SPI_DEBUG
+	boolean "Debug support for SPI drivers"
+	depends on DEBUG_KERNEL
+	help
+	  Say "yes" to enable debug messaging (like dev_dbg and pr_debug),
+	  sysfs, and debugfs support in SPI controller and protocol drivers.
+
+#
+# MASTER side ... talking to discrete SPI slave chips including microcontrollers
+#
+
+config SPI_MASTER
+#	boolean "SPI Master Support"
+	boolean
+	default SPI
+	help
+	  If your system has an master-capable SPI controller (which
+	  provides the clock and chipselect), you can enable that
+	  controller and the protocol drivers for the SPI slave chips
+	  that are connected.
+
+if SPI_MASTER
+
+comment "SPI Master Controller Drivers"
+
+config SPI_ALTERA
+	tristate "Altera SPI Controller"
+	select SPI_BITBANG
+	help
+	  This is the driver for the Altera SPI Controller.
+
+config SPI_ATH79
+	tristate "Atheros AR71XX/AR724X/AR913X SPI controller driver"
+	depends on ATH79 && GENERIC_GPIO
+	select SPI_BITBANG
+	help
+	  This enables support for the SPI controller present on the
+	  Atheros AR71XX/AR724X/AR913X SoCs.
+
+config SPI_AR71XX
+	tristate "Atheros AR71xx SPI Controller"
+	depends on SPI_MASTER && ATHEROS_AR71XX
+	select SPI_BITBANG
+	help
+	  This is the SPI contoller driver for Atheros AR71xx.
+
+config SPI_ATMEL
+	tristate "Atmel SPI Controller"
+	depends on (ARCH_AT91 || AVR32)
+	help
+	  This selects a driver for the Atmel SPI Controller, present on
+	  many AT32 (AVR32) and AT91 (ARM) chips.
+
+config SPI_BFIN
+	tristate "SPI controller driver for ADI Blackfin5xx"
+	depends on BLACKFIN
+	help
+	  This is the SPI controller master driver for Blackfin 5xx processor.
+
+config SPI_AU1550
+	tristate "Au1550/Au12x0 SPI Controller"
+	depends on (SOC_AU1550 || SOC_AU1200) && EXPERIMENTAL
+	select SPI_BITBANG
+	help
+	  If you say yes to this option, support will be included for the
+	  Au1550 SPI controller (may also work with Au1200,Au1210,Au1250).
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called au1550_spi.
+
+config SPI_BITBANG
+	tristate "Utilities for Bitbanging SPI masters"
+	help
+	  With a few GPIO pins, your system can bitbang the SPI protocol.
+	  Select this to get SPI support through I/O pins (GPIO, parallel
+	  port, etc).  Or, some systems' SPI master controller drivers use
+	  this code to manage the per-word or per-transfer accesses to the
+	  hardware shift registers.
+
+	  This is library code, and is automatically selected by drivers that
+	  need it.  You only need to select this explicitly to support driver
+	  modules that aren't part of this kernel tree.
+
+config SPI_BUTTERFLY
+	tristate "Parallel port adapter for AVR Butterfly (DEVELOPMENT)"
+	depends on PARPORT
+	select SPI_BITBANG
+	help
+	  This uses a custom parallel port cable to connect to an AVR
+	  Butterfly <http://www.atmel.com/products/avr/butterfly>, an
+	  inexpensive battery powered microcontroller evaluation board.
+	  This same cable can be used to flash new firmware.
+
+config SPI_COLDFIRE_QSPI
+	tristate "Freescale Coldfire QSPI controller"
+	depends on (M520x || M523x || M5249 || M527x || M528x || M532x)
+	help
+	  This enables support for the Coldfire QSPI controller in master
+	  mode.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called coldfire_qspi.
+
+config SPI_DAVINCI
+	tristate "Texas Instruments DaVinci/DA8x/OMAP-L/AM1x SoC SPI controller"
+	depends on SPI_MASTER && ARCH_DAVINCI
+	select SPI_BITBANG
+	help
+	  SPI master controller for DaVinci/DA8x/OMAP-L/AM1x SPI modules.
+
+	  This driver can also be built as a module. The module will be called
+	  davinci_spi.
+
+config SPI_EP93XX
+	tristate "Cirrus Logic EP93xx SPI controller"
+	depends on ARCH_EP93XX
+	help
+	  This enables using the Cirrus EP93xx SPI controller in master
+	  mode.
+
+	  To compile this driver as a module, choose M here. The module will be
+	  called ep93xx_spi.
+
+config SPI_GPIO
+	tristate "GPIO-based bitbanging SPI Master"
+	depends on GENERIC_GPIO
+	select SPI_BITBANG
+	help
+	  This simple GPIO bitbanging SPI master uses the arch-neutral GPIO
+	  interface to manage MOSI, MISO, SCK, and chipselect signals.  SPI
+	  slaves connected to a bus using this driver are configured as usual,
+	  except that the spi_board_info.controller_data holds the GPIO number
+	  for the chipselect used by this controller driver.
+
+	  Note that this driver often won't achieve even 1 Mbit/sec speeds,
+	  making it unusually slow for SPI.  If your platform can inline
+	  GPIO operations, you should be able to leverage that for better
+	  speed with a custom version of this driver; see the source code.
+
+config SPI_IMX_VER_IMX1
+	def_bool y if SOC_IMX1
+
+config SPI_IMX_VER_0_0
+	def_bool y if SOC_IMX21 || SOC_IMX27
+
+config SPI_IMX_VER_0_4
+	def_bool y if SOC_IMX31
+
+config SPI_IMX_VER_0_7
+	def_bool y if ARCH_MX25 || SOC_IMX35 || SOC_IMX51 || SOC_IMX53
+
+config SPI_IMX_VER_2_3
+	def_bool y if SOC_IMX51 || SOC_IMX53
+
+config SPI_IMX
+	tristate "Freescale i.MX SPI controllers"
+	depends on ARCH_MXC
+	select SPI_BITBANG
+	default m if IMX_HAVE_PLATFORM_SPI_IMX
+	help
+	  This enables using the Freescale i.MX SPI controllers in master
+	  mode.
+
+config SPI_LM70_LLP
+	tristate "Parallel port adapter for LM70 eval board (DEVELOPMENT)"
+	depends on PARPORT && EXPERIMENTAL
+	select SPI_BITBANG
+	help
+	  This driver supports the NS LM70 LLP Evaluation Board,
+	  which interfaces to an LM70 temperature sensor using
+	  a parallel port.
+
+config SPI_MPC52xx
+	tristate "Freescale MPC52xx SPI (non-PSC) controller support"
+	depends on PPC_MPC52xx && SPI
+	select SPI_MASTER_OF
+	help
+	  This drivers supports the MPC52xx SPI controller in master SPI
+	  mode.
+
+config SPI_MPC52xx_PSC
+	tristate "Freescale MPC52xx PSC SPI controller"
+	depends on PPC_MPC52xx && EXPERIMENTAL
+	help
+	  This enables using the Freescale MPC52xx Programmable Serial
+	  Controller in master SPI mode.
+
+config SPI_MPC512x_PSC
+	tristate "Freescale MPC512x PSC SPI controller"
+	depends on SPI_MASTER && PPC_MPC512x
+	help
+	  This enables using the Freescale MPC5121 Programmable Serial
+	  Controller in SPI master mode.
+
+config SPI_FSL_LIB
+	tristate
+	depends on FSL_SOC
+
+config SPI_FSL_SPI
+	tristate "Freescale SPI controller"
+	depends on FSL_SOC
+	select SPI_FSL_LIB
+	help
+	  This enables using the Freescale SPI controllers in master mode.
+	  MPC83xx platform uses the controller in cpu mode or CPM/QE mode.
+	  MPC8569 uses the controller in QE mode, MPC8610 in cpu mode.
+
+config SPI_FSL_ESPI
+	tristate "Freescale eSPI controller"
+	depends on FSL_SOC
+	select SPI_FSL_LIB
+	help
+	  This enables using the Freescale eSPI controllers in master mode.
+	  From MPC8536, 85xx platform uses the controller, and all P10xx,
+	  P20xx, P30xx,P40xx, P50xx uses this controller.
+
+config SPI_OC_TINY
+	tristate "OpenCores tiny SPI"
+	depends on GENERIC_GPIO
+	select SPI_BITBANG
+	help
+	  This is the driver for OpenCores tiny SPI master controller.
+
+config SPI_OMAP_UWIRE
+	tristate "OMAP1 MicroWire"
+	depends on ARCH_OMAP1
+	select SPI_BITBANG
+	help
+	  This hooks up to the MicroWire controller on OMAP1 chips.
+
+config SPI_OMAP24XX
+	tristate "McSPI driver for OMAP"
+	depends on ARCH_OMAP2PLUS
+	help
+	  SPI master controller for OMAP24XX and later Multichannel SPI
+	  (McSPI) modules.
+
+config SPI_OMAP_100K
+	tristate "OMAP SPI 100K"
+	depends on SPI_MASTER && (ARCH_OMAP850 || ARCH_OMAP730)
+	help
+	  OMAP SPI 100K master controller for omap7xx boards.
+
+config SPI_ORION
+	tristate "Orion SPI master (EXPERIMENTAL)"
+	depends on PLAT_ORION && EXPERIMENTAL
+	help
+	  This enables using the SPI master controller on the Orion chips.
+
+config SPI_PL022
+	tristate "ARM AMBA PL022 SSP controller (EXPERIMENTAL)"
+	depends on ARM_AMBA && EXPERIMENTAL
+	default y if MACH_U300
+	default y if ARCH_REALVIEW
+	default y if INTEGRATOR_IMPD1
+	default y if ARCH_VERSATILE
+	help
+	  This selects the ARM(R) AMBA(R) PrimeCell PL022 SSP
+	  controller. If you have an embedded system with an AMBA(R)
+	  bus and a PL022 controller, say Y or M here.
+
+config SPI_PPC4xx
+	tristate "PPC4xx SPI Controller"
+	depends on PPC32 && 4xx && SPI_MASTER
+	select SPI_BITBANG
+	help
+	  This selects a driver for the PPC4xx SPI Controller.
+
+config SPI_PXA2XX
+	tristate "PXA2xx SSP SPI master"
+	depends on (ARCH_PXA || (X86_32 && PCI)) && EXPERIMENTAL
+	select PXA_SSP if ARCH_PXA
+	help
+	  This enables using a PXA2xx or Sodaville SSP port as a SPI master
+	  controller. The driver can be configured to use any SSP port and
+	  additional documentation can be found a Documentation/spi/pxa2xx.
+
+config SPI_PXA2XX_PCI
+	def_bool SPI_PXA2XX && X86_32 && PCI
+
+config SPI_S3C24XX
+	tristate "Samsung S3C24XX series SPI"
+	depends on ARCH_S3C2410 && EXPERIMENTAL
+	select SPI_BITBANG
+	help
+	  SPI driver for Samsung S3C24XX series ARM SoCs
+
+config SPI_S3C24XX_FIQ
+	bool "S3C24XX driver with FIQ pseudo-DMA"
+	depends on SPI_S3C24XX
+	select FIQ
+	help
+	  Enable FIQ support for the S3C24XX SPI driver to provide pseudo
+	  DMA by using the fast-interrupt request framework, This allows
+	  the driver to get DMA-like performance when there are either
+	  no free DMA channels, or when doing transfers that required both
+	  TX and RX data paths.
+
+config SPI_S3C24XX_GPIO
+	tristate "Samsung S3C24XX series SPI by GPIO"
+	depends on ARCH_S3C2410 && EXPERIMENTAL
+	select SPI_BITBANG
+	help
+	  SPI driver for Samsung S3C24XX series ARM SoCs using
+	  GPIO lines to provide the SPI bus. This can be used where
+	  the inbuilt hardware cannot provide the transfer mode, or
+	  where the board is using non hardware connected pins.
+
+config SPI_S3C64XX
+	tristate "Samsung S3C64XX series type SPI"
+	depends on (ARCH_S3C64XX || ARCH_S5P64X0)
+	select S3C64XX_DMA if ARCH_S3C64XX
+	help
+	  SPI driver for Samsung S3C64XX and newer SoCs.
+
+config SPI_SH_MSIOF
+	tristate "SuperH MSIOF SPI controller"
+	depends on SUPERH && HAVE_CLK
+	select SPI_BITBANG
+	help
+	  SPI driver for SuperH MSIOF blocks.
+
+config SPI_SH
+	tristate "SuperH SPI controller"
+	depends on SUPERH
+	help
+	  SPI driver for SuperH SPI blocks.
+
+config SPI_SH_SCI
+	tristate "SuperH SCI SPI controller"
+	depends on SUPERH
+	select SPI_BITBANG
+	help
+	  SPI driver for SuperH SCI blocks.
+
+config SPI_STMP3XXX
+	tristate "Freescale STMP37xx/378x SPI/SSP controller"
+	depends on ARCH_STMP3XXX && SPI_MASTER
+	help
+	  SPI driver for Freescale STMP37xx/378x SoC SSP interface
+
+config SPI_TEGRA
+	tristate "Nvidia Tegra SPI controller"
+	depends on ARCH_TEGRA
+	select TEGRA_SYSTEM_DMA
+	help
+	  SPI driver for NVidia Tegra SoCs
+
+config SPI_TI_SSP
+	tristate "TI Sequencer Serial Port - SPI Support"
+	depends on MFD_TI_SSP
+	help
+	  This selects an SPI master implementation using a TI sequencer
+	  serial port.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ti-ssp-spi.
+
+config SPI_TOPCLIFF_PCH
+	tristate "Topcliff PCH SPI Controller"
+	depends on PCI
+	help
+	  SPI driver for the Topcliff PCH (Platform Controller Hub) SPI bus
+	  used in some x86 embedded processors.
+
+config SPI_TXX9
+	tristate "Toshiba TXx9 SPI controller"
+	depends on GENERIC_GPIO && CPU_TX49XX
+	help
+	  SPI driver for Toshiba TXx9 MIPS SoCs
+
+config SPI_XILINX
+	tristate "Xilinx SPI controller common module"
+	depends on HAS_IOMEM && EXPERIMENTAL
+	select SPI_BITBANG
+	help
+	  This exposes the SPI controller IP from the Xilinx EDK.
+
+	  See the "OPB Serial Peripheral Interface (SPI) (v1.00e)"
+	  Product Specification document (DS464) for hardware details.
+
+	  Or for the DS570, see "XPS Serial Peripheral Interface (SPI) (v2.00b)"
+
+config SPI_NUC900
+	tristate "Nuvoton NUC900 series SPI"
+	depends on ARCH_W90X900 && EXPERIMENTAL
+	select SPI_BITBANG
+	help
+	  SPI driver for Nuvoton NUC900 series ARM SoCs
+
+#
+# Add new SPI master controllers in alphabetical order above this line
+#
+
+config SPI_DESIGNWARE
+	tristate "DesignWare SPI controller core support"
+	depends on SPI_MASTER
+	help
+	  general driver for SPI controller core from DesignWare
+
+config SPI_DW_PCI
+	tristate "PCI interface driver for DW SPI core"
+	depends on SPI_DESIGNWARE && PCI
+
+config SPI_DW_MID_DMA
+	bool "DMA support for DW SPI controller on Intel Moorestown platform"
+	depends on SPI_DW_PCI && INTEL_MID_DMAC
+
+config SPI_DW_MMIO
+	tristate "Memory-mapped io interface driver for DW SPI core"
+	depends on SPI_DESIGNWARE && HAVE_CLK
+
+#
+# There are lots of SPI device types, with sensors and memory
+# being probably the most widely used ones.
+#
+comment "SPI Protocol Masters"
+
+config SPI_SPIDEV
+	tristate "User mode SPI device driver support"
+	depends on EXPERIMENTAL
+	help
+	  This supports user mode SPI protocol drivers.
+
+	  Note that this application programming interface is EXPERIMENTAL
+	  and hence SUBJECT TO CHANGE WITHOUT NOTICE while it stabilizes.
+
+config SPI_TLE62X0
+	tristate "Infineon TLE62X0 (for power switching)"
+	depends on SYSFS
+	help
+	  SPI driver for Infineon TLE62X0 series line driver chips,
+	  such as the TLE6220, TLE6230 and TLE6240.  This provides a
+	  sysfs interface, with each line presented as a kind of GPIO
+	  exposing both switch control and diagnostic feedback.
+
+config SPI_RB4XX_CPLD
+	tristate "MikroTik RB4XX CPLD driver"
+	depends on AR71XX_MACH_RB4XX
+	help
+	  SPI driver for the Xilinx CPLD chip present on the
+	  MikroTik RB4xx boards.
+
+#
+# Add new SPI protocol masters in alphabetical order above this line
+#
+
+endif # SPI_MASTER
+
+# (slave support would go here)
+
+endif # SPI
diff -Nur linux-2.6.39.orig/drivers/spi/Makefile linux-2.6.39/drivers/spi/Makefile
--- linux-2.6.39.orig/drivers/spi/Makefile	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/spi/Makefile	2011-08-23 15:10:24.199233941 +0200
@@ -10,6 +10,7 @@
 
 # SPI master controller drivers (bus)
 obj-$(CONFIG_SPI_ALTERA)		+= spi_altera.o
+obj-$(CONFIG_SPI_AR71XX)		+= ar71xx_spi.o
 obj-$(CONFIG_SPI_ATMEL)			+= atmel_spi.o
 obj-$(CONFIG_SPI_ATH79)			+= ath79_spi.o
 obj-$(CONFIG_SPI_BFIN)			+= spi_bfin5xx.o
@@ -54,6 +55,7 @@
 obj-$(CONFIG_SPI_SH_MSIOF)		+= spi_sh_msiof.o
 obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
 obj-$(CONFIG_SPI_NUC900)		+= spi_nuc900.o
+obj-$(CONFIG_SPI_RB4XX)			+= rb4xx_spi.o
 
 # special build for s3c24xx spi driver with fiq support
 spi_s3c24xx_hw-y			:= spi_s3c24xx.o
@@ -62,6 +64,7 @@
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
+obj-$(CONFIG_SPI_RB4XX_CPLD)	+= spi_rb4xx_cpld.o
 obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
 obj-$(CONFIG_SPI_TLE62X0)	+= tle62x0.o
 # 	... add above this line ...
diff -Nur linux-2.6.39.orig/drivers/spi/Makefile.orig linux-2.6.39/drivers/spi/Makefile.orig
--- linux-2.6.39.orig/drivers/spi/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/spi/Makefile.orig	2011-08-23 15:10:11.300479072 +0200
@@ -0,0 +1,75 @@
+#
+# Makefile for kernel SPI drivers.
+#
+
+ccflags-$(CONFIG_SPI_DEBUG) := -DDEBUG
+
+# small core, mostly translating board-specific
+# config declarations into driver model code
+obj-$(CONFIG_SPI_MASTER)		+= spi.o
+
+# SPI master controller drivers (bus)
+obj-$(CONFIG_SPI_ALTERA)		+= spi_altera.o
+obj-$(CONFIG_SPI_AR71XX)		+= ar71xx_spi.o
+obj-$(CONFIG_SPI_ATMEL)			+= atmel_spi.o
+obj-$(CONFIG_SPI_ATH79)			+= ath79_spi.o
+obj-$(CONFIG_SPI_BFIN)			+= spi_bfin5xx.o
+obj-$(CONFIG_SPI_BITBANG)		+= spi_bitbang.o
+obj-$(CONFIG_SPI_AU1550)		+= au1550_spi.o
+obj-$(CONFIG_SPI_BUTTERFLY)		+= spi_butterfly.o
+obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= coldfire_qspi.o
+obj-$(CONFIG_SPI_DAVINCI)		+= davinci_spi.o
+obj-$(CONFIG_SPI_DESIGNWARE)		+= dw_spi.o
+obj-$(CONFIG_SPI_DW_PCI)		+= dw_spi_midpci.o
+dw_spi_midpci-objs			:= dw_spi_pci.o dw_spi_mid.o
+obj-$(CONFIG_SPI_DW_MMIO)		+= dw_spi_mmio.o
+obj-$(CONFIG_SPI_EP93XX)		+= ep93xx_spi.o
+obj-$(CONFIG_SPI_GPIO)			+= spi_gpio.o
+obj-$(CONFIG_SPI_IMX)			+= spi_imx.o
+obj-$(CONFIG_SPI_LM70_LLP)		+= spi_lm70llp.o
+obj-$(CONFIG_SPI_PXA2XX)		+= pxa2xx_spi.o
+obj-$(CONFIG_SPI_PXA2XX_PCI)		+= pxa2xx_spi_pci.o
+obj-$(CONFIG_SPI_OC_TINY)		+= spi_oc_tiny.o
+obj-$(CONFIG_SPI_OMAP_UWIRE)		+= omap_uwire.o
+obj-$(CONFIG_SPI_OMAP24XX)		+= omap2_mcspi.o
+obj-$(CONFIG_SPI_OMAP_100K)		+= omap_spi_100k.o
+obj-$(CONFIG_SPI_ORION)			+= orion_spi.o
+obj-$(CONFIG_SPI_PL022)			+= amba-pl022.o
+obj-$(CONFIG_SPI_MPC512x_PSC)		+= mpc512x_psc_spi.o
+obj-$(CONFIG_SPI_MPC52xx_PSC)		+= mpc52xx_psc_spi.o
+obj-$(CONFIG_SPI_MPC52xx)		+= mpc52xx_spi.o
+obj-$(CONFIG_SPI_FSL_LIB)		+= spi_fsl_lib.o
+obj-$(CONFIG_SPI_FSL_ESPI)		+= spi_fsl_espi.o
+obj-$(CONFIG_SPI_FSL_SPI)		+= spi_fsl_spi.o
+obj-$(CONFIG_SPI_PPC4xx)		+= spi_ppc4xx.o
+obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
+obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx_hw.o
+obj-$(CONFIG_SPI_S3C64XX)		+= spi_s3c64xx.o
+obj-$(CONFIG_SPI_TEGRA)			+= spi_tegra.o
+obj-$(CONFIG_SPI_TI_SSP)		+= ti-ssp-spi.o
+obj-$(CONFIG_SPI_TOPCLIFF_PCH)		+= spi_topcliff_pch.o
+obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
+obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
+obj-$(CONFIG_SPI_SH)			+= spi_sh.o
+obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
+obj-$(CONFIG_SPI_SH_MSIOF)		+= spi_sh_msiof.o
+obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
+obj-$(CONFIG_SPI_NUC900)		+= spi_nuc900.o
+
+# special build for s3c24xx spi driver with fiq support
+spi_s3c24xx_hw-y			:= spi_s3c24xx.o
+spi_s3c24xx_hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi_s3c24xx_fiq.o
+
+# 	... add above this line ...
+
+# SPI protocol drivers (device/link on bus)
+obj-$(CONFIG_SPI_RB4XX_CPLD)	+= spi_rb4xx_cpld.o
+obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
+obj-$(CONFIG_SPI_TLE62X0)	+= tle62x0.o
+# 	... add above this line ...
+
+# SPI slave controller drivers (upstream link)
+# 	... add above this line ...
+
+# SPI slave drivers (protocol for that link)
+# 	... add above this line ...
diff -Nur linux-2.6.39.orig/drivers/spi/pb44_spi.c linux-2.6.39/drivers/spi/pb44_spi.c
--- linux-2.6.39.orig/drivers/spi/pb44_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/spi/pb44_spi.c	2011-04-27 12:19:22.317665385 +0200
@@ -0,0 +1,299 @@
+/*
+ * Atheros PB44 board SPI controller driver
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/platform.h>
+
+#define DRV_DESC	"Atheros PB44 SPI Controller driver"
+#define DRV_VERSION	"0.1.0"
+#define DRV_NAME	"pb44-spi"
+
+#undef PER_BIT_READ
+
+struct ar71xx_spi {
+	struct	spi_bitbang	bitbang;
+	u32			ioc_base;
+	u32			reg_ctrl;
+
+	void __iomem		*base;
+
+	struct platform_device	*pdev;
+};
+
+static inline u32 pb44_spi_rr(struct ar71xx_spi *sp, unsigned reg)
+{
+	return __raw_readl(sp->base + reg);
+}
+
+static inline void pb44_spi_wr(struct ar71xx_spi *sp, unsigned reg, u32 val)
+{
+	__raw_writel(val, sp->base + reg);
+}
+
+static inline struct ar71xx_spi *spidev_to_sp(struct spi_device *spi)
+{
+	return spi_master_get_devdata(spi->master);
+}
+
+static void pb44_spi_chipselect(struct spi_device *spi, int is_active)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+	int cs_high = (spi->mode & SPI_CS_HIGH) ? is_active : !is_active;
+
+	if (is_active) {
+		/* set initial clock polarity */
+		if (spi->mode & SPI_CPOL)
+			sp->ioc_base |= SPI_IOC_CLK;
+		else
+			sp->ioc_base &= ~SPI_IOC_CLK;
+
+		pb44_spi_wr(sp, SPI_REG_IOC, sp->ioc_base);
+	}
+
+	if (spi->chip_select) {
+		unsigned long gpio = (unsigned long) spi->controller_data;
+
+		/* SPI is normally active-low */
+		gpio_set_value(gpio, cs_high);
+	} else {
+		if (cs_high)
+			sp->ioc_base |= SPI_IOC_CS0;
+		else
+			sp->ioc_base &= ~SPI_IOC_CS0;
+
+		pb44_spi_wr(sp, SPI_REG_IOC, sp->ioc_base);
+	}
+
+}
+
+static int pb44_spi_setup_cs(struct spi_device *spi)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+
+	/* enable GPIO mode */
+	pb44_spi_wr(sp, SPI_REG_FS, SPI_FS_GPIO);
+
+	/* save CTRL register */
+	sp->reg_ctrl = pb44_spi_rr(sp, SPI_REG_CTRL);
+	sp->ioc_base = pb44_spi_rr(sp, SPI_REG_IOC);
+
+	/* TODO: setup speed? */
+	pb44_spi_wr(sp, SPI_REG_CTRL, 0x43);
+
+	if (spi->chip_select) {
+		unsigned long gpio = (unsigned long) spi->controller_data;
+		int status = 0;
+
+		status = gpio_request(gpio, dev_name(&spi->dev));
+		if (status)
+			return status;
+
+		status = gpio_direction_output(gpio, spi->mode & SPI_CS_HIGH);
+		if (status) {
+			gpio_free(gpio);
+			return status;
+		}
+	} else {
+		if (spi->mode & SPI_CS_HIGH)
+			sp->ioc_base |= SPI_IOC_CS0;
+		else
+			sp->ioc_base &= ~SPI_IOC_CS0;
+		pb44_spi_wr(sp, SPI_REG_IOC, sp->ioc_base);
+	}
+
+	return 0;
+}
+
+static void pb44_spi_cleanup_cs(struct spi_device *spi)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+
+	if (spi->chip_select) {
+		unsigned long gpio = (unsigned long) spi->controller_data;
+		gpio_free(gpio);
+	}
+
+	/* restore CTRL register */
+	pb44_spi_wr(sp, SPI_REG_CTRL, sp->reg_ctrl);
+	/* disable GPIO mode */
+	pb44_spi_wr(sp, SPI_REG_FS, 0);
+}
+
+static int pb44_spi_setup(struct spi_device *spi)
+{
+	int status = 0;
+
+	if (spi->bits_per_word > 32)
+		return -EINVAL;
+
+	if (!spi->controller_state) {
+		status = pb44_spi_setup_cs(spi);
+		if (status)
+			return status;
+	}
+
+	status = spi_bitbang_setup(spi);
+	if (status && !spi->controller_state)
+		pb44_spi_cleanup_cs(spi);
+
+	return status;
+}
+
+static void pb44_spi_cleanup(struct spi_device *spi)
+{
+	pb44_spi_cleanup_cs(spi);
+	spi_bitbang_cleanup(spi);
+}
+
+static u32 pb44_spi_txrx_mode0(struct spi_device *spi, unsigned nsecs,
+			       u32 word, u8 bits)
+{
+	struct ar71xx_spi *sp = spidev_to_sp(spi);
+	u32 ioc = sp->ioc_base;
+	u32 ret;
+
+	/* clock starts at inactive polarity */
+	for (word <<= (32 - bits); likely(bits); bits--) {
+		u32 out;
+
+		if (word & (1 << 31))
+			out = ioc | SPI_IOC_DO;
+		else
+			out = ioc & ~SPI_IOC_DO;
+
+		/* setup MSB (to slave) on trailing edge */
+		pb44_spi_wr(sp, SPI_REG_IOC, out);
+		pb44_spi_wr(sp, SPI_REG_IOC, out | SPI_IOC_CLK);
+
+		word <<= 1;
+
+#ifdef PER_BIT_READ
+		/* sample MSB (from slave) on leading edge */
+		ret = pb44_spi_rr(sp, SPI_REG_RDS);
+		pb44_spi_wr(sp, SPI_REG_IOC, out);
+#endif
+	}
+
+#ifndef PER_BIT_READ
+	ret = pb44_spi_rr(sp, SPI_REG_RDS);
+#endif
+	return ret;
+}
+
+static int pb44_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct ar71xx_spi *sp;
+	struct ar71xx_spi_platform_data *pdata;
+	struct resource	*r;
+	int ret;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi master\n");
+		return -ENOMEM;
+	}
+
+	sp = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, sp);
+
+	pdata = pdev->dev.platform_data;
+
+	master->setup = pb44_spi_setup;
+	master->cleanup = pb44_spi_cleanup;
+	if (pdata) {
+		master->bus_num = pdata->bus_num;
+		master->num_chipselect = pdata->num_chipselect;
+	} else {
+		master->bus_num = 0;
+		master->num_chipselect = 1;
+	}
+
+	sp->bitbang.master = spi_master_get(master);
+	sp->bitbang.chipselect = pb44_spi_chipselect;
+	sp->bitbang.txrx_word[SPI_MODE_0] = pb44_spi_txrx_mode0;
+	sp->bitbang.setup_transfer = spi_bitbang_setup_transfer;
+	sp->bitbang.flags = SPI_CS_HIGH;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENOENT;
+		goto err1;
+	}
+
+	sp->base = ioremap_nocache(r->start, r->end - r->start + 1);
+	if (!sp->base) {
+		ret = -ENXIO;
+		goto err1;
+	}
+
+	ret = spi_bitbang_start(&sp->bitbang);
+	if (!ret)
+		return 0;
+
+	iounmap(sp->base);
+err1:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return ret;
+}
+
+static int pb44_spi_remove(struct platform_device *pdev)
+{
+	struct ar71xx_spi *sp = platform_get_drvdata(pdev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	iounmap(sp->base);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver pb44_spi_drv = {
+	.probe		= pb44_spi_probe,
+	.remove		= pb44_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init pb44_spi_init(void)
+{
+	return platform_driver_register(&pb44_spi_drv);
+}
+module_init(pb44_spi_init);
+
+static void __exit pb44_spi_exit(void)
+{
+	platform_driver_unregister(&pb44_spi_drv);
+}
+module_exit(pb44_spi_exit);
+
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.39.orig/drivers/spi/rb4xx_spi.c linux-2.6.39/drivers/spi/rb4xx_spi.c
--- linux-2.6.39.orig/drivers/spi/rb4xx_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/spi/rb4xx_spi.c	2011-04-27 12:19:22.307664943 +0200
@@ -0,0 +1,474 @@
+/*
+ * SPI controller driver for the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#define DRV_NAME	"rb4xx-spi"
+#define DRV_DESC	"Mikrotik RB4xx SPI controller driver"
+#define DRV_VERSION	"0.1.0"
+
+#define SPI_CTRL_FASTEST	0x40
+#define SPI_FLASH_HZ		33333334
+#define SPI_CPLD_HZ		33333334
+
+#define CPLD_CMD_READ_FAST	0x0b
+
+#undef RB4XX_SPI_DEBUG
+
+struct rb4xx_spi {
+	void __iomem		*base;
+	struct spi_master	*master;
+
+	unsigned		spi_ctrl_flash;
+	unsigned		spi_ctrl_fread;
+
+	spinlock_t		lock;
+	struct list_head	queue;
+	int			busy:1;
+	int			cs_wait;
+};
+
+static unsigned spi_clk_low = SPI_IOC_CS1;
+
+#ifdef RB4XX_SPI_DEBUG
+static inline void do_spi_delay(void)
+{
+	ndelay(20000);
+}
+#else
+static inline void do_spi_delay(void) { }
+#endif
+
+static inline void do_spi_init(struct spi_device *spi)
+{
+	unsigned cs = SPI_IOC_CS0 | SPI_IOC_CS1;
+
+	if (!(spi->mode & SPI_CS_HIGH))
+		cs ^= (spi->chip_select == 2) ? SPI_IOC_CS1 : SPI_IOC_CS0;
+
+	spi_clk_low = cs;
+}
+
+static inline void do_spi_finish(void __iomem *base)
+{
+	do_spi_delay();
+	__raw_writel(SPI_IOC_CS0 | SPI_IOC_CS1, base + SPI_REG_IOC);
+}
+
+static inline void do_spi_clk(void __iomem *base, int bit)
+{
+	unsigned bval = spi_clk_low | ((bit & 1) ? SPI_IOC_DO : 0);
+
+	do_spi_delay();
+	__raw_writel(bval, base + SPI_REG_IOC);
+	do_spi_delay();
+	__raw_writel(bval | SPI_IOC_CLK, base + SPI_REG_IOC);
+}
+
+static void do_spi_byte(void __iomem *base, unsigned char byte)
+{
+	do_spi_clk(base, byte >> 7);
+	do_spi_clk(base, byte >> 6);
+	do_spi_clk(base, byte >> 5);
+	do_spi_clk(base, byte >> 4);
+	do_spi_clk(base, byte >> 3);
+	do_spi_clk(base, byte >> 2);
+	do_spi_clk(base, byte >> 1);
+	do_spi_clk(base, byte);
+
+	pr_debug("spi_byte sent 0x%02x got 0x%02x\n",
+	       (unsigned)byte,
+	       (unsigned char)__raw_readl(base + SPI_REG_RDS));
+}
+
+static inline void do_spi_clk_fast(void __iomem *base, unsigned bit1,
+				   unsigned bit2)
+{
+	unsigned bval = (spi_clk_low |
+			 ((bit1 & 1) ? SPI_IOC_DO : 0) |
+			 ((bit2 & 1) ? SPI_IOC_CS2 : 0));
+	do_spi_delay();
+	__raw_writel(bval, base + SPI_REG_IOC);
+	do_spi_delay();
+	__raw_writel(bval | SPI_IOC_CLK, base + SPI_REG_IOC);
+}
+
+static void do_spi_byte_fast(void __iomem *base, unsigned char byte)
+{
+	do_spi_clk_fast(base, byte >> 7, byte >> 6);
+	do_spi_clk_fast(base, byte >> 5, byte >> 4);
+	do_spi_clk_fast(base, byte >> 3, byte >> 2);
+	do_spi_clk_fast(base, byte >> 1, byte >> 0);
+
+	pr_debug("spi_byte_fast sent 0x%02x got 0x%02x\n",
+	       (unsigned)byte,
+	       (unsigned char) __raw_readl(base + SPI_REG_RDS));
+}
+
+static int rb4xx_spi_txrx(void __iomem *base, struct spi_transfer *t)
+{
+	const unsigned char *rxv_ptr = NULL;
+	const unsigned char *tx_ptr = t->tx_buf;
+	unsigned char *rx_ptr = t->rx_buf;
+	unsigned i;
+
+	pr_debug("spi_txrx len %u tx %u rx %u\n",
+	       t->len,
+	       (t->tx_buf ? 1 : 0),
+	       (t->rx_buf ? 1 : 0));
+
+	if (t->verify) {
+		rxv_ptr = tx_ptr;
+		tx_ptr = NULL;
+	}
+
+	for (i = 0; i < t->len; ++i) {
+		unsigned char sdata = tx_ptr ? tx_ptr[i] : 0;
+
+		if (t->fast_write)
+			do_spi_byte_fast(base, sdata);
+		else
+			do_spi_byte(base, sdata);
+
+		if (rx_ptr) {
+			rx_ptr[i] = __raw_readl(base + SPI_REG_RDS) & 0xff;
+		} else if (rxv_ptr) {
+			unsigned char c = __raw_readl(base + SPI_REG_RDS);
+			if (rxv_ptr[i] != c)
+				return i;
+		}
+	}
+
+	return i;
+}
+
+static int rb4xx_spi_read_fast(struct rb4xx_spi *rbspi,
+			       struct spi_message *m)
+{
+	struct spi_transfer *t;
+	const unsigned char *tx_ptr;
+	unsigned addr;
+	void __iomem *base = rbspi->base;
+
+	/* check for exactly two transfers */
+	if (list_empty(&m->transfers) ||
+	    list_is_last(m->transfers.next, &m->transfers) ||
+	    !list_is_last(m->transfers.next->next, &m->transfers)) {
+		return -1;
+	}
+
+	/* first transfer contains command and address  */
+	t = list_entry(m->transfers.next,
+		       struct spi_transfer, transfer_list);
+
+	if (t->len != 5 || t->tx_buf == NULL)
+		return -1;
+
+	tx_ptr = t->tx_buf;
+	if (tx_ptr[0] != CPLD_CMD_READ_FAST)
+		return -1;
+
+	addr = tx_ptr[1];
+	addr = tx_ptr[2] | (addr << 8);
+	addr = tx_ptr[3] | (addr << 8);
+	addr += (unsigned) base;
+
+	m->actual_length += t->len;
+
+	/* second transfer contains data itself */
+	t = list_entry(m->transfers.next->next,
+		       struct spi_transfer, transfer_list);
+
+	if (t->tx_buf && !t->verify)
+		return -1;
+
+	__raw_writel(SPI_FS_GPIO, base + SPI_REG_FS);
+	__raw_writel(rbspi->spi_ctrl_fread, base + SPI_REG_CTRL);
+	__raw_writel(0, base + SPI_REG_FS);
+
+	if (t->rx_buf) {
+		memcpy(t->rx_buf, (const void *)addr, t->len);
+	} else if (t->tx_buf) {
+		unsigned char buf[t->len];
+		memcpy(buf, (const void *)addr, t->len);
+		if (memcmp(t->tx_buf, buf, t->len) != 0)
+			m->status = -EMSGSIZE;
+	}
+	m->actual_length += t->len;
+
+	if (rbspi->spi_ctrl_flash != rbspi->spi_ctrl_fread) {
+		__raw_writel(SPI_FS_GPIO, base + SPI_REG_FS);
+		__raw_writel(rbspi->spi_ctrl_flash, base + SPI_REG_CTRL);
+		__raw_writel(0, base + SPI_REG_FS);
+	}
+
+	return 0;
+}
+
+static int rb4xx_spi_msg(struct rb4xx_spi *rbspi, struct spi_message *m)
+{
+	struct spi_transfer *t = NULL;
+	void __iomem *base = rbspi->base;
+
+	m->status = 0;
+	if (list_empty(&m->transfers))
+		return -1;
+
+	if (m->fast_read)
+		if (rb4xx_spi_read_fast(rbspi, m) == 0)
+			return -1;
+
+	__raw_writel(SPI_FS_GPIO, base + SPI_REG_FS);
+	__raw_writel(SPI_CTRL_FASTEST, base + SPI_REG_CTRL);
+	do_spi_init(m->spi);
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		int len;
+
+		len = rb4xx_spi_txrx(base, t);
+		if (len != t->len) {
+			m->status = -EMSGSIZE;
+			break;
+		}
+		m->actual_length += len;
+
+		if (t->cs_change) {
+			if (list_is_last(&t->transfer_list, &m->transfers)) {
+				/* wait for continuation */
+				return m->spi->chip_select;
+			}
+			do_spi_finish(base);
+			ndelay(100);
+		}
+	}
+
+	do_spi_finish(base);
+	__raw_writel(rbspi->spi_ctrl_flash, base + SPI_REG_CTRL);
+	__raw_writel(0, base + SPI_REG_FS);
+	return -1;
+}
+
+static void rb4xx_spi_process_queue_locked(struct rb4xx_spi *rbspi,
+					   unsigned long *flags)
+{
+	int cs = rbspi->cs_wait;
+
+	rbspi->busy = 1;
+	while (!list_empty(&rbspi->queue)) {
+		struct spi_message *m;
+
+		list_for_each_entry(m, &rbspi->queue, queue)
+			if (cs < 0 || cs == m->spi->chip_select)
+				break;
+
+		if (&m->queue == &rbspi->queue)
+			break;
+
+		list_del_init(&m->queue);
+		spin_unlock_irqrestore(&rbspi->lock, *flags);
+
+		cs = rb4xx_spi_msg(rbspi, m);
+		m->complete(m->context);
+
+		spin_lock_irqsave(&rbspi->lock, *flags);
+	}
+
+	rbspi->cs_wait = cs;
+	rbspi->busy = 0;
+
+	if (cs >= 0) {
+		/* TODO: add timer to unlock cs after 1s inactivity */
+	}
+}
+
+static int rb4xx_spi_transfer(struct spi_device *spi,
+			      struct spi_message *m)
+{
+	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	m->actual_length = 0;
+	m->status = -EINPROGRESS;
+
+	spin_lock_irqsave(&rbspi->lock, flags);
+	list_add_tail(&m->queue, &rbspi->queue);
+	if (rbspi->busy ||
+	    (rbspi->cs_wait >= 0 && rbspi->cs_wait != m->spi->chip_select)) {
+		/* job will be done later */
+		spin_unlock_irqrestore(&rbspi->lock, flags);
+		return 0;
+	}
+
+	/* process job in current context */
+	rb4xx_spi_process_queue_locked(rbspi, &flags);
+	spin_unlock_irqrestore(&rbspi->lock, flags);
+
+	return 0;
+}
+
+static int rb4xx_spi_setup(struct spi_device *spi)
+{
+	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	if (spi->mode & ~(SPI_CS_HIGH)) {
+		dev_err(&spi->dev, "mode %x not supported\n",
+			(unsigned) spi->mode);
+		return -EINVAL;
+	}
+
+	if (spi->bits_per_word != 8 && spi->bits_per_word != 0) {
+		dev_err(&spi->dev, "bits_per_word %u not supported\n",
+			(unsigned) spi->bits_per_word);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&rbspi->lock, flags);
+	if (rbspi->cs_wait == spi->chip_select && !rbspi->busy) {
+		rbspi->cs_wait = -1;
+		rb4xx_spi_process_queue_locked(rbspi, &flags);
+	}
+	spin_unlock_irqrestore(&rbspi->lock, flags);
+
+	return 0;
+}
+
+static unsigned get_spi_ctrl(unsigned hz_max, const char *name)
+{
+	unsigned div;
+
+	div = (ar71xx_ahb_freq - 1) / (2 * hz_max);
+
+	/*
+	 * CPU has a bug at (div == 0) - first bit read is random
+	 */
+	if (div == 0)
+		++div;
+
+	if (name) {
+		unsigned ahb_khz = (ar71xx_ahb_freq + 500) / 1000;
+		unsigned div_real = 2 * (div + 1);
+		pr_debug("rb4xx: %s SPI clock %u kHz (AHB %u kHz / %u)\n",
+		       name,
+		       ahb_khz / div_real,
+		       ahb_khz, div_real);
+	}
+
+	return SPI_CTRL_FASTEST + div;
+}
+
+static int rb4xx_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct rb4xx_spi *rbspi;
+	struct resource *r;
+	int err = 0;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*rbspi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "no memory for spi_master\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	master->bus_num = 0;
+	master->num_chipselect = 3;
+	master->setup = rb4xx_spi_setup;
+	master->transfer = rb4xx_spi_transfer;
+
+	rbspi = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, rbspi);
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		err = -ENOENT;
+		goto err_put_master;
+	}
+
+	rbspi->base = ioremap(r->start, r->end - r->start + 1);
+	if (!rbspi->base) {
+		err = -ENXIO;
+		goto err_put_master;
+	}
+
+	rbspi->master = master;
+	rbspi->spi_ctrl_flash = get_spi_ctrl(SPI_FLASH_HZ, "FLASH");
+	rbspi->spi_ctrl_fread = get_spi_ctrl(SPI_CPLD_HZ, "CPLD");
+	rbspi->cs_wait = -1;
+
+	spin_lock_init(&rbspi->lock);
+	INIT_LIST_HEAD(&rbspi->queue);
+
+	err = spi_register_master(master);
+	if (err) {
+		dev_err(&pdev->dev, "failed to register SPI master\n");
+		goto err_iounmap;
+	}
+
+	return 0;
+
+err_iounmap:
+	iounmap(rbspi->base);
+err_put_master:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(master);
+err_out:
+	return err;
+}
+
+static int rb4xx_spi_remove(struct platform_device *pdev)
+{
+	struct rb4xx_spi *rbspi = platform_get_drvdata(pdev);
+
+	iounmap(rbspi->base);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(rbspi->master);
+
+	return 0;
+}
+
+static struct platform_driver rb4xx_spi_drv = {
+	.probe		= rb4xx_spi_probe,
+	.remove		= rb4xx_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb4xx_spi_init(void)
+{
+	return platform_driver_register(&rb4xx_spi_drv);
+}
+subsys_initcall(rb4xx_spi_init);
+
+static void __exit rb4xx_spi_exit(void)
+{
+	platform_driver_unregister(&rb4xx_spi_drv);
+}
+
+module_exit(rb4xx_spi_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.39.orig/drivers/spi/spi_rb4xx_cpld.c linux-2.6.39/drivers/spi/spi_rb4xx_cpld.c
--- linux-2.6.39.orig/drivers/spi/spi_rb4xx_cpld.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/spi/spi_rb4xx_cpld.c	2011-04-27 12:19:22.317665385 +0200
@@ -0,0 +1,440 @@
+/*
+ * SPI driver for the CPLD chip on the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ar71xx/rb4xx_cpld.h>
+
+#define DRV_NAME	"spi-rb4xx-cpld"
+#define DRV_DESC	"RB4xx CPLD driver"
+#define DRV_VERSION	"0.1.0"
+
+#define CPLD_CMD_WRITE_NAND	0x08 /* send cmd, n x send data, send indle */
+#define CPLD_CMD_WRITE_CFG	0x09 /* send cmd, n x send cfg */
+#define CPLD_CMD_READ_NAND	0x0a /* send cmd, send idle, n x read data */
+#define CPLD_CMD_READ_FAST	0x0b /* send cmd, 4 x idle, n x read data */
+#define CPLD_CMD_LED5_ON	0x0c /* send cmd */
+#define CPLD_CMD_LED5_OFF	0x0d /* send cmd */
+
+struct rb4xx_cpld {
+	struct spi_device	*spi;
+	struct mutex		lock;
+	struct gpio_chip	chip;
+	unsigned int		config;
+};
+
+static struct rb4xx_cpld *rb4xx_cpld;
+
+static inline struct rb4xx_cpld *gpio_to_cpld(struct gpio_chip *chip)
+{
+	return container_of(chip, struct rb4xx_cpld, chip);
+}
+
+static int rb4xx_cpld_write_cmd(struct rb4xx_cpld *cpld, unsigned char cmd)
+{
+	struct spi_transfer t[1];
+	struct spi_message m;
+	unsigned char tx_buf[1];
+	int err;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = tx_buf;
+	t[0].len = sizeof(tx_buf);
+	spi_message_add_tail(&t[0], &m);
+
+	tx_buf[0] = cmd;
+
+	err = spi_sync(cpld->spi, &m);
+	return err;
+}
+
+static int rb4xx_cpld_write_cfg(struct rb4xx_cpld *cpld, unsigned char config)
+{
+	struct spi_transfer t[1];
+	struct spi_message m;
+	unsigned char cmd[2];
+	int err;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_WRITE_CFG;
+	cmd[1] = config;
+
+	err = spi_sync(cpld->spi, &m);
+	return err;
+}
+
+static int __rb4xx_cpld_change_cfg(struct rb4xx_cpld *cpld, unsigned mask,
+				   unsigned value)
+{
+	unsigned int config;
+	int err;
+
+	config = cpld->config & ~mask;
+	config |= value;
+
+	if ((cpld->config ^ config) & 0xff) {
+		err = rb4xx_cpld_write_cfg(cpld, config);
+		if (err)
+			return err;
+	}
+
+	if ((cpld->config ^ config) & CPLD_CFG_nLED5) {
+		err = rb4xx_cpld_write_cmd(cpld, (value) ? CPLD_CMD_LED5_ON :
+							   CPLD_CMD_LED5_OFF);
+		if (err)
+			return err;
+	}
+
+	cpld->config = config;
+	return 0;
+}
+
+int rb4xx_cpld_change_cfg(unsigned mask, unsigned value)
+{
+	int ret;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	mutex_lock(&rb4xx_cpld->lock);
+	ret = __rb4xx_cpld_change_cfg(rb4xx_cpld, mask, value);
+	mutex_unlock(&rb4xx_cpld->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_change_cfg);
+
+int rb4xx_cpld_read_from(unsigned addr, unsigned char *rx_buf,
+			 const unsigned char *verify_buf, unsigned count)
+{
+	const unsigned char cmd[5] = {
+		CPLD_CMD_READ_FAST,
+		(addr >> 16) & 0xff,
+		(addr >> 8) & 0xff,
+		 addr & 0xff,
+		 0
+	};
+	struct spi_transfer t[2] = {
+		{
+			.tx_buf = &cmd,
+			.len = 5,
+		},
+		{
+			.tx_buf = verify_buf,
+			.rx_buf = rx_buf,
+			.len = count,
+			.verify = (verify_buf != NULL),
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	m.fast_read = 1;
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_read_from);
+
+#if 0
+int rb4xx_cpld_read(unsigned char *buf, unsigned char *verify_buf,
+		    unsigned count)
+{
+	struct spi_transfer t[2];
+	struct spi_message m;
+	unsigned char cmd[2];
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	/* send command */
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_READ_NAND;
+	cmd[1] = 0;
+
+	/* read data */
+	t[1].rx_buf = buf;
+	t[1].len = count;
+	spi_message_add_tail(&t[1], &m);
+
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+#else
+int rb4xx_cpld_read(unsigned char *rx_buf, const unsigned char *verify_buf,
+		    unsigned count)
+{
+	static const unsigned char cmd[2] = { CPLD_CMD_READ_NAND, 0 };
+	struct spi_transfer t[2] = {
+		{
+			.tx_buf = &cmd,
+			.len = 2,
+		}, {
+			.tx_buf = verify_buf,
+			.rx_buf = rx_buf,
+			.len = count,
+			.verify = (verify_buf != NULL),
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+#endif
+EXPORT_SYMBOL_GPL(rb4xx_cpld_read);
+
+int rb4xx_cpld_write(const unsigned char *buf, unsigned count)
+{
+#if 0
+	struct spi_transfer t[3];
+	struct spi_message m;
+	unsigned char cmd[1];
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	memset(&t, 0, sizeof(t));
+	spi_message_init(&m);
+
+	/* send command */
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_WRITE_NAND;
+
+	/* write data */
+	t[1].tx_buf = buf;
+	t[1].len = count;
+	spi_message_add_tail(&t[1], &m);
+
+	/* send idle */
+	t[2].len = 1;
+	spi_message_add_tail(&t[2], &m);
+
+	return spi_sync(rb4xx_cpld->spi, &m);
+#else
+	static const unsigned char cmd = CPLD_CMD_WRITE_NAND;
+	struct spi_transfer t[3] = {
+		{
+			.tx_buf = &cmd,
+			.len = 1,
+		}, {
+			.tx_buf = buf,
+			.len = count,
+			.fast_write = 1,
+		}, {
+			.len = 1,
+			.fast_write = 1,
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	spi_message_add_tail(&t[2], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+#endif
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_write);
+
+static int rb4xx_cpld_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+	int ret;
+
+	mutex_lock(&cpld->lock);
+	ret = (cpld->config >> offset) & 1;
+	mutex_unlock(&cpld->lock);
+
+	return ret;
+}
+
+static void rb4xx_cpld_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int value)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+
+	mutex_lock(&cpld->lock);
+	__rb4xx_cpld_change_cfg(cpld, (1 << offset), !!value << offset);
+	mutex_unlock(&cpld->lock);
+}
+
+static int rb4xx_cpld_gpio_direction_input(struct gpio_chip *chip,
+					   unsigned offset)
+{
+	return -EOPNOTSUPP;
+}
+
+static int rb4xx_cpld_gpio_direction_output(struct gpio_chip *chip,
+					    unsigned offset,
+					    int value)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+	int ret;
+
+	mutex_lock(&cpld->lock);
+	ret = __rb4xx_cpld_change_cfg(cpld, (1 << offset), !!value << offset);
+	mutex_unlock(&cpld->lock);
+
+	return ret;
+}
+
+static int rb4xx_cpld_gpio_init(struct rb4xx_cpld *cpld, unsigned int base)
+{
+	int err;
+
+	/* init config */
+	cpld->config = CPLD_CFG_nLED1 | CPLD_CFG_nLED2 | CPLD_CFG_nLED3 |
+		       CPLD_CFG_nLED4 | CPLD_CFG_nCE;
+	rb4xx_cpld_write_cfg(cpld, cpld->config);
+
+	/* setup GPIO chip */
+	cpld->chip.label = DRV_NAME;
+
+	cpld->chip.get = rb4xx_cpld_gpio_get;
+	cpld->chip.set = rb4xx_cpld_gpio_set;
+	cpld->chip.direction_input = rb4xx_cpld_gpio_direction_input;
+	cpld->chip.direction_output = rb4xx_cpld_gpio_direction_output;
+
+	cpld->chip.base = base;
+	cpld->chip.ngpio = CPLD_NUM_GPIOS;
+	cpld->chip.can_sleep = 1;
+	cpld->chip.dev = &cpld->spi->dev;
+	cpld->chip.owner = THIS_MODULE;
+
+	err = gpiochip_add(&cpld->chip);
+	if (err)
+		dev_err(&cpld->spi->dev, "adding GPIO chip failed, err=%d\n",
+			err);
+
+	return err;
+}
+
+static int __devinit rb4xx_cpld_probe(struct spi_device *spi)
+{
+	struct rb4xx_cpld *cpld;
+	struct rb4xx_cpld_platform_data *pdata;
+	int err;
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data\n");
+		return -EINVAL;
+	}
+
+	cpld = kzalloc(sizeof(*cpld), GFP_KERNEL);
+	if (!cpld) {
+		dev_err(&spi->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&cpld->lock);
+	cpld->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, cpld);
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi_setup failed, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = rb4xx_cpld_gpio_init(cpld, pdata->gpio_base);
+	if (err)
+		goto err_drvdata;
+
+	rb4xx_cpld = cpld;
+
+	return 0;
+
+err_drvdata:
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(cpld);
+
+	return err;
+}
+
+static int __devexit rb4xx_cpld_remove(struct spi_device *spi)
+{
+	struct rb4xx_cpld *cpld;
+
+	rb4xx_cpld = NULL;
+	cpld = dev_get_drvdata(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(cpld);
+
+	return 0;
+}
+
+static struct spi_driver rb4xx_cpld_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= rb4xx_cpld_probe,
+	.remove		= __devexit_p(rb4xx_cpld_remove),
+};
+
+static int __init rb4xx_cpld_init(void)
+{
+	return spi_register_driver(&rb4xx_cpld_driver);
+}
+module_init(rb4xx_cpld_init);
+
+static void __exit rb4xx_cpld_exit(void)
+{
+	spi_unregister_driver(&rb4xx_cpld_driver);
+}
+module_exit(rb4xx_cpld_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.39.orig/drivers/spi/spi_vsc7385.c linux-2.6.39/drivers/spi/spi_vsc7385.c
--- linux-2.6.39.orig/drivers/spi/spi_vsc7385.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/spi/spi_vsc7385.c	2011-04-27 12:19:22.317665385 +0200
@@ -0,0 +1,621 @@
+/*
+ * SPI driver for the Vitesse VSC7385 ethernet switch
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+#include <linux/firmware.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/vsc7385.h>
+
+#define DRV_NAME	"spi-vsc7385"
+#define DRV_DESC	"Vitesse VSC7385 Gbit ethernet switch driver"
+#define DRV_VERSION	"0.1.0"
+
+#define VSC73XX_BLOCK_MAC	0x1
+#define VSC73XX_BLOCK_2		0x2
+#define VSC73XX_BLOCK_MII	0x3
+#define VSC73XX_BLOCK_4		0x4
+#define VSC73XX_BLOCK_5		0x5
+#define VSC73XX_BLOCK_SYSTEM	0x7
+
+#define VSC73XX_SUBBLOCK_PORT_0		0
+#define VSC73XX_SUBBLOCK_PORT_1		1
+#define VSC73XX_SUBBLOCK_PORT_2		2
+#define VSC73XX_SUBBLOCK_PORT_3		3
+#define VSC73XX_SUBBLOCK_PORT_4		4
+#define VSC73XX_SUBBLOCK_PORT_MAC	6
+
+/* MAC Block registers */
+#define VSC73XX_MAC_CFG		0x0
+#define VSC73XX_ADVPORTM	0x19
+#define VSC73XX_RXOCT		0x50
+#define VSC73XX_TXOCT		0x51
+#define VSC73XX_C_RX0		0x52
+#define VSC73XX_C_RX1		0x53
+#define VSC73XX_C_RX2		0x54
+#define VSC73XX_C_TX0		0x55
+#define VSC73XX_C_TX1		0x56
+#define VSC73XX_C_TX2		0x57
+#define VSC73XX_C_CFG		0x58
+
+/* MAC_CFG register bits */
+#define VSC73XX_MAC_CFG_WEXC_DIS	(1 << 31)
+#define VSC73XX_MAC_CFG_PORT_RST	(1 << 29)
+#define VSC73XX_MAC_CFG_TX_EN		(1 << 28)
+#define VSC73XX_MAC_CFG_SEED_LOAD	(1 << 27)
+#define VSC73XX_MAC_CFG_FDX		(1 << 18)
+#define VSC73XX_MAC_CFG_GIGE		(1 << 17)
+#define VSC73XX_MAC_CFG_RX_EN		(1 << 16)
+#define VSC73XX_MAC_CFG_VLAN_DBLAWR	(1 << 15)
+#define VSC73XX_MAC_CFG_VLAN_AWR	(1 << 14)
+#define VSC73XX_MAC_CFG_100_BASE_T	(1 << 13)
+#define VSC73XX_MAC_CFG_TX_IPG(x)	(((x) & 0x1f) << 6)
+#define VSC73XX_MAC_CFG_MAC_RX_RST	(1 << 5)
+#define VSC73XX_MAC_CFG_MAC_TX_RST	(1 << 4)
+#define VSC73XX_MAC_CFG_BIT2		(1 << 2)
+#define VSC73XX_MAC_CFG_CLK_SEL(x)	((x) & 0x3)
+
+/* ADVPORTM register bits */
+#define VSC73XX_ADVPORTM_IFG_PPM	(1 << 7)
+#define VSC73XX_ADVPORTM_EXC_COL_CONT	(1 << 6)
+#define VSC73XX_ADVPORTM_EXT_PORT	(1 << 5)
+#define VSC73XX_ADVPORTM_INV_GTX	(1 << 4)
+#define VSC73XX_ADVPORTM_ENA_GTX	(1 << 3)
+#define VSC73XX_ADVPORTM_DDR_MODE	(1 << 2)
+#define VSC73XX_ADVPORTM_IO_LOOPBACK	(1 << 1)
+#define VSC73XX_ADVPORTM_HOST_LOOPBACK	(1 << 0)
+
+/* MII Block registers */
+#define VSC73XX_MII_STAT	0x0
+#define VSC73XX_MII_CMD		0x1
+#define VSC73XX_MII_DATA	0x2
+
+/* System Block registers */
+#define VSC73XX_ICPU_SIPAD		0x01
+#define VSC73XX_ICPU_CLOCK_DELAY	0x05
+#define VSC73XX_ICPU_CTRL		0x10
+#define VSC73XX_ICPU_ADDR		0x11
+#define VSC73XX_ICPU_SRAM		0x12
+#define VSC73XX_ICPU_MBOX_VAL		0x15
+#define VSC73XX_ICPU_MBOX_SET		0x16
+#define VSC73XX_ICPU_MBOX_CLR		0x17
+#define VSC73XX_ICPU_CHIPID		0x18
+#define VSC73XX_ICPU_GPIO		0x34
+
+#define VSC73XX_ICPU_CTRL_CLK_DIV	(1 << 8)
+#define VSC73XX_ICPU_CTRL_SRST_HOLD	(1 << 7)
+#define VSC73XX_ICPU_CTRL_BOOT_EN	(1 << 3)
+#define VSC73XX_ICPU_CTRL_EXT_ACC_EN	(1 << 2)
+#define VSC73XX_ICPU_CTRL_CLK_EN	(1 << 1)
+#define VSC73XX_ICPU_CTRL_SRST		(1 << 0)
+
+#define VSC73XX_ICPU_CHIPID_ID_SHIFT	12
+#define VSC73XX_ICPU_CHIPID_ID_MASK	0xffff
+#define VSC73XX_ICPU_CHIPID_REV_SHIFT	28
+#define VSC73XX_ICPU_CHIPID_REV_MASK	0xf
+#define VSC73XX_ICPU_CHIPID_ID_7385	0x7385
+#define VSC73XX_ICPU_CHIPID_ID_7395	0x7395
+
+#define VSC73XX_CMD_MODE_READ		0
+#define VSC73XX_CMD_MODE_WRITE		1
+#define VSC73XX_CMD_MODE_SHIFT		4
+#define VSC73XX_CMD_BLOCK_SHIFT		5
+#define VSC73XX_CMD_BLOCK_MASK		0x7
+#define VSC73XX_CMD_SUBBLOCK_MASK	0xf
+
+#define VSC7385_CLOCK_DELAY		((3 << 4) | 3)
+#define VSC7385_CLOCK_DELAY_MASK	((3 << 4) | 3)
+
+#define VSC73XX_ICPU_CTRL_STOP	(VSC73XX_ICPU_CTRL_SRST_HOLD | \
+				 VSC73XX_ICPU_CTRL_BOOT_EN | \
+				 VSC73XX_ICPU_CTRL_EXT_ACC_EN)
+
+#define VSC73XX_ICPU_CTRL_START	(VSC73XX_ICPU_CTRL_CLK_DIV | \
+				 VSC73XX_ICPU_CTRL_BOOT_EN | \
+				 VSC73XX_ICPU_CTRL_CLK_EN | \
+				 VSC73XX_ICPU_CTRL_SRST)
+
+#define VSC7385_ADVPORTM_MASK	(VSC73XX_ADVPORTM_IFG_PPM | \
+				 VSC73XX_ADVPORTM_EXC_COL_CONT | \
+				 VSC73XX_ADVPORTM_EXT_PORT | \
+				 VSC73XX_ADVPORTM_INV_GTX | \
+				 VSC73XX_ADVPORTM_ENA_GTX | \
+				 VSC73XX_ADVPORTM_DDR_MODE | \
+				 VSC73XX_ADVPORTM_IO_LOOPBACK | \
+				 VSC73XX_ADVPORTM_HOST_LOOPBACK)
+
+#define VSC7385_ADVPORTM_INIT	(VSC73XX_ADVPORTM_EXT_PORT | \
+				 VSC73XX_ADVPORTM_ENA_GTX | \
+				 VSC73XX_ADVPORTM_DDR_MODE)
+
+#define VSC7385_MAC_CFG_RESET	(VSC73XX_MAC_CFG_PORT_RST | \
+				 VSC73XX_MAC_CFG_MAC_RX_RST | \
+				 VSC73XX_MAC_CFG_MAC_TX_RST)
+
+#define VSC73XX_MAC_CFG_INIT	(VSC73XX_MAC_CFG_TX_EN | \
+				 VSC73XX_MAC_CFG_FDX | \
+				 VSC73XX_MAC_CFG_GIGE | \
+				 VSC73XX_MAC_CFG_RX_EN)
+
+#define VSC73XX_RESET_DELAY	100
+
+struct vsc7385 {
+	struct spi_device		*spi;
+	struct mutex			lock;
+	struct vsc7385_platform_data	*pdata;
+};
+
+static int vsc7385_is_addr_valid(u8 block, u8 subblock)
+{
+	switch (block) {
+	case VSC73XX_BLOCK_MAC:
+		switch (subblock) {
+		case 0 ... 4:
+		case 6:
+			return 1;
+		}
+		break;
+
+	case VSC73XX_BLOCK_2:
+	case VSC73XX_BLOCK_SYSTEM:
+		switch (subblock) {
+		case 0:
+			return 1;
+		}
+		break;
+
+	case VSC73XX_BLOCK_MII:
+	case VSC73XX_BLOCK_4:
+	case VSC73XX_BLOCK_5:
+		switch (subblock) {
+		case 0 ... 1:
+			return 1;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static inline u8 vsc7385_make_addr(u8 mode, u8 block, u8 subblock)
+{
+	u8 ret;
+
+	ret = (block & VSC73XX_CMD_BLOCK_MASK) << VSC73XX_CMD_BLOCK_SHIFT;
+	ret |= (mode & 1) << VSC73XX_CMD_MODE_SHIFT;
+	ret |= subblock & VSC73XX_CMD_SUBBLOCK_MASK;
+
+	return ret;
+}
+
+static int vsc7385_read(struct vsc7385 *vsc, u8 block, u8 subblock, u8 reg,
+			u32 *value)
+{
+	u8 cmd[4];
+	u8 buf[4];
+	struct spi_transfer t[2];
+	struct spi_message m;
+	int err;
+
+	if (!vsc7385_is_addr_valid(block, subblock))
+		return -EINVAL;
+
+	spi_message_init(&m);
+
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = buf;
+	t[1].len = sizeof(buf);
+	spi_message_add_tail(&t[1], &m);
+
+	cmd[0] = vsc7385_make_addr(VSC73XX_CMD_MODE_READ, block, subblock);
+	cmd[1] = reg;
+	cmd[2] = 0;
+	cmd[3] = 0;
+
+	mutex_lock(&vsc->lock);
+	err = spi_sync(vsc->spi, &m);
+	mutex_unlock(&vsc->lock);
+
+	if (err)
+		return err;
+
+	*value = (((u32) buf[0]) << 24) | (((u32) buf[1]) << 16) |
+		 (((u32) buf[2]) << 8) | ((u32) buf[3]);
+
+	return 0;
+}
+
+
+static int vsc7385_write(struct vsc7385 *vsc, u8 block, u8 subblock, u8 reg,
+			 u32 value)
+{
+	u8 cmd[2];
+	u8 buf[4];
+	struct spi_transfer t[2];
+	struct spi_message m;
+	int err;
+
+	if (!vsc7385_is_addr_valid(block, subblock))
+		return -EINVAL;
+
+	spi_message_init(&m);
+
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = buf;
+	t[1].len = sizeof(buf);
+	spi_message_add_tail(&t[1], &m);
+
+	cmd[0] = vsc7385_make_addr(VSC73XX_CMD_MODE_WRITE, block, subblock);
+	cmd[1] = reg;
+
+	buf[0] = (value >> 24) & 0xff;
+	buf[1] = (value >> 16) & 0xff;
+	buf[2] = (value >> 8) & 0xff;
+	buf[3] = value & 0xff;
+
+	mutex_lock(&vsc->lock);
+	err = spi_sync(vsc->spi, &m);
+	mutex_unlock(&vsc->lock);
+
+	return err;
+}
+
+static inline int vsc7385_write_verify(struct vsc7385 *vsc, u8 block,
+				       u8 subblock, u8 reg, u32 value,
+				       u32 read_mask, u32 read_val)
+{
+	struct spi_device *spi = vsc->spi;
+	u32 t;
+	int err;
+
+	err = vsc7385_write(vsc, block, subblock, reg, value);
+	if (err)
+		return err;
+
+	err = vsc7385_read(vsc, block, subblock, reg, &t);
+	if (err)
+		return err;
+
+	if ((t & read_mask) != read_val) {
+		dev_err(&spi->dev, "register write error\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static inline int vsc7385_set_clock_delay(struct vsc7385 *vsc, u32 val)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+			     VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int vsc7385_get_clock_delay(struct vsc7385 *vsc, u32 *val)
+{
+	return vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+			    VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int vsc7385_icpu_stop(struct vsc7385 *vsc)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+			     VSC73XX_ICPU_CTRL_STOP);
+}
+
+static inline int vsc7385_icpu_start(struct vsc7385 *vsc)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+			     VSC73XX_ICPU_CTRL_START);
+}
+
+static inline int vsc7385_icpu_reset(struct vsc7385 *vsc)
+{
+	int rc;
+
+	rc = vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_ADDR,
+			   0x0000);
+	if (rc)
+		dev_err(&vsc->spi->dev,
+			"could not reset microcode, err=%d\n", rc);
+
+	return rc;
+}
+
+static int vsc7385_upload_ucode(struct vsc7385 *vsc)
+{
+	struct spi_device *spi = vsc->spi;
+	const struct firmware *firmware;
+	char *ucode_name;
+	unsigned char *dp;
+	unsigned int curVal;
+	int i;
+	int diffs;
+	int rc;
+
+	ucode_name = (vsc->pdata->ucode_name) ? vsc->pdata->ucode_name
+					      : "vsc7385_ucode.bin";
+	rc = request_firmware(&firmware, ucode_name, &spi->dev);
+	if (rc) {
+		dev_err(&spi->dev, "request_firmware failed, err=%d\n",
+			rc);
+		return rc;
+	}
+
+	rc = vsc7385_icpu_stop(vsc);
+	if (rc)
+		goto out;
+
+	rc = vsc7385_icpu_reset(vsc);
+	if (rc)
+		goto out;
+
+	dev_info(&spi->dev, "uploading microcode...\n");
+
+	dp = (unsigned char *) firmware->data;
+	for (i = 0; i < firmware->size; i++) {
+		rc = vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				   VSC73XX_ICPU_SRAM, *dp++);
+		if (rc) {
+			dev_err(&spi->dev, "could not load microcode, err=%d\n",
+				rc);
+			goto out;
+		}
+	}
+
+	rc = vsc7385_icpu_reset(vsc);
+	if (rc)
+		goto out;
+
+	dev_info(&spi->dev, "verifying microcode...\n");
+
+	dp = (unsigned char *) firmware->data;
+	diffs = 0;
+	for (i = 0; i < firmware->size; i++) {
+		rc = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				  VSC73XX_ICPU_SRAM, &curVal);
+		if (rc) {
+			dev_err(&spi->dev, "could not read microcode %d\n",
+				rc);
+			goto out;
+		}
+
+		if (curVal > 0xff) {
+			dev_err(&spi->dev, "bad val read: %04x : %02x  %02x\n",
+				i, *dp, curVal);
+			rc = -EIO;
+			goto out;
+		}
+
+		if ((curVal & 0xff) != *dp) {
+			diffs++;
+			dev_err(&spi->dev, "verify error: %04x : %02x  %02x\n",
+				i, *dp, curVal);
+
+			if (diffs > 4)
+				break;
+			}
+		dp++;
+	}
+
+	if (diffs) {
+		dev_err(&spi->dev, "microcode verification failed\n");
+		rc = -EIO;
+		goto out;
+	}
+
+	dev_info(&spi->dev, "microcode uploaded\n");
+
+	rc = vsc7385_icpu_start(vsc);
+
+out:
+	release_firmware(firmware);
+	return rc;
+}
+
+static int vsc7385_setup(struct vsc7385 *vsc)
+{
+	struct vsc7385_platform_data *pdata = vsc->pdata;
+	u32 t;
+	int err;
+
+	err = vsc7385_write_verify(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				   VSC73XX_ICPU_CLOCK_DELAY,
+				   VSC7385_CLOCK_DELAY,
+				   VSC7385_CLOCK_DELAY_MASK,
+				   VSC7385_CLOCK_DELAY);
+	if (err)
+		goto err;
+
+	err = vsc7385_write_verify(vsc, VSC73XX_BLOCK_MAC,
+				   VSC73XX_SUBBLOCK_PORT_MAC, VSC73XX_ADVPORTM,
+				   VSC7385_ADVPORTM_INIT,
+				   VSC7385_ADVPORTM_MASK,
+				   VSC7385_ADVPORTM_INIT);
+	if (err)
+		goto err;
+
+	err = vsc7385_write(vsc, VSC73XX_BLOCK_MAC, VSC73XX_SUBBLOCK_PORT_MAC,
+			    VSC73XX_MAC_CFG, VSC7385_MAC_CFG_RESET);
+	if (err)
+		goto err;
+
+	t = VSC73XX_MAC_CFG_INIT;
+	t |= VSC73XX_MAC_CFG_TX_IPG(pdata->mac_cfg.tx_ipg);
+	t |= VSC73XX_MAC_CFG_CLK_SEL(pdata->mac_cfg.clk_sel);
+	if (pdata->mac_cfg.bit2)
+		t |= VSC73XX_MAC_CFG_BIT2;
+
+	err = vsc7385_write(vsc, VSC73XX_BLOCK_MAC, VSC73XX_SUBBLOCK_PORT_MAC,
+			    VSC73XX_MAC_CFG, t);
+	if (err)
+		goto err;
+
+	return 0;
+
+err:
+	return err;
+}
+
+static int vsc7385_detect(struct vsc7385 *vsc)
+{
+	struct spi_device *spi = vsc->spi;
+	u32 t;
+	u32 id;
+	u32 rev;
+	int err;
+
+	err = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				VSC73XX_ICPU_MBOX_VAL, &t);
+	if (err) {
+		dev_err(&spi->dev, "unable to read mailbox, err=%d\n", err);
+		return err;
+	}
+
+	if (t == 0xffffffff) {
+		dev_dbg(&spi->dev, "assert chip reset\n");
+		if (vsc->pdata->reset)
+			vsc->pdata->reset();
+
+	}
+
+	err = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				VSC73XX_ICPU_CHIPID, &t);
+	if (err) {
+		dev_err(&spi->dev, "unable to read chip id, err=%d\n", err);
+		return err;
+	}
+
+	id = (t >> VSC73XX_ICPU_CHIPID_ID_SHIFT) & VSC73XX_ICPU_CHIPID_ID_MASK;
+	switch (id) {
+	case VSC73XX_ICPU_CHIPID_ID_7385:
+	case VSC73XX_ICPU_CHIPID_ID_7395:
+		break;
+	default:
+		dev_err(&spi->dev, "unsupported chip, id=%04x\n", id);
+		return -ENODEV;
+	}
+
+	rev = (t >> VSC73XX_ICPU_CHIPID_REV_SHIFT) &
+	      VSC73XX_ICPU_CHIPID_REV_MASK;
+	dev_info(&spi->dev, "VSC%04X (rev. %d) switch found\n", id, rev);
+
+	return 0;
+}
+
+static int __devinit vsc7385_probe(struct spi_device *spi)
+{
+	struct vsc7385 *vsc;
+	struct vsc7385_platform_data *pdata;
+	int	err;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION"\n");
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		dev_err(&spi->dev, "no platform data specified\n");
+		return -ENODEV;
+	}
+
+	vsc = kzalloc(sizeof(*vsc), GFP_KERNEL);
+	if (!vsc) {
+		dev_err(&spi->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&vsc->lock);
+	vsc->pdata = pdata;
+	vsc->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, vsc);
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi_setup failed, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = vsc7385_detect(vsc);
+	if (err) {
+		dev_err(&spi->dev, "no chip found, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = vsc7385_upload_ucode(vsc);
+	if (err)
+		goto err_drvdata;
+
+	err = vsc7385_setup(vsc);
+	if (err)
+		goto err_drvdata;
+
+	return 0;
+
+err_drvdata:
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(vsc);
+	return err;
+}
+
+static int __devexit vsc7385_remove(struct spi_device *spi)
+{
+	struct vsc7385_data	*vsc;
+
+	vsc = dev_get_drvdata(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(vsc);
+
+	return 0;
+}
+
+static struct spi_driver vsc7385_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= vsc7385_probe,
+	.remove		= __devexit_p(vsc7385_remove),
+};
+
+static int __init vsc7385_init(void)
+{
+	return spi_register_driver(&vsc7385_driver);
+}
+module_init(vsc7385_init);
+
+static void __exit vsc7385_exit(void)
+{
+	spi_unregister_driver(&vsc7385_driver);
+}
+module_exit(vsc7385_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+
diff -Nur linux-2.6.39.orig/drivers/tty/serial/ar933x_uart.c linux-2.6.39/drivers/tty/serial/ar933x_uart.c
--- linux-2.6.39.orig/drivers/tty/serial/ar933x_uart.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/tty/serial/ar933x_uart.c	2011-08-06 09:32:37.098016752 +0200
@@ -0,0 +1,688 @@
+/*
+ *  Atheros AR933X SoC built-in UART driver
+ *
+ *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+
+#include <asm/mach-ar71xx/ar933x_uart.h>
+#include <asm/mach-ar71xx/ar933x_uart_platform.h>
+
+#define DRIVER_NAME "ar933x-uart"
+
+#define AR933X_DUMMY_STATUS_RD	0x01
+
+static struct uart_driver ar933x_uart_driver;
+
+struct ar933x_uart_port {
+	struct uart_port	port;
+	unsigned int		ier;	/* shadow Interrupt Enable Register */
+};
+
+static inline unsigned int ar933x_uart_read(struct ar933x_uart_port *up,
+					    int offset)
+{
+	return readl(up->port.membase + offset);
+}
+
+static inline void ar933x_uart_write(struct ar933x_uart_port *up,
+				     int offset, unsigned int value)
+{
+	writel(value, up->port.membase + offset);
+}
+
+static inline void ar933x_uart_rmw(struct ar933x_uart_port *up,
+				  unsigned int offset,
+				  unsigned int mask,
+				  unsigned int val)
+{
+	unsigned int t;
+
+	t = ar933x_uart_read(up, offset);
+	t &= ~mask;
+	t |= val;
+	ar933x_uart_write(up, offset, t);
+}
+
+static inline void ar933x_uart_rmw_set(struct ar933x_uart_port *up,
+				       unsigned int offset,
+				       unsigned int val)
+{
+	ar933x_uart_rmw(up, offset, 0, val);
+}
+
+static inline void ar933x_uart_rmw_clear(struct ar933x_uart_port *up,
+					 unsigned int offset,
+					 unsigned int val)
+{
+	ar933x_uart_rmw(up, offset, val, 0);
+}
+
+static inline void ar933x_uart_start_tx_interrupt(struct ar933x_uart_port *up)
+{
+	up->ier |= AR933X_UART_INT_TX_EMPTY;
+	ar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);
+}
+
+static inline void ar933x_uart_stop_tx_interrupt(struct ar933x_uart_port *up)
+{
+	up->ier &= ~AR933X_UART_INT_TX_EMPTY;
+	ar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);
+}
+
+static inline void ar933x_uart_putc(struct ar933x_uart_port *up, int ch)
+{
+	unsigned int rdata;
+
+	rdata = ch & AR933X_UART_DATA_TX_RX_MASK;
+	rdata |= AR933X_UART_DATA_TX_CSR;
+	ar933x_uart_write(up, AR933X_UART_DATA_REG, rdata);
+}
+
+static unsigned int ar933x_uart_tx_empty(struct uart_port *port)
+{
+	struct ar933x_uart_port *up = (struct ar933x_uart_port *) port;
+	unsigned long flags;
+	unsigned int rdata;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	rdata = ar933x_uart_read(up, AR933X_UART_DATA_REG);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return (rdata & AR933X_UART_DATA_TX_CSR) ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int ar933x_uart_get_mctrl(struct uart_port *port)
+{
+	return TIOCM_CAR;
+}
+
+static void ar933x_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static void ar933x_uart_start_tx(struct uart_port *port)
+{
+	struct ar933x_uart_port *up = (struct ar933x_uart_port *) port;
+
+	ar933x_uart_start_tx_interrupt(up);
+}
+
+static void ar933x_uart_stop_tx(struct uart_port *port)
+{
+	struct ar933x_uart_port *up = (struct ar933x_uart_port *) port;
+
+	ar933x_uart_stop_tx_interrupt(up);
+}
+
+static void ar933x_uart_stop_rx(struct uart_port *port)
+{
+	struct ar933x_uart_port *up = (struct ar933x_uart_port *) port;
+
+	up->ier &= ~AR933X_UART_INT_RX_VALID;
+	ar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);
+}
+
+static void ar933x_uart_break_ctl(struct uart_port *port, int break_state)
+{
+	struct ar933x_uart_port *up = (struct ar933x_uart_port *) port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (break_state == -1)
+		ar933x_uart_rmw_set(up, AR933X_UART_CS_REG,
+				    AR933X_UART_CS_TX_BREAK);
+	else
+		ar933x_uart_rmw_clear(up, AR933X_UART_CS_REG,
+				      AR933X_UART_CS_TX_BREAK);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void ar933x_uart_enable_ms(struct uart_port *port)
+{
+}
+
+static void ar933x_uart_set_termios(struct uart_port *port,
+				    struct ktermios *new,
+				    struct ktermios *old)
+{
+	struct ar933x_uart_port *up = (struct ar933x_uart_port *) port;
+	unsigned int cs;
+	unsigned long flags;
+	unsigned int baud, scale;
+
+	/* Only CS8 is supported */
+	new->c_cflag &= ~CSIZE;
+	new->c_cflag |= CS8;
+
+	/* Only one stop bit is supported */
+	new->c_cflag &= ~CSTOPB;
+
+	cs = 0;
+	if (new->c_cflag & PARENB) {
+		if (!(new->c_cflag & PARODD))
+			cs |= AR933X_UART_CS_PARITY_EVEN;
+		else
+			cs |= AR933X_UART_CS_PARITY_ODD;
+	} else {
+		cs |= AR933X_UART_CS_PARITY_NONE;
+	}
+
+	/* Mark/space parity is not supported */
+	new->c_cflag &= ~CMSPAR;
+
+	baud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);
+	scale = (port->uartclk / (16 * baud)) - 1;
+
+	/*
+	 * Ok, we're now changing the port state. Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/* Update the per-port timeout. */
+	uart_update_timeout(port, new->c_cflag, baud);
+
+	up->port.ignore_status_mask = 0;
+
+	/* ignore all characters if CREAD is not set */
+	if ((new->c_cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= AR933X_DUMMY_STATUS_RD;
+
+	ar933x_uart_write(up, AR933X_UART_CLOCK_REG,
+			  scale << AR933X_UART_CLOCK_SCALE_S | 8192);
+
+	/* setup configuration register */
+	ar933x_uart_rmw(up, AR933X_UART_CS_REG, AR933X_UART_CS_PARITY_M, cs);
+
+	/* enable host interrupt */
+	ar933x_uart_rmw_set(up, AR933X_UART_CS_REG,
+			    AR933X_UART_CS_HOST_INT_EN);
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	if (tty_termios_baud_rate(new))
+		tty_termios_encode_baud_rate(new, baud, baud);
+}
+
+static void ar933x_uart_rx_chars(struct ar933x_uart_port *up)
+{
+	struct tty_struct *tty;
+	int max_count = 256;
+
+	tty = tty_port_tty_get(&up->port.state->port);
+	do {
+		unsigned int rdata;
+		unsigned char ch;
+
+		rdata = ar933x_uart_read(up, AR933X_UART_DATA_REG);
+		if ((rdata & AR933X_UART_DATA_RX_CSR) == 0)
+			break;
+
+		/* remove the character from the FIFO */
+		ar933x_uart_write(up, AR933X_UART_DATA_REG,
+				  AR933X_UART_DATA_RX_CSR);
+
+		if (!tty) {
+			/* discard the data if no tty available */
+			continue;
+		}
+
+		up->port.icount.rx++;
+		ch = rdata & AR933X_UART_DATA_TX_RX_MASK;
+
+		if (uart_handle_sysrq_char(&up->port, ch))
+			continue;
+
+		if ((up->port.ignore_status_mask & AR933X_DUMMY_STATUS_RD) == 0)
+			tty_insert_flip_char(tty, ch, TTY_NORMAL);
+	} while (max_count-- > 0);
+
+	if (tty) {
+		tty_flip_buffer_push(tty);
+		tty_kref_put(tty);
+	}
+}
+
+static void ar933x_uart_tx_chars(struct ar933x_uart_port *up)
+{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	int count;
+
+	if (uart_tx_stopped(&up->port))
+		return;
+
+	count = up->port.fifosize;
+	do {
+		unsigned int rdata;
+
+		rdata = ar933x_uart_read(up, AR933X_UART_DATA_REG);
+		if ((rdata & AR933X_UART_DATA_TX_CSR) == 0)
+			break;
+
+		if (up->port.x_char) {
+			ar933x_uart_putc(up, up->port.x_char);
+			up->port.icount.tx++;
+			up->port.x_char = 0;
+			continue;
+		}
+
+		if (uart_circ_empty(xmit))
+			break;
+
+		ar933x_uart_putc(up, xmit->buf[xmit->tail]);
+
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (!uart_circ_empty(xmit))
+		ar933x_uart_start_tx_interrupt(up);
+}
+
+static irqreturn_t ar933x_uart_interrupt(int irq, void *dev_id)
+{
+	struct ar933x_uart_port *up = dev_id;
+	unsigned int status;
+
+	status = ar933x_uart_read(up, AR933X_UART_CS_REG);
+	if ((status & AR933X_UART_CS_HOST_INT) == 0)
+		return IRQ_NONE;
+
+	spin_lock(&up->port.lock);
+
+	status = ar933x_uart_read(up, AR933X_UART_INT_REG);
+	status &= ar933x_uart_read(up, AR933X_UART_INT_EN_REG);
+
+	if (status & AR933X_UART_INT_RX_VALID) {
+		ar933x_uart_write(up, AR933X_UART_INT_REG,
+				  AR933X_UART_INT_RX_VALID);
+		ar933x_uart_rx_chars(up);
+	}
+
+	if (status & AR933X_UART_INT_TX_EMPTY) {
+		ar933x_uart_write(up, AR933X_UART_INT_REG,
+				  AR933X_UART_INT_TX_EMPTY);
+		ar933x_uart_stop_tx_interrupt(up);
+		ar933x_uart_tx_chars(up);
+	}
+
+	spin_unlock(&up->port.lock);
+
+	return IRQ_HANDLED;
+}
+
+static int ar933x_uart_startup(struct uart_port *port)
+{
+	struct ar933x_uart_port *up = (struct ar933x_uart_port *) port;
+	unsigned long flags;
+	int ret;
+
+	ret = request_irq(up->port.irq, ar933x_uart_interrupt,
+			  up->port.irqflags, dev_name(up->port.dev), up);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/* Enable HOST interrupts */
+	ar933x_uart_rmw_set(up, AR933X_UART_CS_REG,
+			    AR933X_UART_CS_HOST_INT_EN);
+
+	/* Enable RX interrupts */
+	up->ier = AR933X_UART_INT_RX_VALID;
+	ar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return 0;
+}
+
+static void ar933x_uart_shutdown(struct uart_port *port)
+{
+	struct ar933x_uart_port *up = (struct ar933x_uart_port *) port;
+
+	/* Disable all interrupts */
+	up->ier = 0;
+	ar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);
+
+	/* Disable break condition */
+	ar933x_uart_rmw_clear(up, AR933X_UART_CS_REG,
+			      AR933X_UART_CS_TX_BREAK);
+
+	free_irq(up->port.irq, up);
+}
+
+static const char *ar933x_uart_type(struct uart_port *port)
+{
+	return (port->type == PORT_AR933X) ? "AR933X UART" : NULL;
+}
+
+static void ar933x_uart_release_port(struct uart_port *port)
+{
+	/* Nothing to release ... */
+}
+
+static int ar933x_uart_request_port(struct uart_port *port)
+{
+	/* UARTs always present */
+	return 0;
+}
+
+static void ar933x_uart_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = PORT_AR933X;
+}
+
+static int ar933x_uart_verify_port(struct uart_port *port,
+				   struct serial_struct *ser)
+{
+	if (ser->type != PORT_UNKNOWN &&
+	    ser->type != PORT_AR933X)
+		return -EINVAL;
+
+	if (ser->irq < 0 || ser->irq >= NR_IRQS)
+		return -EINVAL;
+
+	if (ser->baud_base < 28800)
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct uart_ops ar933x_uart_ops = {
+	.tx_empty	= ar933x_uart_tx_empty,
+	.set_mctrl	= ar933x_uart_set_mctrl,
+	.get_mctrl	= ar933x_uart_get_mctrl,
+	.stop_tx	= ar933x_uart_stop_tx,
+	.start_tx	= ar933x_uart_start_tx,
+	.stop_rx	= ar933x_uart_stop_rx,
+	.enable_ms	= ar933x_uart_enable_ms,
+	.break_ctl	= ar933x_uart_break_ctl,
+	.startup	= ar933x_uart_startup,
+	.shutdown	= ar933x_uart_shutdown,
+	.set_termios	= ar933x_uart_set_termios,
+	.type		= ar933x_uart_type,
+	.release_port	= ar933x_uart_release_port,
+	.request_port	= ar933x_uart_request_port,
+	.config_port	= ar933x_uart_config_port,
+	.verify_port	= ar933x_uart_verify_port,
+};
+
+#ifdef CONFIG_SERIAL_AR933X_CONSOLE
+
+static struct ar933x_uart_port *
+ar933x_console_ports[CONFIG_SERIAL_AR933X_NR_UARTS];
+
+static void ar933x_uart_wait_xmitr(struct ar933x_uart_port *up)
+{
+	unsigned int status;
+	unsigned int timeout = 60000;
+
+	/* Wait up to 60ms for the character(s) to be sent. */
+	do {
+		status = ar933x_uart_read(up, AR933X_UART_DATA_REG);
+		if (--timeout == 0)
+			break;
+		udelay(1);
+	} while ((status & AR933X_UART_DATA_TX_CSR) == 0);
+}
+
+static void ar933x_uart_console_putchar(struct uart_port *port, int ch)
+{
+	struct ar933x_uart_port *up = (struct ar933x_uart_port *) port;
+
+	ar933x_uart_wait_xmitr(up);
+	ar933x_uart_putc(up, ch);
+}
+
+static void ar933x_uart_console_write(struct console *co, const char *s,
+				      unsigned int count)
+{
+	struct ar933x_uart_port *up = ar933x_console_ports[co->index];
+	unsigned long flags;
+	unsigned int int_en;
+	int locked = 1;
+
+	local_irq_save(flags);
+
+	if (up->port.sysrq)
+		locked = 0;
+	else if (oops_in_progress)
+		locked = spin_trylock(&up->port.lock);
+	else
+		spin_lock(&up->port.lock);
+
+	/*
+	 * First save the IER then disable the interrupts
+	 */
+	int_en = ar933x_uart_read(up, AR933X_UART_INT_EN_REG);
+	ar933x_uart_write(up, AR933X_UART_INT_EN_REG, 0);
+
+	uart_console_write(&up->port, s, count, ar933x_uart_console_putchar);
+
+	/*
+	 * Finally, wait for transmitter to become empty
+	 * and restore the IER
+	 */
+	ar933x_uart_wait_xmitr(up);
+	ar933x_uart_write(up, AR933X_UART_INT_EN_REG, int_en);
+
+	ar933x_uart_write(up, AR933X_UART_INT_REG, AR933X_UART_INT_ALLINTS);
+
+	if (locked)
+		spin_unlock(&up->port.lock);
+
+	local_irq_restore(flags);
+}
+
+static int ar933x_uart_console_setup(struct console *co, char *options)
+{
+	struct ar933x_uart_port *up;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index < 0 || co->index >= CONFIG_SERIAL_AR933X_NR_UARTS)
+		return -EINVAL;
+
+	up = ar933x_console_ports[co->index];
+	if (!up)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(&up->port, co, baud, parity, bits, flow);
+}
+
+static struct console ar933x_uart_console = {
+	.name		= "ttyATH",
+	.write		= ar933x_uart_console_write,
+	.device		= uart_console_device,
+	.setup		= ar933x_uart_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &ar933x_uart_driver,
+};
+
+static void ar933x_uart_add_console_port(struct ar933x_uart_port *up)
+{
+	ar933x_console_ports[up->port.line] = up;
+}
+
+#define AR933X_SERIAL_CONSOLE	(&ar933x_uart_console)
+
+#else
+
+static inline void ar933x_uart_add_console_port(struct ar933x_uart_port *up) {}
+
+#define AR933X_SERIAL_CONSOLE	NULL
+
+#endif /* CONFIG_SERIAL_AR933X_CONSOLE */
+
+static struct uart_driver ar933x_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= DRIVER_NAME,
+	.dev_name	= "ttyATH",
+	.nr		= CONFIG_SERIAL_AR933X_NR_UARTS,
+	.cons		= AR933X_SERIAL_CONSOLE,
+};
+
+static int __devinit ar933x_uart_probe(struct platform_device *pdev)
+{
+	struct ar933x_uart_platform_data *pdata;
+	struct ar933x_uart_port *up;
+	struct uart_port *port;
+	struct resource *mem_res;
+	struct resource *irq_res;
+	int id;
+	int ret;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata)
+		return -EINVAL;
+
+	id = pdev->id;
+	if (id == -1)
+		id = 0;
+
+	if (id > CONFIG_SERIAL_AR933X_NR_UARTS)
+		return -EINVAL;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "no MEM resource\n");
+		return -EINVAL;
+	}
+
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq_res) {
+		dev_err(&pdev->dev, "no IRQ resource\n");
+		return -EINVAL;
+	}
+
+	up = kzalloc(sizeof(struct ar933x_uart_port), GFP_KERNEL);
+	if (!up)
+		return -ENOMEM;
+
+	port = &up->port;
+	port->mapbase = mem_res->start;
+
+	port->membase = ioremap(mem_res->start, AR933X_UART_REGS_SIZE);
+	if (!port->membase) {
+		ret = -ENOMEM;
+		goto err_free_up;
+	}
+
+	port->line = id;
+	port->irq = irq_res->start;
+	port->dev = &pdev->dev;
+	port->type = PORT_AR933X;
+	port->iotype = UPIO_MEM32;
+	port->uartclk = pdata->uartclk;
+
+	port->regshift = 2;
+	port->fifosize = AR933X_UART_FIFO_SIZE;
+	port->ops = &ar933x_uart_ops;
+
+	ar933x_uart_add_console_port(up);
+
+	ret = uart_add_one_port(&ar933x_uart_driver, &up->port);
+	if (ret)
+		goto err_unmap;
+
+	platform_set_drvdata(pdev, up);
+	return 0;
+
+err_unmap:
+	iounmap(up->port.membase);
+err_free_up:
+	kfree(up);
+	return ret;
+}
+
+static int __devexit ar933x_uart_remove(struct platform_device *pdev)
+{
+	struct ar933x_uart_port *up;
+
+	up = platform_get_drvdata(pdev);
+	platform_set_drvdata(pdev, NULL);
+
+	if (up) {
+		uart_remove_one_port(&ar933x_uart_driver, &up->port);
+		iounmap(up->port.membase);
+		kfree(up);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ar933x_uart_platform_driver = {
+	.probe		= ar933x_uart_probe,
+	.remove		= __devexit_p(ar933x_uart_remove),
+	.driver		= {
+		.name		= DRIVER_NAME,
+		.owner		= THIS_MODULE,
+	},
+};
+
+static int __init ar933x_uart_init(void)
+{
+	int ret;
+
+	ar933x_uart_driver.nr = CONFIG_SERIAL_AR933X_NR_UARTS;
+	ret = uart_register_driver(&ar933x_uart_driver);
+	if (ret)
+		goto err_out;
+
+	ret = platform_driver_register(&ar933x_uart_platform_driver);
+	if (ret)
+		goto err_unregister_uart_driver;
+
+	return 0;
+
+err_unregister_uart_driver:
+	uart_unregister_driver(&ar933x_uart_driver);
+err_out:
+	return ret;
+}
+
+static void __exit ar933x_uart_exit(void)
+{
+	platform_driver_unregister(&ar933x_uart_platform_driver);
+	uart_unregister_driver(&ar933x_uart_driver);
+}
+
+module_init(ar933x_uart_init);
+module_exit(ar933x_uart_exit);
+
+MODULE_DESCRIPTION("Atheros AR933X UART driver");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Nur linux-2.6.39.orig/drivers/usb/host/ehci-ar71xx.c linux-2.6.39/drivers/usb/host/ehci-ar71xx.c
--- linux-2.6.39.orig/drivers/usb/host/ehci-ar71xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/usb/host/ehci-ar71xx.c	2011-04-27 12:19:22.267661616 +0200
@@ -0,0 +1,242 @@
+/*
+ *  Bus Glue for Atheros AR71xx built-in EHCI controller.
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *	Copyright (C) 2007 Atheros Communications, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/platform.h>
+
+extern int usb_disabled(void);
+
+static int ehci_ar71xx_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int ret;
+
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs +
+			HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	ehci->sbrn = 0x20;
+	ehci->has_synopsys_hc_bug = 1;
+
+	ehci_reset(ehci);
+
+	ret = ehci_init(hcd);
+	if (ret)
+		return ret;
+
+	ehci_port_power(ehci, 0);
+
+	return 0;
+}
+
+static int ehci_ar91xx_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int ret;
+
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+			HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	hcd->has_tt = 1;
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
+	ret = ehci_init(hcd);
+	if (ret)
+		return ret;
+
+	ehci_port_power(ehci, 0);
+
+	return 0;
+}
+
+static int ehci_ar71xx_probe(const struct hc_driver *driver,
+			     struct usb_hcd **hcd_out,
+			     struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct resource *res;
+	int irq;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_dbg(&pdev->dev, "no IRQ specified for %s\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_dbg(&pdev->dev, "no base address specified for %s\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start	= res->start;
+	hcd->rsrc_len	= res->end - res->start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		ret = -EBUSY;
+		goto err_put_hcd;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		ret = -EFAULT;
+		goto err_release_region;
+	}
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (ret)
+		goto err_iounmap;
+
+	return 0;
+
+err_iounmap:
+	iounmap(hcd->regs);
+
+err_release_region:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err_put_hcd:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+static void ehci_ar71xx_remove(struct usb_hcd *hcd,
+			       struct platform_device *pdev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+static const struct hc_driver ehci_ar71xx_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "Atheros AR71xx built-in EHCI controller",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	.reset			= ehci_ar71xx_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.endpoint_reset		= ehci_endpoint_reset,
+
+	.get_frame_number	= ehci_get_frame,
+
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#ifdef CONFIG_PM
+	.hub_suspend		= ehci_hub_suspend,
+	.hub_resume		= ehci_hub_resume,
+#endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+};
+
+static const struct hc_driver ehci_ar91xx_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "Atheros AR91xx built-in EHCI controller",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	.reset			= ehci_ar91xx_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.endpoint_reset		= ehci_endpoint_reset,
+
+	.get_frame_number	= ehci_get_frame,
+
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#ifdef CONFIG_PM
+	.hub_suspend		= ehci_hub_suspend,
+	.hub_resume		= ehci_hub_resume,
+#endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+};
+
+static int ehci_ar71xx_driver_probe(struct platform_device *pdev)
+{
+	struct ar71xx_ehci_platform_data *pdata;
+	struct usb_hcd *hcd = NULL;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data specified for %s\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	if (pdata->is_ar91xx)
+		ret = ehci_ar71xx_probe(&ehci_ar91xx_hc_driver, &hcd, pdev);
+	else
+		ret = ehci_ar71xx_probe(&ehci_ar71xx_hc_driver, &hcd, pdev);
+
+	return ret;
+}
+
+static int ehci_ar71xx_driver_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	ehci_ar71xx_remove(hcd, pdev);
+	return 0;
+}
+
+MODULE_ALIAS("platform:ar71xx-ehci");
+
+static struct platform_driver ehci_ar71xx_driver = {
+	.probe		= ehci_ar71xx_driver_probe,
+	.remove		= ehci_ar71xx_driver_remove,
+	.driver = {
+		.name	= "ar71xx-ehci",
+	}
+};
diff -Nur linux-2.6.39.orig/drivers/usb/host/ehci-hcd.c linux-2.6.39/drivers/usb/host/ehci-hcd.c
--- linux-2.6.39.orig/drivers/usb/host/ehci-hcd.c	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/usb/host/ehci-hcd.c	2011-08-22 16:21:42.807985568 +0200
@@ -1265,6 +1265,11 @@
 #define PLATFORM_DRIVER		tegra_ehci_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_AR71XX
+#include "ehci-ar71xx.c"
+#define PLATFORM_DRIVER		ehci_ar71xx_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)
diff -Nur linux-2.6.39.orig/drivers/usb/host/Kconfig linux-2.6.39/drivers/usb/host/Kconfig
--- linux-2.6.39.orig/drivers/usb/host/Kconfig	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/usb/host/Kconfig	2011-08-22 16:21:42.767983341 +0200
@@ -129,6 +129,13 @@
 config USB_FSL_MPH_DR_OF
 	tristate
 
+config USB_EHCI_AR71XX
+	bool "USB EHCI support for AR71xx"
+	depends on USB_EHCI_HCD && ATHEROS_AR71XX
+	default y
+	help
+	  Support for Atheros AR71xx built-in EHCI controller
+
 config USB_EHCI_FSL
 	bool "Support for Freescale on-chip EHCI USB controller"
 	depends on USB_EHCI_HCD && FSL_SOC
@@ -287,6 +294,13 @@
 	  Enables support for the on-chip OHCI controller on
 	  OMAP3 and later chips.
 
+config USB_OHCI_AR71XX
+	bool "USB OHCI support for Atheros AR71xx"
+	depends on USB_OHCI_HCD && ATHEROS_AR71XX
+	default y
+	help
+	  Support for Atheros AR71xx built-in OHCI controller
+
 config USB_OHCI_HCD_PPC_SOC
 	bool "OHCI support for on-chip PPC USB controller"
 	depends on USB_OHCI_HCD && (STB03xxx || PPC_MPC52xx)
diff -Nur linux-2.6.39.orig/drivers/usb/host/ohci-ar71xx.c linux-2.6.39/drivers/usb/host/ohci-ar71xx.c
--- linux-2.6.39.orig/drivers/usb/host/ohci-ar71xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/usb/host/ohci-ar71xx.c	2011-04-27 12:19:22.267661616 +0200
@@ -0,0 +1,165 @@
+/*
+ *  OHCI HCD (Host Controller Driver) for USB.
+ *
+ *  Bus Glue for Atheros AR71xx built-in OHCI controller.
+ *
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15 BSP
+ *	Copyright (C) 2007 Atheros Communications, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+extern int usb_disabled(void);
+
+static int usb_hcd_ar71xx_probe(const struct hc_driver *driver,
+				struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct resource *res;
+	int irq;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_dbg(&pdev->dev, "no IRQ specified for %s\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_dbg(&pdev->dev, "no base address specified for %s\n",
+			dev_name(&pdev->dev));
+		ret = -ENODEV;
+		goto err_put_hcd;
+	}
+	hcd->rsrc_start	= res->start;
+	hcd->rsrc_len	= res->end - res->start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		ret = -EBUSY;
+		goto err_put_hcd;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		ret = -EFAULT;
+		goto err_release_region;
+	}
+
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED);
+	if (ret)
+		goto err_stop_hcd;
+
+	return 0;
+
+err_stop_hcd:
+	iounmap(hcd->regs);
+err_release_region:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err_put_hcd:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+void usb_hcd_ar71xx_remove(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+static int __devinit ohci_ar71xx_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int ret;
+
+	ret = ohci_init(ohci);
+	if (ret < 0)
+		return ret;
+
+	ret = ohci_run(ohci);
+	if (ret < 0)
+		goto err;
+
+	return 0;
+
+err:
+	ohci_stop(hcd);
+	return ret;
+}
+
+static const struct hc_driver ohci_ar71xx_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "Atheros AR71xx built-in OHCI controller",
+	.hcd_priv_size		= sizeof(struct ohci_hcd),
+
+	.irq			= ohci_irq,
+	.flags			= HCD_USB11 | HCD_MEMORY,
+
+	.start			= ohci_ar71xx_start,
+	.stop			= ohci_stop,
+	.shutdown		= ohci_shutdown,
+
+	.urb_enqueue		= ohci_urb_enqueue,
+	.urb_dequeue		= ohci_urb_dequeue,
+	.endpoint_disable	= ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ohci_hub_status_data,
+	.hub_control		= ohci_hub_control,
+	.start_port_reset	= ohci_start_port_reset,
+};
+
+static int ohci_hcd_ar71xx_drv_probe(struct platform_device *pdev)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	return usb_hcd_ar71xx_probe(&ohci_ar71xx_hc_driver, pdev);
+}
+
+static int ohci_hcd_ar71xx_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_hcd_ar71xx_remove(hcd, pdev);
+	return 0;
+}
+
+MODULE_ALIAS("platform:ar71xx-ohci");
+
+static struct platform_driver ohci_hcd_ar71xx_driver = {
+	.probe		= ohci_hcd_ar71xx_drv_probe,
+	.remove		= ohci_hcd_ar71xx_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver		= {
+		.name	= "ar71xx-ohci",
+		.owner	= THIS_MODULE,
+	},
+};
diff -Nur linux-2.6.39.orig/drivers/usb/host/ohci-hcd.c linux-2.6.39/drivers/usb/host/ohci-hcd.c
--- linux-2.6.39.orig/drivers/usb/host/ohci-hcd.c	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/usb/host/ohci-hcd.c	2011-08-22 16:21:42.847983209 +0200
@@ -1105,6 +1105,11 @@
 #define PLATFORM_DRIVER		ohci_hcd_cns3xxx_driver
 #endif
 
+#ifdef CONFIG_USB_OHCI_AR71XX
+#include "ohci-ar71xx.c"
+#define PLATFORM_DRIVER		ohci_hcd_ar71xx_driver
+#endif
+
 #if	!defined(PCI_DRIVER) &&		\
 	!defined(PLATFORM_DRIVER) &&	\
 	!defined(OMAP1_PLATFORM_DRIVER) &&	\
diff -Nur linux-2.6.39.orig/drivers/watchdog/ar71xx_wdt.c linux-2.6.39/drivers/watchdog/ar71xx_wdt.c
--- linux-2.6.39.orig/drivers/watchdog/ar71xx_wdt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/drivers/watchdog/ar71xx_wdt.c	2011-08-06 09:32:37.118022037 +0200
@@ -0,0 +1,299 @@
+/*
+ * Driver for the Atheros AR71xx SoC's built-in hardware watchdog timer.
+ *
+ * Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ * Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ * Parts of this file are based on Atheros 2.6.31 BSP
+ *
+ * This driver was based on: drivers/watchdog/ixp4xx_wdt.c
+ *	Author: Deepak Saxena <dsaxena@plexity.net>
+ *	Copyright 2004 (c) MontaVista, Software, Inc.
+ *
+ * which again was based on sa1100 driver,
+ *	Copyright (C) 2000 Oleg Drokin <green@crimea.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/watchdog.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#define DRV_NAME	"ar71xx-wdt"
+#define DRV_DESC	"Atheros AR71xx hardware watchdog driver"
+#define DRV_VERSION	"0.1.0"
+
+#define WDT_TIMEOUT	15	/* seconds */
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+
+#ifdef CONFIG_WATCHDOG_NOWAYOUT
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
+			   "(default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+#endif
+
+static unsigned long wdt_flags;
+
+#define WDT_FLAGS_BUSY		0
+#define WDT_FLAGS_EXPECT_CLOSE	1
+
+static int wdt_timeout = WDT_TIMEOUT;
+static int boot_status;
+static int max_timeout;
+static u32 wdt_clk_freq;
+
+static inline void ar71xx_wdt_keepalive(void)
+{
+	ar71xx_reset_wr(AR71XX_RESET_REG_WDOG, wdt_clk_freq * wdt_timeout);
+}
+
+static inline void ar71xx_wdt_enable(void)
+{
+	printk(KERN_DEBUG DRV_NAME ": enabling watchdog timer\n");
+	ar71xx_wdt_keepalive();
+	udelay(2);
+	ar71xx_reset_wr(AR71XX_RESET_REG_WDOG_CTRL, WDOG_CTRL_ACTION_FCR);
+}
+
+static inline void ar71xx_wdt_disable(void)
+{
+	printk(KERN_DEBUG DRV_NAME ": disabling watchdog timer\n");
+	ar71xx_reset_wr(AR71XX_RESET_REG_WDOG_CTRL, WDOG_CTRL_ACTION_NONE);
+}
+
+static int ar71xx_wdt_set_timeout(int val)
+{
+	if (val < 1 || val > max_timeout)
+		return -EINVAL;
+
+	wdt_timeout = val;
+	ar71xx_wdt_keepalive();
+
+	printk(KERN_DEBUG DRV_NAME ": timeout=%d secs\n", wdt_timeout);
+
+	return 0;
+}
+
+static int ar71xx_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(WDT_FLAGS_BUSY, &wdt_flags))
+		return -EBUSY;
+
+	clear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);
+
+	ar71xx_wdt_enable();
+
+	return nonseekable_open(inode, file);
+}
+
+static int ar71xx_wdt_release(struct inode *inode, struct file *file)
+{
+	if (test_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags)) {
+		ar71xx_wdt_disable();
+	} else {
+		printk(KERN_CRIT DRV_NAME ": device closed unexpectedly, "
+					"watchdog timer will not stop!\n");
+	}
+
+	clear_bit(WDT_FLAGS_BUSY, &wdt_flags);
+	clear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);
+
+	return 0;
+}
+
+static ssize_t ar71xx_wdt_write(struct file *file, const char *data,
+				size_t len, loff_t *ppos)
+{
+	if (len) {
+		if (!nowayout) {
+			size_t i;
+
+			clear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);
+
+			for (i = 0; i != len; i++) {
+				char c;
+
+				if (get_user(c, data + i))
+					return -EFAULT;
+
+				if (c == 'V')
+					set_bit(WDT_FLAGS_EXPECT_CLOSE,
+						&wdt_flags);
+			}
+		}
+
+		ar71xx_wdt_keepalive();
+	}
+
+	return len;
+}
+
+static struct watchdog_info ar71xx_wdt_info = {
+	.options		= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |
+				  WDIOF_MAGICCLOSE | WDIOF_CARDRESET,
+	.firmware_version	= 0,
+	.identity		= "AR71XX watchdog",
+};
+
+static long ar71xx_wdt_ioctl(struct file *file,
+			    unsigned int cmd, unsigned long arg)
+{
+	int t;
+	int ret;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		ret = copy_to_user((struct watchdog_info *)arg,
+				   &ar71xx_wdt_info,
+				   sizeof(ar71xx_wdt_info)) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_GETSTATUS:
+		ret = put_user(0, (int *)arg) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_GETBOOTSTATUS:
+		ret = put_user(boot_status, (int *)arg) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_KEEPALIVE:
+		ar71xx_wdt_keepalive();
+		ret = 0;
+		break;
+
+	case WDIOC_SETTIMEOUT:
+		ret = get_user(t, (int *)arg) ? -EFAULT : 0;
+		if (ret)
+			break;
+
+		ret = ar71xx_wdt_set_timeout(t);
+		if (ret)
+			break;
+
+		/* fallthrough */
+	case WDIOC_GETTIMEOUT:
+		ret = put_user(wdt_timeout, (int *)arg) ? -EFAULT : 0;
+		break;
+
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct file_operations ar71xx_wdt_fops = {
+	.owner		= THIS_MODULE,
+	.write		= ar71xx_wdt_write,
+	.unlocked_ioctl	= ar71xx_wdt_ioctl,
+	.open		= ar71xx_wdt_open,
+	.release	= ar71xx_wdt_release,
+};
+
+static struct miscdevice ar71xx_wdt_miscdev = {
+	.minor = WATCHDOG_MINOR,
+	.name = "watchdog",
+	.fops = &ar71xx_wdt_fops,
+};
+
+static int __devinit ar71xx_wdt_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7130:
+	case AR71XX_SOC_AR7141:
+	case AR71XX_SOC_AR7161:
+	case AR71XX_SOC_AR7240:
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+	case AR71XX_SOC_AR9130:
+	case AR71XX_SOC_AR9132:
+		wdt_clk_freq = ar71xx_ahb_freq;
+		break;
+
+	case AR71XX_SOC_AR9330:
+	case AR71XX_SOC_AR9331:
+	case AR71XX_SOC_AR9341:
+	case AR71XX_SOC_AR9342:
+	case AR71XX_SOC_AR9344:
+		wdt_clk_freq = ar71xx_ref_freq;
+		break;
+
+	default:
+		BUG();
+	}
+
+	max_timeout = (0xfffffffful / wdt_clk_freq);
+	wdt_timeout = (max_timeout < WDT_TIMEOUT) ? max_timeout : WDT_TIMEOUT;
+
+	if (ar71xx_reset_rr(AR71XX_RESET_REG_WDOG_CTRL) & WDOG_CTRL_LAST_RESET)
+		boot_status = WDIOF_CARDRESET;
+
+	ret = misc_register(&ar71xx_wdt_miscdev);
+	if (ret)
+		goto err_out;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	printk(KERN_DEBUG DRV_NAME ": timeout=%d secs (max=%d)\n",
+					wdt_timeout, max_timeout);
+
+	return 0;
+
+err_out:
+	return ret;
+}
+
+static int __devexit ar71xx_wdt_remove(struct platform_device *pdev)
+{
+	misc_deregister(&ar71xx_wdt_miscdev);
+	return 0;
+}
+
+static struct platform_driver ar71xx_wdt_driver = {
+	.probe		= ar71xx_wdt_probe,
+	.remove		= __devexit_p(ar71xx_wdt_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ar71xx_wdt_init(void)
+{
+	return platform_driver_register(&ar71xx_wdt_driver);
+}
+module_init(ar71xx_wdt_init);
+
+static void __exit ar71xx_wdt_exit(void)
+{
+	platform_driver_unregister(&ar71xx_wdt_driver);
+}
+module_exit(ar71xx_wdt_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -Nur linux-2.6.39.orig/drivers/watchdog/Kconfig linux-2.6.39/drivers/watchdog/Kconfig
--- linux-2.6.39.orig/drivers/watchdog/Kconfig	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/watchdog/Kconfig	2011-08-22 16:22:00.627980889 +0200
@@ -990,6 +990,13 @@
 	  To compile this driver as a loadable module, choose M here.
 	  The module will be called bcm63xx_wdt.
 
+config AR71XX_WDT
+	tristate "Atheros AR71xx Watchdog Timer"
+	depends on ATHEROS_AR71XX
+	help
+	  Hardware driver for the built-in watchdog timer on the Atheros
+	  AR71xx SoCs.
+
 # PARISC Architecture
 
 # POWERPC Architecture
diff -Nur linux-2.6.39.orig/drivers/watchdog/Makefile linux-2.6.39/drivers/watchdog/Makefile
--- linux-2.6.39.orig/drivers/watchdog/Makefile	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/drivers/watchdog/Makefile	2011-08-22 16:22:00.647986892 +0200
@@ -119,6 +119,7 @@
 obj-$(CONFIG_WDT_MTX1) += mtx-1_wdt.o
 obj-$(CONFIG_PNX833X_WDT) += pnx833x_wdt.o
 obj-$(CONFIG_SIBYTE_WDOG) += sb_wdog.o
+obj-$(CONFIG_AR71XX_WDT) += ar71xx_wdt.o
 obj-$(CONFIG_AR7_WDT) += ar7_wdt.o
 obj-$(CONFIG_TXX9_WDT) += txx9wdt.o
 obj-$(CONFIG_OCTEON_WDT) += octeon-wdt.o
diff -Nur linux-2.6.39.orig/include/linux/ath9k_platform.h linux-2.6.39/include/linux/ath9k_platform.h
--- linux-2.6.39.orig/include/linux/ath9k_platform.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/include/linux/ath9k_platform.h	2011-08-06 09:32:36.638021723 +0200
@@ -23,6 +23,15 @@
 
 struct ath9k_platform_data {
 	u16 eeprom_data[ATH9K_PLAT_EEP_MAX_WORDS];
+	u8 *macaddr;
+
+	int led_pin;
+	u32 gpio_mask;
+	u32 gpio_val;
+
+	bool is_clk_25mhz;
+	int (*get_mac_revision)(void);
+	int (*external_reset)(void);
 };
 
 #endif /* _LINUX_ATH9K_PLATFORM_H */
diff -Nur linux-2.6.39.orig/include/linux/ip.h linux-2.6.39/include/linux/ip.h
--- linux-2.6.39.orig/include/linux/ip.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/include/linux/ip.h	2011-08-24 05:53:21.239229027 +0200
@@ -102,7 +102,7 @@
 	__be32	saddr;
 	__be32	daddr;
 	/*The options start here. */
-};
+} __packed;
 
 #ifdef __KERNEL__
 #include <linux/skbuff.h>
diff -Nur linux-2.6.39.orig/include/linux/ipv6.h linux-2.6.39/include/linux/ipv6.h
--- linux-2.6.39.orig/include/linux/ipv6.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/include/linux/ipv6.h	2011-08-24 05:53:21.289229059 +0200
@@ -126,7 +126,7 @@
 
 	struct	in6_addr	saddr;
 	struct	in6_addr	daddr;
-};
+} __packed;
 
 #ifdef __KERNEL__
 /*
diff -Nur linux-2.6.39.orig/include/linux/myloader.h linux-2.6.39/include/linux/myloader.h
--- linux-2.6.39.orig/include/linux/myloader.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/include/linux/myloader.h	2011-08-24 03:12:08.307985040 +0200
@@ -0,0 +1,120 @@
+/*
+ *  Compex's MyLoader specific definitions
+ *
+ *  Copyright (C) 2006-2008 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef _MYLOADER_H_
+#define _MYLOADER_H_
+
+/* Myloader specific magic numbers */
+#define MYLO_MAGIC_SYS_PARAMS	0x20021107
+#define MYLO_MAGIC_PARTITIONS	0x20021103
+#define MYLO_MAGIC_BOARD_PARAMS	0x20021103
+
+/* Vendor ID's (seems to be same as the PCI vendor ID's) */
+#define VENID_COMPEX		0x11F6
+
+/* Devices based on the ADM5120 */
+#define DEVID_COMPEX_NP27G	0x0078
+#define DEVID_COMPEX_NP28G	0x044C
+#define DEVID_COMPEX_NP28GHS	0x044E
+#define DEVID_COMPEX_WP54Gv1C	0x0514
+#define DEVID_COMPEX_WP54G	0x0515
+#define DEVID_COMPEX_WP54AG	0x0546
+#define DEVID_COMPEX_WPP54AG	0x0550
+#define DEVID_COMPEX_WPP54G	0x0555
+
+/* Devices based on the Atheros AR2317 */
+#define DEVID_COMPEX_NP25G	0x05E6
+#define DEVID_COMPEX_WPE53G	0x05DC
+
+/* Devices based on the Atheros AR71xx */
+#define DEVID_COMPEX_WP543	0x0640
+
+/* Devices based on the IXP422 */
+#define DEVID_COMPEX_WP18	0x047E
+#define DEVID_COMPEX_NP18A	0x0489
+
+/* Other devices */
+#define DEVID_COMPEX_NP26G8M	0x03E8
+#define DEVID_COMPEX_NP26G16M	0x03E9
+
+struct mylo_partition {
+	uint16_t	flags;	/* partition flags */
+	uint16_t	type;	/* type of the partition */
+	uint32_t	addr;	/* relative address of the partition from the
+				   flash start */
+	uint32_t	size;	/* size of the partition in bytes */
+	uint32_t	param;	/* if this is the active partition, the
+				   MyLoader load code to this address */
+};
+
+#define PARTITION_FLAG_ACTIVE	0x8000 /* this is the active partition,
+					* MyLoader loads firmware from here */
+#define PARTITION_FLAG_ISRAM	0x2000 /* FIXME: this is a RAM partition? */
+#define PARTIIION_FLAG_RAMLOAD	0x1000 /* FIXME: load this partition into the RAM? */
+#define PARTITION_FLAG_PRELOAD	0x0800 /* the partition data preloaded to RAM
+					* before decompression */
+#define PARTITION_FLAG_LZMA	0x0100 /* partition data compressed by LZMA */
+#define PARTITION_FLAG_HAVEHDR  0x0002 /* the partition data have a header */
+
+#define PARTITION_TYPE_FREE	0
+#define PARTITION_TYPE_USED	1
+
+#define MYLO_MAX_PARTITIONS	8	/* maximum number of partitions in the
+					   partition table */
+
+struct mylo_partition_table {
+	uint32_t	magic;		/* must be MYLO_MAGIC_PARTITIONS */
+	uint32_t	res0;		/* unknown/unused */
+	uint32_t	res1;		/* unknown/unused */
+	uint32_t 	res2;		/* unknown/unused */
+	struct mylo_partition partitions[MYLO_MAX_PARTITIONS];
+};
+
+struct mylo_partition_header {
+	uint32_t	len;		/* length of the partition data */
+	uint32_t	crc;		/* CRC value of the partition data */
+};
+
+struct mylo_system_params {
+	uint32_t	magic;		/* must be MYLO_MAGIC_SYS_PARAMS */
+	uint32_t	res0;
+	uint32_t	res1;
+	uint32_t	mylo_ver;
+	uint16_t	vid;		/* Vendor ID */
+	uint16_t	did;		/* Device ID */
+	uint16_t	svid;		/* Sub Vendor ID */
+	uint16_t	sdid;		/* Sub Device ID */
+	uint32_t	rev;		/* device revision */
+	uint32_t	fwhi;
+	uint32_t	fwlo;
+	uint32_t	tftp_addr;
+	uint32_t	prog_start;
+	uint32_t	flash_size;	/* size of boot FLASH in bytes */
+	uint32_t	dram_size;	/* size of onboard RAM in bytes */
+};
+
+struct mylo_eth_addr {
+	uint8_t	mac[6];
+	uint8_t	csum[2];
+};
+
+#define MYLO_ETHADDR_COUNT	8	/* maximum number of ethernet address
+					   in the board parameters */
+
+struct mylo_board_params {
+	uint32_t	magic;	/* must be MYLO_MAGIC_BOARD_PARAMS */
+	uint32_t	res0;
+	uint32_t	res1;
+	uint32_t	res2;
+	struct mylo_eth_addr addr[MYLO_ETHADDR_COUNT];
+};
+
+#endif /* _MYLOADER_H_*/
diff -Nur linux-2.6.39.orig/include/linux/netdevice.h linux-2.6.39/include/linux/netdevice.h
--- linux-2.6.39.orig/include/linux/netdevice.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/include/linux/netdevice.h	2011-08-22 22:00:06.937981400 +0200
@@ -1182,6 +1182,7 @@
 	void			*ax25_ptr;	/* AX.25 specific data */
 	struct wireless_dev	*ieee80211_ptr;	/* IEEE 802.11 specific data,
 						   assign before registering */
+	void			*phy_ptr; /* PHY device specific data */
 
 /*
  * Cache lines mostly used on receive path (including eth_type_trans())
diff -Nur linux-2.6.39.orig/include/linux/nxp_74hc153.h linux-2.6.39/include/linux/nxp_74hc153.h
--- linux-2.6.39.orig/include/linux/nxp_74hc153.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/include/linux/nxp_74hc153.h	2011-04-27 12:19:21.817661653 +0200
@@ -0,0 +1,24 @@
+/*
+ *  NXP 74HC153 - Dual 4-input multiplexer defines
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _NXP_74HC153_H
+#define _NXP_74HC153_H
+
+#define NXP_74HC153_DRIVER_NAME "nxp-74hc153"
+
+struct nxp_74hc153_platform_data {
+	unsigned	gpio_base;
+	unsigned	gpio_pin_s0;
+	unsigned	gpio_pin_s1;
+	unsigned	gpio_pin_1y;
+	unsigned	gpio_pin_2y;
+};
+
+#endif /* _NXP_74HC153_H */
diff -Nur linux-2.6.39.orig/include/linux/phy.h linux-2.6.39/include/linux/phy.h
--- linux-2.6.39.orig/include/linux/phy.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/include/linux/phy.h	2011-08-22 22:00:06.867980866 +0200
@@ -332,6 +332,20 @@
 	void (*adjust_link)(struct net_device *dev);
 
 	void (*adjust_state)(struct net_device *dev);
+
+	/*
+	 * By default these point to the original functions
+	 * with the same name. adding them to the phy_device
+	 * allows the phy driver to override them for packet
+	 * mangling if the ethernet driver supports it
+	 * This is required to support some really horrible
+	 * switches such as the Marvell 88E6060
+	 */
+	int (*netif_receive_skb)(struct sk_buff *skb);
+	int (*netif_rx)(struct sk_buff *skb);
+
+	/* alignment offset for packets */
+	int pkt_align;
 };
 #define to_phy_device(d) container_of(d, struct phy_device, dev)
 
@@ -508,6 +522,7 @@
 void phy_stop_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr);
 int phy_mii_ioctl(struct phy_device *phydev,
 		struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
diff -Nur linux-2.6.39.orig/include/linux/spi/spi.h linux-2.6.39/include/linux/spi/spi.h
--- linux-2.6.39.orig/include/linux/spi/spi.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/include/linux/spi/spi.h	2011-08-23 15:10:37.559229523 +0200
@@ -441,6 +441,8 @@
 	dma_addr_t	rx_dma;
 
 	unsigned	cs_change:1;
+	unsigned	verify:1;
+	unsigned	fast_write:1;
 	u8		bits_per_word;
 	u16		delay_usecs;
 	u32		speed_hz;
@@ -482,6 +484,7 @@
 	struct spi_device	*spi;
 
 	unsigned		is_dma_mapped:1;
+	unsigned		fast_read:1;
 
 	/* REVISIT:  we might want a flag affecting the behavior of the
 	 * last transfer ... allowing things like "read 16 bit length L"
diff -Nur linux-2.6.39.orig/include/linux/spi/vsc7385.h linux-2.6.39/include/linux/spi/vsc7385.h
--- linux-2.6.39.orig/include/linux/spi/vsc7385.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/include/linux/spi/vsc7385.h	2011-04-27 12:19:21.817661653 +0200
@@ -0,0 +1,19 @@
+/*
+ * Platform data definition for the Vitesse VSC7385 ethernet switch driver
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+struct vsc7385_platform_data {
+	void		(*reset)(void);
+	char		*ucode_name;
+	struct {
+		u32	tx_ipg:5;
+		u32	bit2:1;
+		u32	clk_sel:3;
+	} mac_cfg;
+};
diff -Nur linux-2.6.39.orig/include/linux/switch.h linux-2.6.39/include/linux/switch.h
--- linux-2.6.39.orig/include/linux/switch.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/include/linux/switch.h	2011-08-22 22:09:59.799231408 +0200
@@ -0,0 +1,204 @@
+/*
+ * switch.h: Switch configuration API
+ *
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_SWITCH_H
+#define __LINUX_SWITCH_H
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/netlink.h>
+#include <linux/genetlink.h>
+#ifndef __KERNEL__
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+#else
+#include <net/genetlink.h>
+#endif
+
+/* main attributes */
+enum {
+	SWITCH_ATTR_UNSPEC,
+	/* global */
+	SWITCH_ATTR_TYPE,
+	/* device */
+	SWITCH_ATTR_ID,
+	SWITCH_ATTR_DEV_NAME,
+	SWITCH_ATTR_ALIAS,
+	SWITCH_ATTR_NAME,
+	SWITCH_ATTR_VLANS,
+	SWITCH_ATTR_PORTS,
+	SWITCH_ATTR_CPU_PORT,
+	/* attributes */
+	SWITCH_ATTR_OP_ID,
+	SWITCH_ATTR_OP_TYPE,
+	SWITCH_ATTR_OP_NAME,
+	SWITCH_ATTR_OP_PORT,
+	SWITCH_ATTR_OP_VLAN,
+	SWITCH_ATTR_OP_VALUE_INT,
+	SWITCH_ATTR_OP_VALUE_STR,
+	SWITCH_ATTR_OP_VALUE_PORTS,
+	SWITCH_ATTR_OP_DESCRIPTION,
+	/* port lists */
+	SWITCH_ATTR_PORT,
+	SWITCH_ATTR_MAX
+};
+
+/* commands */
+enum {
+	SWITCH_CMD_UNSPEC,
+	SWITCH_CMD_GET_SWITCH,
+	SWITCH_CMD_NEW_ATTR,
+	SWITCH_CMD_LIST_GLOBAL,
+	SWITCH_CMD_GET_GLOBAL,
+	SWITCH_CMD_SET_GLOBAL,
+	SWITCH_CMD_LIST_PORT,
+	SWITCH_CMD_GET_PORT,
+	SWITCH_CMD_SET_PORT,
+	SWITCH_CMD_LIST_VLAN,
+	SWITCH_CMD_GET_VLAN,
+	SWITCH_CMD_SET_VLAN
+};
+
+/* data types */
+enum switch_val_type {
+	SWITCH_TYPE_UNSPEC,
+	SWITCH_TYPE_INT,
+	SWITCH_TYPE_STRING,
+	SWITCH_TYPE_PORTS,
+	SWITCH_TYPE_NOVAL,
+};
+
+/* port nested attributes */
+enum {
+	SWITCH_PORT_UNSPEC,
+	SWITCH_PORT_ID,
+	SWITCH_PORT_FLAG_TAGGED,
+	SWITCH_PORT_ATTR_MAX
+};
+
+#define SWITCH_ATTR_DEFAULTS_OFFSET	0x1000
+
+#ifdef __KERNEL__
+
+struct switch_dev;
+struct switch_op;
+struct switch_val;
+struct switch_attr;
+struct switch_attrlist;
+
+int register_switch(struct switch_dev *dev, struct net_device *netdev);
+void unregister_switch(struct switch_dev *dev);
+
+/**
+ * struct switch_attrlist - attribute list
+ *
+ * @n_attr: number of attributes
+ * @attr: pointer to the attributes array
+ */
+struct switch_attrlist {
+	int n_attr;
+	const struct switch_attr *attr;
+};
+
+/**
+ * struct switch_dev_ops - switch driver operations
+ *
+ * @attr_global: global switch attribute list
+ * @attr_port: port attribute list
+ * @attr_vlan: vlan attribute list
+ *
+ * Callbacks:
+ *
+ * @get_vlan_ports: read the port list of a VLAN
+ * @set_vlan_ports: set the port list of a VLAN
+ *
+ * @get_port_pvid: get the primary VLAN ID of a port
+ * @set_port_pvid: set the primary VLAN ID of a port
+ *
+ * @apply_config: apply all changed settings to the switch
+ * @reset_switch: resetting the switch
+ */
+struct switch_dev_ops {
+	struct switch_attrlist attr_global, attr_port, attr_vlan;
+
+	int (*get_vlan_ports)(struct switch_dev *dev, struct switch_val *val);
+	int (*set_vlan_ports)(struct switch_dev *dev, struct switch_val *val);
+
+	int (*get_port_pvid)(struct switch_dev *dev, int port, int *val);
+	int (*set_port_pvid)(struct switch_dev *dev, int port, int val);
+
+	int (*apply_config)(struct switch_dev *dev);
+	int (*reset_switch)(struct switch_dev *dev);
+};
+
+struct switch_dev {
+	const struct switch_dev_ops *ops;
+	/* will be automatically filled */
+	char devname[IFNAMSIZ];
+
+	const char *name;
+	/* NB: either alias or netdev must be set */
+	const char *alias;
+	struct net_device *netdev;
+
+	int ports;
+	int vlans;
+	int cpu_port;
+
+	/* the following fields are internal for swconfig */
+	int id;
+	struct list_head dev_list;
+	unsigned long def_global, def_port, def_vlan;
+
+	spinlock_t lock;
+	struct switch_port *portbuf;
+};
+
+struct switch_port {
+	u32 id;
+	u32 flags;
+};
+
+struct switch_val {
+	const struct switch_attr *attr;
+	int port_vlan;
+	int len;
+	union {
+		const char *s;
+		u32 i;
+		struct switch_port *ports;
+	} value;
+};
+
+struct switch_attr {
+	int disabled;
+	int type;
+	const char *name;
+	const char *description;
+
+	int (*set)(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val);
+	int (*get)(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val);
+
+	/* for driver internal use */
+	int id;
+	int ofs;
+	int max;
+};
+
+#endif
+
+#endif
diff -Nur linux-2.6.39.orig/include/linux/tcp.h linux-2.6.39/include/linux/tcp.h
--- linux-2.6.39.orig/include/linux/tcp.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/include/linux/tcp.h	2011-08-24 05:53:21.379228748 +0200
@@ -54,7 +54,7 @@
 	__be16	window;
 	__sum16	check;
 	__be16	urg_ptr;
-};
+} __packed;
 
 /*
  *	The union cast uses a gcc extension to avoid aliasing problems
diff -Nur linux-2.6.39.orig/include/linux/udp.h linux-2.6.39/include/linux/udp.h
--- linux-2.6.39.orig/include/linux/udp.h	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/include/linux/udp.h	2011-08-24 05:53:21.428824967 +0200
@@ -24,7 +24,7 @@
 	__be16	dest;
 	__be16	len;
 	__sum16	check;
-};
+} __packed;
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
diff -Nur linux-2.6.39.orig/net/dsa/mv88e6063.c linux-2.6.39/net/dsa/mv88e6063.c
--- linux-2.6.39.orig/net/dsa/mv88e6063.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39/net/dsa/mv88e6063.c	2011-04-27 12:19:21.827661792 +0200
@@ -0,0 +1,294 @@
+/*
+ * net/dsa/mv88e6063.c - Driver for Marvell 88e6063 switch chips
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This driver was base on: net/dsa/mv88e6060.c
+ *   net/dsa/mv88e6063.c - Driver for Marvell 88e6060 switch chips
+ *   Copyright (c) 2008-2009 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include "dsa_priv.h"
+
+#define REG_BASE		0x10
+#define REG_PHY(p)		(REG_BASE + (p))
+#define REG_PORT(p)		(REG_BASE + 8 + (p))
+#define REG_GLOBAL		(REG_BASE + 0x0f)
+#define NUM_PORTS		7
+
+static int reg_read(struct dsa_switch *ds, int addr, int reg)
+{
+	return mdiobus_read(ds->master_mii_bus, addr, reg);
+}
+
+#define REG_READ(addr, reg)					\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_read(ds, addr, reg);		\
+		if (__ret < 0)					\
+			return __ret;				\
+		__ret;						\
+	})
+
+
+static int reg_write(struct dsa_switch *ds, int addr, int reg, u16 val)
+{
+	return mdiobus_write(ds->master_mii_bus, addr, reg, val);
+}
+
+#define REG_WRITE(addr, reg, val)				\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_write(ds, addr, reg, val);		\
+		if (__ret < 0)					\
+			return __ret;				\
+	})
+
+static char *mv88e6063_probe(struct mii_bus *bus, int sw_addr)
+{
+	int ret;
+
+	ret = mdiobus_read(bus, REG_PORT(0), 0x03);
+	if (ret >= 0) {
+		ret &= 0xfff0;
+		if (ret == 0x1530)
+			return "Marvell 88E6063";
+	}
+
+	return NULL;
+}
+
+static int mv88e6063_switch_reset(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	/*
+	 * Set all ports to the disabled state.
+	 */
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = REG_READ(REG_PORT(i), 0x04);
+		REG_WRITE(REG_PORT(i), 0x04, ret & 0xfffc);
+	}
+
+	/*
+	 * Wait for transmit queues to drain.
+	 */
+	msleep(2);
+
+	/*
+	 * Reset the switch.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0xa130);
+
+	/*
+	 * Wait up to one second for reset to complete.
+	 */
+	for (i = 0; i < 1000; i++) {
+		ret = REG_READ(REG_GLOBAL, 0x00);
+		if ((ret & 0x8000) == 0x0000)
+			break;
+
+		msleep(1);
+	}
+	if (i == 1000)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int mv88e6063_setup_global(struct dsa_switch *ds)
+{
+	/*
+	 * Disable discarding of frames with excessive collisions,
+	 * set the maximum frame size to 1536 bytes, and mask all
+	 * interrupt sources.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x04, 0x0800);
+
+	/*
+	 * Enable automatic address learning, set the address
+	 * database size to 1024 entries, and set the default aging
+	 * time to 5 minutes.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0x2130);
+
+	return 0;
+}
+
+static int mv88e6063_setup_port(struct dsa_switch *ds, int p)
+{
+	int addr = REG_PORT(p);
+
+	/*
+	 * Do not force flow control, disable Ingress and Egress
+	 * Header tagging, disable VLAN tunneling, and set the port
+	 * state to Forwarding.  Additionally, if this is the CPU
+	 * port, enable Ingress and Egress Trailer tagging mode.
+	 */
+	REG_WRITE(addr, 0x04, dsa_is_cpu_port(ds, p) ?  0x4103 : 0x0003);
+
+	/*
+	 * Port based VLAN map: give each port its own address
+	 * database, allow the CPU port to talk to each of the 'real'
+	 * ports, and allow each of the 'real' ports to only talk to
+	 * the CPU port.
+	 */
+	REG_WRITE(addr, 0x06,
+			((p & 0xf) << 12) |
+			 (dsa_is_cpu_port(ds, p) ?
+				ds->phys_port_mask :
+				(1 << ds->dst->cpu_port)));
+
+	/*
+	 * Port Association Vector: when learning source addresses
+	 * of packets, add the address to the address database using
+	 * a port bitmap that has only the bit for this port set and
+	 * the other bits clear.
+	 */
+	REG_WRITE(addr, 0x0b, 1 << p);
+
+	return 0;
+}
+
+static int mv88e6063_setup(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	ret = mv88e6063_switch_reset(ds);
+	if (ret < 0)
+		return ret;
+
+	/* @@@ initialise atu */
+
+	ret = mv88e6063_setup_global(ds);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = mv88e6063_setup_port(ds, i);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mv88e6063_set_addr(struct dsa_switch *ds, u8 *addr)
+{
+	REG_WRITE(REG_GLOBAL, 0x01, (addr[0] << 8) | addr[1]);
+	REG_WRITE(REG_GLOBAL, 0x02, (addr[2] << 8) | addr[3]);
+	REG_WRITE(REG_GLOBAL, 0x03, (addr[4] << 8) | addr[5]);
+
+	return 0;
+}
+
+static int mv88e6063_port_to_phy_addr(int port)
+{
+	if (port >= 0 && port <= NUM_PORTS)
+		return REG_PHY(port);
+	return -1;
+}
+
+static int mv88e6063_phy_read(struct dsa_switch *ds, int port, int regnum)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_read(ds, addr, regnum);
+}
+
+static int
+mv88e6063_phy_write(struct dsa_switch *ds, int port, int regnum, u16 val)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_write(ds, addr, regnum, val);
+}
+
+static void mv88e6063_poll_link(struct dsa_switch *ds)
+{
+	int i;
+
+	for (i = 0; i < DSA_MAX_PORTS; i++) {
+		struct net_device *dev;
+		int uninitialized_var(port_status);
+		int link;
+		int speed;
+		int duplex;
+		int fc;
+
+		dev = ds->ports[i];
+		if (dev == NULL)
+			continue;
+
+		link = 0;
+		if (dev->flags & IFF_UP) {
+			port_status = reg_read(ds, REG_PORT(i), 0x00);
+			if (port_status < 0)
+				continue;
+
+			link = !!(port_status & 0x1000);
+		}
+
+		if (!link) {
+			if (netif_carrier_ok(dev)) {
+				printk(KERN_INFO "%s: link down\n", dev->name);
+				netif_carrier_off(dev);
+			}
+			continue;
+		}
+
+		speed = (port_status & 0x0100) ? 100 : 10;
+		duplex = (port_status & 0x0200) ? 1 : 0;
+		fc = ((port_status & 0xc000) == 0xc000) ? 1 : 0;
+
+		if (!netif_carrier_ok(dev)) {
+			printk(KERN_INFO "%s: link up, %d Mb/s, %s duplex, "
+					 "flow control %sabled\n", dev->name,
+					 speed, duplex ? "full" : "half",
+					 fc ? "en" : "dis");
+			netif_carrier_on(dev);
+		}
+	}
+}
+
+static struct dsa_switch_driver mv88e6063_switch_driver = {
+	.tag_protocol	= htons(ETH_P_TRAILER),
+	.probe		= mv88e6063_probe,
+	.setup		= mv88e6063_setup,
+	.set_addr	= mv88e6063_set_addr,
+	.phy_read	= mv88e6063_phy_read,
+	.phy_write	= mv88e6063_phy_write,
+	.poll_link	= mv88e6063_poll_link,
+};
+
+static int __init mv88e6063_init(void)
+{
+	register_switch_driver(&mv88e6063_switch_driver);
+	return 0;
+}
+module_init(mv88e6063_init);
+
+static void __exit mv88e6063_cleanup(void)
+{
+	unregister_switch_driver(&mv88e6063_switch_driver);
+}
+module_exit(mv88e6063_cleanup);
diff -Nur linux-2.6.39.orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c linux-2.6.39/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
--- linux-2.6.39.orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2011-05-19 06:06:34.000000000 +0200
+++ linux-2.6.39/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2011-08-24 05:53:21.549229118 +0200
@@ -14,6 +14,7 @@
 #include <linux/skbuff.h>
 #include <linux/icmp.h>
 #include <linux/sysctl.h>
+#include <linux/unaligned/packed_struct.h>
 #include <net/route.h>
 #include <net/ip.h>
 
@@ -44,8 +45,8 @@
 	if (ap == NULL)
 		return false;
 
-	tuple->src.u3.ip = ap[0];
-	tuple->dst.u3.ip = ap[1];
+	tuple->src.u3.ip = __get_unaligned_cpu32(ap++);
+	tuple->dst.u3.ip = __get_unaligned_cpu32(ap);
 
 	return true;
 }
