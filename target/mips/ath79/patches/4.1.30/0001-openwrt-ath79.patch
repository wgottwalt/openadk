diff -Nur linux-4.1.13.orig/arch/mips/ath79/clock.c linux-4.1.13/arch/mips/ath79/clock.c
--- linux-4.1.13.orig/arch/mips/ath79/clock.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/clock.c	2015-12-04 19:57:05.422010155 +0100
@@ -25,7 +25,7 @@
 #include "common.h"
 
 #define AR71XX_BASE_FREQ	40000000
-#define AR724X_BASE_FREQ	5000000
+#define AR724X_BASE_FREQ	40000000
 #define AR913X_BASE_FREQ	5000000
 
 struct clk {
@@ -99,8 +99,8 @@
 	div = ((pll >> AR724X_PLL_DIV_SHIFT) & AR724X_PLL_DIV_MASK);
 	freq = div * ref_rate;
 
-	div = ((pll >> AR724X_PLL_REF_DIV_SHIFT) & AR724X_PLL_REF_DIV_MASK);
-	freq *= div;
+	div = ((pll >> AR724X_PLL_REF_DIV_SHIFT) & AR724X_PLL_REF_DIV_MASK) * 2;
+	freq /= div;
 
 	cpu_rate = freq;
 
@@ -350,6 +350,91 @@
 	iounmap(dpll_base);
 }
 
+static void __init qca953x_clocks_init(void)
+{
+	unsigned long ref_rate;
+	unsigned long cpu_rate;
+	unsigned long ddr_rate;
+	unsigned long ahb_rate;
+	u32 pll, out_div, ref_div, nint, frac, clk_ctrl, postdiv;
+	u32 cpu_pll, ddr_pll;
+	u32 bootstrap;
+
+	bootstrap = ath79_reset_rr(QCA953X_RESET_REG_BOOTSTRAP);
+	if (bootstrap &	QCA953X_BOOTSTRAP_REF_CLK_40)
+		ref_rate = 40 * 1000 * 1000;
+	else
+		ref_rate = 25 * 1000 * 1000;
+
+	pll = ath79_pll_rr(QCA953X_PLL_CPU_CONFIG_REG);
+	out_div = (pll >> QCA953X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+		  QCA953X_PLL_CPU_CONFIG_OUTDIV_MASK;
+	ref_div = (pll >> QCA953X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
+		  QCA953X_PLL_CPU_CONFIG_REFDIV_MASK;
+	nint = (pll >> QCA953X_PLL_CPU_CONFIG_NINT_SHIFT) &
+	       QCA953X_PLL_CPU_CONFIG_NINT_MASK;
+	frac = (pll >> QCA953X_PLL_CPU_CONFIG_NFRAC_SHIFT) &
+	       QCA953X_PLL_CPU_CONFIG_NFRAC_MASK;
+
+	cpu_pll = nint * ref_rate / ref_div;
+	cpu_pll += frac * (ref_rate >> 6) / ref_div;
+	cpu_pll /= (1 << out_div);
+
+	pll = ath79_pll_rr(QCA953X_PLL_DDR_CONFIG_REG);
+	out_div = (pll >> QCA953X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
+		  QCA953X_PLL_DDR_CONFIG_OUTDIV_MASK;
+	ref_div = (pll >> QCA953X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
+		  QCA953X_PLL_DDR_CONFIG_REFDIV_MASK;
+	nint = (pll >> QCA953X_PLL_DDR_CONFIG_NINT_SHIFT) &
+	       QCA953X_PLL_DDR_CONFIG_NINT_MASK;
+	frac = (pll >> QCA953X_PLL_DDR_CONFIG_NFRAC_SHIFT) &
+	       QCA953X_PLL_DDR_CONFIG_NFRAC_MASK;
+
+	ddr_pll = nint * ref_rate / ref_div;
+	ddr_pll += frac * (ref_rate >> 6) / (ref_div << 4);
+	ddr_pll /= (1 << out_div);
+
+	clk_ctrl = ath79_pll_rr(QCA953X_PLL_CLK_CTRL_REG);
+
+	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT) &
+		  QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_MASK;
+
+	if (clk_ctrl & QCA953X_PLL_CLK_CTRL_CPU_PLL_BYPASS)
+		cpu_rate = ref_rate;
+	else if (clk_ctrl & QCA953X_PLL_CLK_CTRL_CPUCLK_FROM_CPUPLL)
+		cpu_rate = cpu_pll / (postdiv + 1);
+	else
+		cpu_rate = ddr_pll / (postdiv + 1);
+
+	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT) &
+		  QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_MASK;
+
+	if (clk_ctrl & QCA953X_PLL_CLK_CTRL_DDR_PLL_BYPASS)
+		ddr_rate = ref_rate;
+	else if (clk_ctrl & QCA953X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL)
+		ddr_rate = ddr_pll / (postdiv + 1);
+	else
+		ddr_rate = cpu_pll / (postdiv + 1);
+
+	postdiv = (clk_ctrl >> QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT) &
+		  QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_MASK;
+
+	if (clk_ctrl & QCA953X_PLL_CLK_CTRL_AHB_PLL_BYPASS)
+		ahb_rate = ref_rate;
+	else if (clk_ctrl & QCA953X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL)
+		ahb_rate = ddr_pll / (postdiv + 1);
+	else
+		ahb_rate = cpu_pll / (postdiv + 1);
+
+	ath79_add_sys_clkdev("ref", ref_rate);
+	ath79_add_sys_clkdev("cpu", cpu_rate);
+	ath79_add_sys_clkdev("ddr", ddr_rate);
+	ath79_add_sys_clkdev("ahb", ahb_rate);
+
+	clk_add_alias("wdt", NULL, "ref", NULL);
+	clk_add_alias("uart", NULL, "ref", NULL);
+}
+
 static void __init qca955x_clocks_init(void)
 {
 	unsigned long ref_rate;
@@ -435,6 +520,100 @@
 	clk_add_alias("uart", NULL, "ref", NULL);
 }
 
+static void __init qca956x_clocks_init(void)
+{
+	unsigned long ref_rate;
+	unsigned long cpu_rate;
+	unsigned long ddr_rate;
+	unsigned long ahb_rate;
+	u32 pll, out_div, ref_div, nint, hfrac, lfrac, clk_ctrl, postdiv;
+	u32 cpu_pll, ddr_pll;
+	u32 bootstrap;
+
+	bootstrap = ath79_reset_rr(QCA956X_RESET_REG_BOOTSTRAP);
+	if (bootstrap &	QCA956X_BOOTSTRAP_REF_CLK_40)
+		ref_rate = 40 * 1000 * 1000;
+	else
+		ref_rate = 25 * 1000 * 1000;
+
+	pll = ath79_pll_rr(QCA956X_PLL_CPU_CONFIG_REG);
+	out_div = (pll >> QCA956X_PLL_CPU_CONFIG_OUTDIV_SHIFT) &
+		  QCA956X_PLL_CPU_CONFIG_OUTDIV_MASK;
+	ref_div = (pll >> QCA956X_PLL_CPU_CONFIG_REFDIV_SHIFT) &
+		  QCA956X_PLL_CPU_CONFIG_REFDIV_MASK;
+
+	pll = ath79_pll_rr(QCA956X_PLL_CPU_CONFIG1_REG);
+	nint = (pll >> QCA956X_PLL_CPU_CONFIG1_NINT_SHIFT) &
+	       QCA956X_PLL_CPU_CONFIG1_NINT_MASK;
+	hfrac = (pll >> QCA956X_PLL_CPU_CONFIG1_NFRAC_H_SHIFT) &
+	       QCA956X_PLL_CPU_CONFIG1_NFRAC_H_MASK;
+	lfrac = (pll >> QCA956X_PLL_CPU_CONFIG1_NFRAC_L_SHIFT) &
+	       QCA956X_PLL_CPU_CONFIG1_NFRAC_L_MASK;
+
+	cpu_pll = nint * ref_rate / ref_div;
+	cpu_pll += (lfrac * ref_rate) / ((ref_div * 25) << 13);
+	cpu_pll += (hfrac >> 13) * ref_rate / ref_div;
+	cpu_pll /= (1 << out_div);
+
+	pll = ath79_pll_rr(QCA956X_PLL_DDR_CONFIG_REG);
+	out_div = (pll >> QCA956X_PLL_DDR_CONFIG_OUTDIV_SHIFT) &
+		  QCA956X_PLL_DDR_CONFIG_OUTDIV_MASK;
+	ref_div = (pll >> QCA956X_PLL_DDR_CONFIG_REFDIV_SHIFT) &
+		  QCA956X_PLL_DDR_CONFIG_REFDIV_MASK;
+	pll = ath79_pll_rr(QCA956X_PLL_DDR_CONFIG1_REG);
+	nint = (pll >> QCA956X_PLL_DDR_CONFIG1_NINT_SHIFT) &
+	       QCA956X_PLL_DDR_CONFIG1_NINT_MASK;
+	hfrac = (pll >> QCA956X_PLL_DDR_CONFIG1_NFRAC_H_SHIFT) &
+	       QCA956X_PLL_DDR_CONFIG1_NFRAC_H_MASK;
+	lfrac = (pll >> QCA956X_PLL_DDR_CONFIG1_NFRAC_L_SHIFT) &
+	       QCA956X_PLL_DDR_CONFIG1_NFRAC_L_MASK;
+
+	ddr_pll = nint * ref_rate / ref_div;
+	ddr_pll += (lfrac * ref_rate) / ((ref_div * 25) << 13);
+	ddr_pll += (hfrac >> 13) * ref_rate / ref_div;
+	ddr_pll /= (1 << out_div);
+
+	clk_ctrl = ath79_pll_rr(QCA956X_PLL_CLK_CTRL_REG);
+
+	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT) &
+		  QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_MASK;
+
+	if (clk_ctrl & QCA956X_PLL_CLK_CTRL_CPU_PLL_BYPASS)
+		cpu_rate = ref_rate;
+	else if (clk_ctrl & QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_CPUPLL)
+		cpu_rate = ddr_pll / (postdiv + 1);
+	else
+		cpu_rate = cpu_pll / (postdiv + 1);
+
+	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT) &
+		  QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_MASK;
+
+	if (clk_ctrl & QCA956X_PLL_CLK_CTRL_DDR_PLL_BYPASS)
+		ddr_rate = ref_rate;
+	else if (clk_ctrl & QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_DDRPLL)
+		ddr_rate = cpu_pll / (postdiv + 1);
+	else
+		ddr_rate = ddr_pll / (postdiv + 1);
+
+	postdiv = (clk_ctrl >> QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT) &
+		  QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_MASK;
+
+	if (clk_ctrl & QCA956X_PLL_CLK_CTRL_AHB_PLL_BYPASS)
+		ahb_rate = ref_rate;
+	else if (clk_ctrl & QCA956X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL)
+		ahb_rate = ddr_pll / (postdiv + 1);
+	else
+		ahb_rate = cpu_pll / (postdiv + 1);
+
+	ath79_add_sys_clkdev("ref", ref_rate);
+	ath79_add_sys_clkdev("cpu", cpu_rate);
+	ath79_add_sys_clkdev("ddr", ddr_rate);
+	ath79_add_sys_clkdev("ahb", ahb_rate);
+
+	clk_add_alias("wdt", NULL, "ref", NULL);
+	clk_add_alias("uart", NULL, "ref", NULL);
+}
+
 void __init ath79_clocks_init(void)
 {
 	if (soc_is_ar71xx())
@@ -447,8 +626,12 @@
 		ar933x_clocks_init();
 	else if (soc_is_ar934x())
 		ar934x_clocks_init();
+	else if (soc_is_qca953x())
+		qca953x_clocks_init();
 	else if (soc_is_qca955x())
 		qca955x_clocks_init();
+	else if (soc_is_qca956x())
+		qca956x_clocks_init();
 	else
 		BUG();
 }
@@ -488,3 +671,15 @@
 	return clk->rate;
 }
 EXPORT_SYMBOL(clk_get_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(clk_set_rate);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(clk_round_rate);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/common.c linux-4.1.13/arch/mips/ath79/common.c
--- linux-4.1.13.orig/arch/mips/ath79/common.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/common.c	2015-12-04 19:57:04.474072175 +0100
@@ -22,6 +22,7 @@
 #include "common.h"
 
 static DEFINE_SPINLOCK(ath79_device_reset_lock);
+static DEFINE_MUTEX(ath79_flash_mutex);
 
 u32 ath79_cpu_freq;
 EXPORT_SYMBOL_GPL(ath79_cpu_freq);
@@ -72,10 +73,14 @@
 		reg = AR933X_RESET_REG_RESET_MODULE;
 	else if (soc_is_ar934x())
 		reg = AR934X_RESET_REG_RESET_MODULE;
+	else if (soc_is_qca953x())
+		reg = QCA953X_RESET_REG_RESET_MODULE;
 	else if (soc_is_qca955x())
 		reg = QCA955X_RESET_REG_RESET_MODULE;
+	else if (soc_is_qca956x())
+		reg = QCA956X_RESET_REG_RESET_MODULE;
 	else
-		BUG();
+		panic("Reset register not defined for this SOC");
 
 	spin_lock_irqsave(&ath79_device_reset_lock, flags);
 	t = ath79_reset_rr(reg);
@@ -100,10 +105,14 @@
 		reg = AR933X_RESET_REG_RESET_MODULE;
 	else if (soc_is_ar934x())
 		reg = AR934X_RESET_REG_RESET_MODULE;
+	else if (soc_is_qca953x())
+		reg = QCA953X_RESET_REG_RESET_MODULE;
 	else if (soc_is_qca955x())
 		reg = QCA955X_RESET_REG_RESET_MODULE;
+	else if (soc_is_qca956x())
+		reg = QCA956X_RESET_REG_RESET_MODULE;
 	else
-		BUG();
+		panic("Reset register not defined for this SOC");
 
 	spin_lock_irqsave(&ath79_device_reset_lock, flags);
 	t = ath79_reset_rr(reg);
@@ -111,3 +120,42 @@
 	spin_unlock_irqrestore(&ath79_device_reset_lock, flags);
 }
 EXPORT_SYMBOL_GPL(ath79_device_reset_clear);
+
+u32 ath79_device_reset_get(u32 mask)
+{
+	unsigned long flags;
+	u32 reg;
+	u32 ret;
+
+	if (soc_is_ar71xx())
+		reg = AR71XX_RESET_REG_RESET_MODULE;
+	else if (soc_is_ar724x())
+		reg = AR724X_RESET_REG_RESET_MODULE;
+	else if (soc_is_ar913x())
+		reg = AR913X_RESET_REG_RESET_MODULE;
+	else if (soc_is_ar933x())
+		reg = AR933X_RESET_REG_RESET_MODULE;
+	else if (soc_is_ar934x())
+		reg = AR934X_RESET_REG_RESET_MODULE;
+	else
+		BUG();
+
+	spin_lock_irqsave(&ath79_device_reset_lock, flags);
+	ret = ath79_reset_rr(reg);
+	spin_unlock_irqrestore(&ath79_device_reset_lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ath79_device_reset_get);
+
+void ath79_flash_acquire(void)
+{
+	mutex_lock(&ath79_flash_mutex);
+}
+EXPORT_SYMBOL_GPL(ath79_flash_acquire);
+
+void ath79_flash_release(void)
+{
+	mutex_unlock(&ath79_flash_mutex);
+}
+EXPORT_SYMBOL_GPL(ath79_flash_release);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/common.h linux-4.1.13/arch/mips/ath79/common.h
--- linux-4.1.13.orig/arch/mips/ath79/common.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/common.h	2015-12-04 19:57:05.893979276 +0100
@@ -27,6 +27,9 @@
 void ath79_gpio_function_enable(u32 mask);
 void ath79_gpio_function_disable(u32 mask);
 void ath79_gpio_function_setup(u32 set, u32 clear);
+void ath79_gpio_function2_setup(u32 set, u32 clear);
+void ath79_gpio_output_select(unsigned gpio, u8 val);
+int ath79_gpio_direction_select(unsigned gpio, bool oe);
 void ath79_gpio_init(void);
 
 #endif /* __ATH79_COMMON_H */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-ap9x-pci.c linux-4.1.13/arch/mips/ath79/dev-ap9x-pci.c
--- linux-4.1.13.orig/arch/mips/ath79/dev-ap9x-pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-ap9x-pci.c	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,159 @@
+/*
+ *  Atheros AP9X reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "pci-ath9k-fixup.h"
+#include "pci.h"
+
+static struct ath9k_platform_data ap9x_wmac0_data = {
+	.led_pin = -1,
+};
+static struct ath9k_platform_data ap9x_wmac1_data = {
+	.led_pin = -1,
+};
+static char ap9x_wmac0_mac[6];
+static char ap9x_wmac1_mac[6];
+
+__init void ap9x_pci_setup_wmac_led_pin(unsigned wmac, int pin)
+{
+	switch (wmac) {
+	case 0:
+		ap9x_wmac0_data.led_pin = pin;
+		break;
+	case 1:
+		ap9x_wmac1_data.led_pin = pin;
+		break;
+	}
+}
+
+__init struct ath9k_platform_data *ap9x_pci_get_wmac_data(unsigned wmac)
+{
+	switch (wmac) {
+	case 0:
+		return &ap9x_wmac0_data;
+
+	case 1:
+		return &ap9x_wmac1_data;
+	}
+
+	return NULL;
+}
+
+__init void ap9x_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val)
+{
+	switch (wmac) {
+	case 0:
+		ap9x_wmac0_data.gpio_mask = mask;
+		ap9x_wmac0_data.gpio_val = val;
+		break;
+	case 1:
+		ap9x_wmac1_data.gpio_mask = mask;
+		ap9x_wmac1_data.gpio_val = val;
+		break;
+	}
+}
+
+__init void ap9x_pci_setup_wmac_leds(unsigned wmac, struct gpio_led *leds,
+				     int num_leds)
+{
+	switch (wmac) {
+	case 0:
+		ap9x_wmac0_data.leds = leds;
+		ap9x_wmac0_data.num_leds = num_leds;
+		break;
+	case 1:
+		ap9x_wmac1_data.leds = leds;
+		ap9x_wmac1_data.num_leds = num_leds;
+		break;
+	}
+}
+
+static int ap91_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 0:
+		dev->dev.platform_data = &ap9x_wmac0_data;
+		break;
+	}
+
+	return 0;
+}
+
+__init void ap91_pci_init(u8 *cal_data, u8 *mac_addr)
+{
+	if (cal_data)
+		memcpy(ap9x_wmac0_data.eeprom_data, cal_data,
+		       sizeof(ap9x_wmac0_data.eeprom_data));
+
+	if (mac_addr) {
+		memcpy(ap9x_wmac0_mac, mac_addr, sizeof(ap9x_wmac0_mac));
+		ap9x_wmac0_data.macaddr = ap9x_wmac0_mac;
+	}
+
+	ath79_pci_set_plat_dev_init(ap91_pci_plat_dev_init);
+	ath79_register_pci();
+
+	pci_enable_ath9k_fixup(0, ap9x_wmac0_data.eeprom_data);
+}
+
+__init void ap91_pci_init_simple(void)
+{
+	ap91_pci_init(NULL, NULL);
+	ap9x_wmac0_data.eeprom_name = "pci_wmac0.eeprom";
+}
+
+static int ap94_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &ap9x_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &ap9x_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+__init void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			  u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0)
+		memcpy(ap9x_wmac0_data.eeprom_data, cal_data0,
+		       sizeof(ap9x_wmac0_data.eeprom_data));
+
+	if (cal_data1)
+		memcpy(ap9x_wmac1_data.eeprom_data, cal_data1,
+		       sizeof(ap9x_wmac1_data.eeprom_data));
+
+	if (mac_addr0) {
+		memcpy(ap9x_wmac0_mac, mac_addr0, sizeof(ap9x_wmac0_mac));
+		ap9x_wmac0_data.macaddr = ap9x_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(ap9x_wmac1_mac, mac_addr1, sizeof(ap9x_wmac1_mac));
+		ap9x_wmac1_data.macaddr = ap9x_wmac1_mac;
+	}
+
+	ath79_pci_set_plat_dev_init(ap94_pci_plat_dev_init);
+	ath79_register_pci();
+
+	pci_enable_ath9k_fixup(17, ap9x_wmac0_data.eeprom_data);
+	pci_enable_ath9k_fixup(18, ap9x_wmac1_data.eeprom_data);
+}
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-ap9x-pci.h linux-4.1.13/arch/mips/ath79/dev-ap9x-pci.h
--- linux-4.1.13.orig/arch/mips/ath79/dev-ap9x-pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-ap9x-pci.h	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,48 @@
+/*
+ *  Atheros AP9X reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_AP9X_PCI_H
+#define _ATH79_DEV_AP9X_PCI_H
+
+struct gpio_led;
+struct ath9k_platform_data;
+
+#if defined(CONFIG_ATH79_DEV_AP9X_PCI)
+void ap9x_pci_setup_wmac_led_pin(unsigned wmac, int pin);
+void ap9x_pci_setup_wmac_gpio(unsigned wmac, u32 mask, u32 val);
+void ap9x_pci_setup_wmac_leds(unsigned wmac, struct gpio_led *leds,
+			      int num_leds);
+struct ath9k_platform_data *ap9x_pci_get_wmac_data(unsigned wmac);
+
+void ap91_pci_init(u8 *cal_data, u8 *mac_addr);
+void ap91_pci_init_simple(void);
+void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+		   u8 *cal_data1, u8 *mac_addr1);
+
+#else
+static inline void ap9x_pci_setup_wmac_led_pin(unsigned wmac, int pin) {}
+static inline void ap9x_pci_setup_wmac_gpio(unsigned wmac,
+					    u32 mask, u32 val) {}
+static inline void ap9x_pci_setup_wmac_leds(unsigned wmac,
+					    struct gpio_led *leds,
+					    int num_leds) {}
+static inline struct ath9k_platform_data *ap9x_pci_get_wmac_data(unsigned wmac)
+{
+	return NULL;
+}
+
+static inline void ap91_pci_init(u8 *cal_data, u8 *mac_addr) {}
+static inline void ap91_pci_init_simple(void) {}
+static inline void ap94_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				 u8 *cal_data1, u8 *mac_addr1) {}
+#endif
+
+#endif /* _ATH79_DEV_AP9X_PCI_H */
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-common.c linux-4.1.13/arch/mips/ath79/dev-common.c
--- linux-4.1.13.orig/arch/mips/ath79/dev-common.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-common.c	2015-12-04 19:57:04.474072175 +0100
@@ -80,11 +80,22 @@
 
 	uart_clk_rate = ath79_get_sys_clk_rate("uart");
 
+	if (soc_is_ar71xx())
+		ath79_gpio_function_enable(AR71XX_GPIO_FUNC_UART_EN);
+	else if (soc_is_ar724x())
+		ath79_gpio_function_enable(AR724X_GPIO_FUNC_UART_EN);
+	else if (soc_is_ar913x())
+		ath79_gpio_function_enable(AR913X_GPIO_FUNC_UART_EN);
+	else if (soc_is_ar933x())
+		ath79_gpio_function_enable(AR933X_GPIO_FUNC_UART_EN);
+
 	if (soc_is_ar71xx() ||
 	    soc_is_ar724x() ||
 	    soc_is_ar913x() ||
 	    soc_is_ar934x() ||
-	    soc_is_qca955x()) {
+	    soc_is_qca953x() ||
+	    soc_is_qca955x() ||
+	    soc_is_qca956x()) {
 		ath79_uart_data[0].uartclk = uart_clk_rate;
 		platform_device_register(&ath79_uart_device);
 	} else if (soc_is_ar933x()) {
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-dsa.c linux-4.1.13/arch/mips/ath79/dev-dsa.c
--- linux-4.1.13.orig/arch/mips/ath79/dev-dsa.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-dsa.c	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,41 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+
+static struct platform_device ar71xx_dsa_switch_device = {
+	.name		= "dsa",
+	.id		= 0,
+};
+
+void __init ath79_register_dsa(struct device *netdev,
+			       struct device *miidev,
+			       struct dsa_platform_data *d)
+{
+	int i;
+
+	d->netdev = netdev;
+	for (i = 0; i < d->nr_chips; i++)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+		d->chip[i].mii_bus = miidev;
+#else
+		d->chip[i].host_dev = miidev;
+#endif
+
+	ar71xx_dsa_switch_device.dev.platform_data = d;
+	platform_device_register(&ar71xx_dsa_switch_device);
+}
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-dsa.h linux-4.1.13/arch/mips/ath79/dev-dsa.h
--- linux-4.1.13.orig/arch/mips/ath79/dev-dsa.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-dsa.h	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,21 @@
+/*
+ *  Atheros AR71xx DSA switch device support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_DSA_H
+#define _ATH79_DEV_DSA_H
+
+#include <net/dsa.h>
+
+void ath79_register_dsa(struct device *netdev,
+			struct device *miidev,
+			struct dsa_platform_data *d);
+
+#endif /* _ATH79_DEV_DSA_H */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-eth.c linux-4.1.13/arch/mips/ath79/dev-eth.c
--- linux-4.1.13.orig/arch/mips/ath79/dev-eth.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-eth.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,1254 @@
+/*
+ *  Atheros AR71xx SoC platform devices
+ *
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros 2.6.15 BSP
+ *  Parts of this file are based on Atheros 2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/clk.h>
+#include <linux/sizes.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/irq.h>
+
+#include "common.h"
+#include "dev-eth.h"
+
+unsigned char ath79_mac_base[ETH_ALEN] __initdata;
+
+static struct resource ath79_mdio0_resources[] = {
+	{
+		.name	= "mdio_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}
+};
+
+struct ag71xx_mdio_platform_data ath79_mdio0_data;
+
+struct platform_device ath79_mdio0_device = {
+	.name		= "ag71xx-mdio",
+	.id		= 0,
+	.resource	= ath79_mdio0_resources,
+	.num_resources	= ARRAY_SIZE(ath79_mdio0_resources),
+	.dev = {
+		.platform_data = &ath79_mdio0_data,
+	},
+};
+
+static struct resource ath79_mdio1_resources[] = {
+	{
+		.name	= "mdio_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE1_BASE,
+		.end	= AR71XX_GE1_BASE + 0x200 - 1,
+	}
+};
+
+struct ag71xx_mdio_platform_data ath79_mdio1_data;
+
+struct platform_device ath79_mdio1_device = {
+	.name		= "ag71xx-mdio",
+	.id		= 1,
+	.resource	= ath79_mdio1_resources,
+	.num_resources	= ARRAY_SIZE(ath79_mdio1_resources),
+	.dev = {
+		.platform_data = &ath79_mdio1_data,
+	},
+};
+
+static void ath79_set_pll(u32 cfg_reg, u32 pll_reg, u32 pll_val, u32 shift)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+
+	t = __raw_readl(base + cfg_reg);
+	t &= ~(3 << shift);
+	t |=  (2 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	__raw_writel(pll_val, base + pll_reg);
+
+	t |= (3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	t &= ~(3 << shift);
+	__raw_writel(t, base + cfg_reg);
+	udelay(100);
+
+	printk(KERN_DEBUG "ar71xx: pll_reg %#x: %#x\n",
+		(unsigned int)(base + pll_reg), __raw_readl(base + pll_reg));
+
+	iounmap(base);
+}
+
+static void __init ath79_mii_ctrl_set_if(unsigned int reg,
+					  unsigned int mii_if)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR71XX_MII_BASE, AR71XX_MII_SIZE);
+
+	t = __raw_readl(base + reg);
+	t &= ~(AR71XX_MII_CTRL_IF_MASK);
+	t |= (mii_if & AR71XX_MII_CTRL_IF_MASK);
+	__raw_writel(t, base + reg);
+
+	iounmap(base);
+}
+
+static void ath79_mii_ctrl_set_speed(unsigned int reg, unsigned int speed)
+{
+	void __iomem *base;
+	unsigned int mii_speed;
+	u32 t;
+
+	switch (speed) {
+	case SPEED_10:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_10;
+		break;
+	case SPEED_100:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_100;
+		break;
+	case SPEED_1000:
+		mii_speed =  AR71XX_MII_CTRL_SPEED_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	base = ioremap(AR71XX_MII_BASE, AR71XX_MII_SIZE);
+
+	t = __raw_readl(base + reg);
+	t &= ~(AR71XX_MII_CTRL_SPEED_MASK << AR71XX_MII_CTRL_SPEED_SHIFT);
+	t |= mii_speed  << AR71XX_MII_CTRL_SPEED_SHIFT;
+	__raw_writel(t, base + reg);
+
+	iounmap(base);
+}
+
+static unsigned long ar934x_get_mdio_ref_clock(void)
+{
+	void __iomem *base;
+	unsigned long ret;
+	u32 t;
+
+	base = ioremap(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+
+	ret = 0;
+	t = __raw_readl(base + AR934X_PLL_SWITCH_CLOCK_CONTROL_REG);
+	if (t & AR934X_PLL_SWITCH_CLOCK_CONTROL_MDIO_CLK_SEL) {
+		ret = 100 * 1000 * 1000;
+	} else {
+		struct clk *clk;
+
+		clk = clk_get(NULL, "ref");
+		if (!IS_ERR(clk))
+			ret = clk_get_rate(clk);
+	}
+
+	iounmap(base);
+
+	return ret;
+}
+
+void __init ath79_register_mdio(unsigned int id, u32 phy_mask)
+{
+	struct platform_device *mdio_dev;
+	struct ag71xx_mdio_platform_data *mdio_data;
+	unsigned int max_id;
+
+	if (ath79_soc == ATH79_SOC_AR9341 ||
+	    ath79_soc == ATH79_SOC_AR9342 ||
+	    ath79_soc == ATH79_SOC_AR9344 ||
+	    ath79_soc == ATH79_SOC_QCA9556 ||
+	    ath79_soc == ATH79_SOC_QCA9558)
+		max_id = 1;
+	else
+		max_id = 0;
+
+	if (id > max_id) {
+		printk(KERN_ERR "ar71xx: invalid MDIO id %u\n", id);
+		return;
+	}
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7241:
+	case ATH79_SOC_AR9330:
+	case ATH79_SOC_AR9331:
+	case ATH79_SOC_QCA9533:
+	case ATH79_SOC_QCA9561:
+	case ATH79_SOC_TP9343:
+		mdio_dev = &ath79_mdio1_device;
+		mdio_data = &ath79_mdio1_data;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9556:
+	case ATH79_SOC_QCA9558:
+		if (id == 0) {
+			mdio_dev = &ath79_mdio0_device;
+			mdio_data = &ath79_mdio0_data;
+		} else {
+			mdio_dev = &ath79_mdio1_device;
+			mdio_data = &ath79_mdio1_data;
+		}
+		break;
+
+	case ATH79_SOC_AR7242:
+		ath79_set_pll(AR71XX_PLL_REG_SEC_CONFIG,
+			       AR7242_PLL_REG_ETH0_INT_CLOCK, 0x62000000,
+			       AR71XX_ETH0_PLL_SHIFT);
+		/* fall through */
+	default:
+		mdio_dev = &ath79_mdio0_device;
+		mdio_data = &ath79_mdio0_data;
+		break;
+	}
+
+	mdio_data->phy_mask = phy_mask;
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7240:
+		mdio_data->is_ar7240 = 1;
+		/* fall through */
+	case ATH79_SOC_AR7241:
+		mdio_data->builtin_switch = 1;
+		break;
+
+	case ATH79_SOC_AR9330:
+		mdio_data->is_ar9330 = 1;
+		/* fall through */
+	case ATH79_SOC_AR9331:
+		mdio_data->builtin_switch = 1;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+		if (id == 1) {
+			mdio_data->builtin_switch = 1;
+			mdio_data->ref_clock = ar934x_get_mdio_ref_clock();
+			mdio_data->mdio_clock = 6250000;
+		}
+		mdio_data->is_ar934x = 1;
+		break;
+
+	case ATH79_SOC_QCA9533:
+	case ATH79_SOC_QCA9561:
+	case ATH79_SOC_TP9343:
+		mdio_data->builtin_switch = 1;
+		break;
+
+	case ATH79_SOC_QCA9556:
+	case ATH79_SOC_QCA9558:
+		mdio_data->is_ar934x = 1;
+		break;
+
+	default:
+		break;
+	}
+
+	platform_device_register(mdio_dev);
+}
+
+struct ath79_eth_pll_data ath79_eth0_pll_data;
+struct ath79_eth_pll_data ath79_eth1_pll_data;
+
+static u32 ath79_get_eth_pll(unsigned int mac, int speed)
+{
+	struct ath79_eth_pll_data *pll_data;
+	u32 pll_val;
+
+	switch (mac) {
+	case 0:
+		pll_data = &ath79_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ath79_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (speed) {
+	case SPEED_10:
+		pll_val = pll_data->pll_10;
+		break;
+	case SPEED_100:
+		pll_val = pll_data->pll_100;
+		break;
+	case SPEED_1000:
+		pll_val = pll_data->pll_1000;
+		break;
+	default:
+		BUG();
+	}
+
+	return pll_val;
+}
+
+static void ath79_set_speed_ge0(int speed)
+{
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	ath79_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH0_INT_CLOCK,
+			val, AR71XX_ETH0_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII0_CTRL, speed);
+}
+
+static void ath79_set_speed_ge1(int speed)
+{
+	u32 val = ath79_get_eth_pll(1, speed);
+
+	ath79_set_pll(AR71XX_PLL_REG_SEC_CONFIG, AR71XX_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR71XX_ETH1_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII1_CTRL, speed);
+}
+
+static void ar7242_set_speed_ge0(int speed)
+{
+	u32 val = ath79_get_eth_pll(0, speed);
+	void __iomem *base;
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + AR7242_PLL_REG_ETH0_INT_CLOCK);
+	iounmap(base);
+}
+
+static void ar91xx_set_speed_ge0(int speed)
+{
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	ath79_set_pll(AR913X_PLL_REG_ETH_CONFIG, AR913X_PLL_REG_ETH0_INT_CLOCK,
+			 val, AR913X_ETH0_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII0_CTRL, speed);
+}
+
+static void ar91xx_set_speed_ge1(int speed)
+{
+	u32 val = ath79_get_eth_pll(1, speed);
+
+	ath79_set_pll(AR913X_PLL_REG_ETH_CONFIG, AR913X_PLL_REG_ETH1_INT_CLOCK,
+			 val, AR913X_ETH1_PLL_SHIFT);
+	ath79_mii_ctrl_set_speed(AR71XX_MII_REG_MII1_CTRL, speed);
+}
+
+static void ar934x_set_speed_ge0(int speed)
+{
+	void __iomem *base;
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + AR934X_PLL_ETH_XMII_CONTROL_REG);
+	iounmap(base);
+}
+
+static void qca955x_set_speed_xmii(int speed)
+{
+	void __iomem *base;
+	u32 val = ath79_get_eth_pll(0, speed);
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + QCA955X_PLL_ETH_XMII_CONTROL_REG);
+	iounmap(base);
+}
+
+static void qca955x_set_speed_sgmii(int speed)
+{
+	void __iomem *base;
+	u32 val = ath79_get_eth_pll(1, speed);
+
+	base = ioremap_nocache(AR71XX_PLL_BASE, AR71XX_PLL_SIZE);
+	__raw_writel(val, base + QCA955X_PLL_ETH_SGMII_CONTROL_REG);
+	iounmap(base);
+}
+
+static void ath79_set_speed_dummy(int speed)
+{
+}
+
+static void ath79_ddr_no_flush(void)
+{
+}
+
+static void ath79_ddr_flush_ge0(void)
+{
+	ath79_ddr_wb_flush(AR71XX_DDR_REG_FLUSH_GE0);
+}
+
+static void ath79_ddr_flush_ge1(void)
+{
+	ath79_ddr_wb_flush(AR71XX_DDR_REG_FLUSH_GE1);
+}
+
+static void ar724x_ddr_flush_ge0(void)
+{
+	ath79_ddr_wb_flush(AR724X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar724x_ddr_flush_ge1(void)
+{
+	ath79_ddr_wb_flush(AR724X_DDR_REG_FLUSH_GE1);
+}
+
+static void ar91xx_ddr_flush_ge0(void)
+{
+	ath79_ddr_wb_flush(AR913X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar91xx_ddr_flush_ge1(void)
+{
+	ath79_ddr_wb_flush(AR913X_DDR_REG_FLUSH_GE1);
+}
+
+static void ar933x_ddr_flush_ge0(void)
+{
+	ath79_ddr_wb_flush(AR933X_DDR_REG_FLUSH_GE0);
+}
+
+static void ar933x_ddr_flush_ge1(void)
+{
+	ath79_ddr_wb_flush(AR933X_DDR_REG_FLUSH_GE1);
+}
+
+static struct resource ath79_eth0_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE0_BASE,
+		.end	= AR71XX_GE0_BASE + 0x200 - 1,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= ATH79_CPU_IRQ(4),
+		.end	= ATH79_CPU_IRQ(4),
+	},
+};
+
+struct ag71xx_platform_data ath79_eth0_data = {
+	.reset_bit	= AR71XX_RESET_GE0_MAC,
+};
+
+struct platform_device ath79_eth0_device = {
+	.name		= "ag71xx",
+	.id		= 0,
+	.resource	= ath79_eth0_resources,
+	.num_resources	= ARRAY_SIZE(ath79_eth0_resources),
+	.dev = {
+		.platform_data = &ath79_eth0_data,
+	},
+};
+
+static struct resource ath79_eth1_resources[] = {
+	{
+		.name	= "mac_base",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR71XX_GE1_BASE,
+		.end	= AR71XX_GE1_BASE + 0x200 - 1,
+	}, {
+		.name	= "mac_irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= ATH79_CPU_IRQ(5),
+		.end	= ATH79_CPU_IRQ(5),
+	},
+};
+
+struct ag71xx_platform_data ath79_eth1_data = {
+	.reset_bit	= AR71XX_RESET_GE1_MAC,
+};
+
+struct platform_device ath79_eth1_device = {
+	.name		= "ag71xx",
+	.id		= 1,
+	.resource	= ath79_eth1_resources,
+	.num_resources	= ARRAY_SIZE(ath79_eth1_resources),
+	.dev = {
+		.platform_data = &ath79_eth1_data,
+	},
+};
+
+struct ag71xx_switch_platform_data ath79_switch_data;
+
+#define AR71XX_PLL_VAL_1000	0x00110000
+#define AR71XX_PLL_VAL_100	0x00001099
+#define AR71XX_PLL_VAL_10	0x00991099
+
+#define AR724X_PLL_VAL_1000	0x00110000
+#define AR724X_PLL_VAL_100	0x00001099
+#define AR724X_PLL_VAL_10	0x00991099
+
+#define AR7242_PLL_VAL_1000	0x16000000
+#define AR7242_PLL_VAL_100	0x00000101
+#define AR7242_PLL_VAL_10	0x00001616
+
+#define AR913X_PLL_VAL_1000	0x1a000000
+#define AR913X_PLL_VAL_100	0x13000a44
+#define AR913X_PLL_VAL_10	0x00441099
+
+#define AR933X_PLL_VAL_1000	0x00110000
+#define AR933X_PLL_VAL_100	0x00001099
+#define AR933X_PLL_VAL_10	0x00991099
+
+#define AR934X_PLL_VAL_1000	0x16000000
+#define AR934X_PLL_VAL_100	0x00000101
+#define AR934X_PLL_VAL_10	0x00001616
+
+static void __init ath79_init_eth_pll_data(unsigned int id)
+{
+	struct ath79_eth_pll_data *pll_data;
+	u32 pll_10, pll_100, pll_1000;
+
+	switch (id) {
+	case 0:
+		pll_data = &ath79_eth0_pll_data;
+		break;
+	case 1:
+		pll_data = &ath79_eth1_pll_data;
+		break;
+	default:
+		BUG();
+	}
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7130:
+	case ATH79_SOC_AR7141:
+	case ATH79_SOC_AR7161:
+		pll_10 = AR71XX_PLL_VAL_10;
+		pll_100 = AR71XX_PLL_VAL_100;
+		pll_1000 = AR71XX_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR7240:
+	case ATH79_SOC_AR7241:
+		pll_10 = AR724X_PLL_VAL_10;
+		pll_100 = AR724X_PLL_VAL_100;
+		pll_1000 = AR724X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR7242:
+		pll_10 = AR7242_PLL_VAL_10;
+		pll_100 = AR7242_PLL_VAL_100;
+		pll_1000 = AR7242_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR9130:
+	case ATH79_SOC_AR9132:
+		pll_10 = AR913X_PLL_VAL_10;
+		pll_100 = AR913X_PLL_VAL_100;
+		pll_1000 = AR913X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR9330:
+	case ATH79_SOC_AR9331:
+		pll_10 = AR933X_PLL_VAL_10;
+		pll_100 = AR933X_PLL_VAL_100;
+		pll_1000 = AR933X_PLL_VAL_1000;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9533:
+	case ATH79_SOC_QCA9556:
+	case ATH79_SOC_QCA9558:
+	case ATH79_SOC_QCA9561:
+	case ATH79_SOC_TP9343:
+		pll_10 = AR934X_PLL_VAL_10;
+		pll_100 = AR934X_PLL_VAL_100;
+		pll_1000 = AR934X_PLL_VAL_1000;
+		break;
+
+	default:
+		BUG();
+	}
+
+	if (!pll_data->pll_10)
+		pll_data->pll_10 = pll_10;
+
+	if (!pll_data->pll_100)
+		pll_data->pll_100 = pll_100;
+
+	if (!pll_data->pll_1000)
+		pll_data->pll_1000 = pll_1000;
+}
+
+static int __init ath79_setup_phy_if_mode(unsigned int id,
+					   struct ag71xx_platform_data *pdata)
+{
+	unsigned int mii_if;
+
+	switch (id) {
+	case 0:
+		switch (ath79_soc) {
+		case ATH79_SOC_AR7130:
+		case ATH79_SOC_AR7141:
+		case ATH79_SOC_AR7161:
+		case ATH79_SOC_AR9130:
+		case ATH79_SOC_AR9132:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+				mii_if = AR71XX_MII0_CTRL_IF_MII;
+				break;
+			case PHY_INTERFACE_MODE_GMII:
+				mii_if = AR71XX_MII0_CTRL_IF_GMII;
+				break;
+			case PHY_INTERFACE_MODE_RGMII:
+				mii_if = AR71XX_MII0_CTRL_IF_RGMII;
+				break;
+			case PHY_INTERFACE_MODE_RMII:
+				mii_if = AR71XX_MII0_CTRL_IF_RMII;
+				break;
+			default:
+				return -EINVAL;
+			}
+			ath79_mii_ctrl_set_if(AR71XX_MII_REG_MII0_CTRL, mii_if);
+			break;
+
+		case ATH79_SOC_AR7240:
+		case ATH79_SOC_AR7241:
+		case ATH79_SOC_AR9330:
+		case ATH79_SOC_AR9331:
+		case ATH79_SOC_QCA9533:
+		case ATH79_SOC_TP9343:
+			pdata->phy_if_mode = PHY_INTERFACE_MODE_MII;
+			break;
+
+		case ATH79_SOC_AR7242:
+			/* FIXME */
+
+		case ATH79_SOC_AR9341:
+		case ATH79_SOC_AR9342:
+		case ATH79_SOC_AR9344:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_GMII:
+			case PHY_INTERFACE_MODE_RGMII:
+			case PHY_INTERFACE_MODE_RMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		case ATH79_SOC_QCA9556:
+		case ATH79_SOC_QCA9558:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_RGMII:
+			case PHY_INTERFACE_MODE_SGMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		case ATH79_SOC_QCA9561:
+			if (!pdata->phy_if_mode)
+				pdata->phy_if_mode = PHY_INTERFACE_MODE_MII;
+			break;
+
+		default:
+			BUG();
+		}
+		break;
+	case 1:
+		switch (ath79_soc) {
+		case ATH79_SOC_AR7130:
+		case ATH79_SOC_AR7141:
+		case ATH79_SOC_AR7161:
+		case ATH79_SOC_AR9130:
+		case ATH79_SOC_AR9132:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_RMII:
+				mii_if = AR71XX_MII1_CTRL_IF_RMII;
+				break;
+			case PHY_INTERFACE_MODE_RGMII:
+				mii_if = AR71XX_MII1_CTRL_IF_RGMII;
+				break;
+			default:
+				return -EINVAL;
+			}
+			ath79_mii_ctrl_set_if(AR71XX_MII_REG_MII1_CTRL, mii_if);
+			break;
+
+		case ATH79_SOC_AR7240:
+		case ATH79_SOC_AR7241:
+		case ATH79_SOC_AR9330:
+		case ATH79_SOC_AR9331:
+		case ATH79_SOC_QCA9561:
+		case ATH79_SOC_TP9343:
+			pdata->phy_if_mode = PHY_INTERFACE_MODE_GMII;
+			break;
+
+		case ATH79_SOC_AR7242:
+			/* FIXME */
+
+		case ATH79_SOC_AR9341:
+		case ATH79_SOC_AR9342:
+		case ATH79_SOC_AR9344:
+		case ATH79_SOC_QCA9533:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_GMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		case ATH79_SOC_QCA9556:
+		case ATH79_SOC_QCA9558:
+			switch (pdata->phy_if_mode) {
+			case PHY_INTERFACE_MODE_MII:
+			case PHY_INTERFACE_MODE_RGMII:
+			case PHY_INTERFACE_MODE_SGMII:
+				break;
+			default:
+				return -EINVAL;
+			}
+			break;
+
+		default:
+			BUG();
+		}
+		break;
+	}
+
+	return 0;
+}
+
+void __init ath79_setup_ar933x_phy4_switch(bool mac, bool mdio)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR933X_GMAC_BASE, AR933X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR933X_GMAC_REG_ETH_CFG);
+	t &= ~(AR933X_ETH_CFG_SW_PHY_SWAP | AR933X_ETH_CFG_SW_PHY_ADDR_SWAP);
+	if (mac)
+		t |= AR933X_ETH_CFG_SW_PHY_SWAP;
+	if (mdio)
+		t |= AR933X_ETH_CFG_SW_PHY_ADDR_SWAP;
+	__raw_writel(t, base + AR933X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+void __init ath79_setup_ar934x_eth_cfg(u32 mask)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(AR934X_GMAC_BASE, AR934X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+
+	t &= ~(AR934X_ETH_CFG_RGMII_GMAC0 |
+	       AR934X_ETH_CFG_MII_GMAC0 |
+	       AR934X_ETH_CFG_GMII_GMAC0 |
+	       AR934X_ETH_CFG_SW_ONLY_MODE |
+	       AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	t |= mask;
+
+	__raw_writel(t, base + AR934X_GMAC_REG_ETH_CFG);
+	/* flush write */
+	__raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+void __init ath79_setup_ar934x_eth_rx_delay(unsigned int rxd,
+					    unsigned int rxdv)
+{
+	void __iomem *base;
+	u32 t;
+
+	rxd &= AR934X_ETH_CFG_RXD_DELAY_MASK;
+	rxdv &= AR934X_ETH_CFG_RDV_DELAY_MASK;
+
+	base = ioremap(AR934X_GMAC_BASE, AR934X_GMAC_SIZE);
+
+	t = __raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+
+	t &= ~(AR934X_ETH_CFG_RXD_DELAY_MASK << AR934X_ETH_CFG_RXD_DELAY_SHIFT |
+	       AR934X_ETH_CFG_RDV_DELAY_MASK << AR934X_ETH_CFG_RDV_DELAY_SHIFT);
+
+	t |= (rxd << AR934X_ETH_CFG_RXD_DELAY_SHIFT |
+	      rxdv << AR934X_ETH_CFG_RDV_DELAY_SHIFT);
+
+	__raw_writel(t, base + AR934X_GMAC_REG_ETH_CFG);
+	/* flush write */
+	__raw_readl(base + AR934X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+void __init ath79_setup_qca955x_eth_cfg(u32 mask)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ioremap(QCA955X_GMAC_BASE, QCA955X_GMAC_SIZE);
+
+	t = __raw_readl(base + QCA955X_GMAC_REG_ETH_CFG);
+
+	t &= ~(QCA955X_ETH_CFG_RGMII_EN | QCA955X_ETH_CFG_GE0_SGMII);
+
+	t |= mask;
+
+	__raw_writel(t, base + QCA955X_GMAC_REG_ETH_CFG);
+
+	iounmap(base);
+}
+
+static int ath79_eth_instance __initdata;
+void __init ath79_register_eth(unsigned int id)
+{
+	struct platform_device *pdev;
+	struct ag71xx_platform_data *pdata;
+	int err;
+
+	if (id > 1) {
+		printk(KERN_ERR "ar71xx: invalid ethernet id %d\n", id);
+		return;
+	}
+
+	ath79_init_eth_pll_data(id);
+
+	if (id == 0)
+		pdev = &ath79_eth0_device;
+	else
+		pdev = &ath79_eth1_device;
+
+	pdata = pdev->dev.platform_data;
+
+	pdata->max_frame_len = 1540;
+	pdata->desc_pktlen_mask = 0xfff;
+
+	err = ath79_setup_phy_if_mode(id, pdata);
+	if (err) {
+		printk(KERN_ERR
+		       "ar71xx: invalid PHY interface mode for GE%u\n", id);
+		return;
+	}
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7130:
+		if (id == 0) {
+			pdata->ddr_flush = ath79_ddr_flush_ge0;
+			pdata->set_speed = ath79_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ath79_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_ge1;
+		}
+		break;
+
+	case ATH79_SOC_AR7141:
+	case ATH79_SOC_AR7161:
+		if (id == 0) {
+			pdata->ddr_flush = ath79_ddr_flush_ge0;
+			pdata->set_speed = ath79_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ath79_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_ge1;
+		}
+		pdata->has_gbit = 1;
+		break;
+
+	case ATH79_SOC_AR7242:
+		if (id == 0) {
+			pdata->reset_bit |= AR724X_RESET_GE0_MDIO |
+					    AR71XX_RESET_GE0_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge0;
+			pdata->set_speed = ar7242_set_speed_ge0;
+		} else {
+			pdata->reset_bit |= AR724X_RESET_GE1_MDIO |
+					    AR71XX_RESET_GE1_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_dummy;
+		}
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case ATH79_SOC_AR7241:
+		if (id == 0)
+			pdata->reset_bit |= AR724X_RESET_GE0_MDIO;
+		else
+			pdata->reset_bit |= AR724X_RESET_GE1_MDIO;
+		/* fall through */
+	case ATH79_SOC_AR7240:
+		if (id == 0) {
+			pdata->reset_bit |= AR71XX_RESET_GE0_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge0;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->phy_mask = BIT(4);
+		} else {
+			pdata->reset_bit |= AR71XX_RESET_GE1_PHY;
+			pdata->ddr_flush = ar724x_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->speed = SPEED_1000;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->switch_data = &ath79_switch_data;
+
+			ath79_switch_data.phy_poll_mask |= BIT(4);
+		}
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+		if (ath79_soc == ATH79_SOC_AR7240)
+			pdata->is_ar7240 = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case ATH79_SOC_AR9130:
+		if (id == 0) {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge0;
+			pdata->set_speed = ar91xx_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge1;
+			pdata->set_speed = ar91xx_set_speed_ge1;
+		}
+		pdata->is_ar91xx = 1;
+		break;
+
+	case ATH79_SOC_AR9132:
+		if (id == 0) {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge0;
+			pdata->set_speed = ar91xx_set_speed_ge0;
+		} else {
+			pdata->ddr_flush = ar91xx_ddr_flush_ge1;
+			pdata->set_speed = ar91xx_set_speed_ge1;
+		}
+		pdata->is_ar91xx = 1;
+		pdata->has_gbit = 1;
+		break;
+
+	case ATH79_SOC_AR9330:
+	case ATH79_SOC_AR9331:
+		if (id == 0) {
+			pdata->reset_bit = AR933X_RESET_GE0_MAC |
+					   AR933X_RESET_GE0_MDIO;
+			pdata->ddr_flush = ar933x_ddr_flush_ge0;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->phy_mask = BIT(4);
+		} else {
+			pdata->reset_bit = AR933X_RESET_GE1_MAC |
+					   AR933X_RESET_GE1_MDIO;
+			pdata->ddr_flush = ar933x_ddr_flush_ge1;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->speed = SPEED_1000;
+			pdata->has_gbit = 1;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->switch_data = &ath79_switch_data;
+
+			ath79_switch_data.phy_poll_mask |= BIT(4);
+		}
+
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case ATH79_SOC_AR9341:
+	case ATH79_SOC_AR9342:
+	case ATH79_SOC_AR9344:
+	case ATH79_SOC_QCA9533:
+		if (id == 0) {
+			pdata->reset_bit = AR934X_RESET_GE0_MAC |
+					   AR934X_RESET_GE0_MDIO;
+			pdata->set_speed = ar934x_set_speed_ge0;
+		} else {
+			pdata->reset_bit = AR934X_RESET_GE1_MAC |
+					   AR934X_RESET_GE1_MDIO;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->switch_data = &ath79_switch_data;
+
+			/* reset the built-in switch */
+			ath79_device_reset_set(AR934X_RESET_ETH_SWITCH);
+			ath79_device_reset_clear(AR934X_RESET_ETH_SWITCH);
+		}
+
+		pdata->ddr_flush = ath79_ddr_no_flush;
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		pdata->max_frame_len = SZ_16K - 1;
+		pdata->desc_pktlen_mask = SZ_16K - 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case ATH79_SOC_QCA9561:
+	case ATH79_SOC_TP9343:
+		if (id == 0) {
+			pdata->reset_bit = AR933X_RESET_GE0_MAC |
+					   AR933X_RESET_GE0_MDIO;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			if (!pdata->phy_mask)
+				pdata->phy_mask = BIT(4);
+		} else {
+			pdata->reset_bit = AR933X_RESET_GE1_MAC |
+					   AR933X_RESET_GE1_MDIO;
+			pdata->set_speed = ath79_set_speed_dummy;
+
+			pdata->speed = SPEED_1000;
+			pdata->duplex = DUPLEX_FULL;
+			pdata->switch_data = &ath79_switch_data;
+
+			ath79_switch_data.phy_poll_mask |= BIT(4);
+		}
+
+		pdata->ddr_flush = ath79_ddr_no_flush;
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	case ATH79_SOC_QCA9556:
+	case ATH79_SOC_QCA9558:
+		if (id == 0) {
+			pdata->reset_bit = QCA955X_RESET_GE0_MAC |
+					   QCA955X_RESET_GE0_MDIO;
+			pdata->set_speed = qca955x_set_speed_xmii;
+		} else {
+			pdata->reset_bit = QCA955X_RESET_GE1_MAC |
+					   QCA955X_RESET_GE1_MDIO;
+			pdata->set_speed = qca955x_set_speed_sgmii;
+		}
+
+		pdata->ddr_flush = ath79_ddr_no_flush;
+		pdata->has_gbit = 1;
+		pdata->is_ar724x = 1;
+
+		/*
+		 * Limit the maximum frame length to 4095 bytes.
+		 * Although the documentation says that the hardware
+		 * limit is 16383 bytes but that does not work in
+		 * practice. It seems that the hardware only updates
+		 * the lowest 12 bits of the packet length field
+		 * in the RX descriptor.
+		 */
+		pdata->max_frame_len = SZ_4K - 1;
+		pdata->desc_pktlen_mask = SZ_16K - 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
+		break;
+
+	default:
+		BUG();
+	}
+
+	switch (pdata->phy_if_mode) {
+	case PHY_INTERFACE_MODE_GMII:
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_SGMII:
+		if (!pdata->has_gbit) {
+			printk(KERN_ERR "ar71xx: no gbit available on eth%d\n",
+					id);
+			return;
+		}
+		/* fallthrough */
+	default:
+		break;
+	}
+
+	if (!is_valid_ether_addr(pdata->mac_addr)) {
+		random_ether_addr(pdata->mac_addr);
+		printk(KERN_DEBUG
+			"ar71xx: using random MAC address for eth%d\n",
+			ath79_eth_instance);
+	}
+
+	if (pdata->mii_bus_dev == NULL) {
+		switch (ath79_soc) {
+		case ATH79_SOC_AR9341:
+		case ATH79_SOC_AR9342:
+		case ATH79_SOC_AR9344:
+			if (id == 0)
+				pdata->mii_bus_dev = &ath79_mdio0_device.dev;
+			else
+				pdata->mii_bus_dev = &ath79_mdio1_device.dev;
+			break;
+
+		case ATH79_SOC_AR7241:
+		case ATH79_SOC_AR9330:
+		case ATH79_SOC_AR9331:
+		case ATH79_SOC_QCA9533:
+		case ATH79_SOC_QCA9561:
+		case ATH79_SOC_TP9343:
+			pdata->mii_bus_dev = &ath79_mdio1_device.dev;
+			break;
+
+		case ATH79_SOC_QCA9556:
+		case ATH79_SOC_QCA9558:
+			/* don't assign any MDIO device by default */
+			break;
+
+		default:
+			pdata->mii_bus_dev = &ath79_mdio0_device.dev;
+			break;
+		}
+	}
+
+	/* Reset the device */
+	ath79_device_reset_set(pdata->reset_bit);
+	msleep(100);
+
+	ath79_device_reset_clear(pdata->reset_bit);
+	msleep(100);
+
+	platform_device_register(pdev);
+	ath79_eth_instance++;
+}
+
+void __init ath79_set_mac_base(unsigned char *mac)
+{
+	memcpy(ath79_mac_base, mac, ETH_ALEN);
+}
+
+void __init ath79_parse_ascii_mac(char *mac_str, u8 *mac)
+{
+	int t;
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		   &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != ETH_ALEN)
+		t = sscanf(mac_str, "%02hhx.%02hhx.%02hhx.%02hhx.%02hhx.%02hhx",
+			&mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != ETH_ALEN || !is_valid_ether_addr(mac)) {
+		memset(mac, 0, ETH_ALEN);
+		printk(KERN_DEBUG "ar71xx: invalid mac address \"%s\"\n",
+		       mac_str);
+	}
+}
+
+static void __init ath79_set_mac_base_ascii(char *str)
+{
+	u8 mac[ETH_ALEN];
+
+	ath79_parse_ascii_mac(str, mac);
+	ath79_set_mac_base(mac);
+}
+
+static int __init ath79_ethaddr_setup(char *str)
+{
+	ath79_set_mac_base_ascii(str);
+	return 1;
+}
+__setup("ethaddr=", ath79_ethaddr_setup);
+
+static int __init ath79_kmac_setup(char *str)
+{
+	ath79_set_mac_base_ascii(str);
+	return 1;
+}
+__setup("kmac=", ath79_kmac_setup);
+
+void __init ath79_init_mac(unsigned char *dst, const unsigned char *src,
+			    int offset)
+{
+	int t;
+
+	if (!dst)
+		return;
+
+	if (!src || !is_valid_ether_addr(src)) {
+		memset(dst, '\0', ETH_ALEN);
+		return;
+	}
+
+	t = (((u32) src[3]) << 16) + (((u32) src[4]) << 8) + ((u32) src[5]);
+	t += offset;
+
+	dst[0] = src[0];
+	dst[1] = src[1];
+	dst[2] = src[2];
+	dst[3] = (t >> 16) & 0xff;
+	dst[4] = (t >> 8) & 0xff;
+	dst[5] = t & 0xff;
+}
+
+void __init ath79_init_local_mac(unsigned char *dst, const unsigned char *src)
+{
+	int i;
+
+	if (!dst)
+		return;
+
+	if (!src || !is_valid_ether_addr(src)) {
+		memset(dst, '\0', ETH_ALEN);
+		return;
+	}
+
+	for (i = 0; i < ETH_ALEN; i++)
+		dst[i] = src[i];
+	dst[0] |= 0x02;
+}
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-eth.h linux-4.1.13/arch/mips/ath79/dev-eth.h
--- linux-4.1.13.orig/arch/mips/ath79/dev-eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-eth.h	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,53 @@
+/*
+ *  Atheros AR71xx SoC device definitions
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_ETH_H
+#define _ATH79_DEV_ETH_H
+
+#include <asm/mach-ath79/ag71xx_platform.h>
+
+struct platform_device;
+
+extern unsigned char ath79_mac_base[] __initdata;
+void ath79_parse_ascii_mac(char *mac_str, u8 *mac);
+void ath79_init_mac(unsigned char *dst, const unsigned char *src,
+		    int offset);
+void ath79_init_local_mac(unsigned char *dst, const unsigned char *src);
+
+struct ath79_eth_pll_data {
+	u32	pll_10;
+	u32	pll_100;
+	u32	pll_1000;
+};
+
+extern struct ath79_eth_pll_data ath79_eth0_pll_data;
+extern struct ath79_eth_pll_data ath79_eth1_pll_data;
+
+extern struct ag71xx_platform_data ath79_eth0_data;
+extern struct ag71xx_platform_data ath79_eth1_data;
+extern struct platform_device ath79_eth0_device;
+extern struct platform_device ath79_eth1_device;
+void ath79_register_eth(unsigned int id);
+
+extern struct ag71xx_switch_platform_data ath79_switch_data;
+
+extern struct ag71xx_mdio_platform_data ath79_mdio0_data;
+extern struct ag71xx_mdio_platform_data ath79_mdio1_data;
+extern struct platform_device ath79_mdio0_device;
+extern struct platform_device ath79_mdio1_device;
+void ath79_register_mdio(unsigned int id, u32 phy_mask);
+
+void ath79_setup_ar933x_phy4_switch(bool mac, bool mdio);
+void ath79_setup_ar934x_eth_cfg(u32 mask);
+void ath79_setup_ar934x_eth_rx_delay(unsigned int rxd, unsigned int rxdv);
+void ath79_setup_qca955x_eth_cfg(u32 mask);
+
+#endif /* _ATH79_DEV_ETH_H */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-m25p80.c linux-4.1.13/arch/mips/ath79/dev-m25p80.c
--- linux-4.1.13.orig/arch/mips/ath79/dev-m25p80.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-m25p80.c	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,118 @@
+/*
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/concat.h>
+
+#include "dev-spi.h"
+#include "dev-m25p80.h"
+
+static struct ath79_spi_controller_data ath79_spi0_cdata =
+{
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 0,
+};
+
+static struct ath79_spi_controller_data ath79_spi1_cdata =
+{
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 1,
+};
+
+static struct spi_board_info ath79_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.controller_data = &ath79_spi0_cdata,
+	},
+	{
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz   = 25000000,
+		.modalias	= "m25p80",
+		.controller_data = &ath79_spi1_cdata,
+	}
+};
+
+static struct ath79_spi_platform_data ath79_spi_data;
+
+void __init ath79_register_m25p80(struct flash_platform_data *pdata)
+{
+	ath79_spi_data.bus_num = 0;
+	ath79_spi_data.num_chipselect = 1;
+	ath79_spi0_cdata.is_flash = true;
+	ath79_spi_info[0].platform_data = pdata;
+	ath79_register_spi(&ath79_spi_data, ath79_spi_info, 1);
+}
+
+static struct flash_platform_data *multi_pdata;
+
+static struct mtd_info *concat_devs[2] = { NULL, NULL };
+static struct work_struct mtd_concat_work;
+
+static void mtd_concat_add_work(struct work_struct *work)
+{
+	struct mtd_info *mtd;
+
+	mtd = mtd_concat_create(concat_devs, ARRAY_SIZE(concat_devs), "flash");
+
+	mtd_device_register(mtd, multi_pdata->parts, multi_pdata->nr_parts);
+}
+
+static void mtd_concat_add(struct mtd_info *mtd)
+{
+	static bool registered = false;
+
+	if (registered)
+		return;
+
+	if (!strcmp(mtd->name, "spi0.0"))
+		concat_devs[0] = mtd;
+	else if (!strcmp(mtd->name, "spi0.1"))
+		concat_devs[1] = mtd;
+	else
+		return;
+
+	if (!concat_devs[0] || !concat_devs[1])
+		return;
+
+	registered = true;
+	INIT_WORK(&mtd_concat_work, mtd_concat_add_work);
+	schedule_work(&mtd_concat_work);
+}
+
+static void mtd_concat_remove(struct mtd_info *mtd)
+{
+}
+
+static void add_mtd_concat_notifier(void)
+{
+	static struct mtd_notifier not = {
+		.add = mtd_concat_add,
+		.remove = mtd_concat_remove,
+	};
+
+	register_mtd_user(&not);
+}
+
+
+void __init ath79_register_m25p80_multi(struct flash_platform_data *pdata)
+{
+	multi_pdata = pdata;
+	add_mtd_concat_notifier();
+	ath79_spi_data.bus_num = 0;
+	ath79_spi_data.num_chipselect = 2;
+	ath79_spi0_cdata.is_flash = true;
+	ath79_register_spi(&ath79_spi_data, ath79_spi_info, 2);
+}
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-m25p80.h linux-4.1.13/arch/mips/ath79/dev-m25p80.h
--- linux-4.1.13.orig/arch/mips/ath79/dev-m25p80.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-m25p80.h	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,17 @@
+/*
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_M25P80_H
+#define _ATH79_DEV_M25P80_H
+
+#include <linux/spi/flash.h>
+
+void ath79_register_m25p80(struct flash_platform_data *pdata) __init;
+void ath79_register_m25p80_multi(struct flash_platform_data *pdata) __init;
+
+#endif /* _ATH79_DEV_M25P80_H */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-nfc.c linux-4.1.13/arch/mips/ath79/dev-nfc.c
--- linux-4.1.13.orig/arch/mips/ath79/dev-nfc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-nfc.c	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,141 @@
+/*
+ *  Atheros AR934X SoCs built-in NAND flash controller support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-nfc.h"
+
+static struct resource ath79_nfc_resources[2];
+static u64 ar934x_nfc_dmamask = DMA_BIT_MASK(32);
+static struct ar934x_nfc_platform_data ath79_nfc_data;
+
+static struct platform_device ath79_nfc_device = {
+	.name		= AR934X_NFC_DRIVER_NAME,
+	.id		= -1,
+	.resource	= ath79_nfc_resources,
+	.num_resources	= ARRAY_SIZE(ath79_nfc_resources),
+	.dev = {
+		.dma_mask = &ar934x_nfc_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &ath79_nfc_data,
+	},
+};
+
+static void __init ath79_nfc_init_resource(struct resource res[2],
+					   unsigned long base,
+					   unsigned long size,
+					   int irq)
+{
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	res[0].flags = IORESOURCE_MEM;
+	res[0].start = base;
+	res[0].end = base + size - 1;
+
+	res[1].flags = IORESOURCE_IRQ;
+	res[1].start = irq;
+	res[1].end = irq;
+}
+
+static void ar934x_nfc_hw_reset(bool active)
+{
+	if (active) {
+		ath79_device_reset_set(AR934X_RESET_NANDF);
+		udelay(100);
+
+		ath79_device_reset_set(AR934X_RESET_ETH_SWITCH_ANALOG);
+		udelay(250);
+	} else {
+		ath79_device_reset_clear(AR934X_RESET_ETH_SWITCH_ANALOG);
+		udelay(250);
+
+		ath79_device_reset_clear(AR934X_RESET_NANDF);
+		udelay(100);
+	}
+}
+
+static void ar934x_nfc_setup(void)
+{
+	ath79_nfc_data.hw_reset = ar934x_nfc_hw_reset;
+
+	ath79_nfc_init_resource(ath79_nfc_resources,
+				AR934X_NFC_BASE, AR934X_NFC_SIZE,
+				ATH79_MISC_IRQ(21));
+
+	platform_device_register(&ath79_nfc_device);
+}
+
+static void qca955x_nfc_hw_reset(bool active)
+{
+	if (active) {
+		ath79_device_reset_set(QCA955X_RESET_NANDF);
+		udelay(250);
+	} else {
+		ath79_device_reset_clear(QCA955X_RESET_NANDF);
+		udelay(100);
+	}
+}
+
+static void qca955x_nfc_setup(void)
+{
+	ath79_nfc_data.hw_reset = qca955x_nfc_hw_reset;
+
+	ath79_nfc_init_resource(ath79_nfc_resources,
+				QCA955X_NFC_BASE, QCA955X_NFC_SIZE,
+				ATH79_MISC_IRQ(21));
+
+	platform_device_register(&ath79_nfc_device);
+}
+
+void __init ath79_nfc_set_select_chip(void (*f)(int chip_no))
+{
+	ath79_nfc_data.select_chip = f;
+}
+
+void __init ath79_nfc_set_scan_fixup(int (*f)(struct mtd_info *mtd))
+{
+	ath79_nfc_data.scan_fixup = f;
+}
+
+void __init ath79_nfc_set_swap_dma(bool enable)
+{
+	ath79_nfc_data.swap_dma = enable;
+}
+
+void __init ath79_nfc_set_ecc_mode(enum ar934x_nfc_ecc_mode mode)
+{
+	ath79_nfc_data.ecc_mode = mode;
+}
+
+void __init ath79_nfc_set_parts(struct mtd_partition *parts, int nr_parts)
+{
+	ath79_nfc_data.parts = parts;
+	ath79_nfc_data.nr_parts = nr_parts;
+}
+
+void __init ath79_register_nfc(void)
+{
+	if (soc_is_ar934x())
+		ar934x_nfc_setup();
+	else if (soc_is_qca955x())
+		qca955x_nfc_setup();
+	else
+		BUG();
+}
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-nfc.h linux-4.1.13/arch/mips/ath79/dev-nfc.h
--- linux-4.1.13.orig/arch/mips/ath79/dev-nfc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-nfc.h	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,34 @@
+/*
+ *  Atheros AR934X SoCs built-in NAND Flash Controller support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_NFC_H
+#define _ATH79_DEV_NFC_H
+
+struct mtd_partition;
+enum ar934x_nfc_ecc_mode;
+
+#ifdef CONFIG_ATH79_DEV_NFC
+void ath79_nfc_set_parts(struct mtd_partition *parts, int nr_parts);
+void ath79_nfc_set_select_chip(void (*f)(int chip_no));
+void ath79_nfc_set_scan_fixup(int (*f)(struct mtd_info *mtd));
+void ath79_nfc_set_swap_dma(bool enable);
+void ath79_nfc_set_ecc_mode(enum ar934x_nfc_ecc_mode mode);
+void ath79_register_nfc(void);
+#else
+static inline void ath79_nfc_set_parts(struct mtd_partition *parts,
+				       int nr_parts) {}
+static inline void ath79_nfc_set_select_chip(void (*f)(int chip_no)) {}
+static inline void ath79_nfc_set_scan_fixup(int (*f)(struct mtd_info *mtd)) {}
+static inline void ath79_nfc_set_swap_dma(bool enable) {}
+static inline void ath79_nfc_set_ecc_mode(enum ar934x_nfc_ecc_mode mode) {}
+static inline void ath79_register_nfc(void) {}
+#endif
+
+#endif /* _ATH79_DEV_NFC_H */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-usb.c linux-4.1.13/arch/mips/ath79/dev-usb.c
--- linux-4.1.13.orig/arch/mips/ath79/dev-usb.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-usb.c	2015-12-04 19:57:04.478071913 +0100
@@ -37,6 +37,8 @@
 static struct usb_ehci_pdata ath79_ehci_pdata_v2 = {
 	.caps_offset		= 0x100,
 	.has_tt			= 1,
+	.qca_force_host_mode	= 1,
+	.qca_force_16bit_ptw	= 1,
 };
 
 static void __init ath79_usb_register(const char *name, int id,
@@ -159,6 +161,9 @@
 	ath79_device_reset_clear(AR913X_RESET_USB_PHY);
 	mdelay(10);
 
+	ath79_ehci_pdata_v2.qca_force_host_mode	= 0;
+	ath79_ehci_pdata_v2.qca_force_16bit_ptw	= 0;
+
 	ath79_usb_register("ehci-platform", -1,
 			   AR913X_EHCI_BASE, AR913X_EHCI_SIZE,
 			   ATH79_CPU_IRQ(3),
@@ -182,14 +187,34 @@
 			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
 }
 
-static void __init ar934x_usb_setup(void)
+static void enable_tx_tx_idp_violation_fix(unsigned base)
 {
-	u32 bootstrap;
+	void __iomem *phy_reg;
+	u32 t;
 
-	bootstrap = ath79_reset_rr(AR934X_RESET_REG_BOOTSTRAP);
-	if (bootstrap & AR934X_BOOTSTRAP_USB_MODE_DEVICE)
+	phy_reg = ioremap(base, 4);
+	if (!phy_reg)
 		return;
 
+	t = ioread32(phy_reg);
+	t &= ~0xff;
+	t |= 0x58;
+	iowrite32(t, phy_reg);
+
+	iounmap(phy_reg);
+}
+
+static void ar934x_usb_reset_notifier(struct platform_device *pdev)
+{
+	if (pdev->id != -1)
+		return;
+
+	enable_tx_tx_idp_violation_fix(0x18116c94);
+	dev_info(&pdev->dev, "TX-TX IDP fix enabled\n");
+}
+
+static void __init ar934x_usb_setup(void)
+{
 	ath79_device_reset_set(AR934X_RESET_USBSUS_OVERRIDE);
 	udelay(1000);
 
@@ -202,14 +227,64 @@
 	ath79_device_reset_clear(AR934X_RESET_USB_HOST);
 	udelay(1000);
 
+	if (ath79_soc_rev >= 3)
+		ath79_ehci_pdata_v2.reset_notifier = ar934x_usb_reset_notifier;
+
 	ath79_usb_register("ehci-platform", -1,
 			   AR934X_EHCI_BASE, AR934X_EHCI_SIZE,
 			   ATH79_CPU_IRQ(3),
 			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
 }
 
+static void __init qca953x_usb_setup(void)
+{
+	u32 bootstrap;
+
+	bootstrap = ath79_reset_rr(QCA953X_RESET_REG_BOOTSTRAP);
+
+	ath79_device_reset_set(QCA953X_RESET_USBSUS_OVERRIDE);
+	udelay(1000);
+
+	ath79_device_reset_clear(QCA953X_RESET_USB_PHY);
+	udelay(1000);
+
+	ath79_device_reset_clear(QCA953X_RESET_USB_PHY_ANALOG);
+	udelay(1000);
+
+	ath79_device_reset_clear(QCA953X_RESET_USB_HOST);
+	udelay(1000);
+
+	ath79_usb_register("ehci-platform", -1,
+			   QCA953X_EHCI_BASE, QCA953X_EHCI_SIZE,
+			   ATH79_CPU_IRQ(3),
+			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+}
+
+static void qca955x_usb_reset_notifier(struct platform_device *pdev)
+{
+	u32 base;
+
+	switch (pdev->id) {
+	case 0:
+		base = 0x18116c94;
+		break;
+
+	case 1:
+		base = 0x18116e54;
+		break;
+
+	default:
+		return;
+	}
+
+	enable_tx_tx_idp_violation_fix(base);
+	dev_info(&pdev->dev, "TX-TX IDP fix enabled\n");
+}
+
 static void __init qca955x_usb_setup(void)
 {
+	ath79_ehci_pdata_v2.reset_notifier = qca955x_usb_reset_notifier;
+
 	ath79_usb_register("ehci-platform", 0,
 			   QCA955X_EHCI0_BASE, QCA955X_EHCI_SIZE,
 			   ATH79_IP3_IRQ(0),
@@ -221,6 +296,19 @@
 			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
 }
 
+static void __init qca956x_usb_setup(void)
+{
+	ath79_usb_register("ehci-platform", 0,
+			   QCA956X_EHCI0_BASE, QCA956X_EHCI_SIZE,
+			   ATH79_IP3_IRQ(0),
+			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+
+	ath79_usb_register("ehci-platform", 1,
+			   QCA956X_EHCI1_BASE, QCA956X_EHCI_SIZE,
+			   ATH79_IP3_IRQ(1),
+			   &ath79_ehci_pdata_v2, sizeof(ath79_ehci_pdata_v2));
+}
+
 void __init ath79_register_usb(void)
 {
 	if (soc_is_ar71xx())
@@ -235,8 +323,12 @@
 		ar933x_usb_setup();
 	else if (soc_is_ar934x())
 		ar934x_usb_setup();
+	else if (soc_is_qca953x())
+		qca953x_usb_setup();
 	else if (soc_is_qca955x())
 		qca955x_usb_setup();
+	else if (soc_is_qca9561())
+		qca956x_usb_setup();
 	else
 		BUG();
 }
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-wmac.c linux-4.1.13/arch/mips/ath79/dev-wmac.c
--- linux-4.1.13.orig/arch/mips/ath79/dev-wmac.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-wmac.c	2015-12-04 19:57:04.506070082 +0100
@@ -15,14 +15,21 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/irq.h>
+#include <linux/etherdevice.h>
 #include <linux/platform_device.h>
 #include <linux/ath9k_platform.h>
+#include <linux/gpio.h>
 
 #include <asm/mach-ath79/ath79.h>
 #include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
 #include "dev-wmac.h"
 
-static struct ath9k_platform_data ath79_wmac_data;
+static u8 ath79_wmac_mac[ETH_ALEN];
+
+static struct ath9k_platform_data ath79_wmac_data = {
+	.led_pin = -1,
+};
 
 static struct resource ath79_wmac_resources[] = {
 	{
@@ -44,7 +51,7 @@
 	},
 };
 
-static void __init ar913x_wmac_setup(void)
+static int ar913x_wmac_reset(void)
 {
 	/* reset the WMAC */
 	ath79_device_reset_set(AR913X_RESET_AMBA2WMAC);
@@ -53,22 +60,48 @@
 	ath79_device_reset_clear(AR913X_RESET_AMBA2WMAC);
 	mdelay(10);
 
+	return 0;
+}
+
+static void __init ar913x_wmac_setup(void)
+{
+	ar913x_wmac_reset();
+
 	ath79_wmac_resources[0].start = AR913X_WMAC_BASE;
 	ath79_wmac_resources[0].end = AR913X_WMAC_BASE + AR913X_WMAC_SIZE - 1;
 	ath79_wmac_resources[1].start = ATH79_CPU_IRQ(2);
 	ath79_wmac_resources[1].end = ATH79_CPU_IRQ(2);
+
+	ath79_wmac_data.external_reset = ar913x_wmac_reset;
 }
 
 
 static int ar933x_wmac_reset(void)
 {
+	int retries = 20;
+
 	ath79_device_reset_set(AR933X_RESET_WMAC);
 	ath79_device_reset_clear(AR933X_RESET_WMAC);
 
-	return 0;
+	while (1) {
+		u32 bootstrap;
+
+		bootstrap = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+		if ((bootstrap & AR933X_BOOTSTRAP_EEPBUSY) == 0)
+			return 0;
+
+		if (retries-- == 0)
+			break;
+
+		udelay(10000);
+		retries++;
+	}
+
+	pr_err("ar933x: WMAC reset timed out");
+	return -ETIMEDOUT;
 }
 
-static int ar933x_r1_get_wmac_revision(void)
+static int ar93xx_get_soc_revision(void)
 {
 	return ath79_soc_rev;
 }
@@ -93,7 +126,7 @@
 		ath79_wmac_data.is_clk_25mhz = true;
 
 	if (ath79_soc_rev == 1)
-		ath79_wmac_data.get_mac_revision = ar933x_r1_get_wmac_revision;
+		ath79_wmac_data.get_mac_revision = ar93xx_get_soc_revision;
 
 	ath79_wmac_data.external_reset = ar933x_wmac_reset;
 }
@@ -114,6 +147,28 @@
 		ath79_wmac_data.is_clk_25mhz = false;
 	else
 		ath79_wmac_data.is_clk_25mhz = true;
+
+	ath79_wmac_data.get_mac_revision = ar93xx_get_soc_revision;
+}
+
+static void qca953x_wmac_setup(void)
+{
+	u32 t;
+
+	ath79_wmac_device.name = "qca953x_wmac";
+
+	ath79_wmac_resources[0].start = QCA953X_WMAC_BASE;
+	ath79_wmac_resources[0].end = QCA953X_WMAC_BASE + QCA953X_WMAC_SIZE - 1;
+	ath79_wmac_resources[1].start = ATH79_IP2_IRQ(1);
+	ath79_wmac_resources[1].end = ATH79_IP2_IRQ(1);
+
+	t = ath79_reset_rr(QCA953X_RESET_REG_BOOTSTRAP);
+	if (t & QCA953X_BOOTSTRAP_REF_CLK_40)
+		ath79_wmac_data.is_clk_25mhz = false;
+	else
+		ath79_wmac_data.is_clk_25mhz = true;
+
+	ath79_wmac_data.get_mac_revision = ar93xx_get_soc_revision;
 }
 
 static void qca955x_wmac_setup(void)
@@ -134,7 +189,221 @@
 		ath79_wmac_data.is_clk_25mhz = true;
 }
 
-void __init ath79_register_wmac(u8 *cal_data)
+static void qca956x_wmac_setup(void)
+{
+	u32 t;
+
+	ath79_wmac_device.name = "qca956x_wmac";
+
+	ath79_wmac_resources[0].start = QCA956X_WMAC_BASE;
+	ath79_wmac_resources[0].end = QCA956X_WMAC_BASE + QCA956X_WMAC_SIZE - 1;
+	ath79_wmac_resources[1].start = ATH79_IP2_IRQ(1);
+	ath79_wmac_resources[1].end = ATH79_IP2_IRQ(1);
+
+	t = ath79_reset_rr(QCA956X_RESET_REG_BOOTSTRAP);
+	if (t & QCA956X_BOOTSTRAP_REF_CLK_40)
+		ath79_wmac_data.is_clk_25mhz = false;
+	else
+		ath79_wmac_data.is_clk_25mhz = true;
+}
+
+static bool __init
+ar93xx_wmac_otp_read_word(void __iomem *base, int addr, u32 *data)
+{
+	int timeout = 1000;
+	u32 val;
+
+	__raw_readl(base + AR9300_OTP_BASE + (4 * addr));
+	while (timeout--) {
+		val = __raw_readl(base + AR9300_OTP_STATUS);
+		if ((val & AR9300_OTP_STATUS_TYPE) == AR9300_OTP_STATUS_VALID)
+			break;
+
+		udelay(10);
+	}
+
+	if (!timeout)
+		return false;
+
+	*data = __raw_readl(base + AR9300_OTP_READ_DATA);
+	return true;
+}
+
+static bool __init
+ar93xx_wmac_otp_read(void __iomem *base, int addr, u8 *dest, int len)
+{
+	u32 data;
+	int i;
+
+	for (i = 0; i < len; i++) {
+		int offset = 8 * ((addr - i) % 4);
+
+		if (!ar93xx_wmac_otp_read_word(base, (addr - i) / 4, &data))
+			return false;
+
+		dest[i] = (data >> offset) & 0xff;
+	}
+
+	return true;
+}
+
+static bool __init
+ar93xx_wmac_otp_uncompress(void __iomem *base, int addr, int len, u8 *dest,
+			   int dest_start, int dest_len)
+{
+	int dest_bytes = 0;
+	int offset = 0;
+	int end = addr - len;
+	u8 hdr[2];
+
+	while (addr > end) {
+		if (!ar93xx_wmac_otp_read(base, addr, hdr, 2))
+			return false;
+
+		addr -= 2;
+		offset += hdr[0];
+
+		if (offset <= dest_start + dest_len &&
+		    offset + len >= dest_start) {
+			int data_offset = 0;
+			int dest_offset = 0;
+			int copy_len;
+
+			if (offset < dest_start)
+				data_offset = dest_start - offset;
+			else
+				dest_offset = offset - dest_start;
+
+			copy_len = len - data_offset;
+			if (copy_len > dest_len - dest_offset)
+				copy_len = dest_len - dest_offset;
+
+			ar93xx_wmac_otp_read(base, addr - data_offset,
+					     dest + dest_offset,
+					     copy_len);
+
+			dest_bytes += copy_len;
+		}
+		addr -= hdr[1];
+	}
+	return !!dest_bytes;
+}
+
+bool __init ar93xx_wmac_read_mac_address(u8 *dest)
+{
+	void __iomem *base;
+	bool ret = false;
+	int addr = 0x1ff;
+	unsigned int len;
+	u32 hdr_u32;
+	u8 *hdr = (u8 *) &hdr_u32;
+	u8 mac[6] = { 0x00, 0x02, 0x03, 0x04, 0x05, 0x06 };
+	int mac_start = 2, mac_end = 8;
+
+	BUG_ON(!soc_is_ar933x() && !soc_is_ar934x());
+	base = ioremap_nocache(AR933X_WMAC_BASE, AR933X_WMAC_SIZE);
+	while (addr > sizeof(hdr)) {
+		if (!ar93xx_wmac_otp_read(base, addr, hdr, sizeof(hdr)))
+			break;
+
+		if (hdr_u32 == 0 || hdr_u32 == ~0)
+			break;
+
+		len = (hdr[1] << 4) | (hdr[2] >> 4);
+		addr -= 4;
+
+		switch (hdr[0] >> 5) {
+		case 0:
+			if (len < mac_end)
+				break;
+
+			ar93xx_wmac_otp_read(base, addr - mac_start, mac, 6);
+			ret = true;
+			break;
+		case 3:
+			ret |= ar93xx_wmac_otp_uncompress(base, addr, len, mac,
+							  mac_start, 6);
+			break;
+		default:
+			break;
+		}
+
+		addr -= len + 2;
+	}
+
+	iounmap(base);
+	if (ret)
+		memcpy(dest, mac, 6);
+
+	return ret;
+}
+
+void __init ath79_wmac_disable_2ghz(void)
+{
+	ath79_wmac_data.disable_2ghz = true;
+}
+
+void __init ath79_wmac_disable_5ghz(void)
+{
+	ath79_wmac_data.disable_5ghz = true;
+}
+
+void __init ath79_wmac_set_tx_gain_buffalo(void)
+{
+	ath79_wmac_data.tx_gain_buffalo = true;
+}
+
+static int ath79_request_ext_lna_gpio(unsigned chain, int gpio)
+{
+	char buf[32];
+	char *label;
+	int err;
+
+	scnprintf(buf, sizeof(buf), "external LNA%u", chain);
+	label = kstrdup(buf, GFP_KERNEL);
+
+	err = gpio_request_one(gpio, GPIOF_DIR_OUT | GPIOF_INIT_LOW, label);
+	if (err) {
+		pr_err("unable to request GPIO%d for external LNA%u\n",
+			gpio, chain);
+		kfree(label);
+	}
+
+	return err;
+}
+
+static void ar934x_set_ext_lna_gpio(unsigned chain, int gpio)
+{
+	unsigned int sel;
+	int err;
+
+	if (WARN_ON(chain > 1))
+		return;
+
+	err = ath79_request_ext_lna_gpio(chain, gpio);
+	if (err)
+		return;
+
+	if (chain == 0)
+		sel = AR934X_GPIO_OUT_EXT_LNA0;
+	else
+		sel = AR934X_GPIO_OUT_EXT_LNA1;
+
+	ath79_gpio_output_select(gpio, sel);
+}
+
+void __init ath79_wmac_set_ext_lna_gpio(unsigned chain, int gpio)
+{
+	if (soc_is_ar934x())
+		ar934x_set_ext_lna_gpio(chain, gpio);
+}
+
+void __init ath79_wmac_set_led_pin(int gpio)
+{
+	ath79_wmac_data.led_pin = gpio;
+}
+
+void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
 {
 	if (soc_is_ar913x())
 		ar913x_wmac_setup();
@@ -142,8 +411,12 @@
 		ar933x_wmac_setup();
 	else if (soc_is_ar934x())
 		ar934x_wmac_setup();
+	else if (soc_is_qca953x())
+		qca953x_wmac_setup();
 	else if (soc_is_qca955x())
 		qca955x_wmac_setup();
+	else if (soc_is_qca956x())
+		qca956x_wmac_setup();
 	else
 		BUG();
 
@@ -151,5 +424,16 @@
 		memcpy(ath79_wmac_data.eeprom_data, cal_data,
 		       sizeof(ath79_wmac_data.eeprom_data));
 
+	if (mac_addr) {
+		memcpy(ath79_wmac_mac, mac_addr, sizeof(ath79_wmac_mac));
+		ath79_wmac_data.macaddr = ath79_wmac_mac;
+	}
+
 	platform_device_register(&ath79_wmac_device);
 }
+
+void __init ath79_register_wmac_simple(void)
+{
+	ath79_register_wmac(NULL, NULL);
+	ath79_wmac_data.eeprom_name = "soc_wmac.eeprom";
+}
diff -Nur linux-4.1.13.orig/arch/mips/ath79/dev-wmac.h linux-4.1.13/arch/mips/ath79/dev-wmac.h
--- linux-4.1.13.orig/arch/mips/ath79/dev-wmac.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/dev-wmac.h	2015-12-04 19:57:04.510069820 +0100
@@ -12,6 +12,14 @@
 #ifndef _ATH79_DEV_WMAC_H
 #define _ATH79_DEV_WMAC_H
 
-void ath79_register_wmac(u8 *cal_data);
+void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
+void ath79_register_wmac_simple(void);
+void ath79_wmac_disable_2ghz(void);
+void ath79_wmac_disable_5ghz(void);
+void ath79_wmac_set_tx_gain_buffalo(void);
+void ath79_wmac_set_ext_lna_gpio(unsigned chain, int gpio);
+void ath79_wmac_set_led_pin(int gpio);
+
+bool ar93xx_wmac_read_mac_address(u8 *dest);
 
 #endif /* _ATH79_DEV_WMAC_H */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/early_printk.c linux-4.1.13/arch/mips/ath79/early_printk.c
--- linux-4.1.13.orig/arch/mips/ath79/early_printk.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/early_printk.c	2015-12-04 19:57:04.478071913 +0100
@@ -56,6 +56,46 @@
 	/* nothing to do */
 }
 
+static void prom_enable_uart(u32 id)
+{
+	void __iomem *gpio_base;
+	u32 uart_en;
+	u32 t;
+
+	switch (id) {
+	case REV_ID_MAJOR_AR71XX:
+		uart_en = AR71XX_GPIO_FUNC_UART_EN;
+		break;
+
+	case REV_ID_MAJOR_AR7240:
+	case REV_ID_MAJOR_AR7241:
+	case REV_ID_MAJOR_AR7242:
+		uart_en = AR724X_GPIO_FUNC_UART_EN;
+		break;
+
+	case REV_ID_MAJOR_AR913X:
+		uart_en = AR913X_GPIO_FUNC_UART_EN;
+		break;
+
+	case REV_ID_MAJOR_AR9330:
+	case REV_ID_MAJOR_AR9331:
+		uart_en = AR933X_GPIO_FUNC_UART_EN;
+		break;
+
+	case REV_ID_MAJOR_AR9341:
+	case REV_ID_MAJOR_AR9342:
+	case REV_ID_MAJOR_AR9344:
+		/* TODO */
+	default:
+		return;
+	}
+
+	gpio_base = (void __iomem *)(KSEG1ADDR(AR71XX_GPIO_BASE));
+	t = __raw_readl(gpio_base + AR71XX_GPIO_REG_FUNC);
+	t |= uart_en;
+	__raw_writel(t, gpio_base + AR71XX_GPIO_REG_FUNC);
+}
+
 static void prom_putchar_init(void)
 {
 	void __iomem *base;
@@ -74,8 +114,12 @@
 	case REV_ID_MAJOR_AR9341:
 	case REV_ID_MAJOR_AR9342:
 	case REV_ID_MAJOR_AR9344:
+	case REV_ID_MAJOR_QCA9533:
+	case REV_ID_MAJOR_QCA9533_V2:
 	case REV_ID_MAJOR_QCA9556:
 	case REV_ID_MAJOR_QCA9558:
+	case REV_ID_MAJOR_TP9343:
+	case REV_ID_MAJOR_QCA9561:
 		_prom_putchar = prom_putchar_ar71xx;
 		break;
 
@@ -86,8 +130,10 @@
 
 	default:
 		_prom_putchar = prom_putchar_dummy;
-		break;
+		return;
 	}
+
+	prom_enable_uart(id);
 }
 
 void prom_putchar(unsigned char ch)
diff -Nur linux-4.1.13.orig/arch/mips/ath79/gpio.c linux-4.1.13/arch/mips/ath79/gpio.c
--- linux-4.1.13.orig/arch/mips/ath79/gpio.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/gpio.c	2015-12-04 19:57:05.893979276 +0100
@@ -20,15 +20,29 @@
 #include <linux/io.h>
 #include <linux/ioport.h>
 #include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+#include <linux/of.h>
 
 #include <asm/mach-ath79/ar71xx_regs.h>
 #include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
 #include "common.h"
 
-static void __iomem *ath79_gpio_base;
+void __iomem *ath79_gpio_base;
+EXPORT_SYMBOL_GPL(ath79_gpio_base);
+
 static unsigned long ath79_gpio_count;
 static DEFINE_SPINLOCK(ath79_gpio_lock);
 
+/*
+ * gpio_both_edge is a bitmask of which gpio pins need to have
+ * the detect priority flipped from the interrupt handler to
+ * emulate IRQ_TYPE_EDGE_BOTH.
+ */
+static unsigned long gpio_both_edge = 0;
+
 static void __ath79_gpio_set_value(unsigned gpio, int value)
 {
 	void __iomem *base = ath79_gpio_base;
@@ -128,6 +142,30 @@
 	return 0;
 }
 
+int ath79_gpio_direction_select(unsigned gpio, bool oe)
+{
+	void __iomem *base = ath79_gpio_base;
+	unsigned long flags;
+	bool ieq_1 = (soc_is_ar934x() ||
+			soc_is_qca953x());
+
+	if (gpio >= ath79_gpio_count)
+		return -1;
+
+	spin_lock_irqsave(&ath79_gpio_lock, flags);
+
+	if ((ieq_1 && oe) || (!ieq_1 && !oe))
+		__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) & ~(1 << gpio),
+				base + AR71XX_GPIO_REG_OE);
+	else
+		__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) | (1 << gpio),
+				base + AR71XX_GPIO_REG_OE);
+
+	spin_unlock_irqrestore(&ath79_gpio_lock, flags);
+
+	return 0;
+}
+
 static struct gpio_chip ath79_gpio_chip = {
 	.label			= "ath79",
 	.get			= ath79_gpio_get_value,
@@ -146,7 +184,8 @@
 	    soc_is_ar913x() ||
 	    soc_is_ar933x())
 		reg = AR71XX_GPIO_REG_FUNC;
-	else if (soc_is_ar934x())
+	else if (soc_is_ar934x() ||
+		 soc_is_qca953x() || soc_is_qca956x())
 		reg = AR934X_GPIO_REG_FUNC;
 	else
 		BUG();
@@ -154,6 +193,36 @@
 	return ath79_gpio_base + reg;
 }
 
+static void __iomem *ath79_gpio_get_function2_reg(void)
+{
+	u32 reg = 0;
+
+	if (soc_is_ar71xx() ||
+	    soc_is_ar724x() ||
+	    soc_is_ar913x() ||
+	    soc_is_ar933x())
+		reg = AR71XX_GPIO_REG_FUNC_2;
+	else
+		BUG();
+
+	return ath79_gpio_base + reg;
+}
+
+
+void ath79_gpio_function2_setup(u32 set, u32 clear)
+{
+	void __iomem *reg = ath79_gpio_get_function2_reg();
+	unsigned long flags;
+
+	spin_lock_irqsave(&ath79_gpio_lock, flags);
+
+	__raw_writel((__raw_readl(reg) & ~clear) | set, reg);
+	/* flush write */
+	__raw_readl(reg);
+
+	spin_unlock_irqrestore(&ath79_gpio_lock, flags);
+}
+
 void ath79_gpio_function_setup(u32 set, u32 clear)
 {
 	void __iomem *reg = ath79_gpio_get_function_reg();
@@ -178,6 +247,172 @@
 	ath79_gpio_function_setup(0, mask);
 }
 
+void __init ath79_gpio_output_select(unsigned gpio, u8 val)
+{
+	void __iomem *base = ath79_gpio_base;
+	unsigned long flags;
+	unsigned int reg, reg_base;
+	unsigned long gpio_count;
+	u32 t, s;
+
+	if (soc_is_ar934x()) {
+		gpio_count = AR934X_GPIO_COUNT;
+		reg_base = AR934X_GPIO_REG_OUT_FUNC0;
+	} else if (soc_is_qca953x()) {
+		gpio_count = QCA953X_GPIO_COUNT;
+		reg_base = QCA953X_GPIO_REG_OUT_FUNC0;
+	} else if (soc_is_qca955x()) {
+		gpio_count = QCA955X_GPIO_COUNT;
+		reg_base = QCA955X_GPIO_REG_OUT_FUNC0;
+	} else {
+		BUG();
+	}
+
+	if (gpio >= gpio_count)
+		return;
+
+	reg = reg_base + 4 * (gpio / 4);
+	s = 8 * (gpio % 4);
+
+	spin_lock_irqsave(&ath79_gpio_lock, flags);
+
+	t = __raw_readl(base + reg);
+	t &= ~(0xff << s);
+	t |= val << s;
+	__raw_writel(t, base + reg);
+
+	/* flush write */
+	(void) __raw_readl(base + reg);
+
+	spin_unlock_irqrestore(&ath79_gpio_lock, flags);
+}
+
+static int ath79_gpio_irq_type(struct irq_data *d, unsigned type)
+{
+	int offset = d->irq - ATH79_GPIO_IRQ_BASE;
+	void __iomem *base = ath79_gpio_base;
+	unsigned long flags;
+	unsigned long int_type;
+	unsigned long int_polarity;
+	unsigned long bit = (1 << offset);
+
+	spin_lock_irqsave(&ath79_gpio_lock, flags);
+
+	int_type = __raw_readl(base + AR71XX_GPIO_REG_INT_TYPE);
+	int_polarity = __raw_readl(base + AR71XX_GPIO_REG_INT_POLARITY);
+
+	gpio_both_edge &= ~bit;
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		int_type &= ~bit;
+		int_polarity |= bit;
+		break;
+
+	case IRQ_TYPE_EDGE_FALLING:
+		int_type &= ~bit;
+		int_polarity &= ~bit;
+		break;
+
+	case IRQ_TYPE_LEVEL_HIGH:
+		int_type |= bit;
+		int_polarity |= bit;
+		break;
+
+	case IRQ_TYPE_LEVEL_LOW:
+		int_type |= bit;
+		int_polarity &= ~bit;
+		break;
+
+	case IRQ_TYPE_EDGE_BOTH:
+		int_type |= bit;
+		/* set polarity based on current value */
+		if (gpio_get_value(offset)) {
+			int_polarity &= ~bit;
+		} else {
+			int_polarity |= bit;
+		}
+		/* flip this gpio in the interrupt handler */
+		gpio_both_edge |= bit;
+		break;
+
+	default:
+		spin_unlock_irqrestore(&ath79_gpio_lock, flags);
+		return -EINVAL;
+	}
+
+	__raw_writel(int_type, base + AR71XX_GPIO_REG_INT_TYPE);
+	__raw_writel(int_polarity, base + AR71XX_GPIO_REG_INT_POLARITY);
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_INT_MODE) | (1 << offset),
+		     base + AR71XX_GPIO_REG_INT_MODE);
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_INT_ENABLE) & ~(1 << offset),
+		     base + AR71XX_GPIO_REG_INT_ENABLE);
+
+	spin_unlock_irqrestore(&ath79_gpio_lock, flags);
+	return 0;
+}
+
+static void ath79_gpio_irq_enable(struct irq_data *d)
+{
+	int offset = d->irq - ATH79_GPIO_IRQ_BASE;
+	void __iomem *base = ath79_gpio_base;
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_INT_ENABLE) | (1 << offset),
+		     base + AR71XX_GPIO_REG_INT_ENABLE);
+}
+
+static void ath79_gpio_irq_disable(struct irq_data *d)
+{
+	int offset = d->irq - ATH79_GPIO_IRQ_BASE;
+	void __iomem *base = ath79_gpio_base;
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_INT_ENABLE) & ~(1 << offset),
+		     base + AR71XX_GPIO_REG_INT_ENABLE);
+}
+
+static struct irq_chip ath79_gpio_irqchip = {
+	.name = "GPIO",
+	.irq_enable = ath79_gpio_irq_enable,
+	.irq_disable = ath79_gpio_irq_disable,
+	.irq_set_type = ath79_gpio_irq_type,
+};
+
+static irqreturn_t ath79_gpio_irq(int irq, void *dev)
+{
+	void __iomem *base = ath79_gpio_base;
+	unsigned long stat = __raw_readl(base + AR71XX_GPIO_REG_INT_PENDING);
+	int bit_num;
+
+	for_each_set_bit(bit_num, &stat, sizeof(stat) * BITS_PER_BYTE) {
+		unsigned long bit = BIT(bit_num);
+
+		if (bit & gpio_both_edge) {
+			__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_INT_POLARITY) ^ bit,
+				base + AR71XX_GPIO_REG_INT_POLARITY);
+		}
+
+		generic_handle_irq(ATH79_GPIO_IRQ(bit_num));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init ath79_gpio_irq_init(struct gpio_chip *chip)
+{
+	int irq;
+	int irq_base = ATH79_GPIO_IRQ_BASE;
+
+	for (irq = irq_base; irq < irq_base + chip->ngpio; irq++) {
+		irq_set_chip_data(irq, chip);
+		irq_set_chip_and_handler(irq, &ath79_gpio_irqchip, handle_simple_irq);
+		irq_set_noprobe(irq);
+	}
+
+	return 0;
+}
+
 void __init ath79_gpio_init(void)
 {
 	int err;
@@ -194,14 +429,19 @@
 		ath79_gpio_count = AR933X_GPIO_COUNT;
 	else if (soc_is_ar934x())
 		ath79_gpio_count = AR934X_GPIO_COUNT;
+	else if (soc_is_qca953x())
+		ath79_gpio_count = QCA953X_GPIO_COUNT;
 	else if (soc_is_qca955x())
 		ath79_gpio_count = QCA955X_GPIO_COUNT;
+	else if (soc_is_qca956x())
+		ath79_gpio_count = QCA956X_GPIO_COUNT;
 	else
 		BUG();
 
 	ath79_gpio_base = ioremap_nocache(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE);
 	ath79_gpio_chip.ngpio = ath79_gpio_count;
-	if (soc_is_ar934x() || soc_is_qca955x()) {
+	if (soc_is_ar934x() || soc_is_qca953x() || soc_is_qca955x() ||
+	    soc_is_qca956x()) {
 		ath79_gpio_chip.direction_input = ar934x_gpio_direction_input;
 		ath79_gpio_chip.direction_output = ar934x_gpio_direction_output;
 	}
@@ -209,6 +449,10 @@
 	err = gpiochip_add(&ath79_gpio_chip);
 	if (err)
 		panic("cannot add AR71xx GPIO chip, error=%d", err);
+
+	ath79_gpio_irq_init(&ath79_gpio_chip);
+
+	request_irq(ATH79_MISC_IRQ(2), ath79_gpio_irq, 0, "ath79-gpio", NULL);
 }
 
 int gpio_get_value(unsigned gpio)
@@ -231,14 +475,22 @@
 
 int gpio_to_irq(unsigned gpio)
 {
-	/* FIXME */
-	return -EINVAL;
+	if (gpio > ath79_gpio_count) {
+		return -EINVAL;
+	}
+
+	return ATH79_GPIO_IRQ_BASE + gpio;
 }
 EXPORT_SYMBOL(gpio_to_irq);
 
 int irq_to_gpio(unsigned irq)
 {
-	/* FIXME */
-	return -EINVAL;
+	unsigned gpio = irq - ATH79_GPIO_IRQ_BASE;
+
+	if (gpio > ath79_gpio_count) {
+		return -EINVAL;
+	}
+
+	return gpio;
 }
 EXPORT_SYMBOL(irq_to_gpio);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/irq.c linux-4.1.13/arch/mips/ath79/irq.c
--- linux-4.1.13.orig/arch/mips/ath79/irq.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/irq.c	2015-12-04 19:57:04.498070605 +0100
@@ -26,6 +26,8 @@
 
 static void (*ath79_ip2_handler)(void);
 static void (*ath79_ip3_handler)(void);
+static struct irq_chip ip2_chip;
+static struct irq_chip ip3_chip;
 
 static void ath79_misc_irq_handler(unsigned int irq, struct irq_desc *desc)
 {
@@ -106,7 +108,9 @@
 	else if (soc_is_ar724x() ||
 		 soc_is_ar933x() ||
 		 soc_is_ar934x() ||
-		 soc_is_qca955x())
+		 soc_is_qca953x() ||
+		 soc_is_qca955x() ||
+		 soc_is_qca956x())
 		ath79_misc_irq_chip.irq_ack = ar724x_misc_irq_ack;
 	else
 		BUG();
@@ -147,12 +151,43 @@
 
 	for (i = ATH79_IP2_IRQ_BASE;
 	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
-		irq_set_chip_and_handler(i, &dummy_irq_chip,
-					 handle_level_irq);
+		irq_set_chip_and_handler(i, &ip2_chip, handle_level_irq);
 
 	irq_set_chained_handler(ATH79_CPU_IRQ(2), ar934x_ip2_irq_dispatch);
 }
 
+static void qca953x_ip2_irq_dispatch(unsigned int irq, struct irq_desc *desc)
+{
+	u32 status;
+
+	disable_irq_nosync(irq);
+
+	status = ath79_reset_rr(QCA953X_RESET_REG_PCIE_WMAC_INT_STATUS);
+
+	if (status & QCA953X_PCIE_WMAC_INT_PCIE_ALL) {
+		ath79_ddr_wb_flush(QCA953X_DDR_REG_FLUSH_PCIE);
+		generic_handle_irq(ATH79_IP2_IRQ(0));
+	} else if (status & QCA953X_PCIE_WMAC_INT_WMAC_ALL) {
+		ath79_ddr_wb_flush(QCA953X_DDR_REG_FLUSH_WMAC);
+		generic_handle_irq(ATH79_IP2_IRQ(1));
+	} else {
+		spurious_interrupt();
+	}
+
+	enable_irq(irq);
+}
+
+static void qca953x_irq_init(void)
+{
+	int i;
+
+	for (i = ATH79_IP2_IRQ_BASE;
+	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ip2_chip, handle_level_irq);
+
+	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca953x_ip2_irq_dispatch);
+}
+
 static void qca955x_ip2_irq_dispatch(unsigned int irq, struct irq_desc *desc)
 {
 	u32 status;
@@ -222,19 +257,108 @@
 
 	for (i = ATH79_IP2_IRQ_BASE;
 	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
-		irq_set_chip_and_handler(i, &dummy_irq_chip,
-					 handle_level_irq);
+		irq_set_chip_and_handler(i, &ip2_chip, handle_level_irq);
 
 	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca955x_ip2_irq_dispatch);
 
 	for (i = ATH79_IP3_IRQ_BASE;
 	     i < ATH79_IP3_IRQ_BASE + ATH79_IP3_IRQ_COUNT; i++)
-		irq_set_chip_and_handler(i, &dummy_irq_chip,
-					 handle_level_irq);
+		irq_set_chip_and_handler(i, &ip3_chip, handle_level_irq);
 
 	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca955x_ip3_irq_dispatch);
 }
 
+static void qca956x_ip2_irq_dispatch(unsigned int irq, struct irq_desc *desc)
+{
+	u32 status;
+
+	disable_irq_nosync(irq);
+
+	status = ath79_reset_rr(QCA956X_RESET_REG_EXT_INT_STATUS);
+	status &= QCA956X_EXT_INT_PCIE_RC1_ALL | QCA956X_EXT_INT_WMAC_ALL;
+
+	if (status == 0) {
+		spurious_interrupt();
+		goto enable;
+	}
+
+	if (status & QCA956X_EXT_INT_PCIE_RC1_ALL) {
+		/* TODO: flush DDR? */
+		generic_handle_irq(ATH79_IP2_IRQ(0));
+	}
+
+	if (status & QCA956X_EXT_INT_WMAC_ALL) {
+		/* TODO: flsuh DDR? */
+		generic_handle_irq(ATH79_IP2_IRQ(1));
+	}
+
+enable:
+	enable_irq(irq);
+}
+
+static void qca956x_ip3_irq_dispatch(unsigned int irq, struct irq_desc *desc)
+{
+	u32 status;
+
+	disable_irq_nosync(irq);
+
+	status = ath79_reset_rr(QCA956X_RESET_REG_EXT_INT_STATUS);
+	status &= QCA956X_EXT_INT_PCIE_RC2_ALL |
+		  QCA956X_EXT_INT_USB1 | QCA956X_EXT_INT_USB2;
+
+	if (status == 0) {
+		spurious_interrupt();
+		goto enable;
+	}
+
+	if (status & QCA956X_EXT_INT_USB1) {
+		/* TODO: flush DDR? */
+		generic_handle_irq(ATH79_IP3_IRQ(0));
+	}
+
+	if (status & QCA956X_EXT_INT_USB2) {
+		/* TODO: flush DDR? */
+		generic_handle_irq(ATH79_IP3_IRQ(1));
+	}
+
+	if (status & QCA956X_EXT_INT_PCIE_RC2_ALL) {
+		/* TODO: flush DDR? */
+		generic_handle_irq(ATH79_IP3_IRQ(2));
+	}
+
+enable:
+	enable_irq(irq);
+}
+
+static void qca956x_enable_timer_cb(void) {
+	u32 misc;
+
+	misc = ath79_reset_rr(AR71XX_RESET_REG_MISC_INT_ENABLE);
+	misc |= MISC_INT_MIPS_SI_TIMERINT_MASK;
+	ath79_reset_wr(AR71XX_RESET_REG_MISC_INT_ENABLE, misc);
+}
+
+static void qca956x_irq_init(void)
+{
+	int i;
+
+	for (i = ATH79_IP2_IRQ_BASE;
+	     i < ATH79_IP2_IRQ_BASE + ATH79_IP2_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ip2_chip, handle_level_irq);
+
+	irq_set_chained_handler(ATH79_CPU_IRQ(2), qca956x_ip2_irq_dispatch);
+
+	for (i = ATH79_IP3_IRQ_BASE;
+	     i < ATH79_IP3_IRQ_BASE + ATH79_IP3_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ip3_chip, handle_level_irq);
+
+	irq_set_chained_handler(ATH79_CPU_IRQ(3), qca956x_ip3_irq_dispatch);
+
+	/* QCA956x timer init workaround has to be applied right before setting
+	 * up the clock. Else, there will be no jiffies */
+	late_time_init = &qca956x_enable_timer_cb;
+}
+
 asmlinkage void plat_irq_dispatch(void)
 {
 	unsigned long pending;
@@ -335,8 +459,41 @@
 	do_IRQ(ATH79_CPU_IRQ(3));
 }
 
+static void qca953x_ip3_handler(void)
+{
+	ath79_ddr_wb_flush(QCA953X_DDR_REG_FLUSH_USB);
+	do_IRQ(ATH79_CPU_IRQ(3));
+}
+
+static void ath79_ip2_disable(struct irq_data *data)
+{
+	disable_irq(ATH79_CPU_IRQ(2));
+}
+
+static void ath79_ip2_enable(struct irq_data *data)
+{
+	enable_irq(ATH79_CPU_IRQ(2));
+}
+
+static void ath79_ip3_disable(struct irq_data *data)
+{
+	disable_irq(ATH79_CPU_IRQ(3));
+}
+
+static void ath79_ip3_enable(struct irq_data *data)
+{
+	enable_irq(ATH79_CPU_IRQ(3));
+}
+
 void __init arch_init_irq(void)
 {
+	ip2_chip = dummy_irq_chip;
+	ip3_chip = dummy_irq_chip;
+	ip2_chip.irq_disable = ath79_ip2_disable;
+	ip2_chip.irq_enable = ath79_ip2_enable;
+	ip3_chip.irq_disable = ath79_ip3_disable;
+	ip3_chip.irq_enable = ath79_ip3_enable;
+
 	if (soc_is_ar71xx()) {
 		ath79_ip2_handler = ar71xx_ip2_handler;
 		ath79_ip3_handler = ar71xx_ip3_handler;
@@ -352,9 +509,15 @@
 	} else if (soc_is_ar934x()) {
 		ath79_ip2_handler = ath79_default_ip2_handler;
 		ath79_ip3_handler = ar934x_ip3_handler;
+	} else if (soc_is_qca953x()) {
+		ath79_ip2_handler = ath79_default_ip2_handler;
+		ath79_ip3_handler = qca953x_ip3_handler;
 	} else if (soc_is_qca955x()) {
 		ath79_ip2_handler = ath79_default_ip2_handler;
 		ath79_ip3_handler = ath79_default_ip3_handler;
+	} else if (soc_is_qca956x()) {
+		ath79_ip2_handler = ath79_default_ip2_handler;
+		ath79_ip3_handler = ath79_default_ip3_handler;
 	} else {
 		BUG();
 	}
@@ -364,6 +527,10 @@
 
 	if (soc_is_ar934x())
 		ar934x_ip2_irq_init();
+	else if (soc_is_qca953x())
+		qca953x_irq_init();
 	else if (soc_is_qca955x())
 		qca955x_irq_init();
+	else if (soc_is_qca956x())
+		qca956x_irq_init();
 }
diff -Nur linux-4.1.13.orig/arch/mips/ath79/Kconfig linux-4.1.13/arch/mips/ath79/Kconfig
--- linux-4.1.13.orig/arch/mips/ath79/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/Kconfig	2015-12-04 19:57:05.957975089 +0100
@@ -2,75 +2,1466 @@
 
 menu "Atheros AR71XX/AR724X/AR913X machine selection"
 
+config ATH79_MACH_ALFA_AP96
+	bool "ALFA Network AP96 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_HORNET_UB
+	bool "ALFA Network Hornet-UB board support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ALFA_NX
+	bool "ALFA Network N2/N5 board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TUBE2H
+	bool "ALFA Network Tube2H board support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ALL0258N
+	bool "Allnet ALL0258N support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_ALL0315N
+	bool "Allnet ALL0315N support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_ANTMINER_S1
+	bool "Bitmain Antminer S1 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ANTMINER_S3
+	bool "Bitmain Antminer S3 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ARDUINO_YUN
+	bool "Arduino Yun"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Arduino Yun.
+
+config ATH79_MACH_AP113
+	bool "Atheros AP113 board support"
+	select SOC_AR724X
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_PB9X_PCI if PCI
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_USB
+	select ATH79_DEV_ETH
+
 config ATH79_MACH_AP121
 	bool "Atheros AP121 reference board"
 	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Atheros AP121 reference board.
+
+config ATH79_MACH_AP132
+	bool "Atheros AP132 reference board"
+	select SOC_QCA955X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Atheros AP132 reference boards.
+
+config ATH79_MACH_AP136
+	bool "Atheros AP136/AP135 reference board"
+	select SOC_QCA955X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_NFC
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Atheros AP136 or AP135 reference boards.
+
+config ATH79_MACH_AP143
+	bool "Atheros AP143 reference board"
+	select SOC_QCA953X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_SPI
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_ETH
+	select ATH79_DEV_M25P80
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Atheros AP143 reference board.
+
+config ATH79_MACH_AP147
+	bool "Atheros AP147 reference board"
+	select SOC_QCA953X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_AP9X_PCI if PCI
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  QCA AP147 reference boards.
+
+config ATH79_MACH_AP152
+	bool "Atheros AP152 reference board"
+	select SOC_QCA956X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_AP9X_PCI if PCI
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  QCA AP152 reference boards.
+
+
+config ATH79_MACH_AP81
+	bool "Atheros AP81 reference board"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Atheros AP81 reference board.
+
+config ATH79_MACH_AP83
+	bool "Atheros AP83 board support"
+	select SOC_AR913X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_AP96
+	bool "Atheros AP96 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DB120
+	bool "Atheros DB120 reference board"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Atheros DB120 reference board.
+
+config ATH79_MACH_PB42
+	bool "Atheros PB42 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_PB44
+	bool "Atheros PB44 reference board"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_SPI
+	select ATH79_DEV_USB
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Atheros PB44 reference board.
+
+config ATH79_MACH_PB92
+	bool "Atheros PB92 board support"
+	select SOC_AR724X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_PB9X_PCI if PCI
+	select ATH79_DEV_USB
+
+config ATH79_MACH_AW_NR580
+	bool "AzureWave AW-NR580 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_F9K1115V2
+	bool "Belkin AC1750DB board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EPG5000
+	bool "EnGenius EPG5000 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_ESR1750
+	bool "EnGenius ESR1750 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WHR_HP_G300N
+	bool "Buffalo WHR-HP-G300N board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_WLAE_AG300N
+	bool "Buffalo WLAE-AG300N board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_WLR8100
+	bool "Sitecom WLR-8100 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WZR_HP_AG300H
+	bool "Buffalo WZR-HP-AG300H board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WZR_HP_G300NH
+	bool "Buffalo WZR-HP-G300NH board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select RTL8366_SMI
+
+config ATH79_MACH_WZR_HP_G300NH2
+	bool "Buffalo WZR-HP-G300NH2 board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WZR_HP_G450H
+	bool "Buffalo WZR-HP-G450H board support"
+	select SOC_AR724X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WZR_450HP2
+	bool "Buffalo WZR-450HP2 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WP543
+	bool "Compex WP543/WPJ543 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select MYLOADER
+
+config ATH79_MACH_WPE72
+	bool "Compex WPE72/WPE72NX board support"
+	select SOC_AR724X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select MYLOADER
+
+config ATH79_MACH_WPJ344
+	bool "Compex WPJ344 board support"
+	select SOC_AS934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WPJ531
+       bool "Compex WPJ531 board support"
+       select SOC_QCA953X
+       select ATH79_DEV_ETH
+       select ATH79_DEV_GPIO_BUTTONS
+       select ATH79_DEV_LEDS_GPIO
+       select ATH79_DEV_M25P80
+       select ATH79_DEV_USB
+       select ATH79_DEV_WMAC
+
+config ATH79_MACH_WPJ558
+	bool "Compex WPJ558 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DGL_5500_A1
+	bool "D-Link DGL-5500 A1 support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DHP_1565_A1
+	bool "D-Link DHP-1565 rev. A1 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DIR_505_A1
+	bool "D-Link DIR-505-A1 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_DIR_600_A1
+	bool "D-Link DIR-600 A1/DIR-615 E1/DIR-615 E4 support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_NVRAM
+
+config ATH79_MACH_DIR_615_C1
+	bool "D-Link DIR-615 rev. C1 support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_DIR_615_I1
+	bool "D-Link DIR-615 rev. I1 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_DIR_825_B1
+	bool "D-Link DIR-825 rev. B1 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DIR_825_C1
+	bool "D-Link DIR-825 rev. C1/DIR-835 rev. A1 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DLAN_HOTSPOT
+	bool "devolo dLAN Hotspot support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_DLAN_PRO_500_WP
+	bool "devolo dLAN pro 500 Wireless+ support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DLAN_PRO_1200_AC
+	bool "devolo dLAN pro 1200+ WiFi ac support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+
+config ATH79_MACH_DRAGINO2
+	bool "DRAGINO V2 support"
+	select SOC_AR933X
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_ETH
+	select ATH79_DEV_USB
+
+config ATH79_MACH_ESR900
+	bool "EnGenius ESR900 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EW_DORIN
+	bool "embedded wireless Dorin Platform support"
+	select SOC_AR933X
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_ETH
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Dorin Platform from www.80211.de .
+
+config ATH79_MACH_EL_M150
+	bool "EasyLink EL-M150 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EL_MINI
+	bool "EasyLink EL-MINI support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_AR150
+	bool "GL AR150 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_AR300
+	bool "GL_AR300 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_DOMINO
+	bool "DOMINO support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_INET
+	bool "GL-INET support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EAP300V2
+	bool "EnGenius EAP300 v2 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GS_MINIBOX_V1
+	bool "Gainstrong MiniBox V1.0 support"
+	select SOC_AR933X
+	select ARH79_DEV_ETH
+	select ARH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GS_OOLITE
+       bool "GS Oolite V1 support"
+       select SOC_AR933X
+       select ARH79_DEV_ETH
+       select ARH79_DEV_GPIO_BUTTONS
+       select ATH79_DEV_LEDS_GPIO
+       select ATH79_DEV_M25P80
+       select ATH79_DEV_USB
+       select ATH79_DEV_WMAC
+
+config ATH79_MACH_HIWIFI_HC6361
+	bool "HiWiFi HC6361 board support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_JA76PF
+	bool "jjPlus JA76PF board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_JWAP003
+	bool "jjPlus JWAP003 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WRT160NL
+	bool "Linksys WRT160NL board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_WRT400N
+	bool "Linksys WRT400N board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_R6100
+	bool "NETGEAR R6100 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MC_MAC1200R
+	bool "MERCURY MAC1200R board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_RB4XX
+	bool "MikroTik RouterBOARD 4xx series support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_USB
+
+config ATH79_MACH_RB750
+	bool "MikroTik RouterBOARD 750 support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_USB
+	select ATH79_ROUTERBOOT
+
+config ATH79_MACH_RB91X
+	bool "MikroTik RouterBOARD 91X support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_SPI
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+	select ATH79_ROUTERBOOT
+
+config ATH79_MACH_RB922
+	bool "MikroTik RouterBOARD 922 support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_ROUTERBOOT
+	select RLE_DECOMPRESS
+
+config ATH79_MACH_RB95X
+       bool "MikroTik RouterBOARD 95X support"
+       select SOC_AR934X
+       select ATH79_DEV_ETH
+       select ATH79_DEV_NFC
+       select ATH79_DEV_WMAC
+       select ATH79_DEV_USB
+       select ATH79_ROUTERBOOT
+
+config ATH79_MACH_RB2011
+	bool "MikroTik RouterBOARD 2011 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+	select ATH79_ROUTERBOOT
+
+config ATH79_MACH_RBSXTLITE
+	bool "MikroTik RouterBOARD SXT Lite"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_NFC
+	select ATH79_DEV_WMAC
+	select ATH79_ROUTERBOOT
+
+config ATH79_MACH_SMART_300
+	bool "NC-LINK SMART-300 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WNDAP360
+	bool "NETGEAR WNDAP360 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_WNDR3700
+	bool "NETGEAR WNDR3700 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WNDR4300
+	bool "NETGEAR WNDR3700v4/WNDR4300 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WNR2000
+	bool "NETGEAR WNR2000 board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_WNR2000_V3
+	bool "NETGEAR WNR2000 V3/WNR612 v2/WNR1000 v2 board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+	config ATH79_MACH_WNR2200
+	bool "NETGEAR WNR2200 board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_WNR2000_V4
+	bool "NETGEAR WNR2000 V4"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_OM2P
+	bool "OpenMesh OM2P board support"
+	select SOC_AR724X
+	select SOC_AR933X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_OM5P
+	bool "OpenMesh OM5P board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ONION_OMEGA
+	bool "ONION OMEGA support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR12
+	bool "Meraki MR12 board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR16
+	bool "Meraki MR16 board support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR600
+	bool "OpenMesh MR600 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MZK_W04NU
+	bool "Planex MZK-W04NU board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MZK_W300NH
+	bool "Planex MZK-W300NH board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_RW2458N
+	bool "Redwave RW2458N board support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_CAP4200AG
+	bool "Senao CAP4200AG support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR1750
+	bool "OpenMesh MR1750 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MR900
+	bool "OpenMesh MR900 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_EAP7660D
+	bool "Senao EAP7660D support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_BSB
+	bool "Smart Electronics Black Swift board"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_ARCHER_C7
+	bool "TP-LINK Archer C5/C7/TL-WDR4900 v2 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CPE510
+	bool "TP-LINK CPE510 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_MR11U
+	bool "TP-LINK TL-MR11U/TL-MR3040 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
 	select ATH79_DEV_GPIO_BUTTONS
 	select ATH79_DEV_LEDS_GPIO
-	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
 	select ATH79_DEV_USB
 	select ATH79_DEV_WMAC
-	help
-	  Say 'Y' here if you want your kernel to support the
-	  Atheros AP121 reference board.
 
-config ATH79_MACH_AP136
-	bool "Atheros AP136 reference board"
-	select SOC_QCA955X
+config ATH79_MACH_TL_MR13U
+	bool "TP-LINK TL-MR13U support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
 	select ATH79_DEV_GPIO_BUTTONS
 	select ATH79_DEV_LEDS_GPIO
-	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
 	select ATH79_DEV_USB
 	select ATH79_DEV_WMAC
-	help
-	  Say 'Y' here if you want your kernel to support the
-	  Atheros AP136 reference board.
 
-config ATH79_MACH_AP81
-	bool "Atheros AP81 reference board"
+config ATH79_MACH_TL_MR3020
+	bool "TP-LINK TL-MR3020 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_MR3X20
+	bool "TP-LINK TL-MR3220/3420 support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_TL_WAX50RE
+	bool "TP-LINK TL-WA750/850RE support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA701ND_V2
+	bool "TP-LINK TL-WA701ND v2 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA7210N_V2
+       bool "TP-LINK TL-WA7210N v2 support"
+       select SOC_AR724X
+       select ATH79_DEV_AP9X_PCI if PCI
+       select ATH79_DEV_ETH
+       select ATH79_DEV_LEDS_GPIO
+       select ATH79_DEV_GPIO_BUTTONS
+       select ATH79_DEV_M25P80
+       select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA830RE_V2
+	bool "TP-LINK TL-WA830RE v2 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WA901ND
+	bool "TP-LINK TL-WA901ND/TL-WA7510N support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TL_WA901ND_V2
+	bool "TP-LINK TL-WA901ND v2 support"
 	select SOC_AR913X
+	select ATH79_DEV_ETH
 	select ATH79_DEV_GPIO_BUTTONS
 	select ATH79_DEV_LEDS_GPIO
-	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WDR3320_V2
+	bool "TP-LINK TL-WDR3320 v2 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
 	select ATH79_DEV_USB
 	select ATH79_DEV_WMAC
-	help
-	  Say 'Y' here if you want your kernel to support the
-	  Atheros AP81 reference board.
 
-config ATH79_MACH_DB120
-	bool "Atheros DB120 reference board"
+config ATH79_MACH_TL_WDR3500
+	bool "TP-LINK TL-WDR3500 board support"
 	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
 	select ATH79_DEV_GPIO_BUTTONS
 	select ATH79_DEV_LEDS_GPIO
-	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
 	select ATH79_DEV_USB
 	select ATH79_DEV_WMAC
-	help
-	  Say 'Y' here if you want your kernel to support the
-	  Atheros DB120 reference board.
 
-config ATH79_MACH_PB44
-	bool "Atheros PB44 reference board"
+config ATH79_MACH_TL_WDR4300
+	bool "TP-LINK TL-WDR3600/4300/4310 board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WDR6500_V2
+	bool "TP-LINK TL-WDR6500 v2 board support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR703N
+	bool "TP-LINK TL-WR703N/TL-WR710N/TL-MR10U support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR720N_V3
+	bool "TP-LINK TL-WR720N v3/v4 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR741ND
+	bool "TP-LINK TL-WR741ND support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TL_WR741ND_V4
+	bool "TP-LINK TL-WR741ND v4/TL-MR3220 v2 support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR841N_V1
+	bool "TP-LINK TL-WR841N v1 support"
 	select SOC_AR71XX
+	select ATH79_DEV_DSA
+	select ATH79_DEV_ETH
 	select ATH79_DEV_GPIO_BUTTONS
 	select ATH79_DEV_LEDS_GPIO
-	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_TL_WR841N_V8
+	bool "TP-LINK TL-WR841N/ND v8/TL-MR3420 v2 support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR841N_V9
+       bool "TP-LINK TL-WR841N/ND v9 support"
+       select SOC_QCA953X
+       select ATH79_DEV_ETH
+       select ATH79_DEV_GPIO_BUTTONS
+       select ATH79_DEV_LEDS_GPIO
+       select ATH79_DEV_M25P80
+       select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR941ND
+	bool "TP-LINK TL-WR941ND support"
+	select SOC_AR913X
+	select ATH79_DEV_DSA
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR941ND_V6
+	bool "TP-LINK TL-WR941ND v6 support"
+	select SOC_QCA956X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR1041N_V2
+	bool "TP-LINK TL-WR1041N v2 support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR1043ND
+	bool "TP-LINK TL-WR1043ND support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR1043ND_V2
+	bool "TP-LINK TL-WR1043ND v2 support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_TL_WR2543N
+	bool "TP-LINK TL-WR2543N/ND support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+
+config ATH79_MACH_TEW_632BRP
+	bool "TRENDnet TEW-632BRP support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_TEW_673GRU
+	bool "TRENDnet TEW-673GRU support"
+	select SOC_AR71XX
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_NVRAM
+
+config ATH79_MACH_TEW_712BR
+	bool "TRENDnet TEW-712BR support"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_TEW_732BR
+	bool "TRENDnet TEW-732BR support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_UBNT
+	bool "Ubiquiti AR71xx based boards support"
+	select SOC_AR71XX
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
 	select ATH79_DEV_USB
-	help
-	  Say 'Y' here if you want your kernel to support the
-	  Atheros PB44 reference board.
 
 config ATH79_MACH_UBNT_XM
-	bool "Ubiquiti Networks XM (rev 1.0) board"
+	bool "Ubiquiti Networks XM/UniFi boards"
 	select SOC_AR724X
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
 	select ATH79_DEV_GPIO_BUTTONS
 	select ATH79_DEV_LEDS_GPIO
-	select ATH79_DEV_SPI
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
 	help
 	  Say 'Y' here if you want your kernel to support the
 	  Ubiquiti Networks XM (rev 1.0) board.
 
+config ATH79_MACH_WEIO
+	bool "WeIO board"
+	select SOC_AR933X
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_MYNET_N600
+	bool "WD My Net N600 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_MYNET_N750
+	bool "WD My Net N750 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_MYNET_REXT
+	bool "WD My Net Wi-Fi Range Extender board support"
+	select SOC_AR934X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_NVRAM
+
+config ATH79_MACH_ZCN_1523H
+	bool "Zcomax ZCN-1523H support"
+	select SOC_AR724X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+
+config ATH79_MACH_NBG460N
+	bool "Zyxel NBG460N/550N/550NH board support"
+	select SOC_AR913X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_NBG6716
+	bool "Zyxel NBG6616/NBG6716 board support"
+	select SOC_QCA955X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_NFC
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CARAMBOLA2
+	bool "8devices Carambola2 board"
+	select SOC_AR933X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_CF_E316N_V2
+	bool "COMFAST CF-E316N v2 board"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_BHU_BXU2000N2_A
+	bool "BHU BXU2000n-2 rev. A support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_QIHOO_C301
+	bool "Qihoo 360 C301 board support"
+	select SOC_AR934X
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_WMAC
+	select ATH79_DEV_USB
+	select ATH79_NVRAM
+
 endmenu
 
 config SOC_AR71XX
@@ -93,12 +1484,39 @@
 	select PCI_AR724X if PCI
 	def_bool n
 
+config SOC_QCA953X
+	select USB_ARCH_HAS_EHCI
+	def_bool n
+
 config SOC_QCA955X
 	select HW_HAS_PCI
 	select PCI_AR724X if PCI
 	def_bool n
 
-config PCI_AR724X
+config SOC_QCA956X
+	select USB_ARCH_HAS_EHCI
+	select HW_HAS_PCI
+	select PCI_AR724X if PCI
+	def_bool n
+
+config ATH79_DEV_M25P80
+	select ATH79_DEV_SPI
+	def_bool n
+
+config ATH79_DEV_AP9X_PCI
+	select ATH79_PCI_ATH9K_FIXUP
+	def_bool n
+
+config ATH79_DEV_DSA
+	def_bool n
+
+config ATH79_DEV_ETH
+	def_bool n
+
+config ATH79_DEV_DSA
+	def_bool n
+
+config ATH79_DEV_ETH
 	def_bool n
 
 config ATH79_DEV_GPIO_BUTTONS
@@ -107,6 +1525,10 @@
 config ATH79_DEV_LEDS_GPIO
 	def_bool n
 
+config ATH79_DEV_NFC
+	depends on (SOC_AR934X || SOC_QCA955X)
+	def_bool n
+
 config ATH79_DEV_SPI
 	def_bool n
 
@@ -114,7 +1536,21 @@
 	def_bool n
 
 config ATH79_DEV_WMAC
-	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA955X)
+	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X || SOC_QCA956X)
+	def_bool n
+
+config ATH79_NVRAM
+	def_bool n
+
+config ATH79_PCI_ATH9K_FIXUP
+	def_bool n
+
+config ATH79_ROUTERBOOT
+	select RLE_DECOMPRESS
+	select LZO_DECOMPRESS
+	def_bool n
+
+config PCI_AR724X
 	def_bool n
 
 endif
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-alfa-ap96.c linux-4.1.13/arch/mips/ath79/mach-alfa-ap96.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-alfa-ap96.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-alfa-ap96.c	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,151 @@
+/*
+ *  ALFA Network AP96 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/host.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/mmc_spi.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define ALFA_AP96_GPIO_PCIE_RESET	2
+#define ALFA_AP96_GPIO_SIM_DETECT	3
+#define ALFA_AP96_GPIO_MICROSD_CD	4
+#define ALFA_AP96_GPIO_PCIE_W_DISABLE	5
+
+#define ALFA_AP96_GPIO_BUTTON_RESET	11
+
+#define ALFA_AP96_KEYS_POLL_INTERVAL		20	/* msecs */
+#define ALFA_AP96_KEYS_DEBOUNCE_INTERVAL	(3 * ALFA_AP96_KEYS_POLL_INTERVAL)
+
+static struct gpio_keys_button alfa_ap96_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALFA_AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALFA_AP96_GPIO_BUTTON_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct mmc_spi_platform_data alfa_ap96_mmc_data = {
+	.flags		= MMC_SPI_USE_CD_GPIO,
+	.cd_gpio	= ALFA_AP96_GPIO_MICROSD_CD,
+	.cd_debounce	= 1,
+	.caps		= MMC_CAP_NEEDS_POLL,
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+static struct ath79_spi_controller_data ap96_spi0_cdata = {
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 0,
+	.is_flash = true,
+};
+
+static struct ath79_spi_controller_data ap96_spi1_cdata = {
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 1,
+};
+
+static struct ath79_spi_controller_data ap96_spi2_cdata = {
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 2,
+};
+
+static struct spi_board_info alfa_ap96_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.controller_data = &ap96_spi0_cdata
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "mmc_spi",
+		.platform_data	= &alfa_ap96_mmc_data,
+		.controller_data = &ap96_spi1_cdata
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 2,
+		.max_speed_hz	= 6250000,
+		.modalias	= "rtc-pcf2123",
+		.controller_data = &ap96_spi2_cdata
+	},
+};
+
+static struct ath79_spi_platform_data alfa_ap96_spi_data = {
+	.bus_num		= 0,
+	.num_chipselect		= 3,
+};
+
+static void __init alfa_ap96_gpio_setup(void)
+{
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				   AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	gpio_request(ALFA_AP96_GPIO_MICROSD_CD, "microSD CD");
+	gpio_direction_input(ALFA_AP96_GPIO_MICROSD_CD);
+	gpio_request(ALFA_AP96_GPIO_PCIE_RESET, "PCIe reset");
+	gpio_direction_output(ALFA_AP96_GPIO_PCIE_RESET, 1);
+	gpio_request(ALFA_AP96_GPIO_PCIE_W_DISABLE, "PCIe write disable");
+	gpio_direction_output(ALFA_AP96_GPIO_PCIE_W_DISABLE, 1);
+}
+
+#define ALFA_AP96_WAN_PHYMASK	BIT(4)
+#define ALFA_AP96_LAN_PHYMASK	BIT(5)
+#define ALFA_AP96_MDIO_PHYMASK	(ALFA_AP96_LAN_PHYMASK | ALFA_AP96_WAN_PHYMASK)
+
+static void __init alfa_ap96_init(void)
+{
+	alfa_ap96_gpio_setup();
+
+	ath79_register_mdio(0, ~ALFA_AP96_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = ALFA_AP96_WAN_PHYMASK;
+	ath79_eth1_pll_data.pll_1000 = 0x110000;
+
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = ALFA_AP96_LAN_PHYMASK;
+	ath79_eth1_pll_data.pll_1000 = 0x110000;
+
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+	ath79_register_spi(&alfa_ap96_spi_data, alfa_ap96_spi_info,
+			   ARRAY_SIZE(alfa_ap96_spi_info));
+
+	ath79_register_gpio_keys_polled(-1, ALFA_AP96_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(alfa_ap96_gpio_keys),
+					 alfa_ap96_gpio_keys);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_ALFA_AP96, "ALFA-AP96", "ALFA Network AP96",
+	     alfa_ap96_init);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-alfa-nx.c linux-4.1.13/arch/mips/ath79/mach-alfa-nx.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-alfa-nx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-alfa-nx.c	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,113 @@
+/*
+ *  ALFA Network N2/N5 board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define ALFA_NX_GPIO_LED_2		17
+#define ALFA_NX_GPIO_LED_3		16
+#define ALFA_NX_GPIO_LED_5		12
+#define ALFA_NX_GPIO_LED_6		8
+#define ALFA_NX_GPIO_LED_7		6
+#define ALFA_NX_GPIO_LED_8		7
+
+#define ALFA_NX_GPIO_BTN_RESET		11
+
+#define ALFA_NX_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ALFA_NX_KEYS_DEBOUNCE_INTERVAL (3 * ALFA_NX_KEYS_POLL_INTERVAL)
+
+#define ALFA_NX_MAC0_OFFSET		0
+#define ALFA_NX_MAC1_OFFSET		6
+#define ALFA_NX_CALDATA_OFFSET		0x1000
+
+static struct gpio_keys_button alfa_nx_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALFA_NX_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALFA_NX_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led alfa_nx_leds_gpio[] __initdata = {
+	{
+		.name		= "alfa:green:led_2",
+		.gpio		= ALFA_NX_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:green:led_3",
+		.gpio		= ALFA_NX_GPIO_LED_3,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:red:led_5",
+		.gpio		= ALFA_NX_GPIO_LED_5,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:amber:led_6",
+		.gpio		= ALFA_NX_GPIO_LED_6,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:green:led_7",
+		.gpio		= ALFA_NX_GPIO_LED_7,
+		.active_low	= 1,
+	}, {
+		.name		= "alfa:green:led_8",
+		.gpio		= ALFA_NX_GPIO_LED_8,
+		.active_low	= 1,
+	}
+};
+
+static void __init alfa_nx_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				  AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(0, ARRAY_SIZE(alfa_nx_leds_gpio),
+				 alfa_nx_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ALFA_NX_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(alfa_nx_gpio_keys),
+					alfa_nx_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + ALFA_NX_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+		       art + ALFA_NX_MAC1_OFFSET, 0);
+
+	/* WAN port */
+	ath79_register_eth(0);
+	/* LAN port */
+	ath79_register_eth(1);
+
+	ap91_pci_init(art + ALFA_NX_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_ALFA_NX, "ALFA-NX", "ALFA Network N2/N5",
+	     alfa_nx_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-all0258n.c linux-4.1.13/arch/mips/ath79/mach-all0258n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-all0258n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-all0258n.c	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,88 @@
+/*
+ *  Allnet ALL0258N support
+ *
+ *  Copyright (C) 2011 Daniel Golle <dgolle@allnet.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+/* found via /sys/gpio/... try and error */
+#define ALL0258N_GPIO_BTN_RESET		1
+#define ALL0258N_GPIO_LED_RSSIHIGH	13
+#define ALL0258N_GPIO_LED_RSSIMEDIUM	15
+#define ALL0258N_GPIO_LED_RSSILOW	14
+
+/* defaults taken from others machs */
+#define ALL0258N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ALL0258N_KEYS_DEBOUNCE_INTERVAL (3 * ALL0258N_KEYS_POLL_INTERVAL)
+
+/* showed up in the original firmware's bootlog */
+#define ALL0258N_SEC_PHYMASK BIT(3)
+
+static struct gpio_led all0258n_leds_gpio[] __initdata = {
+	{
+		.name		= "all0258n:green:rssihigh",
+		.gpio		= ALL0258N_GPIO_LED_RSSIHIGH,
+		.active_low	= 1,
+	}, {
+		.name		= "all0258n:yellow:rssimedium",
+		.gpio		= ALL0258N_GPIO_LED_RSSIMEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "all0258n:red:rssilow",
+		.gpio		= ALL0258N_GPIO_LED_RSSILOW,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button all0258n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALL0258N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALL0258N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init all0258n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7f0000);
+	u8 *ee =  (u8 *) KSEG1ADDR(0x1f7f1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(all0258n_leds_gpio),
+				 all0258n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ALL0258N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(all0258n_gpio_keys),
+					all0258n_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	ath79_eth1_data.phy_mask = ALL0258N_SEC_PHYMASK;
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ALL0258N, "ALL0258N", "Allnet ALL0258N",
+	     all0258n_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-all0315n.c linux-4.1.13/arch/mips/ath79/mach-all0315n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-all0315n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-all0315n.c	2015-09-13 20:04:35.064524285 +0200
@@ -0,0 +1,85 @@
+/*
+ *  Allnet ALL0315N support
+ *
+ *  Copyright (C) 2012 Daniel Golle <dgolle@allnet.de>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-m25p80.h"
+#include "dev-leds-gpio.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define ALL0315N_GPIO_BTN_RESET		0
+#define ALL0315N_GPIO_LED_RSSIHIGH	14
+#define ALL0315N_GPIO_LED_RSSIMEDIUM	15
+#define ALL0315N_GPIO_LED_RSSILOW	16
+
+#define ALL0315N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ALL0315N_KEYS_DEBOUNCE_INTERVAL	(3 * ALL0315N_KEYS_POLL_INTERVAL)
+
+static struct gpio_led all0315n_leds_gpio[] __initdata = {
+	{
+		.name		= "all0315n:green:rssihigh",
+		.gpio		= ALL0315N_GPIO_LED_RSSIHIGH,
+		.active_low	= 1,
+	}, {
+		.name		= "all0315n:yellow:rssimedium",
+		.gpio		= ALL0315N_GPIO_LED_RSSIMEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "all0315n:red:rssilow",
+		.gpio		= ALL0315N_GPIO_LED_RSSILOW,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button all0315n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ALL0315N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ALL0315N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init all0315n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ffc0000);
+	u8 *ee =  (u8 *) KSEG1ADDR(0x1ffc1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(all0315n_leds_gpio),
+					all0315n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ALL0315N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(all0315n_gpio_keys),
+					all0315n_gpio_keys);
+
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+	ap91_pci_init(ee, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_ALL0315N, "ALL0315N", "Allnet ALL0315N",
+	     all0315n_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-antminer-s1.c linux-4.1.13/arch/mips/ath79/mach-antminer-s1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-antminer-s1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-antminer-s1.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,98 @@
+/*
+ *   Bitmain Antminer S1 board support
+ *
+ *  Copyright (C) 2015 L. D. Pinney <ldpinney@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "dev-usb.h"
+
+#define ANTMINER_S1_GPIO_BTN_RESET		11
+
+#define ANTMINER_S1_GPIO_LED_SYSTEM		23
+#define ANTMINER_S1_GPIO_LED_WLAN		0
+#define ANTMINER_S1_GPIO_USB_POWER		26
+
+#define ANTMINER_S1_KEYSPOLL_INTERVAL	20	/* msecs */
+#define ANTMINER_S1_KEYSDEBOUNCE_INTERVAL (3 * ANTMINER_S1_KEYSPOLL_INTERVAL)
+
+static const char *ANTMINER_S1_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data ANTMINER_S1_flash_data = {
+	.part_probes	= ANTMINER_S1_part_probes,
+};
+
+static struct gpio_led ANTMINER_S1_leds_gpio[] __initdata = {
+	{
+		.name		= "antminer-s1:green:system",
+		.gpio		= ANTMINER_S1_GPIO_LED_SYSTEM,
+		.active_low	= 0,
+	},{
+		.name		= "antminer-s1:green:wlan",
+		.gpio		= ANTMINER_S1_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ANTMINER_S1_GPIO_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ANTMINER_S1_KEYSDEBOUNCE_INTERVAL,
+		.gpio		= ANTMINER_S1_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+};
+
+static void __init antminer_s1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ANTMINER_S1_leds_gpio),
+				 ANTMINER_S1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ANTMINER_S1_KEYSPOLL_INTERVAL,
+					ARRAY_SIZE(ANTMINER_S1_GPIO_keys),
+					ANTMINER_S1_GPIO_keys);
+
+	gpio_request_one(ANTMINER_S1_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_m25p80(&ANTMINER_S1_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ANTMINER_S1, "ANTMINER-S1",
+	     "Antminer-S1", antminer_s1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-antminer-s3.c linux-4.1.13/arch/mips/ath79/mach-antminer-s3.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-antminer-s3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-antminer-s3.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,103 @@
+/*
+ *   Bitmain Antminer S3 board support
+ *
+ *  Copyright (C) 2015 L. D. Pinney <ldpinney@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "dev-usb.h"
+
+#define ANTMINER_S3_GPIO_LED_WLAN		0
+#define ANTMINER_S3_GPIO_LED_SYSTEM		17
+#define ANTMINER_S3_GPIO_LED_LAN		22
+#define ANTMINER_S3_GPIO_USB_POWER		26
+
+#define ANTMINER_S3_GPIO_BTN_RESET		11
+
+#define ANTMINER_S3_KEYSPOLL_INTERVAL	88	/* msecs */
+#define ANTMINER_S3_KEYSDEBOUNCE_INTERVAL (3 * ANTMINER_S3_KEYSPOLL_INTERVAL)
+
+static const char *ANTMINER_S3_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data ANTMINER_S3_flash_data = {
+	.part_probes	= ANTMINER_S3_part_probes,
+};
+
+static struct gpio_led ANTMINER_S3_leds_gpio[] __initdata = {
+	{
+		.name		= "antminer-s3:green:wlan",
+		.gpio		= ANTMINER_S3_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},{
+		.name		= "antminer-s3:green:system",
+		.gpio		= ANTMINER_S3_GPIO_LED_SYSTEM,
+		.active_low	= 0,
+	},{
+		.name		= "antminer-s3:yellow:lan",
+		.gpio		= ANTMINER_S3_GPIO_LED_LAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ANTMINER_S3_GPIO_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ANTMINER_S3_KEYSDEBOUNCE_INTERVAL,
+		.gpio		= ANTMINER_S3_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+};
+
+static void __init antminer_s3_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ANTMINER_S3_leds_gpio),
+				 ANTMINER_S3_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ANTMINER_S3_KEYSPOLL_INTERVAL,
+					ARRAY_SIZE(ANTMINER_S3_GPIO_keys),
+					ANTMINER_S3_GPIO_keys);
+
+	gpio_request_one(ANTMINER_S3_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_m25p80(&ANTMINER_S3_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ANTMINER_S3, "ANTMINER-S3",
+	     "Antminer-S3", antminer_s3_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap113.c linux-4.1.13/arch/mips/ath79/mach-ap113.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap113.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap113.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,84 @@
+/*
+ *  Atheros AP113 board support
+ *
+ *  Copyright (C) 2011 Florian Fainelli <florian@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "pci.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define AP113_GPIO_LED_USB		0
+#define AP113_GPIO_LED_STATUS		1
+#define AP113_GPIO_LED_ST		11
+
+#define AP113_GPIO_BTN_JUMPSTART	12
+
+#define AP113_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP113_KEYS_DEBOUNCE_INTERVAL	(3 * AP113_KEYS_POLL_INTERVAL)
+
+static struct gpio_led ap113_leds_gpio[] __initdata = {
+	{
+		.name		= "ap113:green:usb",
+		.gpio		= AP113_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap113:green:status",
+		.gpio		= AP113_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap113:green:st",
+		.gpio		= AP113_GPIO_LED_ST,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap113_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP113_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP113_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+};
+
+static void __init ap113_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~BIT(0));
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	ath79_register_gpio_keys_polled(-1, AP113_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap113_gpio_keys),
+					 ap113_gpio_keys);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap113_leds_gpio),
+					ap113_leds_gpio);
+
+	ath79_register_pci();
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_AP113, "AP113", "Atheros AP113",
+	     ap113_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap121.c linux-4.1.13/arch/mips/ath79/mach-ap121.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap121.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap121.c	2015-12-04 19:57:04.298083689 +0100
@@ -1,19 +1,21 @@
 /*
  *  Atheros AP121 board support
  *
- *  Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
  *
  *  This program is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 as published
  *  by the Free Software Foundation.
  */
 
-#include "machtypes.h"
+#include "dev-eth.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
 #include "dev-spi.h"
 #include "dev-usb.h"
 #include "dev-wmac.h"
+#include "machtypes.h"
 
 #define AP121_GPIO_LED_WLAN		0
 #define AP121_GPIO_LED_USB		1
@@ -24,7 +26,14 @@
 #define AP121_KEYS_POLL_INTERVAL	20	/* msecs */
 #define AP121_KEYS_DEBOUNCE_INTERVAL	(3 * AP121_KEYS_POLL_INTERVAL)
 
-#define AP121_CAL_DATA_ADDR	0x1fff1000
+#define AP121_MAC0_OFFSET		0x0000
+#define AP121_MAC1_OFFSET		0x0006
+#define AP121_CALDATA_OFFSET		0x1000
+#define AP121_WMAC_MAC_OFFSET		0x1002
+
+#define AP121_MINI_GPIO_LED_WLAN	0
+#define AP121_MINI_GPIO_BTN_JUMPSTART	12
+#define AP121_MINI_GPIO_BTN_RESET	11
 
 static struct gpio_led ap121_leds_gpio[] __initdata = {
 	{
@@ -58,35 +67,78 @@
 	}
 };
 
-static struct spi_board_info ap121_spi_info[] = {
+static struct gpio_led ap121_mini_leds_gpio[] __initdata = {
 	{
-		.bus_num	= 0,
-		.chip_select	= 0,
-		.max_speed_hz	= 25000000,
-		.modalias	= "mx25l1606e",
-	}
+		.name		= "ap121:green:wlan",
+		.gpio		= AP121_MINI_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
 };
 
-static struct ath79_spi_platform_data ap121_spi_data = {
-	.bus_num	= 0,
-	.num_chipselect = 1,
+static struct gpio_keys_button ap121_mini_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_MINI_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP121_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP121_MINI_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
 };
 
+static void __init ap121_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art + AP121_CALDATA_OFFSET,
+			    art + AP121_WMAC_MAC_OFFSET);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + AP121_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + AP121_MAC1_OFFSET, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+}
+
 static void __init ap121_setup(void)
 {
-	u8 *cal_data = (u8 *) KSEG1ADDR(AP121_CAL_DATA_ADDR);
+	ap121_common_setup();
 
 	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap121_leds_gpio),
 				 ap121_leds_gpio);
 	ath79_register_gpio_keys_polled(-1, AP121_KEYS_POLL_INTERVAL,
 					ARRAY_SIZE(ap121_gpio_keys),
 					ap121_gpio_keys);
-
-	ath79_register_spi(&ap121_spi_data, ap121_spi_info,
-			   ARRAY_SIZE(ap121_spi_info));
 	ath79_register_usb();
-	ath79_register_wmac(cal_data);
 }
 
 MIPS_MACHINE(ATH79_MACH_AP121, "AP121", "Atheros AP121 reference board",
 	     ap121_setup);
+
+static void __init ap121_mini_setup(void)
+{
+	ap121_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap121_mini_leds_gpio),
+				 ap121_mini_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP121_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap121_mini_gpio_keys),
+					ap121_mini_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP121_MINI, "AP121-MINI", "Atheros AP121-MINI",
+	     ap121_mini_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap132.c linux-4.1.13/arch/mips/ath79/mach-ap132.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap132.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap132.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,189 @@
+/*
+ * Atheros AP132 reference board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2013 Embedded Wireless GmbH <info@embeddedwireless.de>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define AP132_GPIO_LED_USB		4
+#define AP132_GPIO_LED_WLAN_5G		12
+#define AP132_GPIO_LED_WLAN_2G		13
+#define AP132_GPIO_LED_STATUS_RED	14
+#define AP132_GPIO_LED_WPS_RED		15
+
+#define AP132_GPIO_BTN_WPS		16
+
+#define AP132_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP132_KEYS_DEBOUNCE_INTERVAL	(3 * AP132_KEYS_POLL_INTERVAL)
+
+#define AP132_MAC0_OFFSET		0
+#define AP132_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led ap132_leds_gpio[] __initdata = {
+	{
+		.name		= "ap132:red:status",
+		.gpio		= AP132_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap132:red:wps",
+		.gpio		= AP132_GPIO_LED_WPS_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap132:red:wlan-2g",
+		.gpio		= AP132_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap132:red:usb",
+		.gpio		= AP132_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap132_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP132_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP132_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg ap132_ar8327_pad0_cfg;
+
+static struct ar8327_platform_data ap132_ar8327_data = {
+	.pad0_cfg = &ap132_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info ap132_mdio1_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.1",
+		.phy_addr = 0,
+		.platform_data = &ap132_ar8327_data,
+	},
+};
+
+static void __init ap132_mdio_setup(void)
+{
+	void __iomem *base;
+	u32 t;
+
+#define GPIO_IN_ENABLE3_ADDRESS                                      0x0050
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_MASK                             0x00ff0000
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_LSB                              16
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_SET(x)                           (((x) << GPIO_IN_ENABLE3_MII_GE1_MDI_LSB) & GPIO_IN_ENABLE3_MII_GE1_MDI_MASK)
+#define GPIO_OUT_FUNCTION4_ADDRESS                                   0x003c
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB                        24
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB                        8
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+
+	base = ioremap(AR71XX_GPIO_BASE, AR71XX_GPIO_SIZE);
+
+	t = __raw_readl(base + GPIO_IN_ENABLE3_ADDRESS);
+	t &= ~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+	t |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+	__raw_writel(t, base + GPIO_IN_ENABLE3_ADDRESS);
+
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) & ~(1 << 19), base + AR71XX_GPIO_REG_OE);
+
+	__raw_writel(__raw_readl(base + AR71XX_GPIO_REG_OE) & ~(1 << 17), base + AR71XX_GPIO_REG_OE);
+
+
+	t = __raw_readl(base + GPIO_OUT_FUNCTION4_ADDRESS);
+	t &= ~(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK | GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK);
+	t |= GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) | GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21);
+	__raw_writel(t, base + GPIO_OUT_FUNCTION4_ADDRESS);
+
+	iounmap(base);
+
+}
+
+static void __init ap132_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap132_leds_gpio),
+				 ap132_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP132_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap132_gpio_keys),
+					ap132_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + AP132_WMAC_CALDATA_OFFSET, NULL);
+
+	/* GMAC0 of the AR8327 switch is connected to GMAC1 via SGMII */
+	ap132_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_SGMII;
+	ap132_ar8327_pad0_cfg.sgmii_delay_en = true;
+
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ap132_mdio_setup();
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + AP132_MAC0_OFFSET, 0);
+
+	mdiobus_register_board_info(ap132_mdio1_info,
+				    ARRAY_SIZE(ap132_mdio1_info));
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_mask = BIT(0);
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP132, "AP132",
+	     "Atheros AP132 reference board",
+	     ap132_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap136.c linux-4.1.13/arch/mips/ath79/mach-ap136.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap136.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap136.c	2015-12-04 19:57:04.370078979 +0100
@@ -18,23 +18,29 @@
  *
  */
 
-#include <linux/pci.h>
-#include <linux/ath9k_platform.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
 
-#include "machtypes.h"
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
 #include "dev-gpio-buttons.h"
+#include "dev-eth.h"
 #include "dev-leds-gpio.h"
-#include "dev-spi.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
 #include "dev-usb.h"
 #include "dev-wmac.h"
-#include "pci.h"
+#include "machtypes.h"
 
-#define AP136_GPIO_LED_STATUS_RED	14
-#define AP136_GPIO_LED_STATUS_GREEN	19
 #define AP136_GPIO_LED_USB		4
-#define AP136_GPIO_LED_WLAN_2G		13
 #define AP136_GPIO_LED_WLAN_5G		12
+#define AP136_GPIO_LED_WLAN_2G		13
+#define AP136_GPIO_LED_STATUS_RED	14
 #define AP136_GPIO_LED_WPS_RED		15
+#define AP136_GPIO_LED_STATUS_GREEN	19
 #define AP136_GPIO_LED_WPS_GREEN	20
 
 #define AP136_GPIO_BTN_WPS		16
@@ -43,37 +49,39 @@
 #define AP136_KEYS_POLL_INTERVAL	20	/* msecs */
 #define AP136_KEYS_DEBOUNCE_INTERVAL	(3 * AP136_KEYS_POLL_INTERVAL)
 
-#define AP136_WMAC_CALDATA_OFFSET 0x1000
-#define AP136_PCIE_CALDATA_OFFSET 0x5000
+#define AP136_MAC0_OFFSET		0
+#define AP136_MAC1_OFFSET		6
+#define AP136_WMAC_CALDATA_OFFSET	0x1000
+#define AP136_PCIE_CALDATA_OFFSET	0x5000
 
 static struct gpio_led ap136_leds_gpio[] __initdata = {
 	{
-		.name		= "qca:green:status",
+		.name		= "ap136:green:status",
 		.gpio		= AP136_GPIO_LED_STATUS_GREEN,
 		.active_low	= 1,
 	},
 	{
-		.name		= "qca:red:status",
+		.name		= "ap136:red:status",
 		.gpio		= AP136_GPIO_LED_STATUS_RED,
 		.active_low	= 1,
 	},
 	{
-		.name		= "qca:green:wps",
+		.name		= "ap136:green:wps",
 		.gpio		= AP136_GPIO_LED_WPS_GREEN,
 		.active_low	= 1,
 	},
 	{
-		.name		= "qca:red:wps",
+		.name		= "ap136:red:wps",
 		.gpio		= AP136_GPIO_LED_WPS_RED,
 		.active_low	= 1,
 	},
 	{
-		.name		= "qca:red:wlan-2g",
+		.name		= "ap136:red:wlan-2g",
 		.gpio		= AP136_GPIO_LED_WLAN_2G,
 		.active_low	= 1,
 	},
 	{
-		.name		= "qca:red:usb",
+		.name		= "ap136:red:usb",
 		.gpio		= AP136_GPIO_LED_USB,
 		.active_low	= 1,
 	}
@@ -98,59 +106,151 @@
 	},
 };
 
-static struct spi_board_info ap136_spi_info[] = {
-	{
-		.bus_num	= 0,
-		.chip_select	= 0,
-		.max_speed_hz	= 25000000,
-		.modalias	= "mx25l6405d",
-	}
+static struct ar8327_pad_cfg ap136_ar8327_pad0_cfg;
+static struct ar8327_pad_cfg ap136_ar8327_pad6_cfg;
+
+static struct ar8327_platform_data ap136_ar8327_data = {
+	.pad0_cfg = &ap136_ar8327_pad0_cfg,
+	.pad6_cfg = &ap136_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
 };
 
-static struct ath79_spi_platform_data ap136_spi_data = {
-	.bus_num	= 0,
-	.num_chipselect	= 1,
+static struct mdio_board_info ap136_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &ap136_ar8327_data,
+	},
 };
 
-#ifdef CONFIG_PCI
-static struct ath9k_platform_data ap136_ath9k_data;
+static void __init ap136_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap136_leds_gpio),
+				 ap136_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP136_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap136_gpio_keys),
+					ap136_gpio_keys);
+
+	ath79_register_usb();
+	ath79_register_nfc();
+
+	ath79_register_wmac(art + AP136_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
 
-static int ap136_pci_plat_dev_init(struct pci_dev *dev)
+	ath79_register_mdio(0, 0x0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + AP136_MAC0_OFFSET, 0);
+
+	mdiobus_register_board_info(ap136_mdio0_info,
+				    ARRAY_SIZE(ap136_mdio0_info));
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected tot eh SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+}
+
+static void __init ap136_010_setup(void)
 {
-	if (dev->bus->number == 1 && (PCI_SLOT(dev->devfn)) == 0)
-		dev->dev.platform_data = &ap136_ath9k_data;
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
 
-	return 0;
+	/* GMAC0 of the AR8327 switch is connected to GMAC0 via RGMII */
+	ap136_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_RGMII;
+	ap136_ar8327_pad0_cfg.txclk_delay_en = true;
+	ap136_ar8327_pad0_cfg.rxclk_delay_en = true;
+	ap136_ar8327_pad0_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
+	ap136_ar8327_pad0_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
+
+	/* GMAC6 of the AR8327 switch is connected to GMAC1 via SGMII */
+	ap136_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
+	ap136_ar8327_pad6_cfg.rxclk_delay_en = true;
+	ap136_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0;
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ap136_common_setup();
+	ap91_pci_init(art + AP136_PCIE_CALDATA_OFFSET, NULL);
 }
 
-static void __init ap136_pci_init(u8 *eeprom)
+MIPS_MACHINE(ATH79_MACH_AP136_010, "AP136-010",
+	     "Atheros AP136-010 reference board",
+	     ap136_010_setup);
+
+static void __init ap136_020_common_setup(void)
 {
-	memcpy(ap136_ath9k_data.eeprom_data, eeprom,
-	       sizeof(ap136_ath9k_data.eeprom_data));
+	/* GMAC0 of the AR8327 switch is connected to GMAC1 via SGMII */
+	ap136_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_SGMII;
+	ap136_ar8327_pad0_cfg.sgmii_delay_en = true;
+
+	/* GMAC6 of the AR8327 switch is connected to GMAC0 via RGMII */
+	ap136_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_RGMII;
+	ap136_ar8327_pad6_cfg.txclk_delay_en = true;
+	ap136_ar8327_pad6_cfg.rxclk_delay_en = true;
+	ap136_ar8327_pad6_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
+	ap136_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
 
-	ath79_pci_set_plat_dev_init(ap136_pci_plat_dev_init);
-	ath79_register_pci();
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ap136_common_setup();
 }
-#else
-static inline void ap136_pci_init(u8 *eeprom) {}
-#endif /* CONFIG_PCI */
 
-static void __init ap136_setup(void)
+static void __init ap136_020_setup(void)
 {
 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
 
-	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap136_leds_gpio),
-				 ap136_leds_gpio);
-	ath79_register_gpio_keys_polled(-1, AP136_KEYS_POLL_INTERVAL,
-					ARRAY_SIZE(ap136_gpio_keys),
-					ap136_gpio_keys);
-	ath79_register_spi(&ap136_spi_data, ap136_spi_info,
-			   ARRAY_SIZE(ap136_spi_info));
-	ath79_register_usb();
-	ath79_register_wmac(art + AP136_WMAC_CALDATA_OFFSET);
-	ap136_pci_init(art + AP136_PCIE_CALDATA_OFFSET);
+	ap136_020_common_setup();
+	ap91_pci_init(art + AP136_PCIE_CALDATA_OFFSET, NULL);
 }
 
-MIPS_MACHINE(ATH79_MACH_AP136_010, "AP136-010",
-	     "Atheros AP136-010 reference board",
-	     ap136_setup);
+MIPS_MACHINE(ATH79_MACH_AP136_020, "AP136-020",
+	     "Atheros AP136-020 reference board",
+	     ap136_020_setup);
+
+/*
+ * AP135-020 is similar to AP136-020, any future AP135 specific init
+ * code can be added here.
+ */
+static void __init ap135_020_setup(void)
+{
+	ap136_leds_gpio[0].name = "ap135:green:status";
+	ap136_leds_gpio[1].name = "ap135:red:status";
+	ap136_leds_gpio[2].name = "ap135:green:wps";
+	ap136_leds_gpio[3].name = "ap135:red:wps";
+	ap136_leds_gpio[4].name = "ap135:red:wlan-2g";
+	ap136_leds_gpio[5].name = "ap135:red:usb";
+
+	ap136_020_common_setup();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_AP135_020, "AP135-020",
+	     "Atheros AP135-020 reference board",
+	     ap135_020_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap143.c linux-4.1.13/arch/mips/ath79/mach-ap143.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap143.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap143.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,142 @@
+/*
+ * Atheros AP143 reference board support
+ *
+ * Copyright (c) 2013-2015 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define AP143_GPIO_LED_WLAN		12
+#define AP143_GPIO_LED_WPS		13
+#define AP143_GPIO_LED_STATUS		13
+
+#define AP143_GPIO_LED_WAN		4
+#define AP143_GPIO_LED_LAN1		16
+#define AP143_GPIO_LED_LAN2		15
+#define AP143_GPIO_LED_LAN3		14
+#define AP143_GPIO_LED_LAN4		11
+
+#define AP143_GPIO_BTN_WPS		17
+
+#define AP143_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP143_KEYS_DEBOUNCE_INTERVAL	(3 * AP143_KEYS_POLL_INTERVAL)
+
+#define AP143_MAC0_OFFSET		0
+#define AP143_MAC1_OFFSET		6
+#define AP143_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led ap143_leds_gpio[] __initdata = {
+	{
+		.name		= "ap143:green:status",
+		.gpio		= AP143_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap143:green:wlan",
+		.gpio		= AP143_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap143_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP143_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP143_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static void __init ap143_gpio_led_setup(void)
+{
+	ath79_gpio_direction_select(AP143_GPIO_LED_WAN, true);
+	ath79_gpio_direction_select(AP143_GPIO_LED_LAN1, true);
+	ath79_gpio_direction_select(AP143_GPIO_LED_LAN2, true);
+	ath79_gpio_direction_select(AP143_GPIO_LED_LAN3, true);
+	ath79_gpio_direction_select(AP143_GPIO_LED_LAN4, true);
+
+	ath79_gpio_output_select(AP143_GPIO_LED_WAN,
+			QCA953X_GPIO_OUT_MUX_LED_LINK5);
+	ath79_gpio_output_select(AP143_GPIO_LED_LAN1,
+			QCA953X_GPIO_OUT_MUX_LED_LINK1);
+	ath79_gpio_output_select(AP143_GPIO_LED_LAN2,
+			QCA953X_GPIO_OUT_MUX_LED_LINK2);
+	ath79_gpio_output_select(AP143_GPIO_LED_LAN3,
+			QCA953X_GPIO_OUT_MUX_LED_LINK3);
+	ath79_gpio_output_select(AP143_GPIO_LED_LAN4,
+			QCA953X_GPIO_OUT_MUX_LED_LINK4);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap143_leds_gpio),
+			ap143_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP143_KEYS_POLL_INTERVAL,
+			ARRAY_SIZE(ap143_gpio_keys),
+			ap143_gpio_keys);
+}
+
+static void __init ap143_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ap143_gpio_led_setup();
+
+	ath79_register_usb();
+
+	ath79_wmac_set_led_pin(AP143_GPIO_LED_WLAN);
+	ath79_register_wmac(art + AP143_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + AP143_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + AP143_MAC1_OFFSET, 0);
+
+	/* WAN port */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_register_eth(0);
+
+	/* LAN ports */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP143, "AP143", "Qualcomm Atheros AP143 reference board",
+	     ap143_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap147.c linux-4.1.13/arch/mips/ath79/mach-ap147.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap147.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap147.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,125 @@
+/*
+ *  Atheros AP147 reference board support
+ *
+ *  Copyright (C) 2014 Matthias Schiffer <mschiffer@universe-factory.net>
+ *  Copyright (C) 2015 Sven Eckelmann <sven@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define AP147_GPIO_LED_WAN	4
+#define AP147_GPIO_LED_LAN1	16
+#define AP147_GPIO_LED_LAN2	15
+#define AP147_GPIO_LED_LAN3	14
+#define AP147_GPIO_LED_LAN4	11
+#define AP147_GPIO_LED_STATUS	13
+#define AP147_GPIO_LED_WLAN_2G	12
+
+#define AP147_GPIO_BTN_WPS	17
+
+#define AP147_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AP147_KEYS_DEBOUNCE_INTERVAL	(3 * AP147_KEYS_POLL_INTERVAL)
+
+#define AP147_MAC0_OFFSET	0x1000
+
+static struct gpio_led ap147_leds_gpio[] __initdata = {
+	{
+		.name		= "ap147:green:status",
+		.gpio		= AP147_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:wlan-2g",
+		.gpio		= AP147_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:lan1",
+		.gpio		= AP147_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:lan2",
+		.gpio		= AP147_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:lan3",
+		.gpio		= AP147_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:lan4",
+		.gpio		= AP147_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "ap147:green:wan",
+		.gpio		= AP147_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button ap147_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP147_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP147_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init ap147_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap147_leds_gpio),
+				 ap147_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP147_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap147_gpio_keys),
+					ap147_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_pci();
+
+	ath79_register_wmac(art + AP147_MAC0_OFFSET, NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 1);
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP147_010, "AP147-010", "Atheros AP147-010 reference board", ap147_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap152.c linux-4.1.13/arch/mips/ath79/mach-ap152.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap152.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap152.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,141 @@
+
+/*
+ * Qualcomm Atheros AP152 reference board support
+ *
+ * Copyright (c) 2015 Qualcomm Atheros
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+
+#define AP152_GPIO_LED_USB0		7
+#define AP152_GPIO_LED_USB1		8
+
+#define AP152_GPIO_BTN_RESET            2
+#define AP152_GPIO_BTN_WPS              1
+#define AP152_KEYS_POLL_INTERVAL        20     /* msecs */
+#define AP152_KEYS_DEBOUNCE_INTERVAL    (3 * AP152_KEYS_POLL_INTERVAL)
+
+#define AP152_MAC0_OFFSET               0
+#define AP152_WMAC_CALDATA_OFFSET       0x1000
+
+static struct gpio_led ap152_leds_gpio[] __initdata = {
+	{
+		.name		= "ap152:green:usb0",
+		.gpio		= AP152_GPIO_LED_USB0,
+		.active_low	= 1,
+	},
+	{
+		.name		= "ap152:green:usb1",
+		.gpio		= AP152_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button ap152_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP152_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP152_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP152_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP152_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg ap152_ar8337_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data ap152_ar8337_data = {
+	.pad0_cfg = &ap152_ar8337_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info ap152_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &ap152_ar8337_data,
+	},
+};
+
+static void __init ap152_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap152_leds_gpio),
+				 ap152_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, AP152_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ap152_gpio_keys),
+					ap152_gpio_keys);
+
+	ath79_register_usb();
+
+	platform_device_register(&ath79_mdio0_device);
+
+	mdiobus_register_board_info(ap152_mdio0_info,
+				    ARRAY_SIZE(ap152_mdio0_info));
+
+	ath79_register_wmac(art + AP152_WMAC_CALDATA_OFFSET, NULL);
+	ath79_register_pci();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + AP152_MAC0_OFFSET, 0);
+
+	/* GMAC0 is connected to an AR8337 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP152, "AP152", "Qualcomm Atheros AP152 reference board",
+	     ap152_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap81.c linux-4.1.13/arch/mips/ath79/mach-ap81.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap81.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap81.c	2015-12-04 19:57:04.310082904 +0100
@@ -9,12 +9,16 @@
  *  by the Free Software Foundation.
  */
 
-#include "machtypes.h"
-#include "dev-wmac.h"
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include "dev-eth.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
-#include "dev-spi.h"
+#include "dev-m25p80.h"
 #include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
 
 #define AP81_GPIO_LED_STATUS	1
 #define AP81_GPIO_LED_AOSS	3
@@ -67,20 +71,6 @@
 	}
 };
 
-static struct spi_board_info ap81_spi_info[] = {
-	{
-		.bus_num	= 0,
-		.chip_select	= 0,
-		.max_speed_hz	= 25000000,
-		.modalias	= "m25p64",
-	}
-};
-
-static struct ath79_spi_platform_data ap81_spi_data = {
-	.bus_num	= 0,
-	.num_chipselect = 1,
-};
-
 static void __init ap81_setup(void)
 {
 	u8 *cal_data = (u8 *) KSEG1ADDR(AP81_CAL_DATA_ADDR);
@@ -90,10 +80,24 @@
 	ath79_register_gpio_keys_polled(-1, AP81_KEYS_POLL_INTERVAL,
 					ARRAY_SIZE(ap81_gpio_keys),
 					ap81_gpio_keys);
-	ath79_register_spi(&ap81_spi_data, ap81_spi_info,
-			   ARRAY_SIZE(ap81_spi_info));
-	ath79_register_wmac(cal_data);
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(cal_data, NULL);
 	ath79_register_usb();
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, cal_data, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, cal_data, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
 }
 
 MIPS_MACHINE(ATH79_MACH_AP81, "AP81", "Atheros AP81 reference board",
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap83.c linux-4.1.13/arch/mips/ath79/mach-ap83.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap83.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap83.c	2015-12-04 19:57:04.438074530 +0100
@@ -0,0 +1,242 @@
+/*
+ *  Atheros AP83 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/spi/vsc7385.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define AP83_GPIO_LED_WLAN	6
+#define AP83_GPIO_LED_POWER	14
+#define AP83_GPIO_LED_JUMPSTART	15
+#define AP83_GPIO_BTN_JUMPSTART	12
+#define AP83_GPIO_BTN_RESET	21
+
+#define AP83_050_GPIO_VSC7385_CS	1
+#define AP83_050_GPIO_VSC7385_MISO	3
+#define AP83_050_GPIO_VSC7385_MOSI	16
+#define AP83_050_GPIO_VSC7385_SCK	17
+
+#define AP83_KEYS_POLL_INTERVAL		20	/* msecs */
+#define AP83_KEYS_DEBOUNCE_INTERVAL	(3 * AP83_KEYS_POLL_INTERVAL)
+
+static struct physmap_flash_data ap83_flash_data = {
+	.width		= 2,
+};
+
+static struct resource ap83_flash_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ap83_flash_device = {
+	.name		= "ar91xx-flash",
+	.id		= -1,
+	.resource	= ap83_flash_resources,
+	.num_resources	= ARRAY_SIZE(ap83_flash_resources),
+	.dev		= {
+		.platform_data = &ap83_flash_data,
+	}
+};
+
+static struct gpio_led ap83_leds_gpio[] __initdata = {
+	{
+		.name		= "ap83:green:jumpstart",
+		.gpio		= AP83_GPIO_LED_JUMPSTART,
+		.active_low	= 0,
+	}, {
+		.name		= "ap83:green:power",
+		.gpio		= AP83_GPIO_LED_POWER,
+		.active_low	= 0,
+	}, {
+		.name		= "ap83:green:wlan",
+		.gpio		= AP83_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button ap83_gpio_keys[] __initdata = {
+	{
+		.desc		= "soft_reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP83_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP83_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "jumpstart",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP83_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP83_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	}
+};
+
+static struct resource ap83_040_spi_resources[] = {
+	[0] = {
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ap83_040_spi_device = {
+	.name		= "ap83-spi",
+	.id		= 0,
+	.resource	= ap83_040_spi_resources,
+	.num_resources	= ARRAY_SIZE(ap83_040_spi_resources),
+};
+
+static struct spi_gpio_platform_data ap83_050_spi_data = {
+	.miso	= AP83_050_GPIO_VSC7385_MISO,
+	.mosi	= AP83_050_GPIO_VSC7385_MOSI,
+	.sck	= AP83_050_GPIO_VSC7385_SCK,
+	.num_chipselect = 1,
+};
+
+static struct platform_device ap83_050_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &ap83_050_spi_data,
+	}
+};
+
+static void ap83_vsc7385_reset(void)
+{
+	ath79_device_reset_set(AR71XX_RESET_GE1_PHY);
+	udelay(10);
+	ath79_device_reset_clear(AR71XX_RESET_GE1_PHY);
+	mdelay(50);
+}
+
+static struct vsc7385_platform_data ap83_vsc7385_data = {
+	.reset		= ap83_vsc7385_reset,
+	.ucode_name	= "vsc7385_ucode_ap83.bin",
+	.mac_cfg = {
+		.tx_ipg		= 6,
+		.bit2		= 0,
+		.clk_sel	= 3,
+	},
+};
+
+static struct spi_board_info ap83_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-vsc7385",
+		.platform_data	= &ap83_vsc7385_data,
+		.controller_data = (void *) AP83_050_GPIO_VSC7385_CS,
+	}
+};
+
+static void __init ap83_generic_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, 0xfffffffe);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = 0x1;
+
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_eth1_pll_data.pll_1000 = 0x1f000000;
+
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap83_leds_gpio),
+					ap83_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AP83_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap83_gpio_keys),
+					 ap83_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(eeprom, NULL);
+
+	platform_device_register(&ap83_flash_device);
+
+	spi_register_board_info(ap83_spi_info, ARRAY_SIZE(ap83_spi_info));
+}
+
+static void ap83_040_flash_lock(struct platform_device *pdev)
+{
+	ath79_flash_acquire();
+}
+
+static void ap83_040_flash_unlock(struct platform_device *pdev)
+{
+	ath79_flash_release();
+}
+
+static void __init ap83_040_setup(void)
+{
+	ap83_flash_data.lock = ap83_040_flash_lock;
+	ap83_flash_data.unlock = ap83_040_flash_unlock;
+	ap83_generic_setup();
+	platform_device_register(&ap83_040_spi_device);
+}
+
+static void __init ap83_050_setup(void)
+{
+	ap83_generic_setup();
+	platform_device_register(&ap83_050_spi_device);
+}
+
+static void __init ap83_setup(void)
+{
+	u8 *board_id = (u8 *) KSEG1ADDR(0x1fff1244);
+	unsigned int board_version;
+
+	board_version = (unsigned int)(board_id[0] - '0');
+	board_version += ((unsigned int)(board_id[1] - '0')) * 10;
+
+	switch (board_version) {
+	case 40:
+		ap83_040_setup();
+		break;
+	case 50:
+		ap83_050_setup();
+		break;
+	default:
+		printk(KERN_WARNING "AP83-%03u board is not yet supported\n",
+		       board_version);
+	}
+}
+
+MIPS_MACHINE(ATH79_MACH_AP83, "AP83", "Atheros AP83", ap83_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ap96.c linux-4.1.13/arch/mips/ath79/mach-ap96.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ap96.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ap96.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,142 @@
+/*
+ *  Atheros AP96 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define AP96_GPIO_LED_12_GREEN		0
+#define AP96_GPIO_LED_3_GREEN		1
+#define AP96_GPIO_LED_2_GREEN		2
+#define AP96_GPIO_LED_WPS_GREEN		4
+#define AP96_GPIO_LED_5_GREEN		5
+#define AP96_GPIO_LED_4_ORANGE		6
+
+/* Reset button - next to the power connector */
+#define AP96_GPIO_BTN_RESET		3
+/* WPS button - next to a led on right */
+#define AP96_GPIO_BTN_WPS		8
+
+#define AP96_KEYS_POLL_INTERVAL		20	/* msecs */
+#define AP96_KEYS_DEBOUNCE_INTERVAL	(3 * AP96_KEYS_POLL_INTERVAL)
+
+#define AP96_WMAC0_MAC_OFFSET		0x120c
+#define AP96_WMAC1_MAC_OFFSET		0x520c
+#define AP96_CALDATA0_OFFSET		0x1000
+#define AP96_CALDATA1_OFFSET		0x5000
+
+/*
+ * AP96 has 12 unlabeled leds in the front; these are numbered from 1 to 12
+ * below (from left to right on the board). Led 1 seems to be on whenever the
+ * board is powered. Led 11 shows LAN link activity actity. Led 3 is orange;
+ * others are green.
+ *
+ * In addition, there is one led next to a button on the right side for WPS.
+ */
+static struct gpio_led ap96_leds_gpio[] __initdata = {
+	{
+		.name		= "ap96:green:led2",
+		.gpio		= AP96_GPIO_LED_2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led3",
+		.gpio		= AP96_GPIO_LED_3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:orange:led4",
+		.gpio		= AP96_GPIO_LED_4_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led5",
+		.gpio		= AP96_GPIO_LED_5_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "ap96:green:led12",
+		.gpio		= AP96_GPIO_LED_12_GREEN,
+		.active_low	= 1,
+	}, { /* next to a button on right */
+		.name		= "ap96:green:wps",
+		.gpio		= AP96_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ap96_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AP96_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AP96_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+#define AP96_WAN_PHYMASK 0x10
+#define AP96_LAN_PHYMASK 0x0f
+
+static void __init ap96_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_mdio(0, ~(AP96_WAN_PHYMASK | AP96_LAN_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = AP96_LAN_PHYMASK;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = AP96_WAN_PHYMASK;
+
+	ath79_eth1_pll_data.pll_1000 = 0x1f000000;
+
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap96_leds_gpio),
+					ap96_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AP96_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ap96_gpio_keys),
+					 ap96_gpio_keys);
+
+	ap94_pci_init(art + AP96_CALDATA0_OFFSET,
+		      art + AP96_WMAC0_MAC_OFFSET,
+		      art + AP96_CALDATA1_OFFSET,
+		      art + AP96_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_AP96, "AP96", "Atheros AP96", ap96_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-archer-c7.c linux-4.1.13/arch/mips/ath79/mach-archer-c7.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-archer-c7.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-archer-c7.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,266 @@
+/*
+ * TP-LINK Archer C5/C7/TL-WDR4900 v2 board support
+ *
+ * Copyright (c) 2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2014  <tenninjas@tenninjas.ca>
+ * Copyright (c) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ *   Copyright (c) 2012 Qualcomm Atheros
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define ARCHER_C7_GPIO_LED_WLAN2G	12
+#define ARCHER_C7_GPIO_LED_SYSTEM	14
+#define ARCHER_C7_GPIO_LED_QSS		15
+#define ARCHER_C7_GPIO_LED_WLAN5G	17
+#define ARCHER_C7_GPIO_LED_USB1		18
+#define ARCHER_C7_GPIO_LED_USB2		19
+
+#define ARCHER_C7_GPIO_BTN_RFKILL	13
+#define ARCHER_C7_GPIO_BTN_RESET	16
+
+#define ARCHER_C7_GPIO_USB1_POWER	22
+#define ARCHER_C7_GPIO_USB2_POWER	21
+
+#define ARCHER_C7_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ARCHER_C7_KEYS_DEBOUNCE_INTERVAL (3 * ARCHER_C7_KEYS_POLL_INTERVAL)
+
+#define ARCHER_C7_WMAC_CALDATA_OFFSET	0x1000
+#define ARCHER_C7_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *archer_c7_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data archer_c7_flash_data = {
+	.part_probes	= archer_c7_part_probes,
+};
+
+static struct gpio_led archer_c7_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:qss",
+		.gpio		= ARCHER_C7_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= ARCHER_C7_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan2g",
+		.gpio		= ARCHER_C7_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan5g",
+		.gpio		= ARCHER_C7_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb1",
+		.gpio		= ARCHER_C7_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb2",
+		.gpio		= ARCHER_C7_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button archer_c7_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = ARCHER_C7_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ARCHER_C7_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = ARCHER_C7_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ARCHER_C7_GPIO_BTN_RFKILL,
+	},
+};
+
+static const struct ar8327_led_info archer_c7_leds_ar8327[] __initconst = {
+	AR8327_LED_INFO(PHY0_0, HW, "tp-link:blue:wan"),
+	AR8327_LED_INFO(PHY1_0, HW, "tp-link:blue:lan1"),
+	AR8327_LED_INFO(PHY2_0, HW, "tp-link:blue:lan2"),
+	AR8327_LED_INFO(PHY3_0, HW, "tp-link:blue:lan3"),
+	AR8327_LED_INFO(PHY4_0, HW, "tp-link:blue:lan4"),
+};
+
+/* GMAC0 of the AR8327 switch is connected to the QCA9558 SoC via SGMII */
+static struct ar8327_pad_cfg archer_c7_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+/* GMAC6 of the AR8327 switch is connected to the QCA9558 SoC via RGMII */
+static struct ar8327_pad_cfg archer_c7_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg archer_c7_ar8327_led_cfg = {
+	.led_ctrl0 = 0xc737c737,
+	.led_ctrl1 = 0x00000000,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x0030c300,
+	.open_drain = false,
+};
+
+static struct ar8327_platform_data archer_c7_ar8327_data = {
+	.pad0_cfg = &archer_c7_ar8327_pad0_cfg,
+	.pad6_cfg = &archer_c7_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &archer_c7_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(archer_c7_leds_ar8327),
+	.leds = archer_c7_leds_ar8327,
+};
+
+static struct mdio_board_info archer_c7_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &archer_c7_ar8327_data,
+	},
+};
+
+static void __init common_setup(bool pcie_slot)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&archer_c7_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(archer_c7_leds_gpio),
+				 archer_c7_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, ARCHER_C7_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(archer_c7_gpio_keys),
+					archer_c7_gpio_keys);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ath79_register_wmac(art + ARCHER_C7_WMAC_CALDATA_OFFSET, tmpmac);
+
+	if (pcie_slot) {
+		ath79_register_pci();
+	} else {
+		ath79_init_mac(tmpmac, mac, -1);
+		ap9x_pci_setup_wmac_led_pin(0, 0);
+		ap91_pci_init(art + ARCHER_C7_PCIE_CALDATA_OFFSET, tmpmac);
+	}
+
+	mdiobus_register_board_info(archer_c7_mdio0_info,
+				    ARRAY_SIZE(archer_c7_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	gpio_request_one(ARCHER_C7_GPIO_USB1_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB1 power");
+	gpio_request_one(ARCHER_C7_GPIO_USB2_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB2 power");
+	ath79_register_usb();
+}
+
+static void __init archer_c5_setup(void)
+{
+	common_setup(true);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C5, "ARCHER-C5", "TP-LINK Archer C5",
+	     archer_c5_setup);
+
+static void __init archer_c7_setup(void)
+{
+	common_setup(true);
+}
+
+MIPS_MACHINE(ATH79_MACH_ARCHER_C7, "ARCHER-C7", "TP-LINK Archer C7",
+	     archer_c7_setup);
+
+static void __init tl_wdr4900_v2_setup(void)
+{
+	common_setup(false);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR4900_V2, "TL-WDR4900-v2", "TP-LINK TL-WDR4900 v2",
+	     tl_wdr4900_v2_setup)
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-arduino-yun.c linux-4.1.13/arch/mips/ath79/mach-arduino-yun.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-arduino-yun.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-arduino-yun.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,137 @@
+/*
+ *  Arduino Yun support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2015 Hauke Mehrtens <hauke@hauke-m.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include "common.h"
+#include "gpio.h"
+#include "linux/gpio.h"
+
+// Uncomment to have reset on gpio18 instead of gipo7
+#define DS2_B
+
+#define DS_GPIO_LED_WLAN		0
+#define DS_GPIO_LED_USB			1
+
+#define DS_GPIO_OE			21
+#define DS_GPIO_AVR_RESET		18
+
+// Maintained to have the console in the previous version of DS2 working
+#define DS_GPIO_AVR_RESET_DS2		7
+
+#define DS_GPIO_OE2			22
+#define DS_GPIO_UART_ENA		23
+#define DS_GPIO_CONF_BTN		20
+
+#define DS_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DS_KEYS_DEBOUNCE_INTERVAL	(3 * DS_KEYS_POLL_INTERVAL)
+
+#define DS_MAC0_OFFSET			0x0000
+#define DS_MAC1_OFFSET			0x0006
+#define DS_CALDATA_OFFSET		0x1000
+#define DS_WMAC_MAC_OFFSET		0x1002
+
+
+static struct gpio_led ds_leds_gpio[] __initdata = {
+	{
+		.name		= "arduino:white:usb",
+		.gpio		= DS_GPIO_LED_USB,
+		.active_low	= 0,
+	},
+	{
+		.name		= "arduino:blue:wlan",
+		.gpio		= DS_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static void __init ds_common_setup(void)
+{
+	static u8 mac[6];
+
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	ath79_register_m25p80(NULL);
+
+	if (ar93xx_wmac_read_mac_address(mac)) {
+		ath79_register_wmac(NULL, NULL);
+	} else {
+		ath79_register_wmac(art + DS_CALDATA_OFFSET,
+				    art + DS_WMAC_MAC_OFFSET);
+		memcpy(mac, art + DS_WMAC_MAC_OFFSET, sizeof(mac));
+	}
+
+	mac[3] |= 0x08;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	mac[3] &= 0xF7;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+}
+
+static void __init ds_setup(void)
+{
+	u32 t;
+
+	ds_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ds_leds_gpio),
+				 ds_leds_gpio);
+	ath79_register_usb();
+
+	//Disable the Function for some pins to have GPIO functionality active
+	// GPIO6-7-8 and GPIO11
+	ath79_gpio_function_setup(AR933X_GPIO_FUNC_JTAG_DISABLE | AR933X_GPIO_FUNC_I2S_MCK_EN, 0);
+
+	ath79_gpio_function2_setup(AR933X_GPIO_FUNC2_JUMPSTART_DISABLE, 0);
+
+	printk("Setting DogStick2 GPIO\n");
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	// Put the avr reset to high 
+	if (gpio_request_one(DS_GPIO_AVR_RESET_DS2,
+	    GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED, "OE-1") != 0)
+		printk("Error setting GPIO OE\n");
+	gpio_unexport(DS_GPIO_AVR_RESET_DS2);
+	gpio_free(DS_GPIO_AVR_RESET_DS2);
+
+	// enable OE of level shifter
+	if (gpio_request_one(DS_GPIO_OE,
+	    GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED, "OE-1") != 0)
+		printk("Error setting GPIO OE\n");
+
+	if (gpio_request_one(DS_GPIO_UART_ENA,
+	    GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED, "UART-ENA") != 0)
+		printk("Error setting GPIO Uart Enable\n");
+
+	// enable OE of level shifter
+	if (gpio_request_one(DS_GPIO_OE2,
+	    GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED, "OE-2") != 0)
+		printk("Error setting GPIO OE2\n");
+}
+
+MIPS_MACHINE(ATH79_MACH_ARDUINO_YUN, "Yun", "Arduino Yun", ds_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-aw-nr580.c linux-4.1.13/arch/mips/ath79/mach-aw-nr580.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-aw-nr580.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-aw-nr580.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,107 @@
+/*
+ *  AzureWave AW-NR580 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define AW_NR580_GPIO_LED_READY_RED	0
+#define AW_NR580_GPIO_LED_WLAN		1
+#define AW_NR580_GPIO_LED_READY_GREEN	2
+#define AW_NR580_GPIO_LED_WPS_GREEN	4
+#define AW_NR580_GPIO_LED_WPS_AMBER	5
+
+#define AW_NR580_GPIO_BTN_WPS		3
+#define AW_NR580_GPIO_BTN_RESET		11
+
+#define AW_NR580_KEYS_POLL_INTERVAL	20	/* msecs */
+#define AW_NR580_KEYS_DEBOUNCE_INTERVAL	(3 * AW_NR580_KEYS_POLL_INTERVAL)
+
+static struct gpio_led aw_nr580_leds_gpio[] __initdata = {
+	{
+		.name		= "aw-nr580:red:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_RED,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:ready",
+		.gpio		= AW_NR580_GPIO_LED_READY_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:amber:wps",
+		.gpio		= AW_NR580_GPIO_LED_WPS_AMBER,
+		.active_low	= 0,
+	}, {
+		.name		= "aw-nr580:green:wlan",
+		.gpio		= AW_NR580_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button aw_nr580_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AW_NR580_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = AW_NR580_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= AW_NR580_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static const char *aw_nr580_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data aw_nr580_flash_data = {
+	.part_probes	= aw_nr580_part_probes,
+};
+
+static void __init aw_nr580_setup(void)
+{
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+
+	ath79_register_pci();
+
+	ath79_register_m25p80(&aw_nr580_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(aw_nr580_leds_gpio),
+				 aw_nr580_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, AW_NR580_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(aw_nr580_gpio_keys),
+					aw_nr580_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_AW_NR580, "AW-NR580", "AzureWave AW-NR580",
+	     aw_nr580_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-bhu-bxu2000n2-a.c linux-4.1.13/arch/mips/ath79/mach-bhu-bxu2000n2-a.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-bhu-bxu2000n2-a.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-bhu-bxu2000n2-a.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,120 @@
+/*
+ *  BHU BXU2000n-2 A1 board support
+ *
+ *  Copyright (C) 2013 Terry Yang <yangbo@bhunetworks.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define BHU_BXU2000N2_A1_GPIO_LED_WLAN		13
+#define BHU_BXU2000N2_A1_GPIO_LED_WAN		19
+#define BHU_BXU2000N2_A1_GPIO_LED_LAN		21
+#define BHU_BXU2000N2_A1_GPIO_LED_SYSTEM	14
+
+#define BHU_BXU2000N2_A1_GPIO_BTN_RESET		17
+
+#define BHU_BXU2000N2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define BHU_BXU2000N2_KEYS_DEBOUNCE_INTERVAL	\
+	(3 * BHU_BXU2000N2_KEYS_POLL_INTERVAL)
+
+static const char *bhu_bxu2000n2_part_probes[] = {
+	"cmdlinepart",
+	NULL,
+};
+
+static struct flash_platform_data bhu_bxu2000n2_flash_data = {
+	.part_probes	= bhu_bxu2000n2_part_probes,
+};
+
+static struct gpio_led bhu_bxu2000n2_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "bhu:green:status",
+		.gpio		= BHU_BXU2000N2_A1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "bhu:green:lan",
+		.gpio		= BHU_BXU2000N2_A1_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "bhu:green:wan",
+		.gpio		= BHU_BXU2000N2_A1_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "bhu:green:wlan",
+		.gpio		= BHU_BXU2000N2_A1_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button bhu_bxu2000n2_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = BHU_BXU2000N2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= BHU_BXU2000N2_A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init bhu_ap123_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&bhu_bxu2000n2_flash_data);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch. Only use PHY3 */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.phy_mask = BIT(3);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, ee+2);
+}
+
+static void __init bhu_bxu2000n2_a1_setup(void)
+{
+	bhu_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(bhu_bxu2000n2_a1_leds_gpio),
+				 bhu_bxu2000n2_a1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, BHU_BXU2000N2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(bhu_bxu2000n2_a1_gpio_keys),
+					bhu_bxu2000n2_a1_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_BHU_BXU2000N2_A1, "BXU2000n-2-A1",
+	     "BHU BXU2000n-2 rev. A1",
+	     bhu_bxu2000n2_a1_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-bsb.c linux-4.1.13/arch/mips/ath79/mach-bsb.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-bsb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-bsb.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,83 @@
+/*
+ *  Smart Electronics Black Swift board support
+ *
+ *  Copyright (C) 2014 Dmitriy Zherebkov dzh@black-swift.com
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define BSB_GPIO_LED_SYS		27
+
+#define BSB_GPIO_BTN_RESET		11
+
+#define BSB_KEYS_POLL_INTERVAL		20	/* msecs */
+#define BSB_KEYS_DEBOUNCE_INTERVAL	(3 * BSB_KEYS_POLL_INTERVAL)
+
+#define BSB_MAC_OFFSET			0x0000
+#define BSB_CALDATA_OFFSET		0x1000
+
+static struct gpio_led bsb_leds_gpio[] __initdata = {
+	{
+		.name		= "bsb:red:sys",
+		.gpio		= BSB_GPIO_LED_SYS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button bsb_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = BSB_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= BSB_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init bsb_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false,false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(bsb_leds_gpio),
+				 bsb_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, BSB_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(bsb_gpio_keys),
+					bsb_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + BSB_MAC_OFFSET, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + BSB_MAC_OFFSET, 2);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + BSB_CALDATA_OFFSET,
+			    art + BSB_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_BSB, "BSB", "Smart Electronics Black Swift board",
+		bsb_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-cap4200ag.c linux-4.1.13/arch/mips/ath79/mach-cap4200ag.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-cap4200ag.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-cap4200ag.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,131 @@
+/*
+ *  Senao CAP4200AG board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define CAP4200AG_GPIO_LED_PWR_GREEN	12
+#define CAP4200AG_GPIO_LED_PWR_AMBER	13
+#define CAP4200AG_GPIO_LED_LAN_GREEN	14
+#define CAP4200AG_GPIO_LED_LAN_AMBER	15
+#define CAP4200AG_GPIO_LED_WLAN_GREEN	18
+#define CAP4200AG_GPIO_LED_WLAN_AMBER	19
+
+#define CAP4200AG_GPIO_BTN_RESET	17
+
+#define CAP4200AG_KEYS_POLL_INTERVAL	20	/* msecs */
+#define CAP4200AG_KEYS_DEBOUNCE_INTERVAL (3 * CAP4200AG_KEYS_POLL_INTERVAL)
+
+#define CAP4200AG_MAC_OFFSET		0
+#define CAP4200AG_WMAC_CALDATA_OFFSET	0x1000
+#define CAP4200AG_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led cap4200ag_leds_gpio[] __initdata = {
+	{
+		.name		= "senao:green:pwr",
+		.gpio		= CAP4200AG_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:amber:pwr",
+		.gpio		= CAP4200AG_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:green:lan",
+		.gpio		= CAP4200AG_GPIO_LED_LAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:amber:lan",
+		.gpio		= CAP4200AG_GPIO_LED_LAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:green:wlan",
+		.gpio		= CAP4200AG_GPIO_LED_WLAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "senao:amber:wlan",
+		.gpio		= CAP4200AG_GPIO_LED_WLAN_AMBER,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cap4200ag_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CAP4200AG_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CAP4200AG_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init cap4200ag_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	ath79_gpio_output_select(CAP4200AG_GPIO_LED_LAN_GREEN,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(CAP4200AG_GPIO_LED_LAN_AMBER,
+				 AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cap4200ag_leds_gpio),
+				 cap4200ag_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, CAP4200AG_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cap4200ag_gpio_keys),
+					cap4200ag_gpio_keys);
+
+	ath79_init_mac(mac, art + CAP4200AG_MAC_OFFSET, -1);
+	ath79_wmac_disable_2ghz();
+	ath79_register_wmac(art + CAP4200AG_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_init_mac(mac, art + CAP4200AG_MAC_OFFSET, -2);
+	ap91_pci_init(art + CAP4200AG_PCIE_CALDATA_OFFSET, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + CAP4200AG_MAC_OFFSET, -2);
+
+	/* GMAC0 is connected to an external PHY */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_CAP4200AG, "CAP4200AG", "Senao CAP4200AG",
+	     cap4200ag_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-carambola2.c linux-4.1.13/arch/mips/ath79/mach-carambola2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-carambola2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-carambola2.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,105 @@
+/*
+ *  8devices Carambola2 board support
+ *
+ *  Copyright (C) 2013 Darius Augulis <darius@8devices.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define CARAMBOLA2_GPIO_LED_WLAN		0
+#define CARAMBOLA2_GPIO_LED_ETH0		14
+#define CARAMBOLA2_GPIO_LED_ETH1		13
+
+#define CARAMBOLA2_GPIO_BTN_JUMPSTART		11
+
+#define CARAMBOLA2_KEYS_POLL_INTERVAL		20	/* msecs */
+#define CARAMBOLA2_KEYS_DEBOUNCE_INTERVAL	(3 * CARAMBOLA2_KEYS_POLL_INTERVAL)
+
+#define CARAMBOLA2_MAC0_OFFSET			0x0000
+#define CARAMBOLA2_MAC1_OFFSET			0x0006
+#define CARAMBOLA2_CALDATA_OFFSET		0x1000
+#define CARAMBOLA2_WMAC_MAC_OFFSET		0x1002
+
+static struct gpio_led carambola2_leds_gpio[] __initdata = {
+	{
+		.name		= "carambola2:green:wlan",
+		.gpio		= CARAMBOLA2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "carambola2:orange:eth0",
+		.gpio		= CARAMBOLA2_GPIO_LED_ETH0,
+		.active_low	= 0,
+	}, {
+		.name		= "carambola2:orange:eth1",
+		.gpio		= CARAMBOLA2_GPIO_LED_ETH1,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button carambola2_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = CARAMBOLA2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CARAMBOLA2_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+};
+
+static void __init carambola2_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art + CARAMBOLA2_CALDATA_OFFSET,
+			    art + CARAMBOLA2_WMAC_MAC_OFFSET);
+
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + CARAMBOLA2_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + CARAMBOLA2_MAC1_OFFSET, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+}
+
+static void __init carambola2_setup(void)
+{
+	carambola2_common_setup();
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(carambola2_leds_gpio),
+				 carambola2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, CARAMBOLA2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(carambola2_gpio_keys),
+					carambola2_gpio_keys);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_CARAMBOLA2, "CARAMBOLA2", "8devices Carambola2 board",
+		carambola2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-cf-e316n-v2.c linux-4.1.13/arch/mips/ath79/mach-cf-e316n-v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-cf-e316n-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-cf-e316n-v2.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,132 @@
+/*
+ *  COMFAST CF-E316N v2
+ *  by Shenzhen Four Seas Global Link Network Technology Co., Ltd
+ *
+ *  aka CF-E316V2, CF-E316N-V2 and CF-E316Nv2.0 (no FCC ID)
+ *
+ *  Copyright (C) 2015 Paul Fertser <fercerpav@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+static struct gpio_led cf_e316n_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "cf-e316n-v2:blue:diag",
+		.gpio		= 0,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e316n-v2:red:diag",
+		.gpio		= 2,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e316n-v2:green:diag",
+		.gpio		= 3,
+		.active_low	= 0,
+	}, {
+		.name		= "cf-e316n-v2:blue:wlan",
+		.gpio		= 12,
+		.active_low	= 1,
+	}, {
+		.name		= "cf-e316n-v2:blue:wan",
+		.gpio		= 17,
+		.active_low	= 1,
+	}, {
+		.name		= "cf-e316n-v2:blue:lan",
+		.gpio		= 19,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cf_e316n_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = 60,
+		.gpio		= 20,
+		.active_low	= 1,
+	},
+};
+
+/* There's a Pericon Technology PT7A7514 connected to GPIO 16 */
+#define EXT_WATCHDOG_GPIO	16
+static struct timer_list gpio_wdt_timer;
+
+static void gpio_wdt_toggle(unsigned long period)
+{
+	static int state;
+	state = !state;
+	gpio_set_value(EXT_WATCHDOG_GPIO, state);
+	mod_timer(&gpio_wdt_timer, jiffies + period);
+}
+
+static void __init cf_e316n_v2_setup(void)
+{
+	u8 *maclan = (u8 *) KSEG1ADDR(0x1f010000);
+	u8 *macwlan = (u8 *) KSEG1ADDR(0x1f011002);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1f011000);
+	u8 tmpmac[ETH_ALEN];
+
+	gpio_request(EXT_WATCHDOG_GPIO, "PT7A7514 watchdog");
+	gpio_direction_output(EXT_WATCHDOG_GPIO, 0);
+	setup_timer(&gpio_wdt_timer, gpio_wdt_toggle, msecs_to_jiffies(500));
+	gpio_wdt_toggle(msecs_to_jiffies(1));
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_init_mac(ath79_eth0_data.mac_addr, maclan, 0);
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_init_mac(ath79_eth1_data.mac_addr, maclan, 2);
+	ath79_register_eth(1);
+
+	/* Enable 2x Skyworks SE2576L WLAN power amplifiers */
+	gpio_request(13, "RF Amp 1");
+	gpio_direction_output(13, 1);
+	gpio_request(14, "RF Amp 2");
+	gpio_direction_output(14, 1);
+	ath79_init_mac(tmpmac, macwlan, 0);
+	ath79_register_wmac(ee, tmpmac);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cf_e316n_v2_leds_gpio),
+				 cf_e316n_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, 20,
+					ARRAY_SIZE(cf_e316n_v2_gpio_keys),
+					cf_e316n_v2_gpio_keys);
+
+	/* J1 is a High-Speed USB port, pin 1 is Vcc */
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_CF_E316N_V2, "CF-E316N-V2", "COMFAST CF-E316N v2",
+	     cf_e316n_v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-cpe510.c linux-4.1.13/arch/mips/ath79/mach-cpe510.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-cpe510.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-cpe510.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,107 @@
+/*
+ *  TP-LINK CPE210/220/510/520 board support
+ *
+ *  Copyright (C) 2014 Matthias Schiffer <mschiffer@universe-factory.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+#define CPE510_GPIO_LED_LAN0	11
+#define CPE510_GPIO_LED_LAN1	12
+#define CPE510_GPIO_LED_L1	13
+#define CPE510_GPIO_LED_L2	14
+#define CPE510_GPIO_LED_L3	15
+#define CPE510_GPIO_LED_L4	16
+
+#define CPE510_GPIO_BTN_RESET	4
+
+#define CPE510_KEYS_POLL_INTERVAL	20 /* msecs */
+#define CPE510_KEYS_DEBOUNCE_INTERVAL	(3 * CPE510_KEYS_POLL_INTERVAL)
+
+
+static struct gpio_led cpe510_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan0",
+		.gpio		= CPE510_GPIO_LED_LAN0,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan1",
+		.gpio		= CPE510_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link1",
+		.gpio		= CPE510_GPIO_LED_L1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link2",
+		.gpio		= CPE510_GPIO_LED_L2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link3",
+		.gpio		= CPE510_GPIO_LED_L3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:link4",
+		.gpio		= CPE510_GPIO_LED_L4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button cpe510_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = CPE510_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= CPE510_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+
+static void __init cpe510_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f830008);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	/* Configure OBS4 line, for GPIO 4*/
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				  AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(cpe510_leds_gpio),
+				 cpe510_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, CPE510_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(cpe510_gpio_keys),
+					cpe510_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_CPE510, "CPE510", "TP-LINK CPE210/220/510/520",
+	     cpe510_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-db120.c linux-4.1.13/arch/mips/ath79/mach-db120.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-db120.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-db120.c	2015-12-04 19:57:04.322082119 +0100
@@ -2,7 +2,7 @@
  * Atheros DB120 reference board support
  *
  * Copyright (c) 2011 Qualcomm Atheros
- * Copyright (c) 2011 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -19,16 +19,26 @@
  */
 
 #include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
 #include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
 
-#include "machtypes.h"
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
 #include "dev-spi.h"
 #include "dev-usb.h"
 #include "dev-wmac.h"
-#include "pci.h"
+#include "machtypes.h"
 
+#define DB120_GPIO_LED_USB		11
 #define DB120_GPIO_LED_WLAN_5G		12
 #define DB120_GPIO_LED_WLAN_2G		13
 #define DB120_GPIO_LED_STATUS		14
@@ -39,8 +49,10 @@
 #define DB120_KEYS_POLL_INTERVAL	20	/* msecs */
 #define DB120_KEYS_DEBOUNCE_INTERVAL	(3 * DB120_KEYS_POLL_INTERVAL)
 
-#define DB120_WMAC_CALDATA_OFFSET 0x1000
-#define DB120_PCIE_CALDATA_OFFSET 0x5000
+#define DB120_MAC0_OFFSET		0
+#define DB120_MAC1_OFFSET		6
+#define DB120_WMAC_CALDATA_OFFSET	0x1000
+#define DB120_PCIE_CALDATA_OFFSET	0x5000
 
 static struct gpio_led db120_leds_gpio[] __initdata = {
 	{
@@ -63,6 +75,11 @@
 		.gpio		= DB120_GPIO_LED_WLAN_2G,
 		.active_low	= 1,
 	},
+	{
+		.name		= "db120:green:usb",
+		.gpio		= DB120_GPIO_LED_USB,
+		.active_low	= 1,
+	}
 };
 
 static struct gpio_keys_button db120_gpio_keys[] __initdata = {
@@ -76,60 +93,85 @@
 	},
 };
 
-static struct spi_board_info db120_spi_info[] = {
-	{
-		.bus_num	= 0,
-		.chip_select	= 0,
-		.max_speed_hz	= 25000000,
-		.modalias	= "s25sl064a",
-	}
+static struct ar8327_pad_cfg db120_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
 };
 
-static struct ath79_spi_platform_data db120_spi_data = {
-	.bus_num	= 0,
-	.num_chipselect = 1,
+static struct ar8327_led_cfg db120_ar8327_led_cfg = {
+	.led_ctrl0 = 0x00000000,
+	.led_ctrl1 = 0xc737c737,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00c30c00,
+	.open_drain = true,
 };
 
-#ifdef CONFIG_PCI
-static struct ath9k_platform_data db120_ath9k_data;
-
-static int db120_pci_plat_dev_init(struct pci_dev *dev)
-{
-	switch (PCI_SLOT(dev->devfn)) {
-	case 0:
-		dev->dev.platform_data = &db120_ath9k_data;
-		break;
-	}
-
-	return 0;
-}
-
-static void __init db120_pci_init(u8 *eeprom)
-{
-	memcpy(db120_ath9k_data.eeprom_data, eeprom,
-	       sizeof(db120_ath9k_data.eeprom_data));
+static struct ar8327_platform_data db120_ar8327_data = {
+	.pad0_cfg = &db120_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &db120_ar8327_led_cfg,
+};
 
-	ath79_pci_set_plat_dev_init(db120_pci_plat_dev_init);
-	ath79_register_pci();
-}
-#else
-static inline void db120_pci_init(u8 *eeprom) {}
-#endif /* CONFIG_PCI */
+static struct mdio_board_info db120_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &db120_ar8327_data,
+	},
+};
 
 static void __init db120_setup(void)
 {
 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
 
+	ath79_gpio_output_select(DB120_GPIO_LED_USB, AR934X_GPIO_OUT_GPIO);
+	ath79_register_m25p80(NULL);
+
 	ath79_register_leds_gpio(-1, ARRAY_SIZE(db120_leds_gpio),
 				 db120_leds_gpio);
 	ath79_register_gpio_keys_polled(-1, DB120_KEYS_POLL_INTERVAL,
 					ARRAY_SIZE(db120_gpio_keys),
 					db120_gpio_keys);
-	ath79_register_spi(&db120_spi_data, db120_spi_info,
-			   ARRAY_SIZE(db120_spi_info));
 	ath79_register_usb();
-	ath79_register_wmac(art + DB120_WMAC_CALDATA_OFFSET);
-	db120_pci_init(art + DB120_PCIE_CALDATA_OFFSET);
+	ath79_register_wmac(art + DB120_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(art + DB120_PCIE_CALDATA_OFFSET, NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + DB120_MAC0_OFFSET, 0);
+
+	mdiobus_register_board_info(db120_mdio0_info,
+				    ARRAY_SIZE(db120_mdio0_info));
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + DB120_MAC1_OFFSET, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+
+	ath79_register_nfc();
 }
 
 MIPS_MACHINE(ATH79_MACH_DB120, "DB120", "Atheros DB120 reference board",
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dgl-5500-a1.c linux-4.1.13/arch/mips/ath79/mach-dgl-5500-a1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dgl-5500-a1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dgl-5500-a1.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,150 @@
+/*
+ *  D-Link DGL-5500 board support
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DGL_5500_A1_GPIO_LED_POWER_ORANGE	14
+#define DGL_5500_A1_GPIO_LED_POWER_GREEN	19
+#define DGL_5500_A1_GPIO_LED_PLANET_GREEN	22
+#define DGL_5500_A1_GPIO_LED_PLANET_ORANGE	23
+
+#define DGL_5500_A1_GPIO_BTN_WPS		16
+#define DGL_5500_A1_GPIO_BTN_RESET		17
+
+#define DGL_5500_A1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DGL_5500_A1_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * DGL_5500_A1_KEYS_POLL_INTERVAL)
+
+#define DGL_5500_A1_WMAC_CALDATA_OFFSET		0x1000
+
+#define DGL_5500_A1_LAN_MAC_OFFSET	0x04
+#define DGL_5500_A1_WAN_MAC_OFFSET	0x16
+
+static struct gpio_led dgl_5500_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DGL_5500_A1_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:orange:power",
+		.gpio		= DGL_5500_A1_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:planet",
+		.gpio		= DGL_5500_A1_GPIO_LED_PLANET_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:orange:planet",
+		.gpio		= DGL_5500_A1_GPIO_LED_PLANET_ORANGE,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dgl_5500_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DGL_5500_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DGL_5500_A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DGL_5500_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DGL_5500_A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg dgl_5500_a1_ar8327_pad0_cfg = {
+	/* Use the SGMII interface for the GMAC0 of the AR8327 switch */
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data dgl_5500_a1_ar8327_data = {
+	.pad0_cfg = &dgl_5500_a1_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info dgl_5500_a1_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &dgl_5500_a1_ar8327_data,
+	},
+};
+
+static void __init dgl_5500_a1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ffe0000);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 lan_mac[ETH_ALEN];
+
+	ath79_parse_ascii_mac(mac + DGL_5500_A1_LAN_MAC_OFFSET, lan_mac);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dgl_5500_a1_leds_gpio),
+				 dgl_5500_a1_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DGL_5500_A1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dgl_5500_a1_gpio_keys),
+					dgl_5500_a1_gpio_keys);
+
+	ath79_register_wmac(art + DGL_5500_A1_WMAC_CALDATA_OFFSET, lan_mac);
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(dgl_5500_a1_mdio0_info,
+				    ARRAY_SIZE(dgl_5500_a1_mdio0_info));
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, lan_mac, 0);
+
+	/* GMAC1 is connected to an AR8327N switch via the SMGII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.phy_mask = BIT(0);
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_DGL_5500_A1, "DGL-5500-A1", "D-Link DGL-5500 rev. A1",
+	     dgl_5500_a1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dhp-1565-a1.c linux-4.1.13/arch/mips/ath79/mach-dhp-1565-a1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dhp-1565-a1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dhp-1565-a1.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,170 @@
+/*
+ *  D-Link DHP-1565 rev. A1 board support
+ *
+ *  Copyright (C) 2014 Jacek Kikiewicz
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DHP1565A1_GPIO_LED_BLUE_USB		11
+#define DHP1565A1_GPIO_LED_AMBER_POWER		14
+#define DHP1565A1_GPIO_LED_BLUE_POWER		22
+#define DHP1565A1_GPIO_LED_BLUE_WPS		15
+#define DHP1565A1_GPIO_LED_AMBER_PLANET		19
+#define DHP1565A1_GPIO_LED_BLUE_PLANET		18
+#define DHP1565A1_GPIO_LED_WLAN_2G		13
+
+#define DHP1565A1_GPIO_WAN_LED_ENABLE		20
+
+#define DHP1565A1_GPIO_BTN_RESET			17
+#define DHP1565A1_GPIO_BTN_WPS			16
+
+#define DHP1565A1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DHP1565A1_KEYS_DEBOUNCE_INTERVAL		(3 * DHP1565A1_KEYS_POLL_INTERVAL)
+
+#define DHP1565A1_MAC0_OFFSET			0xFFA0
+#define DHP1565A1_MAC1_OFFSET			0xFFB4
+#define DHP1565A1_WMAC0_OFFSET			0x5
+#define DHP1565A1_WMAC_CALDATA_OFFSET		0x1000
+#define DHP1565A1_PCIE_CALDATA_OFFSET		0x5000
+
+static struct gpio_led dhp1565a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:amber:power",
+		.gpio		= DHP1565A1_GPIO_LED_AMBER_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DHP1565A1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:amber:planet",
+		.gpio		= DHP1565A1_GPIO_LED_AMBER_PLANET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:planet",
+		.gpio		= DHP1565A1_GPIO_LED_BLUE_PLANET,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dhp1565a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Soft reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DHP1565A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DHP1565A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DHP1565A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DHP1565A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg dhp1565a1_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data dhp1565a1_ar8327_data = {
+	.pad0_cfg = &dhp1565a1_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info dhp1565a1_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &dhp1565a1_ar8327_data,
+	},
+};
+
+static void __init dhp1565a1_generic_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ffe0000);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac0[ETH_ALEN], mac1[ETH_ALEN];
+	u8 wmac0[ETH_ALEN];
+
+	ath79_parse_ascii_mac(mac + DHP1565A1_MAC0_OFFSET, mac0);
+	ath79_parse_ascii_mac(mac + DHP1565A1_MAC1_OFFSET, mac1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_gpio_keys_polled(-1, DHP1565A1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dhp1565a1_gpio_keys),
+					dhp1565a1_gpio_keys);
+
+	ath79_init_mac(wmac0, mac0, 0);
+	ath79_register_wmac(art + DHP1565A1_WMAC_CALDATA_OFFSET, wmac0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(dhp1565a1_mdio0_info,
+				    ARRAY_SIZE(dhp1565a1_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 1);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+static void __init dhp1565a1_setup(void)
+{
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dhp1565a1_leds_gpio),
+				 dhp1565a1_leds_gpio);
+
+	dhp1565a1_generic_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_DHP_1565_A1, "DHP-1565-A1",
+	     "D-Link DHP-1565 rev. A1",
+	     dhp1565a1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dir-505-a1.c linux-4.1.13/arch/mips/ath79/mach-dir-505-a1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dir-505-a1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dir-505-a1.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,116 @@
+/*
+ *  DLink DIR-505 A1 board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define DIR_505A1_GPIO_BTN_WPS         11 /* verify */
+#define DIR_505A1_GPIO_BTN_RESET       12 /* verify */
+
+#define DIR_505A1_GPIO_LED_RED         26 /* unused, fyi */
+#define DIR_505A1_GPIO_LED_GREEN       27
+
+#define DIR_505A1_GPIO_WAN_LED_ENABLE  1
+
+#define DIR_505A1_KEYS_POLL_INTERVAL   20      /* msecs */
+#define DIR_505A1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_505A1_KEYS_POLL_INTERVAL)
+
+#define DIR_505A1_ART_ADDRESS          0x1f010000
+#define DIR_505A1_CALDATA_OFFSET       0x1000
+
+#define DIR_505A1_MAC_PART_ADDRESS	0x1f020000
+#define DIR_505A1_LAN_MAC_OFFSET	0x04
+#define DIR_505A1_WAN_MAC_OFFSET	0x16
+
+static struct gpio_led dir_505_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DIR_505A1_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:red:status",
+		.gpio		= DIR_505A1_GPIO_LED_RED,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dir_505_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_505A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_505A1_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}, {
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_505A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_505A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init dir_505_a1_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(DIR_505A1_ART_ADDRESS);
+	u8 *mac = (u8 *) KSEG1ADDR(DIR_505A1_MAC_PART_ADDRESS);
+	u8 lan_mac[ETH_ALEN];
+	u8 wan_mac[ETH_ALEN];
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+		AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	gpio_request_one(DIR_505A1_GPIO_WAN_LED_ENABLE,
+		GPIOF_OUT_INIT_LOW, "WAN LED enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_505_a1_leds_gpio),
+		dir_505_a1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, DIR_505A1_KEYS_POLL_INTERVAL,
+		ARRAY_SIZE(dir_505_a1_gpio_keys),
+		dir_505_a1_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_usb();
+
+	ath79_parse_ascii_mac(mac + DIR_505A1_LAN_MAC_OFFSET, lan_mac);
+	ath79_parse_ascii_mac(mac + DIR_505A1_WAN_MAC_OFFSET, wan_mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, wan_mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, lan_mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + DIR_505A1_CALDATA_OFFSET, lan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_505_A1, "DIR-505-A1",
+		"D-Link DIR-505 rev. A1", dir_505_a1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dir-600-a1.c linux-4.1.13/arch/mips/ath79/mach-dir-600-a1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dir-600-a1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dir-600-a1.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,159 @@
+/*
+ *  D-Link DIR-600 rev. A1 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2012 Vadim Girlin <vadimgirlin@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define DIR_600_A1_GPIO_LED_WPS			0
+#define DIR_600_A1_GPIO_LED_POWER_AMBER		1
+#define DIR_600_A1_GPIO_LED_POWER_GREEN		6
+#define DIR_600_A1_GPIO_LED_LAN1		13
+#define DIR_600_A1_GPIO_LED_LAN2		14
+#define DIR_600_A1_GPIO_LED_LAN3		15
+#define DIR_600_A1_GPIO_LED_LAN4		16
+#define DIR_600_A1_GPIO_LED_WAN_AMBER		7
+#define DIR_600_A1_GPIO_LED_WAN_GREEN		17
+
+#define DIR_600_A1_GPIO_BTN_RESET		8
+#define DIR_600_A1_GPIO_BTN_WPS			12
+
+#define DIR_600_A1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR_600_A1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_600_A1_KEYS_POLL_INTERVAL)
+
+#define DIR_600_A1_NVRAM_ADDR	0x1f030000
+#define DIR_600_A1_NVRAM_SIZE	0x10000
+
+static struct gpio_led dir_600_a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_GREEN,
+	}, {
+		.name		= "d-link:amber:power",
+		.gpio		= DIR_600_A1_GPIO_LED_POWER_AMBER,
+	}, {
+		.name		= "d-link:amber:wan",
+		.gpio		= DIR_600_A1_GPIO_LED_WAN_AMBER,
+	}, {
+		.name		= "d-link:green:wan",
+		.gpio		= DIR_600_A1_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan1",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan2",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan3",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:lan4",
+		.gpio		= DIR_600_A1_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR_600_A1_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dir_600_a1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_600_A1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_600_A1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_600_A1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init dir_600_a1_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(DIR_600_A1_NVRAM_ADDR);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac_buff[6];
+	u8 *mac = NULL;
+
+	if (ath79_nvram_parse_mac_addr(nvram, DIR_600_A1_NVRAM_SIZE,
+				       "lan_mac=", mac_buff) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac_buff, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac_buff, 1);
+		mac = mac_buff;
+	}
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_600_a1_leds_gpio),
+				 dir_600_a1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR_600_A1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_600_a1_gpio_keys),
+					dir_600_a1_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_600_A1, "DIR-600-A1", "D-Link DIR-600 rev. A1",
+	     dir_600_a1_setup);
+
+static void __init dir_615_e1_setup(void)
+{
+	dir_600_a1_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_E1, "DIR-615-E1", "D-Link DIR-615 rev. E1",
+	     dir_615_e1_setup);
+
+static void __init dir_615_e4_setup(void)
+{
+	dir_600_a1_setup();
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_E4, "DIR-615-E4", "D-Link DIR-615 rev. E4",
+	     dir_615_e4_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dir-615-c1.c linux-4.1.13/arch/mips/ath79/mach-dir-615-c1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dir-615-c1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dir-615-c1.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,135 @@
+/*
+ *  D-Link DIR-615 rev C1 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define DIR_615C1_GPIO_LED_ORANGE_STATUS 1	/* ORANGE:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_BLUE_WPS	3	/* BLUE:WPS */
+#define DIR_615C1_GPIO_LED_GREEN_WAN	4       /* GREEN:WAN:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WANCPU	5       /* GREEN:WAN:CPU:TRICOLOR */
+#define DIR_615C1_GPIO_LED_GREEN_WLAN	6	/* GREEN:WLAN */
+#define DIR_615C1_GPIO_LED_GREEN_STATUS	14	/* GREEN:STATUS:TRICOLOR */
+#define DIR_615C1_GPIO_LED_ORANGE_WAN	15	/* ORANGE:WAN:TRICOLOR */
+
+/* buttons may need refinement */
+
+#define DIR_615C1_GPIO_BTN_WPS		12
+#define DIR_615C1_GPIO_BTN_RESET	21
+
+#define DIR_615C1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DIR_615C1_KEYS_DEBOUNCE_INTERVAL (3 * DIR_615C1_KEYS_POLL_INTERVAL)
+
+#define DIR_615C1_CONFIG_ADDR		0x1f020000
+#define DIR_615C1_CONFIG_SIZE		0x10000
+
+#define DIR_615C1_WLAN_MAC_ADDR		0x1f3fffb4
+
+static struct gpio_led dir_615c1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:orange:status",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR_615C1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:wan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:wancpu",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WANCPU,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:wlan",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:green:status",
+		.gpio		= DIR_615C1_GPIO_LED_GREEN_STATUS,
+		.active_low     = 1,
+	}, {
+		.name		= "d-link:orange:wan",
+		.gpio		= DIR_615C1_GPIO_LED_ORANGE_WAN,
+		.active_low	= 1,
+	}
+
+};
+
+static struct gpio_keys_button dir_615c1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615C1_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_615C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615C1_GPIO_BTN_WPS,
+	}
+};
+
+#define DIR_615C1_LAN_PHYMASK	BIT(0)
+#define DIR_615C1_WAN_PHYMASK	BIT(4)
+#define DIR_615C1_MDIO_MASK	(~(DIR_615C1_LAN_PHYMASK | \
+				   DIR_615C1_WAN_PHYMASK))
+
+static void __init dir_615c1_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(DIR_615C1_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[ETH_ALEN], wlan_mac[ETH_ALEN];
+
+	if (ath79_nvram_parse_mac_addr(config, DIR_615C1_CONFIG_SIZE,
+				       "lan_mac=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	}
+
+	ath79_parse_ascii_mac((char *) KSEG1ADDR(DIR_615C1_WLAN_MAC_ADDR), wlan_mac);
+
+	ath79_register_mdio(0, DIR_615C1_MDIO_MASK);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = DIR_615C1_LAN_PHYMASK;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = DIR_615C1_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_615c1_leds_gpio),
+				 dir_615c1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR_615C1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_615c1_gpio_keys),
+					dir_615c1_gpio_keys);
+
+	ath79_register_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_C1, "DIR-615-C1", "D-Link DIR-615 rev. C1",
+	     dir_615c1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dir-615-i1.c linux-4.1.13/arch/mips/ath79/mach-dir-615-i1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dir-615-i1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dir-615-i1.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,133 @@
+/*
+ *  D-Link DIR-615 rev. I1 board support
+ *  Copyright (C) 2013-2015 Jaehoon You <teslamint@gmail.com>
+ *
+ *  based on the DIR-600 rev. A1 board support code
+ *    Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *    Copyright (C) 2012 Vadim Girlin <vadimgirlin@gmail.com>
+ *
+ *  based on the TP-LINK TL-WR841N/ND v8/TL-MR3420 v2 board support code
+ *    Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DIR_615_I1_GPIO_LED_WPS				15
+#define DIR_615_I1_GPIO_LED_POWER_AMBER		14
+#define DIR_615_I1_GPIO_LED_POWER_GREEN		4
+#define DIR_615_I1_GPIO_LED_WAN_AMBER		22
+#define DIR_615_I1_GPIO_LED_WAN_GREEN		12
+#define DIR_615_I1_GPIO_LED_WLAN_GREEN		13
+
+#define DIR_615_I1_GPIO_BTN_WPS				16
+#define DIR_615_I1_GPIO_BTN_RESET			17
+
+#define DIR_615_I1_KEYS_POLL_INTERVAL		20 /* msecs */
+#define DIR_615_I1_KEYS_DEBOUNCE_INTERVAL	(3 * DIR_615_I1_KEYS_POLL_INTERVAL)
+
+#define DIR_615_I1_LAN_PHYMASK	BIT(0)
+#define DIR_615_I1_WAN_PHYMASK	BIT(4)
+#define DIR_615_I1_WLAN_MAC_ADDR	0x1fffffb4
+
+static struct gpio_led dir_615_i1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DIR_615_I1_GPIO_LED_POWER_GREEN,
+	}, {
+		.name		= "d-link:amber:power",
+		.gpio		= DIR_615_I1_GPIO_LED_POWER_AMBER,
+	}, {
+		.name		= "d-link:amber:wan",
+		.gpio		= DIR_615_I1_GPIO_LED_WAN_AMBER,
+	}, {
+		.name		= "d-link:green:wan",
+		.gpio		= DIR_615_I1_GPIO_LED_WAN_GREEN,
+		.active_low = 1,
+	}, {
+		.name		= "d-link:green:wlan",
+		.gpio		= DIR_615_I1_GPIO_LED_WLAN_GREEN,
+		.active_low = 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR_615_I1_GPIO_LED_WPS,
+		.active_low = 1,
+	}
+};
+
+static struct gpio_keys_button dir_615_i1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR_615_I1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615_I1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR_615_I1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR_615_I1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init dir_615_i1_setup(void)
+{
+	u8 *eeprom  = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[ETH_ALEN];
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, ~(DIR_615_I1_WAN_PHYMASK));
+
+	ath79_parse_ascii_mac((char *) KSEG1ADDR(DIR_615_I1_WLAN_MAC_ADDR), mac);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = DIR_615_I1_WAN_PHYMASK;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_mask = DIR_615_I1_LAN_PHYMASK;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	/* Configure OBS4 line, for GPIO 4*/
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				 AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir_615_i1_leds_gpio),
+					dir_615_i1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR_615_I1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir_615_i1_gpio_keys),
+					dir_615_i1_gpio_keys);
+
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_615_I1, "DIR-615-I1", "D-Link DIR-615 rev. I1",
+		dir_615_i1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dir-825-b1.c linux-4.1.13/arch/mips/ath79/mach-dir-825-b1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dir-825-b1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dir-825-b1.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,191 @@
+/*
+ *  D-Link DIR-825 rev. B1 board support
+ *
+ *  Copyright (C) 2009-2011 Lukas Kuna, Evkanet, s.r.o.
+ *
+ *  based on mach-wndr3700.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define DIR825B1_GPIO_LED_BLUE_USB		0
+#define DIR825B1_GPIO_LED_ORANGE_POWER		1
+#define DIR825B1_GPIO_LED_BLUE_POWER		2
+#define DIR825B1_GPIO_LED_BLUE_WPS		4
+#define DIR825B1_GPIO_LED_ORANGE_PLANET		6
+#define DIR825B1_GPIO_LED_BLUE_PLANET		11
+
+#define DIR825B1_GPIO_BTN_RESET			3
+#define DIR825B1_GPIO_BTN_WPS			8
+
+#define DIR825B1_GPIO_RTL8366_SDA		5
+#define DIR825B1_GPIO_RTL8366_SCK		7
+
+#define DIR825B1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR825B1_KEYS_DEBOUNCE_INTERVAL		(3 * DIR825B1_KEYS_POLL_INTERVAL)
+
+#define DIR825B1_CAL0_OFFSET			0x1000
+#define DIR825B1_CAL1_OFFSET			0x5000
+#define DIR825B1_MAC0_OFFSET			0xffa0
+#define DIR825B1_MAC1_OFFSET			0xffb4
+
+#define DIR825B1_CAL_LOCATION_0			0x1f660000
+#define DIR825B1_CAL_LOCATION_1			0x1f7f0000
+
+static struct gpio_led dir825b1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:blue:usb",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:orange:power",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:power",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:orange:planet",
+		.gpio		= DIR825B1_GPIO_LED_ORANGE_PLANET,
+		.active_low	= 1,
+	}, {
+		.name		= "d-link:blue:planet",
+		.gpio		= DIR825B1_GPIO_LED_BLUE_PLANET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dir825b1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825B1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR825B1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825B1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_initval dir825b1_rtl8366s_initvals[] = {
+	{ .reg = 0x06, .val = 0x0108 },
+};
+
+static struct rtl8366_platform_data dir825b1_rtl8366s_data = {
+	.gpio_sda	= DIR825B1_GPIO_RTL8366_SDA,
+	.gpio_sck	= DIR825B1_GPIO_RTL8366_SCK,
+	.num_initvals	= ARRAY_SIZE(dir825b1_rtl8366s_initvals),
+	.initvals	= dir825b1_rtl8366s_initvals,
+};
+
+static struct platform_device dir825b1_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &dir825b1_rtl8366s_data,
+	}
+};
+
+static bool __init dir825b1_is_caldata_valid(u8 *p)
+{
+	u16 *magic0, *magic1;
+
+	magic0 = (u16 *)(p + DIR825B1_CAL0_OFFSET);
+	magic1 = (u16 *)(p + DIR825B1_CAL1_OFFSET);
+
+	return (*magic0 == 0xa55a && *magic1 == 0xa55a);
+}
+
+static void __init dir825b1_wlan_init(void)
+{
+	u8 *caldata;
+	u8 mac0[ETH_ALEN], mac1[ETH_ALEN];
+	u8 wmac0[ETH_ALEN], wmac1[ETH_ALEN];
+
+	caldata = (u8 *) KSEG1ADDR(DIR825B1_CAL_LOCATION_0);
+	if (!dir825b1_is_caldata_valid(caldata)) {
+		caldata = (u8 *)KSEG1ADDR(DIR825B1_CAL_LOCATION_1);
+		if (!dir825b1_is_caldata_valid(caldata)) {
+			pr_err("no calibration data found\n");
+			return;
+		}
+	}
+
+	ath79_parse_ascii_mac(caldata + DIR825B1_MAC0_OFFSET, mac0);
+	ath79_parse_ascii_mac(caldata + DIR825B1_MAC1_OFFSET, mac1);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, 0);
+	ath79_init_mac(wmac0, mac0, 0);
+	ath79_init_mac(wmac1, mac1, 1);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init(caldata + DIR825B1_CAL0_OFFSET, wmac0,
+		      caldata + DIR825B1_CAL1_OFFSET, wmac1);
+}
+
+static void __init dir825b1_setup(void)
+{
+	dir825b1_wlan_init();
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+
+	ath79_eth1_data.mii_bus_dev = &dir825b1_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+	ath79_eth1_pll_data.pll_1000 = 0x11110000;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir825b1_leds_gpio),
+				 dir825b1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DIR825B1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir825b1_gpio_keys),
+					dir825b1_gpio_keys);
+
+	ath79_register_usb();
+
+	platform_device_register(&dir825b1_rtl8366s_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_825_B1, "DIR-825-B1", "D-Link DIR-825 rev. B1",
+	     dir825b1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dir-825-c1.c linux-4.1.13/arch/mips/ath79/mach-dir-825-c1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dir-825-c1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dir-825-c1.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,241 @@
+/*
+ *  D-Link DIR-825 rev. C1 board support
+ *
+ *  Copyright (C) 2013 Alexander Stadler
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DIR825C1_GPIO_LED_BLUE_USB		11
+#define DIR825C1_GPIO_LED_AMBER_POWER		14
+#define DIR825C1_GPIO_LED_BLUE_POWER		22
+#define DIR825C1_GPIO_LED_BLUE_WPS		15
+#define DIR825C1_GPIO_LED_AMBER_PLANET		19
+#define DIR825C1_GPIO_LED_BLUE_PLANET		18
+#define DIR825C1_GPIO_LED_WLAN_2G		13
+
+#define DIR825C1_GPIO_WAN_LED_ENABLE		20
+
+#define DIR825C1_GPIO_BTN_RESET			17
+#define DIR825C1_GPIO_BTN_WPS			16
+
+#define DIR825C1_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DIR825C1_KEYS_DEBOUNCE_INTERVAL		(3 * DIR825C1_KEYS_POLL_INTERVAL)
+
+#define DIR825C1_MAC0_OFFSET			0x4
+#define DIR825C1_MAC1_OFFSET			0x18
+#define DIR825C1_WMAC_CALDATA_OFFSET		0x1000
+#define DIR825C1_PCIE_CALDATA_OFFSET		0x5000
+
+static struct gpio_led dir825c1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:blue:usb",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:amber:power",
+		.gpio		= DIR825C1_GPIO_LED_AMBER_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:blue:power",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:amber:planet",
+		.gpio		= DIR825C1_GPIO_LED_AMBER_PLANET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:blue:wlan2g",
+		.gpio		= DIR825C1_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led dir835a1_leds_gpio[] __initdata = {
+	{
+		.name		= "d-link:amber:power",
+		.gpio		= DIR825C1_GPIO_LED_AMBER_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:power",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:blue:wps",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:amber:planet",
+		.gpio		= DIR825C1_GPIO_LED_AMBER_PLANET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "d-link:green:planet",
+		.gpio		= DIR825C1_GPIO_LED_BLUE_PLANET,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dir825c1_gpio_keys[] __initdata = {
+	{
+		.desc		= "Soft reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DIR825C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825C1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DIR825C1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DIR825C1_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg dir825c1_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg dir825c1_ar8327_led_cfg = {
+	.led_ctrl0 = 0x00000000,
+	.led_ctrl1 = 0xc737c737,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00c30c00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data dir825c1_ar8327_data = {
+	.pad0_cfg = &dir825c1_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &dir825c1_ar8327_led_cfg,
+};
+
+static struct mdio_board_info dir825c1_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &dir825c1_ar8327_data,
+	},
+};
+
+static void __init dir825c1_generic_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1ffe0000);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 mac0[ETH_ALEN], mac1[ETH_ALEN];
+	u8 wmac0[ETH_ALEN], wmac1[ETH_ALEN];
+
+	ath79_parse_ascii_mac(mac + DIR825C1_MAC0_OFFSET, mac0);
+	ath79_parse_ascii_mac(mac + DIR825C1_MAC1_OFFSET, mac1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_gpio_keys_polled(-1, DIR825C1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dir825c1_gpio_keys),
+					dir825c1_gpio_keys);
+
+	ath79_init_mac(wmac0, mac0, 0);
+	ath79_register_wmac(art + DIR825C1_WMAC_CALDATA_OFFSET, wmac0);
+
+	ath79_init_mac(wmac1, mac1, 1);
+	ap91_pci_init(art + DIR825C1_PCIE_CALDATA_OFFSET, wmac1);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(dir825c1_mdio0_info,
+				    ARRAY_SIZE(dir825c1_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+static void __init dir825c1_setup(void)
+{
+	ath79_gpio_output_select(DIR825C1_GPIO_LED_BLUE_USB,
+				 AR934X_GPIO_OUT_GPIO);
+
+	gpio_request_one(DIR825C1_GPIO_WAN_LED_ENABLE,
+			 GPIOF_OUT_INIT_LOW, "WAN LED enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir825c1_leds_gpio),
+				 dir825c1_leds_gpio);
+
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+
+	dir825c1_generic_setup();
+}
+
+static void __init dir835a1_setup(void)
+{
+	dir825c1_ar8327_data.led_cfg = NULL;
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dir835a1_leds_gpio),
+				 dir835a1_leds_gpio);
+
+	dir825c1_generic_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_DIR_825_C1, "DIR-825-C1",
+	     "D-Link DIR-825 rev. C1",
+	     dir825c1_setup);
+
+MIPS_MACHINE(ATH79_MACH_DIR_835_A1, "DIR-835-A1",
+	     "D-Link DIR-835 rev. A1",
+	     dir835a1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dlan-hotspot.c linux-4.1.13/arch/mips/ath79/mach-dlan-hotspot.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dlan-hotspot.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dlan-hotspot.c	2015-12-04 18:27:35.457807850 +0100
@@ -0,0 +1,117 @@
+/*
+ *  devolo dLAN Hotspot board support
+ *
+ *  Copyright (C) 2015 Torsten Schnuis <torsten.schnuis@gik.de>
+ *  Copyright (C) 2015 devolo AG
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DLAN_HOTSPOT_GPIO_LED_WIFI                0
+
+#define DLAN_HOTSPOT_GPIO_BTN_RESET              11
+#define DLAN_HOTSPOT_GPIO_BTN_PLC_PAIRING        12
+#define DLAN_HOTSPOT_GPIO_BTN_WIFI               21
+
+#define DLAN_HOTSPOT_GPIO_PLC_POWER              22
+#define DLAN_HOTSPOT_GPIO_PLC_RESET              20
+#define DLAN_HOTSPOT_GPIO_PLC_DISABLE_LEDS       18
+
+#define DLAN_HOTSPOT_KEYS_POLL_INTERVAL          20    /* msecs */
+#define DLAN_HOTSPOT_KEYS_DEBOUNCE_INTERVAL      (3 * DLAN_HOTSPOT_KEYS_POLL_INTERVAL)
+
+#define DLAN_HOTSPOT_ART_ADDRESS                 0x1fff0000
+#define DLAN_HOTSPOT_CALDATA_OFFSET              0x00001000
+#define DLAN_HOTSPOT_MAC_ADDRESS_OFFSET          0x00001002
+
+static struct gpio_led dlan_hotspot_leds_gpio[] __initdata = {
+	{
+		.name		= "devolo:green:wifi",
+		.gpio		= DLAN_HOTSPOT_GPIO_LED_WIFI,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button dlan_hotspot_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DLAN_HOTSPOT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_HOTSPOT_GPIO_BTN_RESET,
+		.active_low     = 0,
+	},
+	{
+		.desc		= "Pairing button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = DLAN_HOTSPOT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_HOTSPOT_GPIO_BTN_PLC_PAIRING,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "WLAN button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DLAN_HOTSPOT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_HOTSPOT_GPIO_BTN_WIFI,
+		.active_low	= 0,
+	}
+};
+
+static void __init dlan_hotspot_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(DLAN_HOTSPOT_ART_ADDRESS);
+	u8 *cal = art + DLAN_HOTSPOT_CALDATA_OFFSET;
+	u8 *wifi_mac = art + DLAN_HOTSPOT_MAC_ADDRESS_OFFSET;
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dlan_hotspot_leds_gpio),
+				 dlan_hotspot_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DLAN_HOTSPOT_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dlan_hotspot_gpio_keys),
+					dlan_hotspot_gpio_keys);
+
+	gpio_request_one(DLAN_HOTSPOT_GPIO_PLC_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC power");
+	gpio_request_one(DLAN_HOTSPOT_GPIO_PLC_RESET,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC reset");
+	gpio_request_one(DLAN_HOTSPOT_GPIO_PLC_DISABLE_LEDS,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC LEDs");
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, wifi_mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, wifi_mac, 2);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(cal, wifi_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_DLAN_HOTSPOT, "dLAN-Hotspot",
+	     "dLAN Hotspot", dlan_hotspot_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dlan-pro-1200-ac.c linux-4.1.13/arch/mips/ath79/mach-dlan-pro-1200-ac.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dlan-pro-1200-ac.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dlan-pro-1200-ac.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,189 @@
+/*
+ * devolo dLAN pro 500 Wireless+ support
+ *
+ * Copyright (c) 2013-2015 devolo AG
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DLAN_PRO_1200_AC_GPIO_DLAN_POWER_ENABLE		13
+#define DLAN_PRO_1200_AC_GPIO_WLAN_POWER_ENABLE		21
+#define DLAN_PRO_1200_AC_GPIO_LED_WLAN		12
+#define DLAN_PRO_1200_AC_GPIO_LED_DLAN			14
+#define DLAN_PRO_1200_AC_GPIO_LED_DLAN_ERR			15
+
+#define DLAN_PRO_1200_AC_GPIO_BTN_WLAN			20
+#define DLAN_PRO_1200_AC_GPIO_BTN_DLAN			22
+#define DLAN_PRO_1200_AC_GPIO_BTN_RESET			4
+#define DLAN_PRO_1200_AC_GPIO_DLAN_IND          17
+#define DLAN_PRO_1200_AC_GPIO_DLAN_ERR_IND      16
+
+#define DLAN_PRO_1200_AC_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DLAN_PRO_1200_AC_KEYS_DEBOUNCE_INTERVAL		(3 * DLAN_PRO_1200_AC_KEYS_POLL_INTERVAL)
+
+#define DLAN_PRO_1200_AC_ART_ADDRESS			0x1fff0000
+#define DLAN_PRO_1200_AC_CALDATA_OFFSET			0x1000
+#define DLAN_PRO_1200_AC_WIFIMAC_OFFSET			0x1002
+#define DLAN_PRO_1200_AC_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led dlan_pro_1200_ac_leds_gpio[] __initdata = {
+	{
+		.name		        = "devolo:status:wlan",
+		.gpio		        = DLAN_PRO_1200_AC_GPIO_LED_WLAN,
+		.active_low	        = 1,
+	},
+	{
+		.name		        = "devolo:status:dlan",
+		.gpio		        = DLAN_PRO_1200_AC_GPIO_LED_DLAN,
+		.active_low	        = 1,
+	},
+	{
+		.name		        = "devolo:error:dlan",
+		.gpio		        = DLAN_PRO_1200_AC_GPIO_LED_DLAN_ERR,
+		.active_low	        = 0,
+	}
+};
+
+static struct gpio_keys_button dlan_pro_1200_ac_gpio_keys[] __initdata = {
+	{
+		.desc		= "dLAN button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = DLAN_PRO_1200_AC_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_1200_AC_GPIO_BTN_DLAN,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WLAN button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DLAN_PRO_1200_AC_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_1200_AC_GPIO_BTN_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DLAN_PRO_1200_AC_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_1200_AC_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct ar8327_pad_cfg dlan_pro_1200_ac_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = false,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_pad_cfg dlan_pro_1200_ac_ar8327_pad5_cfg = {
+	.mode = 0,
+	.txclk_delay_en = 0,
+	.rxclk_delay_en = 0,
+	.txclk_delay_sel = 0,
+	.rxclk_delay_sel = 0,
+};
+
+static struct ar8327_platform_data dlan_pro_1200_ac_ar8327_data = {
+	.pad0_cfg = &dlan_pro_1200_ac_ar8327_pad0_cfg,
+	.pad5_cfg = &dlan_pro_1200_ac_ar8327_pad5_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info dlan_pro_1200_ac_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &dlan_pro_1200_ac_ar8327_data,
+	},
+};
+
+static void __init dlan_pro_1200_ac_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(DLAN_PRO_1200_AC_ART_ADDRESS);
+	u8 *cal = art + DLAN_PRO_1200_AC_CALDATA_OFFSET;
+	u8 *wifi_mac = art + DLAN_PRO_1200_AC_WIFIMAC_OFFSET;
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dlan_pro_1200_ac_leds_gpio),
+				 dlan_pro_1200_ac_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DLAN_PRO_1200_AC_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dlan_pro_1200_ac_gpio_keys),
+					dlan_pro_1200_ac_gpio_keys);
+
+	/* dLAN power must be enabled from user-space as soon as the boot-from-host daemon is running */
+	gpio_request_one(DLAN_PRO_1200_AC_GPIO_DLAN_POWER_ENABLE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "dLAN power");
+
+	/* WLAN power is turned on initially to allow the PCI bus scan to succeed */
+	gpio_request_one(DLAN_PRO_1200_AC_GPIO_WLAN_POWER_ENABLE,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "WLAN power");
+
+	ath79_register_wmac(cal, wifi_mac);
+	ap91_pci_init(art + DLAN_PRO_1200_AC_PCIE_CALDATA_OFFSET, NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 | AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, wifi_mac, 2);
+
+	mdiobus_register_board_info(dlan_pro_1200_ac_mdio0_info,
+				    ARRAY_SIZE(dlan_pro_1200_ac_mdio0_info));
+
+	/* GMAC0 is connected to an AR8337 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x02000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_DLAN_PRO_1200_AC, "dLAN-pro-1200-ac", "devolo dLAN pro 1200+ WiFi ac",
+	     dlan_pro_1200_ac_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dlan-pro-500-wp.c linux-4.1.13/arch/mips/ath79/mach-dlan-pro-500-wp.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dlan-pro-500-wp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dlan-pro-500-wp.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,203 @@
+/*
+ * devolo dLAN pro 500 Wireless+ support
+ *
+ * Copyright (c) 2013-2015 devolo AG
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DLAN_PRO_500_WP_GPIO_DLAN_POWER_ENABLE		13
+#define DLAN_PRO_500_WP_GPIO_DLAN_LED_ENABLE		17
+#define DLAN_PRO_500_WP_GPIO_LED_WLAN_5G		11
+#define DLAN_PRO_500_WP_GPIO_LED_WLAN_2G		12
+#define DLAN_PRO_500_WP_GPIO_LED_STATUS			16
+#define DLAN_PRO_500_WP_GPIO_LED_ETH			14
+
+#define DLAN_PRO_500_WP_GPIO_BTN_WPS			20
+#define DLAN_PRO_500_WP_GPIO_BTN_WLAN			22
+#define DLAN_PRO_500_WP_GPIO_BTN_DLAN			21
+#define DLAN_PRO_500_WP_GPIO_BTN_RESET			4
+
+#define DLAN_PRO_500_WP_KEYS_POLL_INTERVAL		20	/* msecs */
+#define DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL		(3 * DLAN_PRO_500_WP_KEYS_POLL_INTERVAL)
+
+#define DLAN_PRO_500_WP_ART_ADDRESS			0x1fff0000
+#define DLAN_PRO_500_WP_CALDATA_OFFSET			0x1000
+#define DLAN_PRO_500_WP_MAC_ADDRESS_OFFSET		0x1002
+#define DLAN_PRO_500_WP_PCIE_CALDATA_OFFSET		0x5000
+
+static struct gpio_led dlan_pro_500_wp_leds_gpio[] __initdata = {
+	{
+		.name		= "devolo:green:status",
+		.gpio		= DLAN_PRO_500_WP_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "devolo:green:eth",
+		.gpio		= DLAN_PRO_500_WP_GPIO_LED_ETH,
+		.active_low	= 1,
+	},
+	{
+		.name		= "devolo:blue:wlan-5g",
+		.gpio		= DLAN_PRO_500_WP_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "devolo:green:wlan-2g",
+		.gpio		= DLAN_PRO_500_WP_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button dlan_pro_500_wp_gpio_keys[] __initdata = {
+	{
+		.desc		= "dLAN button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_500_WP_GPIO_BTN_DLAN,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_500_WP_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "WLAN button",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_500_WP_GPIO_BTN_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code           = KEY_RESTART,
+		.debounce_interval = DLAN_PRO_500_WP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DLAN_PRO_500_WP_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct ar8327_pad_cfg dlan_pro_500_wp_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_PHY_RGMII,
+	.txclk_delay_en = false,
+	.rxclk_delay_en = false,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_led_cfg dlan_pro_500_wp_ar8327_led_cfg = {
+	.led_ctrl0 = 0x00000000,
+	.led_ctrl1 = 0xc737c737,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00c30c00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data dlan_pro_500_wp_ar8327_data = {
+	.pad0_cfg = &dlan_pro_500_wp_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 0,
+		.rxpause = 0,
+	},
+	.led_cfg = &dlan_pro_500_wp_ar8327_led_cfg,
+};
+
+static struct mdio_board_info dlan_pro_500_wp_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &dlan_pro_500_wp_ar8327_data,
+	},
+};
+
+static void __init dlan_pro_500_wp_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(DLAN_PRO_500_WP_ART_ADDRESS);
+	u8 *cal = art + DLAN_PRO_500_WP_CALDATA_OFFSET;
+	u8 *wifi_mac = art + DLAN_PRO_500_WP_MAC_ADDRESS_OFFSET;
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dlan_pro_500_wp_leds_gpio),
+				 dlan_pro_500_wp_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, DLAN_PRO_500_WP_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dlan_pro_500_wp_gpio_keys),
+					dlan_pro_500_wp_gpio_keys);
+
+	gpio_request_one(DLAN_PRO_500_WP_GPIO_DLAN_POWER_ENABLE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC power");
+	gpio_request_one(DLAN_PRO_500_WP_GPIO_DLAN_LED_ENABLE,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "PLC LEDs");
+
+	ath79_register_wmac(cal, wifi_mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(dlan_pro_500_wp_mdio0_info,
+				    ARRAY_SIZE(dlan_pro_500_wp_mdio0_info));
+
+	/* GMAC0 is connected to a AR7400 PLC in PHY mode */
+	ath79_init_mac(ath79_eth0_data.mac_addr, wifi_mac, 2);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_pll_data.pll_1000 = 0x0e000000;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, wifi_mac, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_DLAN_PRO_500_WP, "dLAN-pro-500-wp", "devolo dLAN pro 500 Wireless+",
+	     dlan_pro_500_wp_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-dragino2.c linux-4.1.13/arch/mips/ath79/mach-dragino2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-dragino2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-dragino2.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,136 @@
+/*
+ *  DRAGINO V2 board support, based on Atheros AP121 board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2012 Elektra Wagenrad <elektra@villagetelco.org>
+ *  Copyright (C) 2014 Vittorio Gambaletta <openwrt@vittgam.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DRAGINO2_GPIO_LED_WLAN		0
+#define DRAGINO2_GPIO_LED_LAN		13
+#define DRAGINO2_GPIO_LED_WAN		17
+
+/*
+ * The following GPIO is named "SYS" on newer revisions of the the board.
+ * It was previously used to indicate USB activity, even though it was
+ * named "Router".
+ */
+
+#define DRAGINO2_GPIO_LED_SYS		28
+#define DRAGINO2_GPIO_BTN_JUMPSTART	11
+#define DRAGINO2_GPIO_BTN_RESET		12
+
+#define DRAGINO2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DRAGINO2_KEYS_DEBOUNCE_INTERVAL	(3 * DRAGINO2_KEYS_POLL_INTERVAL)
+
+#define DRAGINO2_MAC0_OFFSET		0x0000
+#define DRAGINO2_MAC1_OFFSET		0x0006
+#define DRAGINO2_CALDATA_OFFSET		0x1000
+#define DRAGINO2_WMAC_MAC_OFFSET	0x1002
+
+static struct gpio_led dragino2_leds_gpio[] __initdata = {
+	{
+		.name		= "dragino2:red:wlan",
+		.gpio		= DRAGINO2_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "dragino2:red:wan",
+		.gpio		= DRAGINO2_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dragino2:red:lan",
+		.gpio		= DRAGINO2_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dragino2:red:system",
+		.gpio		= DRAGINO2_GPIO_LED_SYS,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button dragino2_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DRAGINO2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DRAGINO2_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DRAGINO2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DRAGINO2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init dragino2_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art + DRAGINO2_CALDATA_OFFSET,
+			    art + DRAGINO2_WMAC_MAC_OFFSET);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + DRAGINO2_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + DRAGINO2_MAC1_OFFSET, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* Enable GPIO13, GPIO14, GPIO15, GPIO16 and GPIO17 */
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	/* LAN port */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	/* Enable GPIO26 and GPIO27 */
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP,
+		       ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP) |
+		       AR933X_BOOTSTRAP_MDIO_GPIO_EN);
+}
+
+static void __init dragino2_setup(void)
+{
+	dragino2_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dragino2_leds_gpio),
+				 dragino2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DRAGINO2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dragino2_gpio_keys),
+					dragino2_gpio_keys);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_DRAGINO2, "DRAGINO2", "Dragino Dragino v2",
+	     dragino2_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-eap300v2.c linux-4.1.13/arch/mips/ath79/mach-eap300v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-eap300v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-eap300v2.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,101 @@
+/*
+ * EnGenius EAP300 v2 board support
+ *
+ * Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define EAP300V2_GPIO_LED_POWER		0
+#define EAP300V2_GPIO_LED_LAN		16
+#define EAP300V2_GPIO_LED_WLAN		17
+
+#define EAP300V2_GPIO_BTN_RESET		1
+
+#define EAP300V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EAP300V2_KEYS_DEBOUNCE_INTERVAL	(3 * EAP300V2_KEYS_POLL_INTERVAL)
+
+static struct gpio_led eap300v2_leds_gpio[] __initdata = {
+	{
+		.name		= "engenius:blue:power",
+		.gpio		= EAP300V2_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "engenius:blue:lan",
+		.gpio		= EAP300V2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "engenius:blue:wlan",
+		.gpio		= EAP300V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button eap300v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EAP300V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP300V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+#define EAP300V2_ART_MAC_OFFSET		2
+
+#define EAP300V2_LAN_PHYMASK		BIT(0)
+
+static void __init eap300v2_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_gpio_output_select(EAP300V2_GPIO_LED_POWER, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(EAP300V2_GPIO_LED_LAN, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(EAP300V2_GPIO_LED_WLAN, AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(eap300v2_leds_gpio),
+				 eap300v2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, EAP300V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(eap300v2_gpio_keys),
+					eap300v2_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art, NULL);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + EAP300V2_ART_MAC_OFFSET, 0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = EAP300V2_LAN_PHYMASK;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = EAP300V2_LAN_PHYMASK;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_EAP300V2, "EAP300V2", "EnGenius EAP300 v2",
+	     eap300v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-eap7660d.c linux-4.1.13/arch/mips/ath79/mach-eap7660d.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-eap7660d.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-eap7660d.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,181 @@
+/*
+ *  Senao EAP7660D board support
+ *
+ *  Copyright (C) 2010 Daniel Golle <daniel.golle@gmail.com>
+ *  Copyright (C) 2008 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/ath5k_platform.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define EAP7660D_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EAP7660D_KEYS_DEBOUNCE_INTERVAL	(3 * EAP7660D_KEYS_POLL_INTERVAL)
+
+#define EAP7660D_GPIO_DS4		7
+#define EAP7660D_GPIO_DS5		2
+#define EAP7660D_GPIO_DS7		0
+#define EAP7660D_GPIO_DS8		4
+#define EAP7660D_GPIO_SW1		3
+#define EAP7660D_GPIO_SW3		8
+#define EAP7660D_PHYMASK		BIT(20)
+#define EAP7660D_BOARDCONFIG		0x1F7F0000
+#define EAP7660D_GBIC_MAC_OFFSET	0x1000
+#define EAP7660D_WMAC0_MAC_OFFSET	0x1010
+#define EAP7660D_WMAC1_MAC_OFFSET	0x1016
+#define EAP7660D_WMAC0_CALDATA_OFFSET	0x2000
+#define EAP7660D_WMAC1_CALDATA_OFFSET	0x3000
+
+#ifdef CONFIG_PCI
+static struct ath5k_platform_data eap7660d_wmac0_data;
+static struct ath5k_platform_data eap7660d_wmac1_data;
+static char eap7660d_wmac0_mac[6];
+static char eap7660d_wmac1_mac[6];
+static u16 eap7660d_wmac0_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+static u16 eap7660d_wmac1_eeprom[ATH5K_PLAT_EEP_MAX_WORDS];
+
+static int eap7660d_pci_plat_dev_init(struct pci_dev *dev)
+{
+	switch (PCI_SLOT(dev->devfn)) {
+	case 17:
+		dev->dev.platform_data = &eap7660d_wmac0_data;
+		break;
+
+	case 18:
+		dev->dev.platform_data = &eap7660d_wmac1_data;
+		break;
+	}
+
+	return 0;
+}
+
+void __init eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+			      u8 *cal_data1, u8 *mac_addr1)
+{
+	if (cal_data0 && *cal_data0 == 0xa55a) {
+		memcpy(eap7660d_wmac0_eeprom, cal_data0,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac0_data.eeprom_data = eap7660d_wmac0_eeprom;
+	}
+
+	if (cal_data1 && *cal_data1 == 0xa55a) {
+		memcpy(eap7660d_wmac1_eeprom, cal_data1,
+			ATH5K_PLAT_EEP_MAX_WORDS);
+		eap7660d_wmac1_data.eeprom_data = eap7660d_wmac1_eeprom;
+	}
+
+	if (mac_addr0) {
+		memcpy(eap7660d_wmac0_mac, mac_addr0,
+			sizeof(eap7660d_wmac0_mac));
+		eap7660d_wmac0_data.macaddr = eap7660d_wmac0_mac;
+	}
+
+	if (mac_addr1) {
+		memcpy(eap7660d_wmac1_mac, mac_addr1,
+			sizeof(eap7660d_wmac1_mac));
+		eap7660d_wmac1_data.macaddr = eap7660d_wmac1_mac;
+	}
+
+	ath79_pci_set_plat_dev_init(eap7660d_pci_plat_dev_init);
+	ath79_register_pci();
+}
+#else
+static inline void eap7660d_pci_init(u8 *cal_data0, u8 *mac_addr0,
+				     u8 *cal_data1, u8 *mac_addr1)
+{
+}
+#endif /* CONFIG_PCI */
+
+static struct gpio_led eap7660d_leds_gpio[] __initdata = {
+	{
+		.name		= "eap7660d:green:ds8",
+		.gpio		= EAP7660D_GPIO_DS8,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds5",
+		.gpio		= EAP7660D_GPIO_DS5,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds7",
+		.gpio		= EAP7660D_GPIO_DS7,
+		.active_low	= 0,
+	},
+	{
+		.name		= "eap7660d:green:ds4",
+		.gpio		= EAP7660D_GPIO_DS4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button eap7660d_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW1,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = EAP7660D_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EAP7660D_GPIO_SW3,
+		.active_low	= 1,
+	}
+};
+
+static const char *eap7660d_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data eap7660d_flash_data = {
+	.part_probes	= eap7660d_part_probes,
+};
+
+static void __init eap7660d_setup(void)
+{
+	u8 *boardconfig = (u8 *) KSEG1ADDR(EAP7660D_BOARDCONFIG);
+
+	ath79_register_mdio(0, ~EAP7660D_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+			boardconfig + EAP7660D_GBIC_MAC_OFFSET, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = EAP7660D_PHYMASK;
+	ath79_register_eth(0);
+	ath79_register_m25p80(&eap7660d_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(eap7660d_leds_gpio),
+					eap7660d_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, EAP7660D_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(eap7660d_gpio_keys),
+					 eap7660d_gpio_keys);
+	eap7660d_pci_init(boardconfig + EAP7660D_WMAC0_CALDATA_OFFSET,
+			  boardconfig + EAP7660D_WMAC0_MAC_OFFSET,
+			  boardconfig + EAP7660D_WMAC1_CALDATA_OFFSET,
+			  boardconfig + EAP7660D_WMAC1_MAC_OFFSET);
+};
+
+MIPS_MACHINE(ATH79_MACH_EAP7660D, "EAP7660D", "Senao EAP7660D",
+	     eap7660d_setup);
+
+MIPS_MACHINE(ATH79_MACH_ALL0305, "ALL0305", "Allnet ALL0305",
+	     eap7660d_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-el-m150.c linux-4.1.13/arch/mips/ath79/mach-el-m150.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-el-m150.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-el-m150.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,112 @@
+/*
+ *  Easy-Link EL-M150 board support
+ *
+ *  Copyright (C) 2012 huangfc <huangfangcheng@163.com>
+ *  Copyright (C) 2012 HYS <550663898@qq.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "dev-usb.h"
+
+#define EL_M150_GPIO_BTN6		6
+#define EL_M150_GPIO_BTN7		7
+#define EL_M150_GPIO_BTN_RESET		11
+
+#define EL_M150_GPIO_LED_SYSTEM		27
+#define EL_M150_GPIO_USB_POWER		8
+
+#define EL_M150_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EL_M150_KEYS_DEBOUNCE_INTERVAL (3 * EL_M150_KEYS_POLL_INTERVAL)
+
+static const char *EL_M150_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data EL_M150_flash_data = {
+	.part_probes	= EL_M150_part_probes,
+};
+
+static struct gpio_led EL_M150_leds_gpio[] __initdata = {
+	{
+		.name		= "easylink:green:system",
+		.gpio		= EL_M150_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button EL_M150_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EL_M150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EL_M150_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "BTN_6",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = EL_M150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EL_M150_GPIO_BTN6,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "BTN_7",
+		.type		= EV_KEY,
+		.code		= BTN_7,
+		.debounce_interval = EL_M150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EL_M150_GPIO_BTN7,
+		.active_low	= 1,
+	},
+};
+
+static void __init el_m150_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(EL_M150_leds_gpio),
+				 EL_M150_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, EL_M150_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(EL_M150_gpio_keys),
+					EL_M150_gpio_keys);
+
+	gpio_request_one(EL_M150_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_m25p80(&EL_M150_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_EL_M150, "EL-M150",
+	     "EasyLink EL-M150", el_m150_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-el-mini.c linux-4.1.13/arch/mips/ath79/mach-el-mini.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-el-mini.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-el-mini.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,86 @@
+/*
+ *  Easy-Link EL-MINI board support
+ *
+ *  Copyright (C) 2012 huangfc <huangfangcheng@163.com>
+ *  Copyright (C) 2011 hys <550663898@qq.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MINI_GPIO_LED_SYSTEM	27
+#define MINI_GPIO_BTN_RESET	11
+
+#define MINI_GPIO_USB_POWER	8
+
+#define MINI_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MINI_KEYS_DEBOUNCE_INTERVAL	(3 * MINI_KEYS_POLL_INTERVAL)
+
+static const char *mini_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data mini_flash_data = {
+	.part_probes	= mini_part_probes,
+};
+
+static struct gpio_led mini_leds_gpio[] __initdata = {
+	{
+		.name		= "easylink:green:system",
+		.gpio		= MINI_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mini_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MINI_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MINI_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init el_mini_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&mini_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mini_leds_gpio),
+				 mini_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MINI_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mini_gpio_keys),
+					mini_gpio_keys);
+
+	gpio_request_one(MINI_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_EL_MINI, "EL-MINI", "EasyLink EL-MINI",
+	     el_mini_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-epg5000.c linux-4.1.13/arch/mips/ath79/mach-epg5000.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-epg5000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-epg5000.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,178 @@
+/*
+ *  EnGenius EPG5000 board support
+ *
+ *  Copyright (c) 2014 Jon Suphammer <jon@suphammer.net>
+ *  Copyright (c) 2015 Christian Beier <cb@shoutrlabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define EPG5000_GPIO_LED_WLAN_5G	23
+#define EPG5000_GPIO_LED_WLAN_2G	13
+#define EPG5000_GPIO_LED_POWER_AMBER	2
+#define EPG5000_GPIO_LED_WPS_AMBER	22
+#define EPG5000_GPIO_LED_WPS_BLUE	19
+
+#define EPG5000_GPIO_BTN_WPS		16
+#define EPG5000_GPIO_BTN_RESET		17
+
+#define EPG5000_KEYS_POLL_INTERVAL	20	/* msecs */
+#define EPG5000_KEYS_DEBOUNCE_INTERVAL	(3 * EPG5000_KEYS_POLL_INTERVAL)
+
+#define EPG5000_CALDATA_ADDR 0x1fff0000
+#define EPG5000_WMAC_CALDATA_OFFSET	0x1000
+#define EPG5000_PCIE_CALDATA_OFFSET	0x5000
+
+#define EPG5000_NVRAM_ADDR	0x1f030000
+#define EPG5000_NVRAM_SIZE	0x10000
+
+static struct gpio_led epg5000_leds_gpio[] __initdata = {
+	{
+		.name		= "epg5000:amber:power",
+		.gpio		= EPG5000_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "epg5000:blue:wps",
+		.gpio		= EPG5000_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "epg5000:amber:wps",
+		.gpio		= EPG5000_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "epg5000:blue:wlan-2g",
+		.gpio		= EPG5000_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "epg5000:blue:wlan-5g",
+		.gpio		= EPG5000_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button epg5000_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = EPG5000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EPG5000_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = EPG5000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= EPG5000_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg epg5000_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.mac06_exchange_en = true,
+};
+
+static struct ar8327_platform_data epg5000_ar8327_data = {
+	.pad0_cfg = &epg5000_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info epg5000_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &epg5000_ar8327_data,
+	},
+};
+
+static int epg5000_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(EPG5000_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, EPG5000_NVRAM_SIZE,
+					 name, mac);
+	if (err) {
+		pr_err("no MAC address found for %s\n", name);
+		return false;
+	}
+
+	return true;
+}
+
+static void __init epg5000_setup(void)
+{
+	u8 *caldata = (u8 *) KSEG1ADDR(EPG5000_CALDATA_ADDR);
+	u8 mac1[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(epg5000_leds_gpio),
+					epg5000_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, EPG5000_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(epg5000_gpio_keys),
+					epg5000_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(epg5000_mdio0_info,
+					ARRAY_SIZE(epg5000_mdio0_info));
+
+	/* GMAC0 is connected to an QCA8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	if (epg5000_get_mac("ethaddr=", mac1))
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_register_eth(0);
+
+	ath79_register_wmac(caldata + EPG5000_WMAC_CALDATA_OFFSET, mac1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_EPG5000, "EPG5000",
+	     "EnGenius EPG5000",
+	     epg5000_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-esr1750.c linux-4.1.13/arch/mips/ath79/mach-esr1750.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-esr1750.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-esr1750.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,177 @@
+/*
+ *  EnGenius ESR1750 board support
+ *
+ *  Copyright (c) 2014 Jon Suphammer <jon@suphammer.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define ESR1750_GPIO_LED_WLAN_5G	23
+#define ESR1750_GPIO_LED_WLAN_2G	13
+#define ESR1750_GPIO_LED_POWER_AMBER	2
+#define ESR1750_GPIO_LED_WPS_AMBER	22
+#define ESR1750_GPIO_LED_WPS_BLUE	19
+
+#define ESR1750_GPIO_BTN_WPS		16
+#define ESR1750_GPIO_BTN_RESET		17
+
+#define ESR1750_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ESR1750_KEYS_DEBOUNCE_INTERVAL	(3 * ESR1750_KEYS_POLL_INTERVAL)
+
+#define ESR1750_CALDATA_ADDR 0x1fff0000
+#define ESR1750_WMAC_CALDATA_OFFSET	0x1000
+#define ESR1750_PCIE_CALDATA_OFFSET	0x5000
+
+#define ESR1750_NVRAM_ADDR	0x1f030000
+#define ESR1750_NVRAM_SIZE	0x10000
+
+static struct gpio_led esr1750_leds_gpio[] __initdata = {
+	{
+		.name		= "esr1750:amber:power",
+		.gpio		= ESR1750_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "esr1750:blue:wps",
+		.gpio		= ESR1750_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "esr1750:amber:wps",
+		.gpio		= ESR1750_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "esr1750:blue:wlan-2g",
+		.gpio		= ESR1750_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "esr1750:blue:wlan-5g",
+		.gpio		= ESR1750_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button esr1750_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = ESR1750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ESR1750_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ESR1750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ESR1750_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg esr1750_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.mac06_exchange_en = true,
+};
+
+static struct ar8327_platform_data esr1750_ar8327_data = {
+	.pad0_cfg = &esr1750_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info esr1750_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &esr1750_ar8327_data,
+	},
+};
+
+static int esr1750_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(ESR1750_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, ESR1750_NVRAM_SIZE,
+					 name, mac);
+	if (err) {
+		pr_err("no MAC address found for %s\n", name);
+		return false;
+	}
+
+	return true;
+}
+
+static void __init esr1750_setup(void)
+{
+	u8 *caldata = (u8 *) KSEG1ADDR(ESR1750_CALDATA_ADDR);
+	u8 mac1[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(esr1750_leds_gpio),
+					esr1750_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, ESR1750_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(esr1750_gpio_keys),
+					esr1750_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(esr1750_mdio0_info,
+					ARRAY_SIZE(esr1750_mdio0_info));
+
+	/* GMAC0 is connected to an QCA8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	if (esr1750_get_mac("ethaddr=", mac1))
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_register_eth(0);
+
+	ath79_register_wmac(caldata + ESR1750_WMAC_CALDATA_OFFSET, mac1);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_ESR1750, "ESR1750",
+	     "EnGenius ESR1750",
+	     esr1750_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-esr900.c linux-4.1.13/arch/mips/ath79/mach-esr900.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-esr900.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-esr900.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,200 @@
+/*
+ *  EnGenius ESR900 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "esr900: " fmt
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define ESR900_GPIO_LED_POWER           2
+#define ESR900_GPIO_LED_WLAN_2G         13
+#define ESR900_GPIO_LED_WPS_BLUE        19
+#define ESR900_GPIO_LED_WPS_AMBER       22
+#define ESR900_GPIO_LED_WLAN_5G         23
+
+#define ESR900_GPIO_BTN_WPS             16
+#define ESR900_GPIO_BTN_RESET           17
+
+#define ESR900_KEYS_POLL_INTERVAL       20 /* msecs */
+#define ESR900_KEYS_DEBOUNCE_INTERVAL   (3 * ESR900_KEYS_POLL_INTERVAL)
+
+#define ESR900_CALDATA_ADDR             0x1fff0000
+#define ESR900_WMAC_CALDATA_OFFSET      0x1000
+#define ESR900_PCIE_CALDATA_OFFSET      0x5000
+
+#define ESR900_CONFIG_ADDR              0x1f030000
+#define ESR900_CONFIG_SIZE              0x10000
+
+#define ESR900_LAN_PHYMASK              BIT(0)
+#define ESR900_WAN_PHYMASK              BIT(5)
+#define ESR900_MDIO_MASK                (~(ESR900_LAN_PHYMASK | ESR900_WAN_PHYMASK))
+
+static struct gpio_led esr900_leds_gpio[] __initdata = {
+	{
+		.name		= "engenius:amber:power",
+		.gpio		= ESR900_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "engenius:blue:wlan-2g",
+		.gpio		= ESR900_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "engenius:blue:wps",
+		.gpio		= ESR900_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "engenius:amber:wps",
+		.gpio		= ESR900_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "engenius:blue:wlan-5g",
+		.gpio		= ESR900_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button esr900_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = ESR900_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ESR900_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ESR900_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ESR900_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg esr900_ar8327_pad0_cfg = {
+	/* GMAC0 of the AR8337 switch is connected to GMAC0 via RGMII */
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_pad_cfg esr900_ar8327_pad6_cfg = {
+	/* GMAC6 of the AR8337 switch is connected to GMAC1 via SGMII */
+	.mode = AR8327_PAD_MAC_SGMII,
+	.rxclk_delay_en = true,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_platform_data esr900_ar8327_data = {
+	.pad0_cfg = &esr900_ar8327_pad0_cfg,
+	.pad6_cfg = &esr900_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info esr900_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &esr900_ar8327_data,
+	},
+};
+
+static void __init esr900_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(ESR900_CONFIG_ADDR);
+	u8 *art = (u8 *) KSEG1ADDR(ESR900_CALDATA_ADDR);
+	u8 lan_mac[ETH_ALEN];
+	u8 wlan0_mac[ETH_ALEN];
+	u8 wlan1_mac[ETH_ALEN];
+
+	if (ath79_nvram_parse_mac_addr(config, ESR900_CONFIG_SIZE,
+				       "ethaddr=", lan_mac) == 0) {
+		ath79_init_local_mac(ath79_eth0_data.mac_addr, lan_mac);
+		ath79_init_mac(wlan0_mac, lan_mac, 0);
+		ath79_init_mac(wlan1_mac, lan_mac, 1);
+	} else {
+		pr_err("could not find ethaddr in u-boot environment\n");
+	}
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(esr900_leds_gpio),
+					esr900_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, ESR900_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(esr900_gpio_keys),
+					esr900_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + ESR900_WMAC_CALDATA_OFFSET, wlan0_mac);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(esr900_mdio0_info,
+				    ARRAY_SIZE(esr900_mdio0_info));
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = ESR900_LAN_PHYMASK;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+	ath79_register_eth(1);
+
+	ap91_pci_init(art + ESR900_PCIE_CALDATA_OFFSET, wlan1_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ESR900, "ESR900", "EnGenius ESR900", esr900_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ew-dorin.c linux-4.1.13/arch/mips/ath79/mach-ew-dorin.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ew-dorin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ew-dorin.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,150 @@
+/*
+ *  EW Dorin board support
+ *  (based on Atheros Ref. Design AP121)
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2012-2015 Embedded Wireless GmbH    www.80211.de
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DORIN_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DORIN_KEYS_DEBOUNCE_INTERVAL	(3 * DORIN_KEYS_POLL_INTERVAL)
+
+#define DORIN_CALDATA_OFFSET		0x1000
+#define DORIN_WMAC_MAC_OFFSET		0x1002
+
+#define DORIN_GPIO_LED_21		21
+#define DORIN_GPIO_LED_22		22
+#define DORIN_GPIO_LED_STATUS	23
+
+#define DORIN_GPIO_BTN_JUMPSTART	11
+#define DORIN_GPIO_BTN_RESET		6
+
+static struct gpio_led dorin_leds_gpio[] __initdata = {
+	{
+		.name		= "dorin:green:led21",
+		.gpio		= DORIN_GPIO_LED_21,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dorin:green:led22",
+		.gpio		= DORIN_GPIO_LED_22,
+		.active_low	= 1,
+	},
+	{
+		.name		= "dorin:green:status",
+		.gpio		= DORIN_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button dorin_gpio_keys[] __initdata = {
+	{
+		.desc		= "jumpstart button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = DORIN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DORIN_GPIO_BTN_JUMPSTART,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = DORIN_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= DORIN_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init ew_dorin_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	static u8 mac[6];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_usb();
+
+	if (ar93xx_wmac_read_mac_address(mac)) {
+		ath79_register_wmac(NULL, NULL);
+	} else {
+		ath79_register_wmac(art + DORIN_CALDATA_OFFSET,
+				    art + DORIN_WMAC_MAC_OFFSET);
+		memcpy(mac, art + DORIN_WMAC_MAC_OFFSET, sizeof(mac));
+	}
+
+	mac[3] |= 0x40;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dorin_leds_gpio),
+				 dorin_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DORIN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dorin_gpio_keys),
+					dorin_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_EW_DORIN, "EW-DORIN", "EmbWir-Dorin",
+	     ew_dorin_setup);
+
+
+static void __init ew_dorin_router_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	static u8 mac[6];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_usb();
+
+	if (ar93xx_wmac_read_mac_address(mac)) {
+		ath79_register_wmac(NULL, NULL);
+	} else {
+		ath79_register_wmac(art + DORIN_CALDATA_OFFSET,
+				    art + DORIN_WMAC_MAC_OFFSET);
+		memcpy(mac, art + DORIN_WMAC_MAC_OFFSET, sizeof(mac));
+	}
+
+	mac[3] |= 0x40;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	mac[3] &= 0x3F;
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(dorin_leds_gpio),
+				 dorin_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DORIN_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(dorin_gpio_keys),
+					dorin_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_EW_DORIN_ROUTER, "EW-DORIN-ROUTER",
+	     "EmbWir-Dorin-Router", ew_dorin_router_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-f9k1115v2.c linux-4.1.13/arch/mips/ath79/mach-f9k1115v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-f9k1115v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-f9k1115v2.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,190 @@
+/*
+ *  Belkin AC1750DB (F9K1115V2) board support
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define F9K1115V2_GPIO_LED_USB2		4
+#define F9K1115V2_GPIO_LED_WPS_AMBER	14
+#define F9K1115V2_GPIO_LED_STATUS_AMBER	15
+#define F9K1115V2_GPIO_LED_WPS_BLUE	19
+#define F9K1115V2_GPIO_LED_STATUS_BLUE	20
+
+#define F9K1115V2_GPIO_BTN_WPS		16
+#define F9K1115V2_GPIO_BTN_RESET	17
+
+#define F9K1115V2_GPIO_USB2_POWER	21
+
+#define F9K1115V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define F9K1115V2_KEYS_DEBOUNCE_INTERVAL (3 * F9K1115V2_KEYS_POLL_INTERVAL)
+
+#define F9K1115V2_WAN_MAC_OFFSET	0
+#define F9K1115V2_LAN_MAC_OFFSET	6
+#define F9K1115V2_WMAC_CALDATA_OFFSET	0x1000
+#define F9K1115V2_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led f9k1115v2_leds_gpio[] __initdata = {
+	{
+		.name		= "belkin:amber:status",
+		.gpio		= F9K1115V2_GPIO_LED_STATUS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "belkin:blue:status",
+		.gpio		= F9K1115V2_GPIO_LED_STATUS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "belkin:blue:wps",
+		.gpio		= F9K1115V2_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	},
+	{
+		.name		= "belkin:amber:wps",
+		.gpio		= F9K1115V2_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "belkin:green:usb2",
+		.gpio		= F9K1115V2_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button f9k1115v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = F9K1115V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= F9K1115V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = F9K1115V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= F9K1115V2_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg f9k1115v2_ar8327_pad0_cfg = {
+	/* Use the RGMII interface for the GMAC0 of the AR8337 switch */
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+	.mac06_exchange_en = true,
+};
+
+static struct ar8327_pad_cfg f9k1115v2_ar8327_pad6_cfg = {
+	/* Use the SGMII interface for the GMAC6 of the AR8337 switch */
+	.mode = AR8327_PAD_MAC_SGMII,
+	.rxclk_delay_en = true,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_platform_data f9k1115v2_ar8327_data = {
+	.pad0_cfg = &f9k1115v2_ar8327_pad0_cfg,
+	.pad6_cfg = &f9k1115v2_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info f9k1115v2_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &f9k1115v2_ar8327_data,
+	},
+};
+
+static void __init f9k1115v2_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(f9k1115v2_leds_gpio),
+				 f9k1115v2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, F9K1115V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(f9k1115v2_gpio_keys),
+					f9k1115v2_gpio_keys);
+
+	ath79_register_wmac(art + F9K1115V2_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(f9k1115v2_mdio0_info,
+				    ARRAY_SIZE(f9k1115v2_mdio0_info));
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + F9K1115V2_WAN_MAC_OFFSET, 0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+		       art + F9K1115V2_LAN_MAC_OFFSET, 0);
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+
+	ath79_register_pci();
+
+	ath79_register_usb();
+	gpio_request_one(F9K1115V2_GPIO_USB2_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB2 power");
+}
+
+MIPS_MACHINE(ATH79_MACH_F9K1115V2, "F9K1115V2", "Belkin AC1750DB",
+	     f9k1115v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-gl-ar150.c linux-4.1.13/arch/mips/ath79/mach-gl-ar150.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-gl-ar150.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-gl-ar150.c	2015-12-04 18:27:35.461807609 +0100
@@ -0,0 +1,125 @@
+/*
+ *  GL_ar150 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_AR150_GPIO_LED_WLAN		   0
+#define GL_AR150_GPIO_LED_LAN		   13
+#define GL_AR150_GPIO_LED_WAN		   15 
+
+#define GL_AR150_GPIO_BIN_USB         6
+#define GL_AR150_GPIO_BTN_MANUAL      7
+#define GL_AR150_GPIO_BTN_AUTO	   	   8
+#define GL_AR150_GPIO_BTN_RESET	   11
+
+#define GL_AR150_KEYS_POLL_INTERVAL   20	/* msecs */
+#define GL_AR150_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR150_KEYS_POLL_INTERVAL)
+
+#define GL_AR150_MAC0_OFFSET	0x0000
+#define GL_AR150_MAC1_OFFSET	0x0000
+#define GL_AR150_CALDATA_OFFSET	0x1000
+#define GL_AR150_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led gl_ar150_leds_gpio[] __initdata = {
+	{
+		.name = "gl_ar150:wlan",
+		.gpio = GL_AR150_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl_ar150:lan",
+		.gpio = GL_AR150_GPIO_LED_LAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl_ar150:wan",
+		.gpio = GL_AR150_GPIO_LED_WAN,
+		.active_low = 0,
+ 		.default_state = 1,
+	},
+};
+
+static struct gpio_keys_button gl_ar150_gpio_keys[] __initdata = {
+	{
+		.desc = "BTN_7",
+		.type = EV_KEY,
+		.code = BTN_7,
+		.debounce_interval = GL_AR150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR150_GPIO_BTN_MANUAL,
+		.active_low = 0,
+	},
+	{
+		.desc = "BTN_8",
+		.type = EV_KEY,
+		.code = BTN_8,
+		.debounce_interval = GL_AR150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR150_GPIO_BTN_AUTO,
+		.active_low = 0,
+	},
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_AR150_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR150_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+};
+
+static void __init gl_ar150_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar150_leds_gpio),
+				 gl_ar150_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_AR150_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_ar150_gpio_keys),
+					gl_ar150_gpio_keys);
+
+	/* enable usb */
+	gpio_request_one(GL_AR150_GPIO_BIN_USB,
+				 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+	 			 "USB power");
+	ath79_register_usb();
+	
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+GL_AR150_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+GL_AR150_MAC1_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + GL_AR150_CALDATA_OFFSET, art + GL_AR150_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_AR150, "GL-AR150", "GL AR150",gl_ar150_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-gl-ar300.c linux-4.1.13/arch/mips/ath79/mach-gl-ar300.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-gl-ar300.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-gl-ar300.c	2015-12-04 18:27:35.461807609 +0100
@@ -0,0 +1,103 @@
+/*
+ *  Domino board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_AR300_GPIO_LED_WLAN	13
+#define GL_AR300_GPIO_LED_WAN	14
+#define GL_AR300_GPIO_BTN_RESET	16
+
+
+#define GL_AR300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define GL_AR300_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR300_KEYS_POLL_INTERVAL)
+
+#define GL_AR300_MAC0_OFFSET	0x0000
+#define	GL_AR300_MAC1_OFFSET	0x0000
+#define GL_AR300_CALDATA_OFFSET	0x1000
+#define GL_AR300_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led gl_ar300_leds_gpio[] __initdata = {
+	{
+		.name = "gl_ar300:wlan",
+		.gpio = GL_AR300_GPIO_LED_WLAN,
+		.active_low = 1,
+	},
+	{
+		.name = "gl_ar300:wan",
+		.gpio = GL_AR300_GPIO_LED_WAN,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_keys_button gl_ar300_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_AR300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_AR300_GPIO_BTN_RESET,
+		.active_low = 1,
+	},
+};
+
+static void __init gl_ar300_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar300_leds_gpio),
+				 gl_ar300_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_AR300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_ar300_gpio_keys),
+					gl_ar300_gpio_keys);
+
+	/* enable usb */
+	ath79_register_usb();
+	ath79_register_mdio(1, 0x0);
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+GL_AR300_MAC0_OFFSET, 0);
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+GL_AR300_MAC1_OFFSET, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + GL_AR300_CALDATA_OFFSET, art + GL_AR300_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_AR300, "GL-AR300", "GL AR300",gl_ar300_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-gl-domino.c linux-4.1.13/arch/mips/ath79/mach-gl-domino.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-gl-domino.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-gl-domino.c	2015-12-04 18:27:35.461807609 +0100
@@ -0,0 +1,136 @@
+/*
+ *  Domino board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+*/
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define DOMINO_GPIO_LED_WLAN		0
+#define DOMINO_GPIO_LED_WAN			17
+#define DOMINO_GPIO_LED_USB			1
+#define DOMINO_GPIO_LED_LAN1		13
+#define DOMINO_GPIO_LED_LAN2		14
+#define DOMINO_GPIO_LED_LAN3		15
+#define DOMINO_GPIO_LED_LAN4		16
+#define DOMINO_GPIO_LED_SYS			27
+#define DOMINO_GPIO_LED_WPS			26
+#define DOMINO_GPIO_USB_POWER		6
+
+#define DOMINO_GPIO_BTN_RESET		11
+#define DOMINO_GPIO_BTN_WPS			20
+
+#define DOMINO_KEYS_POLL_INTERVAL	20	/* msecs */
+#define DOMINO_KEYS_DEBOUNCE_INTERVAL	(3 * DOMINO_KEYS_POLL_INTERVAL)
+
+#define DOMINO_MAC0_OFFSET	0x0000
+#define	DOMINO_MAC1_OFFSET	0x0000
+#define DOMINO_CALDATA_OFFSET	0x1000
+#define DOMINO_WMAC_MAC_OFFSET	0x0000
+
+static struct gpio_led domino_leds_gpio[] __initdata = {
+	{
+		.name = "domino:blue:wlan",
+		.gpio = DOMINO_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "domino:red:wan",
+		.gpio = DOMINO_GPIO_LED_WAN,
+		.active_low = 1,
+	},
+	{
+		.name = "domino:white:usb",
+		.gpio = DOMINO_GPIO_LED_USB,
+		.active_low = 0,
+	},
+	{
+		.name = "domino:green:lan1",
+		.gpio = DOMINO_GPIO_LED_LAN1,
+		.active_low = 0,
+	},
+	{
+		.name = "domino:yellow:wps",
+		.gpio = DOMINO_GPIO_LED_WPS,
+		.active_low = 1,
+	},
+	{
+		.name = "domino:orange:sys",
+		.gpio = DOMINO_GPIO_LED_SYS,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_keys_button domino_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = DOMINO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = DOMINO_GPIO_BTN_RESET,
+		.active_low = 0,
+	},
+	{
+		.desc = "wps",
+		.type = EV_KEY,
+		.code = KEY_WPS_BUTTON,
+		.debounce_interval = DOMINO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = DOMINO_GPIO_BTN_WPS,
+		.active_low = 0,
+	}
+};
+
+static void __init domino_setup(void)
+{
+
+	/* ART base address */
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. */
+	ath79_register_m25p80(NULL);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(domino_leds_gpio),
+				 domino_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, DOMINO_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(domino_gpio_keys),
+					domino_gpio_keys);
+
+	gpio_request_one(DOMINO_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	/* enable usb */
+	ath79_register_usb();
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+DOMINO_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+DOMINO_MAC1_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(art + DOMINO_CALDATA_OFFSET, art + DOMINO_WMAC_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_DOMINO, "DOMINO", "Domino Pi", domino_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-gl-inet.c linux-4.1.13/arch/mips/ath79/mach-gl-inet.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-gl-inet.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-gl-inet.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,104 @@
+/*
+ *  GL-CONNECT iNet board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 alzhao <alzhao@gmail.com>
+ *  Copyright (C) 2014 Michel Stempin <michel.stempin@wanadoo.fr>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_INET_GPIO_LED_WLAN		0
+#define GL_INET_GPIO_LED_LAN		13
+#define GL_INET_GPIO_BTN_RESET		11
+
+#define GL_INET_KEYS_POLL_INTERVAL	20	/* msecs */
+#define GL_INET_KEYS_DEBOUNCE_INTERVAL	(3 * GL_INET_KEYS_POLL_INTERVAL)
+
+static const char * gl_inet_part_probes[] = {
+	"tp-link", /* dont change, this will use tplink parser */
+	NULL ,
+};
+
+static struct flash_platform_data gl_inet_flash_data = {
+	.part_probes = gl_inet_part_probes,
+};
+
+static struct gpio_led gl_inet_leds_gpio[] __initdata = {
+	{
+		.name = "gl-connect:red:wlan",
+		.gpio = GL_INET_GPIO_LED_WLAN,
+		.active_low = 0,
+	},
+	{
+		.name = "gl-connect:green:lan",
+		.gpio = GL_INET_GPIO_LED_LAN,
+		.active_low = 0,
+		.default_state = 1,
+	},
+};
+
+static struct gpio_keys_button gl_inet_gpio_keys[] __initdata = {
+	{
+		.desc = "reset",
+		.type = EV_KEY,
+		.code = KEY_RESTART,
+		.debounce_interval = GL_INET_KEYS_DEBOUNCE_INTERVAL,
+		.gpio = GL_INET_GPIO_BTN_RESET,
+		.active_low = 0,
+	}
+};
+
+static void __init gl_inet_setup(void)
+{
+	/* get the mac address which is stored in the 1st 64k uboot MTD */
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	/* get the art address, which is the last 64K. By using
+	   0x1fff1000, it doesn't matter it is 4M, 8M or 16M flash */
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	/* register flash. MTD will use tp-link parser to parser MTD */
+	ath79_register_m25p80(&gl_inet_flash_data);
+
+	/* register gpio LEDs and keys */
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_inet_leds_gpio),
+				 gl_inet_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, GL_INET_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_inet_gpio_keys),
+					gl_inet_gpio_keys);
+
+	/* enable usb */
+	ath79_register_usb();
+
+	/* register eth0 as WAN, eth1 as LAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	/* register wireless mac with cal data */
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_INET, "GL-INET", "GL-CONNECT INET v1",
+	     gl_inet_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-gs-minibox-v1.c linux-4.1.13/arch/mips/ath79/mach-gs-minibox-v1.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-gs-minibox-v1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-gs-minibox-v1.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,85 @@
+/*
+ *  Gainstrong MiniBox V1.0 board support
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GS_MINIBOX_V1_GPIO_BTN_RESET	11
+
+#define GS_MINIBOX_V1_GPIO_LED_SYSTEM	1
+
+#define GS_MINIBOX_V1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define GS_MINIBOX_V1_KEYS_DEBOUNCE_INTERVAL (3 * GS_MINIBOX_V1_KEYS_POLL_INTERVAL)
+
+static const char *gs_minibox_v1_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data gs_minibox_v1_flash_data = {
+	.part_probes	= gs_minibox_v1_part_probes,
+};
+
+static struct gpio_led gs_minibox_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "minibox-v1:green:system",
+		.gpio		= GS_MINIBOX_V1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button gs_minibox_v1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = GS_MINIBOX_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= GS_MINIBOX_V1_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+};
+
+static void __init gs_minibox_v1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gs_minibox_v1_leds_gpio),
+				 gs_minibox_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, GS_MINIBOX_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gs_minibox_v1_gpio_keys),
+					gs_minibox_v1_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(&gs_minibox_v1_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_GS_MINIBOX_V1, "MINIBOX-V1",
+	     "MiniBox V1.0", gs_minibox_v1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-gs-oolite.c linux-4.1.13/arch/mips/ath79/mach-gs-oolite.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-gs-oolite.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-gs-oolite.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,103 @@
+/*
+ *  Oolite board support
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "dev-usb.h"
+
+#define GS_OOLITE_GPIO_BTN6		6
+#define GS_OOLITE_GPIO_BTN7		7
+#define GS_OOLITE_GPIO_BTN_RESET	11
+
+#define GS_OOLITE_GPIO_LED_SYSTEM	27
+
+#define GS_OOLITE_KEYS_POLL_INTERVAL	20	/* msecs */
+#define GS_OOLITE_KEYS_DEBOUNCE_INTERVAL (3 * GS_OOLITE_KEYS_POLL_INTERVAL)
+
+static const char *gs_oolite_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data gs_oolite_flash_data = {
+	.part_probes	= gs_oolite_part_probes,
+};
+
+static struct gpio_led gs_oolite_leds_gpio[] __initdata = {
+	{
+		.name		= "oolite:red:system",
+		.gpio		= GS_OOLITE_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button gs_oolite_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = GS_OOLITE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= GS_OOLITE_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "BTN_6",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = GS_OOLITE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= GS_OOLITE_GPIO_BTN6,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "BTN_7",
+		.type		= EV_KEY,
+		.code		= BTN_7,
+		.debounce_interval = GS_OOLITE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= GS_OOLITE_GPIO_BTN7,
+		.active_low	= 0,
+	},
+};
+
+static void __init gs_oolite_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gs_oolite_leds_gpio),
+				 gs_oolite_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, GS_OOLITE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gs_oolite_gpio_keys),
+					gs_oolite_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(&gs_oolite_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_GS_OOLITE, "GS-OOLITE",
+	     "Oolite V1.0", gs_oolite_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-hiwifi-hc6361.c linux-4.1.13/arch/mips/ath79/mach-hiwifi-hc6361.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-hiwifi-hc6361.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-hiwifi-hc6361.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,115 @@
+/*
+ *  HiWiFi HC6361 board support
+ *
+ *  Copyright (C) 2012-2013 eric
+ *  Copyright (C) 2014 Yousong Zhou <yszhou4tech@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/proc_fs.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define HIWIFI_HC6361_GPIO_LED_WLAN_2P4		0	/* 2.4G WLAN LED */
+#define HIWIFI_HC6361_GPIO_LED_SYSTEM		1	/* System LED */
+#define HIWIFI_HC6361_GPIO_LED_INTERNET		27	/* Internet LED */
+
+#define HIWIFI_HC6361_GPIO_USBPOWER		20	/* USB power control */
+#define HIWIFI_HC6361_GPIO_BTN_RST		11	/* Reset button */
+
+#define HIWIFI_HC6361_KEYS_POLL_INTERVAL	20	/* msecs */
+#define HIWIFI_HC6361_KEYS_DEBOUNCE_INTERVAL	\
+	(3 * HIWIFI_HC6361_KEYS_POLL_INTERVAL)
+
+static struct gpio_led hiwifi_leds_gpio[] __initdata = {
+	{
+		.name		= "hiwifi:blue:wlan-2p4",
+		.gpio		= HIWIFI_HC6361_GPIO_LED_WLAN_2P4,
+		.active_low	= 1,
+	}, {
+		.name		= "hiwifi:blue:system",
+		.gpio		= HIWIFI_HC6361_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "hiwifi:blue:internet",
+		.gpio		= HIWIFI_HC6361_GPIO_LED_INTERNET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button hiwifi_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = HIWIFI_HC6361_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= HIWIFI_HC6361_GPIO_BTN_RST,
+		.active_low	= 1,
+	}
+};
+
+static void __init get_mac_from_bdinfo(u8 *mac, void *bdinfo)
+{
+	if (sscanf(bdinfo, "fac_mac = %2hhx:%2hhx:%2hhx:%2hhx:%2hhx:%2hhx",
+				&mac[0], &mac[1], &mac[2], &mac[3],
+				&mac[4], &mac[5]) == 6) {
+		return;
+	}
+
+	printk(KERN_WARNING "Parsing MAC address failed.\n");
+	memcpy(mac, "\x00\xba\xbe\x00\x00\x00", 6);
+}
+
+static void __init hiwifi_hc6361_setup(void)
+{
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(NULL);
+	ath79_gpio_function_enable(
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+			AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(hiwifi_leds_gpio),
+			hiwifi_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, HIWIFI_HC6361_KEYS_POLL_INTERVAL,
+			ARRAY_SIZE(hiwifi_gpio_keys),
+			hiwifi_gpio_keys);
+	gpio_request_one(HIWIFI_HC6361_GPIO_USBPOWER,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"USB power");
+	ath79_register_usb();
+
+	get_mac_from_bdinfo(mac, (void *) KSEG1ADDR(0x1f010180));
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_HIWIFI_HC6361, "HiWiFi-HC6361",
+		"HiWiFi HC6361", hiwifi_hc6361_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-hornet-ub.c linux-4.1.13/arch/mips/ath79/mach-hornet-ub.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-hornet-ub.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-hornet-ub.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,142 @@
+/*
+ *  ALFA NETWORK Hornet-UB board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define HORNET_UB_GPIO_LED_WLAN		0
+#define HORNET_UB_GPIO_LED_USB		1
+#define HORNET_UB_GPIO_LED_LAN		13
+#define HORNET_UB_GPIO_LED_WAN		17
+#define HORNET_UB_GPIO_LED_WPS		27
+#define HORNET_UB_GPIO_EXT_LNA		28
+
+#define HORNET_UB_GPIO_BTN_RESET	12
+#define HORNET_UB_GPIO_BTN_WPS		11
+
+#define HORNET_UB_GPIO_USB_POWER	26
+
+#define HORNET_UB_KEYS_POLL_INTERVAL	20	/* msecs */
+#define HORNET_UB_KEYS_DEBOUNCE_INTERVAL	(3 * HORNET_UB_KEYS_POLL_INTERVAL)
+
+#define HORNET_UB_MAC0_OFFSET		0x0000
+#define HORNET_UB_MAC1_OFFSET		0x0006
+#define HORNET_UB_CALDATA_OFFSET	0x1000
+
+static struct gpio_led hornet_ub_leds_gpio[] __initdata = {
+	{
+		.name		= "alfa:blue:lan",
+		.gpio		= HORNET_UB_GPIO_LED_LAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:blue:usb",
+		.gpio		= HORNET_UB_GPIO_LED_USB,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:blue:wan",
+		.gpio		= HORNET_UB_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "alfa:blue:wlan",
+		.gpio		= HORNET_UB_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:blue:wps",
+		.gpio		= HORNET_UB_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button hornet_ub_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = HORNET_UB_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= HORNET_UB_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = HORNET_UB_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= HORNET_UB_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init hornet_ub_gpio_setup(void)
+{
+	u32 t;
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	gpio_request_one(HORNET_UB_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	gpio_request_one(HORNET_UB_GPIO_EXT_LNA,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"external LNA0");
+
+}
+
+static void __init hornet_ub_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	hornet_ub_gpio_setup();
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(hornet_ub_leds_gpio),
+					hornet_ub_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, HORNET_UB_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(hornet_ub_gpio_keys),
+					 hornet_ub_gpio_keys);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+			art + HORNET_UB_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+			art + HORNET_UB_MAC1_OFFSET, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + HORNET_UB_CALDATA_OFFSET, NULL);
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_HORNET_UB, "HORNET-UB", "ALFA NETWORK Hornet-UB",
+	     hornet_ub_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ja76pf.c linux-4.1.13/arch/mips/ath79/mach-ja76pf.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ja76pf.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ja76pf.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,190 @@
+/*
+ *  jjPlus JA76PF board support
+ */
+
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define JA76PF_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JA76PF_KEYS_DEBOUNCE_INTERVAL	(3 * JA76PF_KEYS_POLL_INTERVAL)
+
+#define JA76PF_GPIO_I2C_SCL		0
+#define JA76PF_GPIO_I2C_SDA		1
+#define JA76PF_GPIO_LED_1		5
+#define JA76PF_GPIO_LED_2		4
+#define JA76PF_GPIO_LED_3		3
+#define JA76PF_GPIO_BTN_RESET		11
+
+static struct gpio_led ja76pf_leds_gpio[] __initdata = {
+	{
+		.name		= "jjplus:green:led1",
+		.gpio		= JA76PF_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "jjplus:green:led2",
+		.gpio		= JA76PF_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "jjplus:green:led3",
+		.gpio		= JA76PF_GPIO_LED_3,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button ja76pf_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data ja76pf_i2c_gpio_data = {
+	.sda_pin	= JA76PF_GPIO_I2C_SDA,
+	.scl_pin	= JA76PF_GPIO_I2C_SCL,
+};
+
+static struct platform_device ja76pf_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &ja76pf_i2c_gpio_data,
+	}
+};
+
+static const char *ja76pf_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data ja76pf_flash_data = {
+	.part_probes	= ja76pf_part_probes,
+};
+
+#define JA76PF_WAN_PHYMASK	(1 << 4)
+#define JA76PF_LAN_PHYMASK	((1 << 0) | (1 << 1) | (1 << 2) | (1 < 3))
+#define JA76PF_MDIO_PHYMASK	(JA76PF_LAN_PHYMASK | JA76PF_WAN_PHYMASK)
+
+static void __init ja76pf_init(void)
+{
+	ath79_register_m25p80(&ja76pf_flash_data);
+
+	ath79_register_mdio(0, ~JA76PF_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = JA76PF_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = JA76PF_WAN_PHYMASK;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	platform_device_register(&ja76pf_i2c_gpio_device);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ja76pf_leds_gpio),
+					ja76pf_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, JA76PF_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(ja76pf_gpio_keys),
+					 ja76pf_gpio_keys);
+
+	ath79_register_usb();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_JA76PF, "JA76PF", "jjPlus JA76PF", ja76pf_init);
+
+#define JA76PF2_GPIO_LED_D2		5
+#define JA76PF2_GPIO_LED_D3		4
+#define JA76PF2_GPIO_LED_D4		3
+#define JA76PF2_GPIO_BTN_RESET		7
+#define JA76PF2_GPIO_BTN_WPS		8
+
+static struct gpio_led ja76pf2_leds_gpio[] __initdata = {
+	{
+		.name		= "jjplus:green:led1",
+		.gpio		= JA76PF2_GPIO_LED_D2,
+		.active_low	= 1,
+	}, {
+		.name		= "jjplus:green:led2",
+		.gpio		= JA76PF2_GPIO_LED_D3,
+		.active_low	= 0,
+	}, {
+		.name		= "jjplus:green:led3",
+		.gpio		= JA76PF2_GPIO_LED_D4,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button ja76pf2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = JA76PF_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JA76PF2_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+#define JA76PF2_LAN_PHYMASK	BIT(0)
+#define JA76PF2_WAN_PHYMASK	BIT(4)
+#define JA76PF2_MDIO_PHYMASK	(JA76PF2_LAN_PHYMASK | JA76PF2_WAN_PHYMASK)
+
+static void __init ja76pf2_init(void)
+{
+	ath79_register_m25p80(&ja76pf_flash_data);
+
+	ath79_register_mdio(0, ~JA76PF2_MDIO_PHYMASK);
+
+	/* MAC0 is connected to the CPU port of the AR8316 switch */
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	/* MAC1 is connected to the PHY4 of the AR8316 switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = BIT(4);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ja76pf2_leds_gpio),
+				 ja76pf2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, JA76PF_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ja76pf2_gpio_keys),
+					ja76pf2_gpio_keys);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_JA76PF2, "JA76PF2", "jjPlus JA76PF2", ja76pf2_init);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-jwap003.c linux-4.1.13/arch/mips/ath79/mach-jwap003.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-jwap003.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-jwap003.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,95 @@
+/*
+ *  jjPlus JWAP003 board support
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define JWAP003_KEYS_POLL_INTERVAL	20	/* msecs */
+#define JWAP003_KEYS_DEBOUNCE_INTERVAL	(3 * JWAP003_KEYS_POLL_INTERVAL)
+
+#define JWAP003_GPIO_WPS	11
+#define JWAP003_GPIO_I2C_SCL	0
+#define JWAP003_GPIO_I2C_SDA	1
+
+static struct gpio_keys_button jwap003_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = JWAP003_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= JWAP003_GPIO_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data jwap003_i2c_gpio_data = {
+	.sda_pin	= JWAP003_GPIO_I2C_SDA,
+	.scl_pin	= JWAP003_GPIO_I2C_SCL,
+};
+
+static struct platform_device jwap003_i2c_gpio_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data  = &jwap003_i2c_gpio_data,
+	}
+};
+
+static const char *jwap003_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data jwap003_flash_data = {
+	.part_probes	= jwap003_part_probes,
+};
+
+#define JWAP003_WAN_PHYMASK	BIT(0)
+#define JWAP003_LAN_PHYMASK	BIT(4)
+
+static void __init jwap003_init(void)
+{
+	ath79_register_m25p80(&jwap003_flash_data);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = JWAP003_WAN_PHYMASK;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = JWAP003_LAN_PHYMASK;
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	platform_device_register(&jwap003_i2c_gpio_device);
+
+	ath79_register_usb();
+
+	ath79_register_gpio_keys_polled(-1, JWAP003_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(jwap003_gpio_keys),
+					 jwap003_gpio_keys);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_JWAP003, "JWAP003", "jjPlus JWAP003", jwap003_init);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mc-mac1200r.c linux-4.1.13/arch/mips/ath79/mach-mc-mac1200r.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mc-mac1200r.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mc-mac1200r.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,155 @@
+/*
+ *  MERCURY MAC1200R board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 Gui Iribarren <gui@altermundi.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MAC1200R_GPIO_LED_WLAN2G	13
+#define MAC1200R_GPIO_LED_WLAN5G	17
+#define MAC1200R_GPIO_LED_SYSTEM	14
+#define MAC1200R_GPIO_LED_WPS		11
+#define MAC1200R_GPIO_LED_WAN		12
+#define MAC1200R_GPIO_LED_LAN1		15
+#define MAC1200R_GPIO_LED_LAN2		21
+#define MAC1200R_GPIO_LED_LAN3		22
+#define MAC1200R_GPIO_LED_LAN4		20
+
+#define MAC1200R_GPIO_BTN_WPS		16
+
+#define MAC1200R_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MAC1200R_KEYS_DEBOUNCE_INTERVAL	(3 * MAC1200R_KEYS_POLL_INTERVAL)
+
+#define MAC1200R_MAC0_OFFSET		0
+#define MAC1200R_MAC1_OFFSET		6
+#define MAC1200R_WMAC_CALDATA_OFFSET	0x1000
+#define MAC1200R_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *mac1200r_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data mac1200r_flash_data = {
+	.part_probes	= mac1200r_part_probes,
+};
+
+static struct gpio_led mac1200r_leds_gpio[] __initdata = {
+	{
+		.name		= "mercury:green:wps",
+		.gpio		= MAC1200R_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mercury:green:system",
+		.gpio		= MAC1200R_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mercury:green:wlan2g",
+		.gpio		= MAC1200R_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mercury:green:wlan5g",
+		.gpio		= MAC1200R_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mac1200r_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MAC1200R_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MAC1200R_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+
+static void __init mac1200r_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&mac1200r_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mac1200r_leds_gpio),
+					mac1200r_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MAC1200R_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mac1200r_gpio_keys),
+					mac1200r_gpio_keys);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_wmac_disable_5ghz();
+	ath79_register_wmac(art + MAC1200R_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_init_mac(tmpmac, mac, 1);
+	ap91_pci_init(art + MAC1200R_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 2);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_LED_LINK3);
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_LED_LINK2);
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_LAN3,
+				 AR934X_GPIO_OUT_LED_LINK1);
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_LAN4,
+				 AR934X_GPIO_OUT_LED_LINK0);
+	ath79_gpio_output_select(MAC1200R_GPIO_LED_WAN,
+				 AR934X_GPIO_OUT_LED_LINK4);
+}
+
+MIPS_MACHINE(ATH79_MACH_MC_MAC1200R, "MC-MAC1200R",
+	     "MERCURY MAC1200R",
+	     mac1200r_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mr12.c linux-4.1.13/arch/mips/ath79/mach-mr12.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mr12.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mr12.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,115 @@
+/*
+ *  Cisco Meraki MR12 board support
+ *
+ *  Copyright (C) 2014-2015 Chris Blake <chrisrblake93@gmail.com>
+ *
+ *  Based on Atheros AP96 board support configuration
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define MR12_GPIO_LED_W4_GREEN		14
+#define MR12_GPIO_LED_W3_GREEN		13
+#define MR12_GPIO_LED_W2_GREEN		12
+#define MR12_GPIO_LED_W1_GREEN		11
+
+#define MR12_GPIO_LED_WAN		15
+
+#define MR12_GPIO_LED_POWER_ORANGE		16
+#define MR12_GPIO_LED_POWER_GREEN		17
+
+#define MR12_GPIO_BTN_RESET		8
+#define MR12_KEYS_POLL_INTERVAL		20	/* msecs */
+#define MR12_KEYS_DEBOUNCE_INTERVAL	(3 * MR12_KEYS_POLL_INTERVAL)
+
+#define MR12_WAN_PHYMASK    BIT(4)
+
+#define MR12_WMAC0_MAC_OFFSET           0x120c
+#define MR12_CALDATA0_OFFSET            0x1000
+
+static struct gpio_led MR12_leds_gpio[] __initdata = {
+	{
+		.name		= "mr12:green:wan",
+		.gpio		= MR12_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:orange:power",
+		.gpio		= MR12_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:power",
+		.gpio		= MR12_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:wifi4",
+		.gpio		= MR12_GPIO_LED_W4_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:wifi3",
+		.gpio		= MR12_GPIO_LED_W3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:wifi2",
+		.gpio		= MR12_GPIO_LED_W2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr12:green:wifi1",
+		.gpio		= MR12_GPIO_LED_W1_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button MR12_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR12_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR12_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init MR12_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0xbfff0000);
+	
+	ath79_register_mdio(0,0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = MR12_WAN_PHYMASK;
+	ath79_register_eth(0);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(MR12_leds_gpio),
+					MR12_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MR12_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(MR12_gpio_keys),
+					MR12_gpio_keys);
+
+	ap91_pci_init(mac + MR12_CALDATA0_OFFSET,
+				mac + MR12_WMAC0_MAC_OFFSET);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_MR12, "MR12", "Meraki MR12", MR12_setup);
\ No newline at end of file
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mr16.c linux-4.1.13/arch/mips/ath79/mach-mr16.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mr16.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mr16.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,118 @@
+/*
+ *  Cisco Meraki MR16 board support
+ *
+ *  Copyright (C) 2015 Chris Blake <chrisrblake93@gmail.com>
+ *
+ *  Based on Atheros AP96 board support configuration
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define MR16_GPIO_LED_W4_GREEN		3
+#define MR16_GPIO_LED_W3_GREEN		2
+#define MR16_GPIO_LED_W2_GREEN		1
+#define MR16_GPIO_LED_W1_GREEN		0
+
+#define MR16_GPIO_LED_WAN		4
+
+#define MR16_GPIO_LED_POWER_ORANGE		5
+#define MR16_GPIO_LED_POWER_GREEN		6
+
+#define MR16_GPIO_BTN_RESET		7
+#define MR16_KEYS_POLL_INTERVAL		20	/* msecs */
+#define MR16_KEYS_DEBOUNCE_INTERVAL	(3 * MR16_KEYS_POLL_INTERVAL)
+
+#define MR16_WAN_PHYMASK    BIT(0)
+
+#define MR16_WMAC0_MAC_OFFSET		0x120c
+#define MR16_WMAC1_MAC_OFFSET		0x520c
+#define MR16_CALDATA0_OFFSET		0x1000
+#define MR16_CALDATA1_OFFSET		0x5000
+
+static struct gpio_led MR16_leds_gpio[] __initdata = {
+	{
+		.name		= "mr16:green:wan",
+		.gpio		= MR16_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:orange:power",
+		.gpio		= MR16_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:power",
+		.gpio		= MR16_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:wifi4",
+		.gpio		= MR16_GPIO_LED_W4_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:wifi3",
+		.gpio		= MR16_GPIO_LED_W3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:wifi2",
+		.gpio		= MR16_GPIO_LED_W2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "mr16:green:wifi1",
+		.gpio		= MR16_GPIO_LED_W1_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button MR16_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR16_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR16_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init MR16_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0xbfff0000);
+	
+	ath79_register_mdio(0,0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = MR16_WAN_PHYMASK;
+	ath79_register_eth(0);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(MR16_leds_gpio),
+					MR16_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MR16_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(MR16_gpio_keys),
+					MR16_gpio_keys);
+
+	ap94_pci_init(mac + MR16_CALDATA0_OFFSET,
+		    mac + MR16_WMAC0_MAC_OFFSET,
+		    mac + MR16_CALDATA1_OFFSET,
+		    mac + MR16_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR16, "MR16", "Meraki MR16", MR16_setup);
\ No newline at end of file
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mr1750.c linux-4.1.13/arch/mips/ath79/mach-mr1750.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mr1750.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mr1750.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,129 @@
+/*
+ * MR1750 board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Marek Lindner <marek@open-mesh.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define MR1750_GPIO_LED_LAN		12
+#define MR1750_GPIO_LED_WLAN_2G		13
+#define MR1750_GPIO_LED_STATUS_GREEN	19
+#define MR1750_GPIO_LED_STATUS_RED	21
+#define MR1750_GPIO_LED_POWER		22
+#define MR1750_GPIO_LED_WLAN_5G		23
+
+#define MR1750_GPIO_BTN_RESET		17
+
+#define MR1750_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MR1750_KEYS_DEBOUNCE_INTERVAL	(3 * MR1750_KEYS_POLL_INTERVAL)
+
+#define MR1750_MAC0_OFFSET		0
+#define MR1750_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led mr1750_leds_gpio[] __initdata = {
+	{
+		.name		= "mr1750:blue:power",
+		.gpio		= MR1750_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:blue:wan",
+		.gpio		= MR1750_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:blue:wlan24",
+		.gpio		= MR1750_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:blue:wlan58",
+		.gpio		= MR1750_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:green:status",
+		.gpio		= MR1750_GPIO_LED_STATUS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr1750:red:status",
+		.gpio		= MR1750_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mr1750_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR1750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR1750_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init mr1750_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	ath79_eth0_pll_data.pll_1000 = 0xbe000101;
+	ath79_eth0_pll_data.pll_100 = 0x80000101;
+	ath79_eth0_pll_data.pll_10 = 0x80001313;
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mr1750_leds_gpio),
+				 mr1750_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MR1750_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mr1750_gpio_keys),
+					mr1750_gpio_keys);
+
+	ath79_init_mac(mac, art + MR1750_MAC0_OFFSET, 1);
+	ath79_register_wmac(art + MR1750_WMAC_CALDATA_OFFSET, mac);
+	ath79_register_pci();
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + MR1750_MAC0_OFFSET, 0);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(5);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR1750, "MR1750", "OpenMesh MR1750", mr1750_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mr600.c linux-4.1.13/arch/mips/ath79/mach-mr600.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mr600.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mr600.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,177 @@
+/*
+ * OpenMesh OM2P board support
+ *
+ * Copyright (C) 2012 Marek Lindner <marek@open-mesh.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MR600_GPIO_LED_WLAN58		12
+#define MR600_GPIO_LED_WPS			13
+#define MR600_GPIO_LED_POWER			14
+
+#define MR600V2_GPIO_LED_WLAN58_RED		12
+#define MR600V2_GPIO_LED_WPS			13
+#define MR600V2_GPIO_LED_POWER			14
+#define MR600V2_GPIO_LED_WLAN24_GREEN		18
+#define MR600V2_GPIO_LED_WLAN24_YELLOW		19
+#define MR600V2_GPIO_LED_WLAN24_RED		20
+#define MR600V2_GPIO_LED_WLAN58_GREEN		21
+#define MR600V2_GPIO_LED_WLAN58_YELLOW		22
+
+#define MR600_GPIO_BTN_RESET		17
+
+#define MR600_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MR600_KEYS_DEBOUNCE_INTERVAL (3 * MR600_KEYS_POLL_INTERVAL)
+
+#define MR600_MAC_OFFSET		0
+#define MR600_WMAC_CALDATA_OFFSET	0x1000
+#define MR600_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led mr600_leds_gpio[] __initdata = {
+	{
+		.name		= "mr600:orange:power",
+		.gpio		= MR600_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:blue:wps",
+		.gpio		= MR600_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:green:wlan58",
+		.gpio		= MR600_GPIO_LED_WLAN58,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led mr600v2_leds_gpio[] __initdata = {
+	{
+		.name		= "mr600:blue:power",
+		.gpio		= MR600V2_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:blue:wps",
+		.gpio		= MR600V2_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:red:wlan24",
+		.gpio		= MR600V2_GPIO_LED_WLAN24_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:yellow:wlan24",
+		.gpio		= MR600V2_GPIO_LED_WLAN24_YELLOW,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:green:wlan24",
+		.gpio		= MR600V2_GPIO_LED_WLAN24_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:red:wlan58",
+		.gpio		= MR600V2_GPIO_LED_WLAN58_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:yellow:wlan58",
+		.gpio		= MR600V2_GPIO_LED_WLAN58_YELLOW,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr600:green:wlan58",
+		.gpio		= MR600V2_GPIO_LED_WLAN58_GREEN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mr600_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR600_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR600_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init mr600_base_setup(unsigned num_leds, struct gpio_led *leds)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, num_leds, leds);
+	ath79_register_gpio_keys_polled(-1, MR600_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mr600_gpio_keys),
+					mr600_gpio_keys);
+
+	ath79_init_mac(mac, art + MR600_MAC_OFFSET, 1);
+	ath79_register_wmac(art + MR600_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_init_mac(mac, art + MR600_MAC_OFFSET, 8);
+	ap91_pci_init(art + MR600_PCIE_CALDATA_OFFSET, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + MR600_MAC_OFFSET, 0);
+
+	/* GMAC0 is connected to an external PHY */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+static void __init mr600_setup(void)
+{
+	mr600_base_setup(ARRAY_SIZE(mr600_leds_gpio), mr600_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR600, "MR600", "OpenMesh MR600", mr600_setup);
+
+static void __init mr600v2_setup(void)
+{
+	mr600_base_setup(ARRAY_SIZE(mr600v2_leds_gpio), mr600v2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR600V2, "MR600v2", "OpenMesh MR600v2", mr600v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mr900.c linux-4.1.13/arch/mips/ath79/mach-mr900.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mr900.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mr900.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,140 @@
+/*
+ * MR900 board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Marek Lindner <marek@open-mesh.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define MR900_GPIO_LED_LAN		12
+#define MR900_GPIO_LED_WLAN_2G		13
+#define MR900_GPIO_LED_STATUS_GREEN	19
+#define MR900_GPIO_LED_STATUS_RED	21
+#define MR900_GPIO_LED_POWER		22
+#define MR900_GPIO_LED_WLAN_5G		23
+
+#define MR900_GPIO_BTN_RESET		17
+
+#define MR900_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MR900_KEYS_DEBOUNCE_INTERVAL	(3 * MR900_KEYS_POLL_INTERVAL)
+
+#define MR900_MAC0_OFFSET		0
+#define MR900_WMAC_CALDATA_OFFSET	0x1000
+#define MR900_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led mr900_leds_gpio[] __initdata = {
+	{
+		.name		= "mr900:blue:power",
+		.gpio		= MR900_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:blue:wan",
+		.gpio		= MR900_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:blue:wlan24",
+		.gpio		= MR900_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:blue:wlan58",
+		.gpio		= MR900_GPIO_LED_WLAN_5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:green:status",
+		.gpio		= MR900_GPIO_LED_STATUS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "mr900:red:status",
+		.gpio		= MR900_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mr900_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MR900_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MR900_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init mr900_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6], pcie_mac[6];
+	struct ath9k_platform_data *pdata;
+
+	ath79_eth0_pll_data.pll_1000 = 0xbe000101;
+	ath79_eth0_pll_data.pll_100 = 0x80000101;
+	ath79_eth0_pll_data.pll_10 = 0x80001313;
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mr900_leds_gpio),
+				 mr900_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MR900_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mr900_gpio_keys),
+					mr900_gpio_keys);
+
+	ath79_init_mac(mac, art + MR900_MAC0_OFFSET, 1);
+	ath79_register_wmac(art + MR900_WMAC_CALDATA_OFFSET, mac);
+	ath79_init_mac(pcie_mac, art + MR900_MAC0_OFFSET, 16);
+	ap91_pci_init(art + MR900_PCIE_CALDATA_OFFSET, pcie_mac);
+	pdata = ap9x_pci_get_wmac_data(0);
+	if (!pdata) {
+		pr_err("mr900: unable to get address of wlan data\n");
+		return;
+	}
+	pdata->use_eeprom = true;
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + MR900_MAC0_OFFSET, 0);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(5);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_MR900, "MR900", "OpenMesh MR900", mr900_setup);
+MIPS_MACHINE(ATH79_MACH_MR900v2, "MR900v2", "OpenMesh MR900v2", mr900_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mynet-n600.c linux-4.1.13/arch/mips/ath79/mach-mynet-n600.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mynet-n600.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mynet-n600.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,202 @@
+/*
+ *  WD My Net N600 board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define MYNET_N600_GPIO_LED_WIFI	0
+#define MYNET_N600_GPIO_LED_POWER	11
+#define MYNET_N600_GPIO_LED_INTERNET	12
+#define MYNET_N600_GPIO_LED_WPS		13
+
+#define MYNET_N600_GPIO_LED_LAN1	4
+#define MYNET_N600_GPIO_LED_LAN2	3
+#define MYNET_N600_GPIO_LED_LAN3	2
+#define MYNET_N600_GPIO_LED_LAN4	1
+
+#define MYNET_N600_GPIO_BTN_RESET	16
+#define MYNET_N600_GPIO_BTN_WPS		17
+
+#define MYNET_N600_GPIO_EXTERNAL_LNA0	14
+#define MYNET_N600_GPIO_EXTERNAL_LNA1	15
+
+#define MYNET_N600_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MYNET_N600_KEYS_DEBOUNCE_INTERVAL (3 * MYNET_N600_KEYS_POLL_INTERVAL)
+
+#define MYNET_N600_MAC0_OFFSET		0
+#define MYNET_N600_MAC1_OFFSET		6
+#define MYNET_N600_WMAC_CALDATA_OFFSET	0x1000
+#define MYNET_N600_PCIE_CALDATA_OFFSET	0x5000
+
+#define MYNET_N600_NVRAM_ADDR		0x1f058010
+#define MYNET_N600_NVRAM_SIZE		0x7ff0
+
+static struct gpio_led mynet_n600_leds_gpio[] __initdata = {
+	{
+		.name		= "wd:blue:power",
+		.gpio		= MYNET_N600_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wps",
+		.gpio		= MYNET_N600_GPIO_LED_WPS,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wireless",
+		.gpio		= MYNET_N600_GPIO_LED_WIFI,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:internet",
+		.gpio		= MYNET_N600_GPIO_LED_INTERNET,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:green:lan1",
+		.gpio		= MYNET_N600_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:green:lan2",
+		.gpio		= MYNET_N600_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:green:lan3",
+		.gpio		= MYNET_N600_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:green:lan4",
+		.gpio		= MYNET_N600_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mynet_n600_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MYNET_N600_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N600_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MYNET_N600_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N600_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static void mynet_n600_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(MYNET_N600_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, MYNET_N600_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+#define MYNET_N600_WAN_PHY_MASK	BIT(0)
+
+static void __init mynet_n600_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN3,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN4,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_INTERNET,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mynet_n600_leds_gpio),
+				 mynet_n600_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MYNET_N600_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mynet_n600_gpio_keys),
+					mynet_n600_gpio_keys);
+
+	/*
+	 * Control signal for external LNAs 0 and 1
+	 * Taken from GPL bootloader source:
+	 *   board/ar7240/db12x/alpha_gpio.c
+	 */
+	ath79_wmac_set_ext_lna_gpio(0, MYNET_N600_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, MYNET_N600_GPIO_EXTERNAL_LNA1);
+
+	mynet_n600_get_mac("wlan24mac=", tmpmac);
+	ath79_register_wmac(art + MYNET_N600_WMAC_CALDATA_OFFSET, tmpmac);
+
+	mynet_n600_get_mac("wlan5mac=", tmpmac);
+	ap91_pci_init(art + MYNET_N600_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE |
+				   AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	mynet_n600_get_mac("lanmac=", ath79_eth1_data.mac_addr);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	mynet_n600_get_mac("wanmac=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = MYNET_N600_WAN_PHY_MASK;
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = MYNET_N600_WAN_PHY_MASK;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_MYNET_N600, "MYNET-N600", "WD My Net N600",
+	     mynet_n600_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mynet-n750.c linux-4.1.13/arch/mips/ath79/mach-mynet-n750.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mynet-n750.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mynet-n750.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,226 @@
+/*
+ *  WD My Net N750 board support
+ *
+ *  Copyright (C) 2013 Felix Kaechele <felix@fetzig.org>
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+
+/*
+ * Taken from GPL bootloader source:
+ *   board/ar7240/db12x/alpha_gpio.c
+ */
+#define MYNET_N750_GPIO_LED_WIFI	11
+#define MYNET_N750_GPIO_LED_INTERNET	12
+#define MYNET_N750_GPIO_LED_WPS		13
+#define MYNET_N750_GPIO_LED_POWER	14
+
+#define MYNET_N750_GPIO_BTN_RESET	17
+#define MYNET_N750_GPIO_BTN_WPS		19
+
+#define MYNET_N750_GPIO_EXTERNAL_LNA0	15
+#define MYNET_N750_GPIO_EXTERNAL_LNA1	18
+
+#define MYNET_N750_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MYNET_N750_KEYS_DEBOUNCE_INTERVAL (3 * MYNET_N750_KEYS_POLL_INTERVAL)
+
+#define MYNET_N750_WMAC_CALDATA_OFFSET	0x1000
+#define MYNET_N750_PCIE_CALDATA_OFFSET	0x5000
+
+#define MYNET_N750_NVRAM_ADDR		0x1f058010
+#define MYNET_N750_NVRAM_SIZE		0x7ff0
+
+static struct gpio_led mynet_n750_leds_gpio[] __initdata = {
+	{
+		.name		= "wd:blue:power",
+		.gpio		= MYNET_N750_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wps",
+		.gpio		= MYNET_N750_GPIO_LED_WPS,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wireless",
+		.gpio		= MYNET_N750_GPIO_LED_WIFI,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:internet",
+		.gpio		= MYNET_N750_GPIO_LED_INTERNET,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button mynet_n750_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MYNET_N750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N750_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MYNET_N750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N750_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info mynet_n750_leds_ar8327[] __initconst = {
+	AR8327_LED_INFO(PHY0_0, HW, "wd:green:lan1"),
+	AR8327_LED_INFO(PHY1_0, HW, "wd:green:lan2"),
+	AR8327_LED_INFO(PHY2_0, HW, "wd:green:lan3"),
+	AR8327_LED_INFO(PHY3_0, HW, "wd:green:lan4"),
+	AR8327_LED_INFO(PHY4_0, HW, "wd:green:wan"),
+	AR8327_LED_INFO(PHY0_1, HW, "wd:yellow:lan1"),
+	AR8327_LED_INFO(PHY1_1, HW, "wd:yellow:lan2"),
+	AR8327_LED_INFO(PHY2_1, HW, "wd:yellow:lan3"),
+	AR8327_LED_INFO(PHY3_1, HW, "wd:yellow:lan4"),
+	AR8327_LED_INFO(PHY4_1, HW, "wd:yellow:wan"),
+};
+
+static struct ar8327_pad_cfg mynet_n750_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg mynet_n750_ar8327_led_cfg = {
+	.led_ctrl0 = 0xcc35cc35,
+	.led_ctrl1 = 0xca35ca35,
+	.led_ctrl2 = 0xc935c935,
+	.led_ctrl3 = 0x03ffff00,
+	.open_drain = false,
+};
+
+static struct ar8327_platform_data mynet_n750_ar8327_data = {
+	.pad0_cfg = &mynet_n750_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &mynet_n750_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(mynet_n750_leds_ar8327),
+	.leds = mynet_n750_leds_ar8327,
+};
+
+static struct mdio_board_info mynet_n750_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &mynet_n750_ar8327_data,
+	},
+};
+
+static void mynet_n750_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(MYNET_N750_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, MYNET_N750_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+/*
+ * The bootloader on this board powers down all PHYs on the switch
+ * before booting the kernel. We bring all PHYs back up so that they are
+ * discoverable by the mdio bus scan and the switch is detected
+ * correctly.
+ */
+static void mynet_n750_mdio_fixup(struct mii_bus *bus)
+{
+	int i;
+
+	for (i = 0; i < 5; i++)
+		bus->write(bus, i, MII_BMCR,
+			   (BMCR_RESET | BMCR_ANENABLE | BMCR_SPEED1000));
+
+	mdelay(1000);
+}
+
+static void __init mynet_n750_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mynet_n750_leds_gpio),
+				 mynet_n750_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MYNET_N750_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mynet_n750_gpio_keys),
+					mynet_n750_gpio_keys);
+	/*
+	 * Control signal for external LNAs 0 and 1
+	 * Taken from GPL bootloader source:
+	 *   board/ar7240/db12x/alpha_gpio.c
+	 */
+	ath79_wmac_set_ext_lna_gpio(0, MYNET_N750_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, MYNET_N750_GPIO_EXTERNAL_LNA1);
+
+	mynet_n750_get_mac("wlan24mac=", tmpmac);
+	ath79_register_wmac(art + MYNET_N750_WMAC_CALDATA_OFFSET, tmpmac);
+
+	mynet_n750_get_mac("wlan5mac=", tmpmac);
+	ap91_pci_init(art + MYNET_N750_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(mynet_n750_mdio0_info,
+				    ARRAY_SIZE(mynet_n750_mdio0_info));
+
+	ath79_mdio0_data.reset = mynet_n750_mdio_fixup;
+	ath79_register_mdio(0, 0x0);
+
+	mynet_n750_get_mac("lanmac=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_MYNET_N750, "MYNET-N750", "WD My Net N750",
+	     mynet_n750_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mynet-rext.c linux-4.1.13/arch/mips/ath79/mach-mynet-rext.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mynet-rext.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mynet-rext.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,208 @@
+/*
+ *  WD My Net WI-FI Range Extender (Codename:Starfish db12x) board support
+ *
+ *  Copyright (C) 2013 Christian Lamparter <chunkeey@googlemail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define MYNET_REXT_GPIO_LED_POWER	11
+#define MYNET_REXT_GPIO_LED_ETHERNET	12
+#define MYNET_REXT_GPIO_LED_WIFI	19
+
+#define MYNET_REXT_GPIO_LED_RF_QTY1	20
+#define MYNET_REXT_GPIO_LED_RF_QTY2	21
+#define MYNET_REXT_GPIO_LED_RF_QTY3	22
+
+#define MYNET_REXT_GPIO_BTN_RESET	13
+#define MYNET_REXT_GPIO_BTN_WPS		15
+#define MYNET_REXT_GPIO_SW_RF		14
+
+#define MYNET_REXT_GPIO_PHY_SWRST	16	/* disables Ethernet PHY */
+#define MYNET_REXT_GPIO_PHY_INT		17
+#define MYNET_REXT_GPIO_18		18
+
+#define MYNET_REXT_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MYNET_REXT_KEYS_DEBOUNCE_INTERVAL (3 * MYNET_REXT_KEYS_POLL_INTERVAL)
+
+#define MYNET_REXT_WMAC_CALDATA_OFFSET	0x1000
+
+#define MYNET_REXT_NVRAM_ADDR		0x1f7e0010
+#define MYNET_REXT_NVRAM_SIZE		0xfff0
+
+#define MYNET_REXT_ART_ADDR		0x1f7f0000
+
+static const char *mynet_rext_part_probes[] = {
+	"cybertan",
+	NULL,
+};
+
+static struct flash_platform_data mynet_rext_flash_data = {
+	.type		= "s25fl064k",
+	.part_probes	= mynet_rext_part_probes,
+};
+
+static struct gpio_led mynet_rext_leds_gpio[] __initdata = {
+	{
+		.name		= "wd:blue:power",
+		.gpio		= MYNET_REXT_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wireless",
+		.gpio		= MYNET_REXT_GPIO_LED_WIFI,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:ethernet",
+		.gpio		= MYNET_REXT_GPIO_LED_ETHERNET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:quality1",
+		.gpio		= MYNET_REXT_GPIO_LED_RF_QTY1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:quality2",
+		.gpio		= MYNET_REXT_GPIO_LED_RF_QTY2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:quality3",
+		.gpio		= MYNET_REXT_GPIO_LED_RF_QTY3,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mynet_rext_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MYNET_REXT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_REXT_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MYNET_REXT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_REXT_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc           = "RF Band switch",
+		.type           = EV_SW,
+		.code           = BTN_1,
+		.debounce_interval = MYNET_REXT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio           = MYNET_REXT_GPIO_SW_RF,
+	},
+};
+
+static struct at803x_platform_data mynet_rext_at803x_data = {
+	.disable_smarteee = 0,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 0,
+	.fixup_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info mynet_rext_mdio0_info[] = {
+        {
+                .bus_id = "ag71xx-mdio.0",
+                .phy_addr = 4,
+                .platform_data = &mynet_rext_at803x_data,
+        },
+};
+
+static void mynet_rext_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(MYNET_REXT_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, MYNET_REXT_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init mynet_rext_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(MYNET_REXT_ART_ADDR);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&mynet_rext_flash_data);
+
+	/* GPIO configuration from drivers/char/GPIO8.c */
+
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_POWER,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_WIFI,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_RF_QTY1,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_RF_QTY2,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_RF_QTY3,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_ETHERNET,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mynet_rext_leds_gpio),
+				 mynet_rext_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MYNET_REXT_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mynet_rext_gpio_keys),
+					mynet_rext_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_RXD_DELAY |
+				   AR934X_ETH_CFG_RDV_DELAY);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(mynet_rext_mdio0_info,
+				    ARRAY_SIZE(mynet_rext_mdio0_info));
+
+	/* LAN */
+	mynet_rext_get_mac("et0macaddr=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to an external PHY on Port 4 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_pll_data.pll_10   = 0x00001313; /* athrs_mac.c */
+	ath79_eth0_pll_data.pll_1000 = 0x0e000000; /* athrs_mac.c */
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_register_eth(0);
+
+	/* WLAN */
+	mynet_rext_get_mac("wl0_hwaddr=", tmpmac);
+	ap91_pci_init(art + MYNET_REXT_WMAC_CALDATA_OFFSET, tmpmac);
+}
+
+MIPS_MACHINE(ATH79_MACH_MYNET_REXT, "MYNET-REXT",
+	     "WD My Net Wi-Fi Range Extender", mynet_rext_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mzk-w04nu.c linux-4.1.13/arch/mips/ath79/mach-mzk-w04nu.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mzk-w04nu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mzk-w04nu.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,124 @@
+/*
+ *  Planex MZK-W04NU board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MZK_W04NU_GPIO_LED_USB		0
+#define MZK_W04NU_GPIO_LED_STATUS	1
+#define MZK_W04NU_GPIO_LED_WPS		3
+#define MZK_W04NU_GPIO_LED_WLAN		6
+#define MZK_W04NU_GPIO_LED_AP		15
+#define MZK_W04NU_GPIO_LED_ROUTER	16
+
+#define MZK_W04NU_GPIO_BTN_APROUTER	5
+#define MZK_W04NU_GPIO_BTN_WPS		12
+#define MZK_W04NU_GPIO_BTN_RESET	21
+
+#define MZK_W04NU_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W04NU_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W04NU_KEYS_POLL_INTERVAL)
+
+static struct gpio_led mzk_w04nu_leds_gpio[] __initdata = {
+	{
+		.name		= "planex:green:status",
+		.gpio		= MZK_W04NU_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:blue:wps",
+		.gpio		= MZK_W04NU_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:wlan",
+		.gpio		= MZK_W04NU_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:usb",
+		.gpio		= MZK_W04NU_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:ap",
+		.gpio		= MZK_W04NU_GPIO_LED_AP,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:router",
+		.gpio		= MZK_W04NU_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button mzk_w04nu_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = MZK_W04NU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W04NU_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W04NU_WAN_PHYMASK	BIT(4)
+#define MZK_W04NU_MDIO_MASK	(~MZK_W04NU_WAN_PHYMASK)
+
+static void __init mzk_w04nu_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, MZK_W04NU_MDIO_MASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = MZK_W04NU_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mzk_w04nu_leds_gpio),
+				 mzk_w04nu_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MZK_W04NU_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mzk_w04nu_gpio_keys),
+					mzk_w04nu_gpio_keys);
+	ath79_register_usb();
+
+	ath79_register_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_MZK_W04NU, "MZK-W04NU", "Planex MZK-W04NU",
+	     mzk_w04nu_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-mzk-w300nh.c linux-4.1.13/arch/mips/ath79/mach-mzk-w300nh.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-mzk-w300nh.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-mzk-w300nh.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,115 @@
+/*
+ *  Planex MZK-W300NH board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define MZK_W300NH_GPIO_LED_STATUS	1
+#define MZK_W300NH_GPIO_LED_WPS		3
+#define MZK_W300NH_GPIO_LED_WLAN	6
+#define MZK_W300NH_GPIO_LED_AP_GREEN	15
+#define MZK_W300NH_GPIO_LED_AP_AMBER	16
+
+#define MZK_W300NH_GPIO_BTN_APROUTER	5
+#define MZK_W300NH_GPIO_BTN_WPS		12
+#define MZK_W300NH_GPIO_BTN_RESET	21
+
+#define MZK_W300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MZK_W300NH_KEYS_DEBOUNCE_INTERVAL (3 * MZK_W300NH_KEYS_POLL_INTERVAL)
+
+static struct gpio_led mzk_w300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "planex:green:status",
+		.gpio		= MZK_W300NH_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:blue:wps",
+		.gpio		= MZK_W300NH_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:wlan",
+		.gpio		= MZK_W300NH_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "planex:green:aprouter",
+		.gpio		= MZK_W300NH_GPIO_LED_AP_GREEN,
+	}, {
+		.name		= "planex:amber:aprouter",
+		.gpio		= MZK_W300NH_GPIO_LED_AP_AMBER,
+	}
+};
+
+static struct gpio_keys_button mzk_w300nh_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "aprouter",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = MZK_W300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MZK_W300NH_GPIO_BTN_APROUTER,
+		.active_low	= 0,
+	}
+};
+
+#define MZK_W300NH_WAN_PHYMASK	BIT(4)
+#define MZK_W300NH_MDIO_MASK	(~MZK_W300NH_WAN_PHYMASK)
+
+static void __init mzk_w300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, MZK_W300NH_MDIO_MASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = MZK_W300NH_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mzk_w300nh_leds_gpio),
+				 mzk_w300nh_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MZK_W300NH_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mzk_w300nh_gpio_keys),
+					mzk_w300nh_gpio_keys);
+	ath79_register_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_MZK_W300NH, "MZK-W300NH", "Planex MZK-W300NH",
+	     mzk_w300nh_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-nbg460n.c linux-4.1.13/arch/mips/ath79/mach-nbg460n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-nbg460n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-nbg460n.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,220 @@
+/*
+ *  Zyxel NBG 460N/550N/550NH board support
+ *
+ *  Copyright (C) 2010 Michael Kurz <michi.kurz@googlemail.com>
+ *
+ *  based on mach-tl-wr1043nd.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+/* LEDs */
+#define NBG460N_GPIO_LED_WPS		3
+#define NBG460N_GPIO_LED_WAN		6
+#define NBG460N_GPIO_LED_POWER		14
+#define NBG460N_GPIO_LED_WLAN		15
+
+/* Buttons */
+#define NBG460N_GPIO_BTN_WPS		12
+#define NBG460N_GPIO_BTN_RESET		21
+
+#define NBG460N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define NBG460N_KEYS_DEBOUNCE_INTERVAL	(3 * NBG460N_KEYS_POLL_INTERVAL)
+
+/* RTC chip PCF8563 I2C interface */
+#define NBG460N_GPIO_PCF8563_SDA	8
+#define NBG460N_GPIO_PCF8563_SCK	7
+
+/* Switch configuration I2C interface */
+#define NBG460N_GPIO_RTL8366_SDA	16
+#define NBG460N_GPIO_RTL8366_SCK	18
+
+static struct mtd_partition nbg460n_partitions[] = {
+	{
+		.name		= "Bootbase",
+		.offset		= 0,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "U-Boot Config",
+		.offset		= 0x010000,
+		.size		= 0x030000,
+	}, {
+		.name		= "U-Boot",
+		.offset		= 0x040000,
+		.size		= 0x030000,
+	}, {
+		.name		= "linux",
+		.offset		= 0x070000,
+		.size		= 0x0e0000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x150000,
+		.size		= 0x2a0000,
+	}, {
+		.name		= "CalibData",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x070000,
+		.size		= 0x380000,
+	}
+};
+
+static struct flash_platform_data nbg460n_flash_data = {
+	.parts		= nbg460n_partitions,
+	.nr_parts       = ARRAY_SIZE(nbg460n_partitions),
+};
+
+static struct gpio_led nbg460n_leds_gpio[] __initdata = {
+	{
+		.name		= "nbg460n:green:power",
+		.gpio		= NBG460N_GPIO_LED_POWER,
+		.active_low	= 0,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "nbg460n:green:wps",
+		.gpio		= NBG460N_GPIO_LED_WPS,
+		.active_low	= 0,
+	}, {
+		.name		= "nbg460n:green:wlan",
+		.gpio		= NBG460N_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}, {
+		/* Not really for controlling the LED,
+		   when set low the LED blinks uncontrollable  */
+		.name		= "nbg460n:green:wan",
+		.gpio		= NBG460N_GPIO_LED_WAN,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button nbg460n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = NBG460N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG460N_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data nbg460n_i2c_device_platdata = {
+	.sda_pin	= NBG460N_GPIO_PCF8563_SDA,
+	.scl_pin	= NBG460N_GPIO_PCF8563_SCK,
+	.udelay		= 10,
+};
+
+static struct platform_device nbg460n_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= -1,
+	.num_resources	= 0,
+	.resource	= NULL,
+	.dev		= {
+		.platform_data	= &nbg460n_i2c_device_platdata,
+	},
+};
+
+static struct i2c_board_info nbg460n_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf8563", 0x51),
+	},
+};
+
+static void nbg460n_i2c_init(void)
+{
+	/* The gpio interface */
+	platform_device_register(&nbg460n_i2c_device);
+	/* I2C devices */
+	i2c_register_board_info(0, nbg460n_i2c_devs,
+				ARRAY_SIZE(nbg460n_i2c_devs));
+}
+
+
+static struct rtl8366_platform_data nbg460n_rtl8366s_data = {
+	.gpio_sda	= NBG460N_GPIO_RTL8366_SDA,
+	.gpio_sck	= NBG460N_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device nbg460n_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &nbg460n_rtl8366s_data,
+	}
+};
+
+static void __init nbg460n_setup(void)
+{
+	/* end of bootloader sector contains mac address */
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fc0fff8);
+	/* last sector contains wlan calib data */
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* LAN Port */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	/* WAN Port */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	ath79_eth1_data.mii_bus_dev = &nbg460n_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	/* register the switch phy */
+	platform_device_register(&nbg460n_rtl8366s_device);
+
+	/* register flash */
+	ath79_register_m25p80(&nbg460n_flash_data);
+
+	ath79_register_wmac(eeprom, mac);
+
+	/* register RTC chip */
+	nbg460n_i2c_init();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(nbg460n_leds_gpio),
+				 nbg460n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, NBG460N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(nbg460n_gpio_keys),
+					nbg460n_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_NBG460N, "NBG460N", "Zyxel NBG460N/550N/550NH",
+	     nbg460n_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-nbg6716.c linux-4.1.13/arch/mips/ath79/mach-nbg6716.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-nbg6716.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-nbg6716.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,381 @@
+/*
+ * ZyXEL NBG6716/NBG6616 board support
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2013 Andre Valentin <avalentin@marcant.net>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define NBG6716_GPIO_LED_INTERNET	18
+#define NBG6716_GPIO_LED_POWER		15
+#define NBG6716_GPIO_LED_USB1		4
+#define NBG6716_GPIO_LED_USB2		13
+#define NBG6716_GPIO_LED_WIFI2G		19
+#define NBG6716_GPIO_LED_WIFI5G		17
+#define NBG6716_GPIO_LED_WPS		21
+
+#define NBG6716_GPIO_BTN_RESET		23
+#define NBG6716_GPIO_BTN_RFKILL		1
+#define NBG6716_GPIO_BTN_USB1		0
+#define NBG6716_GPIO_BTN_USB2		14
+#define NBG6716_GPIO_BTN_WPS		22
+
+#define NBG6716_GPIO_USB_POWER		16
+
+#define NBG6716_KEYS_POLL_INTERVAL	20	/* msecs */
+#define NBG6716_KEYS_DEBOUNCE_INTERVAL	(3 * NBG6716_KEYS_POLL_INTERVAL)
+
+#define NBG6716_MAC0_OFFSET		0
+#define NBG6716_MAC1_OFFSET		6
+#define NBG6716_WMAC_CALDATA_OFFSET	0x1000
+#define NBG6716_PCIE_CALDATA_OFFSET	0x5000
+
+/* NBG6616 has a different GPIO usage as it does not have USB Buttons */
+#define NBG6616_GPIO_LED_USB0		14
+#define NBG6616_GPIO_LED_USB1		21
+#define NBG6616_GPIO_LED_WPS		0
+
+static struct gpio_led nbg6716_leds_gpio[] __initdata = {
+	{
+		.name		= "nbg6716:white:internet",
+		.gpio		= NBG6716_GPIO_LED_INTERNET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:power",
+		.gpio		= NBG6716_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:usb1",
+		.gpio		= NBG6716_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:usb2",
+		.gpio		= NBG6716_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:wifi2g",
+		.gpio		= NBG6716_GPIO_LED_WIFI2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:wifi5g",
+		.gpio		= NBG6716_GPIO_LED_WIFI5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6716:white:wps",
+		.gpio		= NBG6716_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button nbg6716_gpio_keys[] __initdata = {
+	{
+		.desc		= "RESET button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_RFKILL,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "USB1 eject button",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_USB1,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "USB2 eject button",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_USB2,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+
+
+static struct gpio_led nbg6616_leds_gpio[] __initdata = {
+	{
+		.name		= "nbg6616:green:power",
+		.gpio		= NBG6716_GPIO_LED_POWER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:usb2",
+		.gpio		= NBG6616_GPIO_LED_USB0,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:usb1",
+		.gpio		= NBG6616_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:wifi2g",
+		.gpio		= NBG6716_GPIO_LED_WIFI2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:wifi5g",
+		.gpio		= NBG6716_GPIO_LED_WIFI5G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "nbg6616:green:wps",
+		.gpio		= NBG6616_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button nbg6616_gpio_keys[] __initdata = {
+	{
+		.desc		= "RESET button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = NBG6716_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= NBG6716_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+
+static struct ar8327_pad_cfg nbg6716_ar8327_pad0_cfg;
+static struct ar8327_pad_cfg nbg6716_ar8327_pad6_cfg;
+static struct ar8327_led_cfg nbg6716_ar8327_led_cfg;
+
+static struct ar8327_platform_data nbg6716_ar8327_data = {
+	.pad0_cfg = &nbg6716_ar8327_pad0_cfg,
+	.pad6_cfg = &nbg6716_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &nbg6716_ar8327_led_cfg
+};
+
+static struct mdio_board_info nbg6716_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &nbg6716_ar8327_data,
+	},
+};
+
+static void nbg6716_get_mac(void* nvram_addr, const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(nvram_addr);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, 0x10000,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init nbg6716_common_setup(u32 leds_num, struct gpio_led* leds,
+					u32 keys_num,
+					struct gpio_keys_button* keys,
+					void* art_addr, void* nvram)
+{
+	u8 *art = (u8 *) KSEG1ADDR(art_addr);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, leds_num, leds);
+	ath79_register_gpio_keys_polled(-1, NBG6716_KEYS_POLL_INTERVAL,
+					keys_num, keys);
+
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+
+	gpio_request_one(NBG6716_GPIO_USB_POWER,
+		GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+		"USB power");
+
+	ath79_register_usb();
+
+	nbg6716_get_mac(nvram, "ethaddr=", tmpmac);
+
+	ath79_register_pci();
+
+	ath79_register_wmac(art + NBG6716_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, tmpmac, 2);
+	ath79_init_mac(ath79_eth1_data.mac_addr, tmpmac, 3);
+
+	mdiobus_register_board_info(nbg6716_mdio0_info,
+				    ARRAY_SIZE(nbg6716_mdio0_info));
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+}
+
+static void __init nbg6716_010_setup(void)
+{
+	/* GMAC0 of the AR8337 switch is connected to GMAC0 via RGMII */
+	nbg6716_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_RGMII;
+	nbg6716_ar8327_pad0_cfg.txclk_delay_en = true;
+	nbg6716_ar8327_pad0_cfg.rxclk_delay_en = true;
+	nbg6716_ar8327_pad0_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
+	nbg6716_ar8327_pad0_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
+	nbg6716_ar8327_pad0_cfg.mac06_exchange_en = true;
+
+	/* GMAC6 of the AR8337 switch is connected to GMAC1 via SGMII */
+	nbg6716_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
+	nbg6716_ar8327_pad6_cfg.rxclk_delay_en = true;
+	nbg6716_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0;
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	nbg6716_ar8327_led_cfg.open_drain = 0;
+	nbg6716_ar8327_led_cfg.led_ctrl0 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl1 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl2 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl3 = 0x03ffff00;
+
+	nbg6716_common_setup(ARRAY_SIZE(nbg6716_leds_gpio), nbg6716_leds_gpio,
+			     ARRAY_SIZE(nbg6716_gpio_keys), nbg6716_gpio_keys,
+			     (void*) 0x1f050000, (void*) 0x1f040000);
+}
+
+static void __init nbg6616_010_setup(void)
+{
+	/* GMAC0 of the AR8337 switch is connected to GMAC0 via RGMII */
+	nbg6716_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_RGMII;
+	nbg6716_ar8327_pad0_cfg.txclk_delay_en = true;
+	nbg6716_ar8327_pad0_cfg.rxclk_delay_en = true;
+	nbg6716_ar8327_pad0_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
+	nbg6716_ar8327_pad0_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
+
+	/* GMAC6 of the AR8337 switch is connected to GMAC1 via SGMII */
+	nbg6716_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
+	nbg6716_ar8327_pad6_cfg.rxclk_delay_en = true;
+	nbg6716_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0;
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	nbg6716_ar8327_led_cfg.open_drain = 0;
+	nbg6716_ar8327_led_cfg.led_ctrl0 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl1 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl2 = 0xffb7ffb7;
+	nbg6716_ar8327_led_cfg.led_ctrl3 = 0x03ffff00;
+
+
+	nbg6716_common_setup(ARRAY_SIZE(nbg6616_leds_gpio), nbg6616_leds_gpio,
+			     ARRAY_SIZE(nbg6616_gpio_keys), nbg6616_gpio_keys,
+			     (void*) 0x1f040000, (void*) 0x1f030000);
+}
+
+
+MIPS_MACHINE(ATH79_MACH_NBG6716, "NBG6716",
+	     "Zyxel NBG6716",
+	     nbg6716_010_setup);
+
+MIPS_MACHINE(ATH79_MACH_NBG6616, "NBG6616",
+	     "Zyxel NBG6616",
+	     nbg6616_010_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-om2p.c linux-4.1.13/arch/mips/ath79/mach-om2p.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-om2p.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-om2p.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,225 @@
+/*
+ *  OpenMesh OM2P support
+ *
+ *  Copyright (C) 2011 Marek Lindner <marek@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define OM2P_GPIO_LED_POWER	0
+#define OM2P_GPIO_LED_GREEN	13
+#define OM2P_GPIO_LED_RED	14
+#define OM2P_GPIO_LED_YELLOW	15
+#define OM2P_GPIO_LED_LAN	16
+#define OM2P_GPIO_LED_WAN	17
+#define OM2P_GPIO_BTN_RESET	1
+
+#define OM2P_KEYS_POLL_INTERVAL		20	/* msecs */
+#define OM2P_KEYS_DEBOUNCE_INTERVAL	(3 * OM2P_KEYS_POLL_INTERVAL)
+
+#define OM2P_WAN_PHYMASK	BIT(4)
+
+#define OM2P_LC_GPIO_LED_POWER	1
+#define OM2P_LC_GPIO_LED_GREEN	15
+#define OM2P_LC_GPIO_LED_RED	16
+#define OM2P_LC_GPIO_LED_YELLOW	0
+#define OM2P_LC_GPIO_LED_LAN	13
+#define OM2P_LC_GPIO_LED_WAN	17
+#define OM2P_LC_GPIO_BTN_RESET	12
+
+static struct flash_platform_data om2p_flash_data = {
+	.type = "s25sl12800",
+	.name = "ar7240-nor0",
+};
+
+static struct gpio_led om2p_leds_gpio[] __initdata = {
+	{
+		.name		= "om2p:blue:power",
+		.gpio		= OM2P_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:red:wifi",
+		.gpio		= OM2P_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:yellow:wifi",
+		.gpio		= OM2P_GPIO_LED_YELLOW,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:green:wifi",
+		.gpio		= OM2P_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:lan",
+		.gpio		= OM2P_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "om2p:blue:wan",
+		.gpio		= OM2P_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button om2p_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OM2P_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OM2P_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init om2p_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *ee = (u8 *)KSEG1ADDR(0x1ffc1000);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(&om2p_flash_data);
+
+	ath79_register_mdio(0, ~OM2P_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om2p_leds_gpio),
+				 om2p_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om2p_gpio_keys),
+					om2p_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM2P, "OM2P", "OpenMesh OM2P", om2p_setup);
+
+
+static struct flash_platform_data om2p_lc_flash_data = {
+	.type = "s25sl12800",
+};
+
+static void __init om2p_lc_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *art = (u8 *)KSEG1ADDR(0x1ffc1000);
+	u32 t;
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	ath79_register_m25p80(&om2p_lc_flash_data);
+
+	om2p_leds_gpio[0].gpio = OM2P_LC_GPIO_LED_POWER;
+	om2p_leds_gpio[1].gpio = OM2P_LC_GPIO_LED_RED;
+	om2p_leds_gpio[2].gpio = OM2P_LC_GPIO_LED_YELLOW;
+	om2p_leds_gpio[3].gpio = OM2P_LC_GPIO_LED_GREEN;
+	om2p_leds_gpio[4].gpio = OM2P_LC_GPIO_LED_LAN;
+	om2p_leds_gpio[5].gpio = OM2P_LC_GPIO_LED_WAN;
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om2p_leds_gpio),
+				 om2p_leds_gpio);
+
+	om2p_gpio_keys[0].gpio = OM2P_LC_GPIO_BTN_RESET;
+	ath79_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om2p_gpio_keys),
+					om2p_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM2P_LC, "OM2P-LC", "OpenMesh OM2P LC", om2p_lc_setup);
+MIPS_MACHINE(ATH79_MACH_OM2Pv2, "OM2Pv2", "OpenMesh OM2Pv2", om2p_lc_setup);
+
+static void __init om2p_hs_setup(void)
+{
+	u8 *mac1 = (u8 *)KSEG1ADDR(0x1ffc0000);
+	u8 *mac2 = (u8 *)KSEG1ADDR(0x1ffc0000 + ETH_ALEN);
+	u8 *art = (u8 *)KSEG1ADDR(0x1ffc1000);
+
+	/* make lan / wan leds software controllable */
+	ath79_gpio_output_select(OM2P_GPIO_LED_LAN, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(OM2P_GPIO_LED_WAN, AR934X_GPIO_OUT_GPIO);
+
+	/* enable reset button */
+	ath79_gpio_output_select(OM2P_GPIO_BTN_RESET, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	om2p_leds_gpio[4].gpio = OM2P_GPIO_LED_WAN;
+	om2p_leds_gpio[5].gpio = OM2P_GPIO_LED_LAN;
+
+	ath79_register_m25p80(&om2p_lc_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om2p_leds_gpio),
+				 om2p_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, OM2P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om2p_gpio_keys),
+					om2p_gpio_keys);
+
+	ath79_register_wmac(art, NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM2P_HS, "OM2P-HS", "OpenMesh OM2P HS", om2p_hs_setup);
+MIPS_MACHINE(ATH79_MACH_OM2P_HSv2, "OM2P-HSv2", "OpenMesh OM2P HSv2", om2p_hs_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-om5p.c linux-4.1.13/arch/mips/ath79/mach-om5p.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-om5p.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-om5p.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,218 @@
+/*
+ *  OpenMesh OM5P support
+ *
+ *  Copyright (C) 2013 Marek Lindner <marek@open-mesh.com>
+ *  Copyright (C) 2014 Sven Eckelmann <sven@open-mesh.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define OM5P_GPIO_LED_POWER	13
+#define OM5P_GPIO_LED_GREEN	16
+#define OM5P_GPIO_LED_RED	19
+#define OM5P_GPIO_LED_YELLOW	17
+#define OM5P_GPIO_LED_LAN	14
+#define OM5P_GPIO_LED_WAN	15
+#define OM5P_GPIO_BTN_RESET	4
+#define OM5P_GPIO_I2C_SCL	20
+#define OM5P_GPIO_I2C_SDA	21
+
+#define OM5P_KEYS_POLL_INTERVAL		20	/* msecs */
+#define OM5P_KEYS_DEBOUNCE_INTERVAL	(3 * OM5P_KEYS_POLL_INTERVAL)
+
+#define OM5P_WMAC_CALDATA_OFFSET	0x1000
+#define OM5P_PCI_CALDATA_OFFSET		0x5000
+
+static struct gpio_led om5p_leds_gpio[] __initdata = {
+	{
+		.name		= "om5p:blue:power",
+		.gpio		= OM5P_GPIO_LED_POWER,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:red:wifi",
+		.gpio		= OM5P_GPIO_LED_RED,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:yellow:wifi",
+		.gpio		= OM5P_GPIO_LED_YELLOW,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:green:wifi",
+		.gpio		= OM5P_GPIO_LED_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:blue:lan",
+		.gpio		= OM5P_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "om5p:blue:wan",
+		.gpio		= OM5P_GPIO_LED_WAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button om5p_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = OM5P_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= OM5P_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct flash_platform_data om5p_flash_data = {
+	.type = "mx25l12805d",
+};
+
+static void __init om5p_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	/* make lan / wan leds software controllable */
+	ath79_gpio_output_select(OM5P_GPIO_LED_LAN, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(OM5P_GPIO_LED_WAN, AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(&om5p_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om5p_leds_gpio),
+				 om5p_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, OM5P_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(om5p_gpio_keys),
+					om5p_gpio_keys);
+
+	ath79_init_mac(mac, art, 2);
+	ath79_register_wmac(art + OM5P_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 1);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM5P, "OM5P", "OpenMesh OM5P", om5p_setup);
+
+static struct i2c_gpio_platform_data om5pan_i2c_device_platdata = {
+	.sda_pin		= OM5P_GPIO_I2C_SDA,
+	.scl_pin		= OM5P_GPIO_I2C_SCL,
+	.udelay			= 10,
+	.sda_is_open_drain	= 1,
+	.scl_is_open_drain	= 1,
+};
+
+static struct platform_device om5pan_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &om5pan_i2c_device_platdata,
+	},
+};
+
+static struct i2c_board_info om5pan_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("tmp423", 0x4c),
+	},
+};
+
+static struct at803x_platform_data om5p_an_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info om5p_an_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 7,
+		.platform_data = &om5p_an_at803x_data,
+	},
+};
+
+static void __init om5p_an_setup(void)
+{
+	u8 *art = (u8 *)KSEG1ADDR(0x1fff0000);
+	u8 mac[6];
+
+	/* temperature sensor */
+	platform_device_register(&om5pan_i2c_device);
+	i2c_register_board_info(0, om5pan_i2c_devs,
+				ARRAY_SIZE(om5pan_i2c_devs));
+
+	/* make lan / wan leds software controllable */
+	ath79_gpio_output_select(OM5P_GPIO_LED_LAN, AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(OM5P_GPIO_LED_WAN, AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(&om5p_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(om5p_leds_gpio),
+				 om5p_leds_gpio);
+
+	ath79_init_mac(mac, art, 0x02);
+	ath79_register_wmac(art + OM5P_WMAC_CALDATA_OFFSET, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+	ath79_setup_ar934x_eth_rx_delay(2, 2);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_mdio(1, 0x0);
+
+	mdiobus_register_board_info(om5p_an_mdio0_info,
+				    ARRAY_SIZE(om5p_an_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art, 0x00);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art, 0x01);
+
+	/* GMAC0 is connected to the PHY7 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(7);
+	ath79_eth0_pll_data.pll_1000 = 0x02000000;
+	ath79_eth0_pll_data.pll_100 = 0x00000101;
+	ath79_eth0_pll_data.pll_10 = 0x00001313;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(1);
+
+	ath79_init_mac(mac, art, 0x10);
+	ap91_pci_init(art + OM5P_PCI_CALDATA_OFFSET, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_OM5P_AN, "OM5P-AN", "OpenMesh OM5P AN", om5p_an_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-onion-omega.c linux-4.1.13/arch/mips/ath79/mach-onion-omega.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-onion-omega.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-onion-omega.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,84 @@
+/*
+ *  Onion Omega board support
+ *
+ *  Copyright (C) 2015 Boken Lin <bl@onion.io>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define OMEGA_GPIO_LED_SYSTEM	27
+#define OMEGA_GPIO_BTN_RESET	11
+
+#define OMEGA_GPIO_USB_POWER	8
+
+#define OMEGA_KEYS_POLL_INTERVAL	20  /* msecs */
+#define OMEGA_KEYS_DEBOUNCE_INTERVAL	(3 * OMEGA_KEYS_POLL_INTERVAL)
+
+static const char *omega_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data omega_flash_data = {
+	.part_probes    = omega_part_probes,
+};
+
+static struct gpio_led omega_leds_gpio[] __initdata = {
+	{
+		.name       = "onion:amber:system",
+		.gpio       = OMEGA_GPIO_LED_SYSTEM,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_keys_button omega_gpio_keys[] __initdata = {
+	{
+		.desc       = "reset",
+		.type       = EV_KEY,
+		.code       = KEY_RESTART,
+		.debounce_interval = OMEGA_KEYS_DEBOUNCE_INTERVAL,
+		.gpio       = OMEGA_GPIO_BTN_RESET,
+		.active_low = 0,
+	}
+};
+
+static void __init onion_omega_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&omega_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(omega_leds_gpio),
+				omega_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, OMEGA_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(omega_gpio_keys),
+					omega_gpio_keys);
+
+	gpio_request_one(OMEGA_GPIO_USB_POWER,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_ONION_OMEGA, "ONION-OMEGA", "Onion Omega", onion_omega_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-pb42.c linux-4.1.13/arch/mips/ath79/mach-pb42.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-pb42.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-pb42.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,83 @@
+/*
+ *  Atheros PB42 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define PB42_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB42_KEYS_DEBOUNCE_INTERVAL	(3 * PB42_KEYS_POLL_INTERVAL)
+
+#define PB42_GPIO_BTN_SW4	8
+#define PB42_GPIO_BTN_SW5	3
+
+static struct gpio_keys_button pb42_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB42_GPIO_BTN_SW4,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw5",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = PB42_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB42_GPIO_BTN_SW5,
+		.active_low	= 1,
+	}
+};
+
+static const char *pb42_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data pb42_flash_data = {
+	.part_probes	= pb42_part_probes,
+};
+
+#define PB42_WAN_PHYMASK	BIT(20)
+#define PB42_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
+#define PB42_MDIO_PHYMASK	(PB42_LAN_PHYMASK | PB42_WAN_PHYMASK)
+
+static void __init pb42_init(void)
+{
+	ath79_register_m25p80(&pb42_flash_data);
+
+	ath79_register_mdio(0, ~PB42_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = PB42_WAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_gpio_keys_polled(-1, PB42_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(pb42_gpio_keys),
+					pb42_gpio_keys);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_PB42, "PB42", "Atheros PB42", pb42_init);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-pb44.c linux-4.1.13/arch/mips/ath79/mach-pb44.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-pb44.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-pb44.c	2015-12-04 19:57:04.334081334 +0100
@@ -8,23 +8,48 @@
  *  by the Free Software Foundation.
  */
 
+#include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/i2c.h>
 #include <linux/i2c-gpio.h>
 #include <linux/i2c/pcf857x.h>
+#include <linux/i2c/pcf857x.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/vsc7385.h>
 
-#include "machtypes.h"
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
 #include "dev-spi.h"
 #include "dev-usb.h"
+#include "machtypes.h"
 #include "pci.h"
 
 #define PB44_GPIO_I2C_SCL	0
 #define PB44_GPIO_I2C_SDA	1
 
+#define PB44_PCF8757_VSC7395_CS	0
+#define PB44_PCF8757_STEREO_CS	1
+#define PB44_PCF8757_SLIC_CS0	2
+#define PB44_PCF8757_SLIC_TEST	3
+#define PB44_PCF8757_SLIC_INT0	4
+#define PB44_PCF8757_SLIC_INT1	5
+#define PB44_PCF8757_SW_RESET	6
+#define PB44_PCF8757_SW_JUMP	8
+#define PB44_PCF8757_LED_JUMP1	9
+#define PB44_PCF8757_LED_JUMP2	10
+#define PB44_PCF8757_TP24	11
+#define PB44_PCF8757_TP25	12
+#define PB44_PCF8757_TP26	13
+#define PB44_PCF8757_TP27	14
+#define PB44_PCF8757_TP28	15
+
 #define PB44_GPIO_EXP_BASE	16
+#define PB44_GPIO_VSC7395_CS	(PB44_GPIO_EXP_BASE + PB44_PCF8757_VSC7395_CS)
 #define PB44_GPIO_SW_RESET	(PB44_GPIO_EXP_BASE + 6)
 #define PB44_GPIO_SW_JUMP	(PB44_GPIO_EXP_BASE + 8)
 #define PB44_GPIO_LED_JUMP1	(PB44_GPIO_EXP_BASE + 9)
@@ -87,20 +112,71 @@
 	}
 };
 
+static struct ath79_spi_controller_data pb44_spi0_data = {
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 0,
+};
+
+static struct ath79_spi_controller_data pb44_spi1_data = {
+	.cs_type = ATH79_SPI_CS_TYPE_GPIO,
+	.cs_line = PB44_GPIO_VSC7395_CS,
+};
+
+static void pb44_vsc7395_reset(void)
+{
+	ath79_device_reset_set(AR71XX_RESET_GE1_PHY);
+	udelay(10);
+	ath79_device_reset_clear(AR71XX_RESET_GE1_PHY);
+	mdelay(50);
+}
+
+static struct vsc7385_platform_data pb44_vsc7395_data = {
+	.reset		= pb44_vsc7395_reset,
+	.ucode_name	= "vsc7395_ucode_pb44.bin",
+	.mac_cfg = {
+		.tx_ipg		= 6,
+		.bit2		= 1,
+		.clk_sel	= 0,
+	},
+};
+
+static const char *pb44_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data pb44_flash_data = {
+	.part_probes	= pb44_part_probes,
+};
+
 static struct spi_board_info pb44_spi_info[] = {
 	{
 		.bus_num	= 0,
 		.chip_select	= 0,
 		.max_speed_hz	= 25000000,
 		.modalias	= "m25p64",
+		.platform_data	= &pb44_flash_data,
+		.controller_data = &pb44_spi0_data,
 	},
+	{
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-vsc7385",
+		.platform_data	= &pb44_vsc7395_data,
+		.controller_data = &pb44_spi1_data,
+	}
 };
 
 static struct ath79_spi_platform_data pb44_spi_data = {
 	.bus_num		= 0,
-	.num_chipselect		= 1,
+	.num_chipselect		= 2,
 };
 
+#define PB44_WAN_PHYMASK	BIT(0)
+#define PB44_LAN_PHYMASK	0
+#define PB44_MDIO_PHYMASK	(PB44_LAN_PHYMASK | PB44_WAN_PHYMASK)
+
 static void __init pb44_init(void)
 {
 	i2c_register_board_info(0, pb44_i2c_board_info,
@@ -116,6 +192,22 @@
 			   ARRAY_SIZE(pb44_spi_info));
 	ath79_register_usb();
 	ath79_register_pci();
+
+	ath79_register_mdio(0, ~PB44_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = PB44_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x110000;
+
+	ath79_register_eth(1);
 }
 
 MIPS_MACHINE(ATH79_MACH_PB44, "PB44", "Atheros PB44 reference board",
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-pb92.c linux-4.1.13/arch/mips/ath79/mach-pb92.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-pb92.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-pb92.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,70 @@
+/*
+ *  Atheros PB92 board support
+ *
+ *  Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define PB92_KEYS_POLL_INTERVAL		20	/* msecs */
+#define PB92_KEYS_DEBOUNCE_INTERVAL	(3 * PB92_KEYS_POLL_INTERVAL)
+
+#define PB92_GPIO_BTN_SW4	8
+#define PB92_GPIO_BTN_SW5	3
+
+static struct gpio_keys_button pb92_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = PB92_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB92_GPIO_BTN_SW4,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw5",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = PB92_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= PB92_GPIO_BTN_SW5,
+		.active_low	= 1,
+	}
+};
+
+static void __init pb92_init(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~BIT(0));
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	ath79_register_gpio_keys_polled(-1, PB92_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(pb92_gpio_keys),
+					 pb92_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_PB92, "PB92", "Atheros PB92", pb92_init);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-qihoo-c301.c linux-4.1.13/arch/mips/ath79/mach-qihoo-c301.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-qihoo-c301.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-qihoo-c301.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,166 @@
+/*
+ *  Qihoo 360 C301 board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Weijie Gao <hackpascal@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define QIHOO_C301_GPIO_LED_STATUS_GREEN	0
+#define QIHOO_C301_GPIO_LED_STATUS_RED		11
+
+#define QIHOO_C301_GPIO_LED_WAN			1
+#define QIHOO_C301_GPIO_LED_LAN1		2
+#define QIHOO_C301_GPIO_LED_LAN2		3
+#define QIHOO_C301_GPIO_ETH_LEN_EN		18
+
+#define QIHOO_C301_GPIO_BTN_RESET		16
+
+#define QIHOO_C301_GPIO_USB_POWER		19
+
+#define QIHOO_C301_GPIO_SPI_CS1			12
+
+#define QIHOO_C301_GPIO_EXTERNAL_LNA0		14
+#define QIHOO_C301_GPIO_EXTERNAL_LNA1		15
+
+#define QIHOO_C301_KEYS_POLL_INTERVAL		20	/* msecs */
+#define QIHOO_C301_KEYS_DEBOUNCE_INTERVAL	\
+	(3 * QIHOO_C301_KEYS_POLL_INTERVAL)
+
+#define QIHOO_C301_WMAC_CALDATA_OFFSET		0x1000
+
+#define QIHOO_C301_NVRAM_ADDR			0x1f058010
+#define QIHOO_C301_NVRAM_SIZE			0x7ff0
+
+static struct gpio_led qihoo_c301_leds_gpio[] __initdata = {
+	{
+		.name		= "qihoo:green:status",
+		.gpio		= QIHOO_C301_GPIO_LED_STATUS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "qihoo:red:status",
+		.gpio		= QIHOO_C301_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button qihoo_c301_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = QIHOO_C301_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= QIHOO_C301_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct flash_platform_data flash __initdata = {NULL, NULL, 0};
+
+static void qihoo_c301_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(QIHOO_C301_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, QIHOO_C301_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init qihoo_c301_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80_multi(&flash);
+
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_gpio_output_select(QIHOO_C301_GPIO_LED_WAN,
+				 AR934X_GPIO_OUT_LED_LINK4);
+	ath79_gpio_output_select(QIHOO_C301_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_LED_LINK1);
+	ath79_gpio_output_select(QIHOO_C301_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_LED_LINK2);
+
+	ath79_gpio_output_select(QIHOO_C301_GPIO_SPI_CS1,
+				 AR934X_GPIO_OUT_SPI_CS1);
+
+	gpio_request_one(QIHOO_C301_GPIO_ETH_LEN_EN,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "Ethernet LED enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(qihoo_c301_leds_gpio),
+				 qihoo_c301_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, QIHOO_C301_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(qihoo_c301_gpio_keys),
+					qihoo_c301_gpio_keys);
+
+	ath79_wmac_set_ext_lna_gpio(0, QIHOO_C301_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, QIHOO_C301_GPIO_EXTERNAL_LNA1);
+
+	qihoo_c301_get_mac("wlan24mac=", tmpmac);
+	ath79_register_wmac(art + QIHOO_C301_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_register_pci();
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE |
+				   AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	qihoo_c301_get_mac("lanmac=", ath79_eth1_data.mac_addr);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	qihoo_c301_get_mac("wanmac=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	gpio_request_one(QIHOO_C301_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_QIHOO_C301, "QIHOO-C301", "Qihoo 360 C301",
+	     qihoo_c301_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-r6100.c linux-4.1.13/arch/mips/ath79/mach-r6100.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-r6100.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-r6100.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,146 @@
+/*
+ *  NETGEAR R6100 board support
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define R6100_GPIO_LED_WLAN		0
+#define R6100_GPIO_LED_USB		11
+#define R6100_GPIO_LED_WAN_GREEN	13
+#define R6100_GPIO_LED_POWER_AMBER	14
+#define R6100_GPIO_LED_WAN_AMBER	15
+#define R6100_GPIO_LED_POWER_GREEN	17
+
+#define R6100_GPIO_BTN_WIRELESS		1
+#define R6100_GPIO_BTN_WPS		3
+#define R6100_GPIO_BTN_RESET		12
+
+#define R6100_GPIO_USB_POWER		16
+
+#define R6100_KEYS_POLL_INTERVAL	20	/* msecs */
+#define R6100_KEYS_DEBOUNCE_INTERVAL	(3 * R6100_KEYS_POLL_INTERVAL)
+
+static struct gpio_led r6100_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= R6100_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:power",
+		.gpio		= R6100_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wan",
+		.gpio		= R6100_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:wan",
+		.gpio		= R6100_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:blue:usb",
+		.gpio		= R6100_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:blue:wlan",
+		.gpio		= R6100_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button r6100_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = R6100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= R6100_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = R6100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= R6100_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = R6100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= R6100_GPIO_BTN_WIRELESS,
+		.active_low	= 0,
+	},
+};
+
+static void __init r6100_setup(void)
+{
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(r6100_leds_gpio),
+				 r6100_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, R6100_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(r6100_gpio_keys),
+					r6100_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	gpio_request_one(R6100_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+
+	ath79_register_usb();
+
+	ath79_register_wmac_simple();
+
+	ap91_pci_init_simple();
+}
+
+MIPS_MACHINE(ATH79_MACH_R6100, "R6100", "NETGEAR R6100",
+	     r6100_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-rb2011.c linux-4.1.13/arch/mips/ath79/mach-rb2011.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-rb2011.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-rb2011.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,338 @@
+/*
+ *  MikroTik RouterBOARD 2011 support
+ *
+ *  Copyright (C) 2012 Stijn Tintel <stijn@linux-ipv6.be>
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "rb2011: " fmt
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+
+#include <asm/prom.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "routerboot.h"
+
+#define RB2011_GPIO_NAND_NCE	14
+#define RB2011_GPIO_SFP_LOS	21
+
+#define RB_ROUTERBOOT_OFFSET	0x0000
+#define RB_ROUTERBOOT_MIN_SIZE	0xb000
+#define RB_HARD_CFG_SIZE	0x1000
+#define RB_BIOS_OFFSET		0xd000
+#define RB_BIOS_SIZE		0x1000
+#define RB_SOFT_CFG_OFFSET	0xf000
+#define RB_SOFT_CFG_SIZE	0x1000
+
+#define RB_ART_SIZE		0x10000
+
+#define RB2011_FLAG_SFP		BIT(0)
+#define RB2011_FLAG_USB		BIT(1)
+#define RB2011_FLAG_WLAN	BIT(2)
+
+static struct mtd_partition rb2011_spi_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= RB_ROUTERBOOT_OFFSET,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.size		= RB_HARD_CFG_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= RB_BIOS_OFFSET,
+		.size		= RB_BIOS_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.size		= RB_SOFT_CFG_SIZE,
+	}
+};
+
+static void __init rb2011_init_partitions(const struct rb_info *info)
+{
+	rb2011_spi_partitions[0].size = info->hard_cfg_offs;
+	rb2011_spi_partitions[1].offset = info->hard_cfg_offs;
+	rb2011_spi_partitions[3].offset = info->soft_cfg_offs;
+}
+
+static struct mtd_partition rb2011_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct flash_platform_data rb2011_spi_flash_data = {
+	.parts		= rb2011_spi_partitions,
+	.nr_parts	= ARRAY_SIZE(rb2011_spi_partitions),
+};
+
+static struct ar8327_pad_cfg rb2011_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL3,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
+};
+
+static struct ar8327_pad_cfg rb2011_ar8327_pad6_cfg;
+static struct ar8327_sgmii_cfg rb2011_ar8327_sgmii_cfg;
+
+static struct ar8327_led_cfg rb2011_ar8327_led_cfg = {
+	.led_ctrl0 = 0xc731c731,
+	.led_ctrl1 = 0x00000000,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x0030c300,
+	.open_drain = false,
+};
+
+static const struct ar8327_led_info rb2011_ar8327_leds[] __initconst = {
+	AR8327_LED_INFO(PHY0_0, HW, "rb:green:eth1"),
+	AR8327_LED_INFO(PHY1_0, HW, "rb:green:eth2"),
+	AR8327_LED_INFO(PHY2_0, HW, "rb:green:eth3"),
+	AR8327_LED_INFO(PHY3_0, HW, "rb:green:eth4"),
+	AR8327_LED_INFO(PHY4_0, HW, "rb:green:eth5"),
+	AR8327_LED_INFO(PHY0_1, SW, "rb:green:eth6"),
+	AR8327_LED_INFO(PHY1_1, SW, "rb:green:eth7"),
+	AR8327_LED_INFO(PHY2_1, SW, "rb:green:eth8"),
+	AR8327_LED_INFO(PHY3_1, SW, "rb:green:eth9"),
+	AR8327_LED_INFO(PHY4_1, SW, "rb:green:eth10"),
+	AR8327_LED_INFO(PHY4_2, SW, "rb:green:usr"),
+};
+
+static struct ar8327_platform_data rb2011_ar8327_data = {
+	.pad0_cfg = &rb2011_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &rb2011_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(rb2011_ar8327_leds),
+	.leds = rb2011_ar8327_leds,
+};
+
+static struct mdio_board_info rb2011_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &rb2011_ar8327_data,
+	},
+};
+
+static void __init rb2011_wlan_init(void)
+{
+	char *art_buf;
+	u8 wlan_mac[ETH_ALEN];
+
+	art_buf = rb_get_wlan_data();
+	if (art_buf == NULL)
+		return;
+
+	ath79_init_mac(wlan_mac, ath79_mac_base, 11);
+	ath79_register_wmac(art_buf + 0x1000, wlan_mac);
+
+	kfree(art_buf);
+}
+
+static void rb2011_nand_select_chip(int chip_no)
+{
+	switch (chip_no) {
+	case 0:
+		gpio_set_value(RB2011_GPIO_NAND_NCE, 0);
+		break;
+	default:
+		gpio_set_value(RB2011_GPIO_NAND_NCE, 1);
+		break;
+	}
+	ndelay(500);
+}
+
+static struct nand_ecclayout rb2011_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static int rb2011_nand_scan_fixup(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	if (mtd->writesize == 512) {
+		/*
+		 * Use the OLD Yaffs-1 OOB layout, otherwise RouterBoot
+		 * will not be able to find the kernel that we load.
+		 */
+		chip->ecc.layout = &rb2011_nand_ecclayout;
+	}
+
+	return 0;
+}
+
+static void __init rb2011_nand_init(void)
+{
+	gpio_request_one(RB2011_GPIO_NAND_NCE, GPIOF_OUT_INIT_HIGH, "NAND nCE");
+
+	ath79_nfc_set_scan_fixup(rb2011_nand_scan_fixup);
+	ath79_nfc_set_parts(rb2011_nand_partitions,
+			    ARRAY_SIZE(rb2011_nand_partitions));
+	ath79_nfc_set_select_chip(rb2011_nand_select_chip);
+	ath79_nfc_set_swap_dma(true);
+	ath79_register_nfc();
+}
+
+static int rb2011_get_port_link(unsigned port)
+{
+	if (port != 6)
+		return -EINVAL;
+
+	/* The Loss of signal line is active low */
+	return !gpio_get_value(RB2011_GPIO_SFP_LOS);
+}
+
+static void __init rb2011_sfp_init(void)
+{
+	gpio_request_one(RB2011_GPIO_SFP_LOS, GPIOF_IN, "SFP LOS");
+
+	rb2011_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
+
+	rb2011_ar8327_data.pad6_cfg = &rb2011_ar8327_pad6_cfg;
+
+	rb2011_ar8327_sgmii_cfg.sgmii_ctrl = 0xc70167d0;
+	rb2011_ar8327_sgmii_cfg.serdes_aen = true;
+
+	rb2011_ar8327_data.sgmii_cfg = &rb2011_ar8327_sgmii_cfg;
+
+	rb2011_ar8327_data.port6_cfg.force_link = 1;
+	rb2011_ar8327_data.port6_cfg.speed = AR8327_PORT_SPEED_1000;
+	rb2011_ar8327_data.port6_cfg.duplex = 1;
+
+	rb2011_ar8327_data.get_port_link = rb2011_get_port_link;
+}
+
+static int __init rb2011_setup(u32 flags)
+{
+	const struct rb_info *info;
+	char buf[64];
+
+	info = rb_init_info((void *) KSEG1ADDR(0x1f000000), 0x10000);
+	if (!info)
+		return -ENODEV;
+
+	scnprintf(buf, sizeof(buf), "Mikrotik RouterBOARD %s",
+		  (info->board_name) ? info->board_name : "");
+	mips_set_machine_name(buf);
+
+	rb2011_init_partitions(info);
+
+	ath79_register_m25p80(&rb2011_spi_flash_data);
+	rb2011_nand_init();
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(rb2011_mdio0_info,
+				    ARRAY_SIZE(rb2011_mdio0_info));
+
+	/* GMAC0 is connected to an ar8327 switch */
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 5);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+
+	if (flags & RB2011_FLAG_SFP)
+		rb2011_sfp_init();
+
+	if (flags & RB2011_FLAG_WLAN)
+		rb2011_wlan_init();
+
+	if (flags & RB2011_FLAG_USB)
+		ath79_register_usb();
+
+	return 0;
+}
+
+static void __init rb2011l_setup(void)
+{
+	rb2011_setup(0);
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_2011L, "2011L", rb2011l_setup);
+
+static void __init rb2011us_setup(void)
+{
+	rb2011_setup(RB2011_FLAG_SFP | RB2011_FLAG_USB);
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_2011US, "2011US", rb2011us_setup);
+
+static void __init rb2011r5_setup(void)
+{
+	rb2011_setup(RB2011_FLAG_SFP | RB2011_FLAG_USB | RB2011_FLAG_WLAN);
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_2011R5, "2011r5", rb2011r5_setup);
+
+static void __init rb2011g_setup(void)
+{
+	rb2011_setup(RB2011_FLAG_SFP |
+		     RB2011_FLAG_USB |
+		     RB2011_FLAG_WLAN);
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_2011G, "2011G", rb2011g_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-rb4xx.c linux-4.1.13/arch/mips/ath79/mach-rb4xx.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-rb4xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-rb4xx.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,465 @@
+/*
+ *  MikroTik RouterBOARD 4xx series support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mdio-gpio.h>
+#include <linux/mmc/host.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/mmc_spi.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/rb4xx_cpld.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define RB4XX_GPIO_USER_LED	4
+#define RB4XX_GPIO_RESET_SWITCH	7
+
+#define RB4XX_GPIO_CPLD_BASE	32
+#define RB4XX_GPIO_CPLD_LED1	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED1)
+#define RB4XX_GPIO_CPLD_LED2	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED2)
+#define RB4XX_GPIO_CPLD_LED3	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED3)
+#define RB4XX_GPIO_CPLD_LED4	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED4)
+#define RB4XX_GPIO_CPLD_LED5	(RB4XX_GPIO_CPLD_BASE + CPLD_GPIO_nLED5)
+
+#define RB4XX_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RB4XX_KEYS_DEBOUNCE_INTERVAL	(3 * RB4XX_KEYS_POLL_INTERVAL)
+
+static struct gpio_led rb4xx_leds_gpio[] __initdata = {
+	{
+		.name		= "rb4xx:yellow:user",
+		.gpio		= RB4XX_GPIO_USER_LED,
+		.active_low	= 0,
+	}, {
+		.name		= "rb4xx:green:led1",
+		.gpio		= RB4XX_GPIO_CPLD_LED1,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led2",
+		.gpio		= RB4XX_GPIO_CPLD_LED2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led3",
+		.gpio		= RB4XX_GPIO_CPLD_LED3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led4",
+		.gpio		= RB4XX_GPIO_CPLD_LED4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb4xx:green:led5",
+		.gpio		= RB4XX_GPIO_CPLD_LED5,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button rb4xx_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset_switch",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RB4XX_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RB4XX_GPIO_RESET_SWITCH,
+		.active_low	= 1,
+	}
+};
+
+static struct platform_device rb4xx_nand_device = {
+	.name	= "rb4xx-nand",
+	.id	= -1,
+};
+
+static struct ath79_pci_irq rb4xx_pci_irqs[] __initdata = {
+	{
+		.slot	= 17,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 18,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(0),
+	}, {
+		.slot	= 18,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(1),
+	}, {
+		.slot	= 19,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(1),
+	}, {
+		.slot	= 19,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 20,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 20,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(0),
+	}, {
+		.slot	= 21,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(0),
+	}, {
+		.slot	= 22,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(1),
+	}, {
+		.slot	= 22,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 23,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(2),
+	}, {
+		.slot	= 23,
+		.pin	= 2,
+		.irq	= ATH79_PCI_IRQ(0),
+	}
+};
+
+static struct mtd_partition rb4xx_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= 0,
+		.size		= 0x0b000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.offset		= 0x0b000,
+		.size		= 0x01000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= 0x0d000,
+		.size		= 0x02000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.offset		= 0x0f000,
+		.size		= 0x01000,
+	}
+};
+
+static struct flash_platform_data rb4xx_flash_data = {
+	.type		= "pm25lv512",
+	.parts		= rb4xx_partitions,
+	.nr_parts	= ARRAY_SIZE(rb4xx_partitions),
+};
+
+static struct rb4xx_cpld_platform_data rb4xx_cpld_data = {
+	.gpio_base	= RB4XX_GPIO_CPLD_BASE,
+};
+
+static struct mmc_spi_platform_data rb4xx_mmc_data = {
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+static struct spi_board_info rb4xx_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data	= &rb4xx_flash_data,
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 25000000,
+		.modalias	= "spi-rb4xx-cpld",
+		.platform_data	= &rb4xx_cpld_data,
+	}
+};
+
+static struct spi_board_info rb4xx_microsd_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 2,
+		.max_speed_hz	= 25000000,
+		.modalias	= "mmc_spi",
+		.platform_data	= &rb4xx_mmc_data,
+	}
+};
+
+
+static struct resource rb4xx_spi_resources[] = {
+	{
+		.start	= AR71XX_SPI_BASE,
+		.end	= AR71XX_SPI_BASE + AR71XX_SPI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device rb4xx_spi_device = {
+	.name		= "rb4xx-spi",
+	.id		= -1,
+	.resource	= rb4xx_spi_resources,
+	.num_resources	= ARRAY_SIZE(rb4xx_spi_resources),
+};
+
+static void __init rb4xx_generic_setup(void)
+{
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				   AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
+					rb4xx_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, RB4XX_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rb4xx_gpio_keys),
+					rb4xx_gpio_keys);
+
+	spi_register_board_info(rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+	platform_device_register(&rb4xx_spi_device);
+	platform_device_register(&rb4xx_nand_device);
+}
+
+static void __init rb411_setup(void)
+{
+	rb4xx_generic_setup();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ath79_register_mdio(0, 0xfffffffc);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = 0x00000003;
+
+	ath79_register_eth(0);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_411, "411", "MikroTik RouterBOARD 411/A/AH",
+	     rb411_setup);
+
+static void __init rb411u_setup(void)
+{
+	rb411_setup();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_411U, "411U", "MikroTik RouterBOARD 411U",
+	     rb411u_setup);
+
+#define RB433_LAN_PHYMASK	BIT(0)
+#define RB433_WAN_PHYMASK	BIT(4)
+#define RB433_MDIO_PHYMASK	(RB433_LAN_PHYMASK | RB433_WAN_PHYMASK)
+
+static void __init rb433_setup(void)
+{
+	rb4xx_generic_setup();
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ath79_register_mdio(0, ~RB433_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = RB433_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = RB433_WAN_PHYMASK;
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_433, "433", "MikroTik RouterBOARD 433/AH",
+	     rb433_setup);
+
+static void __init rb433u_setup(void)
+{
+	rb433_setup();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_433U, "433U", "MikroTik RouterBOARD 433UAH",
+	     rb433u_setup);
+
+static void __init rb435g_setup(void)
+{
+	rb4xx_generic_setup();
+
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	ath79_register_mdio(0, ~RB433_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = RB433_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = RB433_WAN_PHYMASK;
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_435G, "435G", "MikroTik RouterBOARD 435G",
+	     rb435g_setup);
+
+#define RB450_LAN_PHYMASK	BIT(0)
+#define RB450_WAN_PHYMASK	BIT(4)
+#define RB450_MDIO_PHYMASK	(RB450_LAN_PHYMASK | RB450_WAN_PHYMASK)
+
+static void __init rb450_generic_setup(int gige)
+{
+	rb4xx_generic_setup();
+	ath79_register_mdio(0, ~RB450_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth0_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = RB450_LAN_PHYMASK;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = (gige) ?
+		PHY_INTERFACE_MODE_RGMII : PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = RB450_WAN_PHYMASK;
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+}
+
+static void __init rb450_setup(void)
+{
+	rb450_generic_setup(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_450, "450", "MikroTik RouterBOARD 450",
+	     rb450_setup);
+
+static void __init rb450g_setup(void)
+{
+	rb450_generic_setup(1);
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_450G, "450G", "MikroTik RouterBOARD 450G",
+	     rb450g_setup);
+
+static void __init rb493_setup(void)
+{
+	rb4xx_generic_setup();
+
+	ath79_register_mdio(0, 0x3fffff00);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x00000001;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_493, "493", "MikroTik RouterBOARD 493/AH",
+	     rb493_setup);
+
+#define RB493G_GPIO_MDIO_MDC		7
+#define RB493G_GPIO_MDIO_DATA		8
+
+#define RB493G_MDIO_PHYMASK		BIT(0)
+
+static struct mdio_gpio_platform_data rb493g_mdio_data = {
+	.mdc		= RB493G_GPIO_MDIO_MDC,
+	.mdio		= RB493G_GPIO_MDIO_DATA,
+
+	.phy_mask	= ~RB493G_MDIO_PHYMASK,
+};
+
+static struct platform_device rb493g_mdio_device = {
+	.name 		= "mdio-gpio",
+	.id 		= -1,
+	.dev 		= {
+		.platform_data	= &rb493g_mdio_data,
+	},
+};
+
+static void __init rb493g_setup(void)
+{
+	ath79_gpio_function_enable(AR71XX_GPIO_FUNC_SPI_CS1_EN |
+				    AR71XX_GPIO_FUNC_SPI_CS2_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb4xx_leds_gpio),
+				    rb4xx_leds_gpio);
+
+	spi_register_board_info(rb4xx_spi_info, ARRAY_SIZE(rb4xx_spi_info));
+	spi_register_board_info(rb4xx_microsd_info,
+				ARRAY_SIZE(rb4xx_microsd_info));
+
+	platform_device_register(&rb4xx_spi_device);
+	platform_device_register(&rb4xx_nand_device);
+
+	ath79_register_mdio(0, ~RB493G_MDIO_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = RB493G_MDIO_PHYMASK;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.mii_bus_dev = &rb493g_mdio_device.dev;
+	ath79_eth1_data.phy_mask = RB493G_MDIO_PHYMASK;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	platform_device_register(&rb493g_mdio_device);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+
+	ath79_pci_set_irq_map(ARRAY_SIZE(rb4xx_pci_irqs), rb4xx_pci_irqs);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_493G, "493G", "MikroTik RouterBOARD 493G",
+	     rb493g_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-rb750.c linux-4.1.13/arch/mips/ath79/mach-rb750.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-rb750.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-rb750.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,346 @@
+/*
+ *  MikroTik RouterBOARD 750/750GL support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/export.h>
+#include <linux/pci.h>
+#include <linux/ath9k_platform.h>
+#include <linux/platform_device.h>
+#include <linux/phy.h>
+#include <linux/ar8216_platform.h>
+#include <linux/rle.h>
+#include <linux/routerboot.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/mach-rb750.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-usb.h"
+#include "dev-eth.h"
+#include "machtypes.h"
+#include "routerboot.h"
+
+static struct rb750_led_data rb750_leds[] = {
+	{
+		.name		= "rb750:green:act",
+		.mask		= RB750_LED_ACT,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port1",
+		.mask		= RB750_LED_PORT5,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port2",
+		.mask		= RB750_LED_PORT4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port3",
+		.mask		= RB750_LED_PORT3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port4",
+		.mask		= RB750_LED_PORT2,
+		.active_low	= 1,
+	}, {
+		.name		= "rb750:green:port5",
+		.mask		= RB750_LED_PORT1,
+		.active_low	= 1,
+	}
+};
+
+static struct rb750_led_data rb750gr3_leds[] = {
+	{
+		.name		= "rb750:green:act",
+		.mask		= RB7XX_LED_ACT,
+		.active_low	= 1,
+	},
+};
+
+static struct rb750_led_platform_data rb750_leds_data;
+static struct platform_device rb750_leds_device = {
+	.name	= "leds-rb750",
+	.dev	= {
+		.platform_data = &rb750_leds_data,
+	}
+};
+
+static struct rb7xx_nand_platform_data rb750_nand_data;
+static struct platform_device rb750_nand_device = {
+	.name	= "rb750-nand",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb750_nand_data,
+	}
+};
+
+static void rb750_latch_change(u32 mask_clr, u32 mask_set)
+{
+	static DEFINE_SPINLOCK(lock);
+	static u32 latch_set = RB750_LED_BITS | RB750_LVC573_LE;
+	static u32 latch_oe;
+	static u32 latch_clr;
+	unsigned long flags;
+	u32 t;
+
+	spin_lock_irqsave(&lock, flags);
+
+	if ((mask_clr & BIT(31)) != 0 &&
+	    (latch_set & RB750_LVC573_LE) == 0) {
+		goto unlock;
+	}
+
+	latch_set = (latch_set | mask_set) & ~mask_clr;
+	latch_clr = (latch_clr | mask_clr) & ~mask_set;
+
+	if (latch_oe == 0)
+		latch_oe = __raw_readl(ath79_gpio_base + AR71XX_GPIO_REG_OE);
+
+	if (likely(latch_set & RB750_LVC573_LE)) {
+		void __iomem *base = ath79_gpio_base;
+
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		t |= mask_clr | latch_oe | mask_set;
+
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+		__raw_writel(latch_clr, base + AR71XX_GPIO_REG_CLEAR);
+		__raw_writel(latch_set, base + AR71XX_GPIO_REG_SET);
+	} else if (mask_clr & RB750_LVC573_LE) {
+		void __iomem *base = ath79_gpio_base;
+
+		latch_oe = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(RB750_LVC573_LE, base + AR71XX_GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_CLEAR);
+	}
+
+unlock:
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+static void rb750_nand_enable_pins(void)
+{
+	rb750_latch_change(RB750_LVC573_LE, 0);
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_SPI_EN);
+}
+
+static void rb750_nand_disable_pins(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_SPI_EN,
+				  AR724X_GPIO_FUNC_JTAG_DISABLE);
+	rb750_latch_change(0, RB750_LVC573_LE);
+}
+
+static void __init rb750_setup(void)
+{
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	rb750_leds_data.num_leds = ARRAY_SIZE(rb750_leds);
+	rb750_leds_data.leds = rb750_leds;
+	rb750_leds_data.latch_change = rb750_latch_change;
+	platform_device_register(&rb750_leds_device);
+
+	rb750_nand_data.nce_line = RB750_NAND_NCE;
+	rb750_nand_data.enable_pins = rb750_nand_enable_pins;
+	rb750_nand_data.disable_pins = rb750_nand_disable_pins;
+	rb750_nand_data.latch_change = rb750_latch_change;
+	platform_device_register(&rb750_nand_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_750, "750i", "MikroTik RouterBOARD 750",
+	     rb750_setup);
+
+static struct ar8327_pad_cfg rb750gr3_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data rb750gr3_ar8327_data = {
+	.pad0_cfg = &rb750gr3_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	}
+};
+
+static struct mdio_board_info rb750g3_mdio_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &rb750gr3_ar8327_data,
+	},
+};
+
+static void rb750gr3_nand_enable_pins(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_JTAG_DISABLE,
+				  AR724X_GPIO_FUNC_SPI_EN |
+				  AR724X_GPIO_FUNC_SPI_CS_EN2);
+}
+
+static void rb750gr3_nand_disable_pins(void)
+{
+	ath79_gpio_function_setup(AR724X_GPIO_FUNC_SPI_EN |
+				  AR724X_GPIO_FUNC_SPI_CS_EN2,
+				  AR724X_GPIO_FUNC_JTAG_DISABLE);
+}
+
+static void rb750gr3_latch_change(u32 mask_clr, u32 mask_set)
+{
+	static DEFINE_SPINLOCK(lock);
+	static u32 latch_set = RB7XX_LED_ACT;
+	static u32 latch_clr;
+	void __iomem *base = ath79_gpio_base;
+	unsigned long flags;
+	u32 t;
+
+	spin_lock_irqsave(&lock, flags);
+
+	latch_set = (latch_set | mask_set) & ~mask_clr;
+	latch_clr = (latch_clr | mask_clr) & ~mask_set;
+
+	mask_set = latch_set & (RB7XX_USB_POWERON | RB7XX_MONITOR);
+	mask_clr = latch_clr & (RB7XX_USB_POWERON | RB7XX_MONITOR);
+
+	if ((latch_set ^ RB7XX_LED_ACT) & RB7XX_LED_ACT) {
+		/* enable output mode */
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		t |= RB7XX_LED_ACT;
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+
+		mask_clr |= RB7XX_LED_ACT;
+	} else {
+		/* disable output mode */
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		t &= ~RB7XX_LED_ACT;
+		__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+	}
+
+	__raw_writel(mask_set, base + AR71XX_GPIO_REG_SET);
+	__raw_writel(mask_clr, base + AR71XX_GPIO_REG_CLEAR);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+static void __init rb750gr3_setup(void)
+{
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(rb750g3_mdio_info,
+				    ARRAY_SIZE(rb750g3_mdio_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_pll_data.pll_1000 = 0x62000000;
+
+	ath79_register_eth(0);
+
+	rb750_leds_data.num_leds = ARRAY_SIZE(rb750gr3_leds);
+	rb750_leds_data.leds = rb750gr3_leds;
+	rb750_leds_data.latch_change = rb750gr3_latch_change;
+	platform_device_register(&rb750_leds_device);
+
+	rb750_nand_data.nce_line = RB7XX_NAND_NCE;
+	rb750_nand_data.enable_pins = rb750gr3_nand_enable_pins;
+	rb750_nand_data.disable_pins = rb750gr3_nand_disable_pins;
+	rb750_nand_data.latch_change = rb750gr3_latch_change;
+	platform_device_register(&rb750_nand_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_750G_R3, "750Gr3", "MikroTik RouterBOARD 750GL",
+	     rb750gr3_setup);
+
+#define RB751_HARDCONFIG	0x1f00b000
+#define RB751_HARDCONFIG_SIZE	0x1000
+
+static void __init rb751_wlan_setup(void)
+{
+	u8 *hardconfig = (u8 *) KSEG1ADDR(RB751_HARDCONFIG);
+	struct ath9k_platform_data *wmac_data;
+	u16 tag_len;
+	u8 *tag;
+	u16 mac_len;
+	u8 *mac;
+	int err;
+
+	wmac_data = ap9x_pci_get_wmac_data(0);
+	if (!wmac_data) {
+		pr_err("rb75x: unable to get address of wlan data\n");
+		return;
+	}
+
+	ap9x_pci_setup_wmac_led_pin(0, 9);
+
+	err = routerboot_find_tag(hardconfig, RB751_HARDCONFIG_SIZE,
+				  RB_ID_WLAN_DATA, &tag, &tag_len);
+	if (err) {
+		pr_err("rb75x: no calibration data found\n");
+		return;
+	}
+
+	err = rle_decode(tag, tag_len, (unsigned char *) wmac_data->eeprom_data,
+			 sizeof(wmac_data->eeprom_data), NULL, NULL);
+	if (err) {
+		pr_err("rb75x: unable to decode wlan eeprom data\n");
+		return;
+	}
+
+	err = routerboot_find_tag(hardconfig, RB751_HARDCONFIG_SIZE,
+                                 RB_ID_MAC_ADDRESS_PACK, &mac, &mac_len);
+	if (err) {
+		pr_err("rb75x: no mac address found\n");
+		return;
+	}
+
+	ap91_pci_init(NULL, mac);
+}
+
+static void __init rb751_setup(void)
+{
+	rb750_setup();
+	ath79_register_usb();
+	rb751_wlan_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_751, "751", "MikroTik RouterBOARD 751",
+	     rb751_setup);
+
+static void __init rb751g_setup(void)
+{
+	rb750gr3_setup();
+	ath79_register_usb();
+	rb751_wlan_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_751G, "751g", "MikroTik RouterBOARD 751G",
+	     rb751g_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-rb91x.c linux-4.1.13/arch/mips/ath79/mach-rb91x.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-rb91x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-rb91x.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,349 @@
+/*
+ *  MikroTik RouterBOARD 91X support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "rb91x: " fmt
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/74x164.h>
+#include <linux/spi/flash.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/gpio-latch.h>
+#include <linux/platform_data/rb91x_nand.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/prom.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ath79_spi_platform.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "routerboot.h"
+
+#define RB_ROUTERBOOT_OFFSET	0x0000
+#define RB_ROUTERBOOT_MIN_SIZE	0xb000
+#define RB_HARD_CFG_SIZE	0x1000
+#define RB_BIOS_OFFSET		0xd000
+#define RB_BIOS_SIZE		0x1000
+#define RB_SOFT_CFG_OFFSET	0xf000
+#define RB_SOFT_CFG_SIZE	0x1000
+
+#define RB91X_FLAG_USB		BIT(0)
+#define RB91X_FLAG_PCIE		BIT(1)
+
+#define RB91X_LATCH_GPIO_BASE	AR934X_GPIO_COUNT
+#define RB91X_LATCH_GPIO(_x)	(RB91X_LATCH_GPIO_BASE + (_x))
+
+#define RB91X_SSR_GPIO_BASE	(RB91X_LATCH_GPIO_BASE + AR934X_GPIO_COUNT)
+#define RB91X_SSR_GPIO(_x)	(RB91X_SSR_GPIO_BASE + (_x))
+
+#define RB91X_SSR_BIT_LED1		0
+#define RB91X_SSR_BIT_LED2		1
+#define RB91X_SSR_BIT_LED3		2
+#define RB91X_SSR_BIT_LED4		3
+#define RB91X_SSR_BIT_LED5		4
+#define RB91X_SSR_BIT_5			5
+#define RB91X_SSR_BIT_USB_POWER		6
+#define RB91X_SSR_BIT_PCIE_POWER	7
+
+#define RB91X_GPIO_SSR_STROBE	RB91X_LATCH_GPIO(0)
+#define RB91X_GPIO_LED_POWER	RB91X_LATCH_GPIO(1)
+#define RB91X_GPIO_LED_USER	RB91X_LATCH_GPIO(2)
+#define RB91X_GPIO_NAND_READ	RB91X_LATCH_GPIO(3)
+#define RB91X_GPIO_NAND_RDY	RB91X_LATCH_GPIO(4)
+#define RB91X_GPIO_NLE		RB91X_LATCH_GPIO(11)
+#define RB91X_GPIO_NAND_NRW	RB91X_LATCH_GPIO(12)
+#define RB91X_GPIO_NAND_NCE	RB91X_LATCH_GPIO(13)
+#define RB91X_GPIO_NAND_CLE	RB91X_LATCH_GPIO(14)
+#define RB91X_GPIO_NAND_ALE	RB91X_LATCH_GPIO(15)
+
+#define RB91X_GPIO_LED_1	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED1)
+#define RB91X_GPIO_LED_2	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED2)
+#define RB91X_GPIO_LED_3	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED3)
+#define RB91X_GPIO_LED_4	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED4)
+#define RB91X_GPIO_LED_5	RB91X_SSR_GPIO(RB91X_SSR_BIT_LED5)
+#define RB91X_GPIO_USB_POWER	RB91X_SSR_GPIO(RB91X_SSR_BIT_USB_POWER)
+#define RB91X_GPIO_PCIE_POWER	RB91X_SSR_GPIO(RB91X_SSR_BIT_PCIE_POWER)
+
+struct rb_board_info {
+	const char *name;
+	u32 flags;
+};
+
+static struct mtd_partition rb711gr100_spi_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= RB_ROUTERBOOT_OFFSET,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.size		= RB_HARD_CFG_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= RB_BIOS_OFFSET,
+		.size		= RB_BIOS_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.size		= RB_SOFT_CFG_SIZE,
+	}
+};
+
+static struct flash_platform_data rb711gr100_spi_flash_data = {
+	.parts		= rb711gr100_spi_partitions,
+	.nr_parts	= ARRAY_SIZE(rb711gr100_spi_partitions),
+};
+
+static int rb711gr100_gpio_latch_gpios[AR934X_GPIO_COUNT] __initdata = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
+	12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22
+};
+
+static struct gpio_latch_platform_data rb711gr100_gpio_latch_data __initdata = {
+	.base = RB91X_LATCH_GPIO_BASE,
+	.num_gpios = ARRAY_SIZE(rb711gr100_gpio_latch_gpios),
+	.gpios = rb711gr100_gpio_latch_gpios,
+	.le_gpio_index = 11,
+	.le_active_low = true,
+};
+
+static struct rb91x_nand_platform_data rb711gr100_nand_data __initdata = {
+	.gpio_nce = RB91X_GPIO_NAND_NCE,
+	.gpio_ale = RB91X_GPIO_NAND_ALE,
+	.gpio_cle = RB91X_GPIO_NAND_CLE,
+	.gpio_rdy = RB91X_GPIO_NAND_RDY,
+	.gpio_read = RB91X_GPIO_NAND_READ,
+	.gpio_nrw = RB91X_GPIO_NAND_NRW,
+	.gpio_nle = RB91X_GPIO_NLE,
+};
+
+static u8 rb711gr100_ssr_initdata[] __initdata = {
+	BIT(RB91X_SSR_BIT_PCIE_POWER) |
+	BIT(RB91X_SSR_BIT_USB_POWER) |
+	BIT(RB91X_SSR_BIT_5)
+};
+
+static struct gen_74x164_chip_platform_data rb711gr100_ssr_data = {
+	.base = RB91X_SSR_GPIO_BASE,
+	.num_registers = ARRAY_SIZE(rb711gr100_ssr_initdata),
+	.init_data = rb711gr100_ssr_initdata,
+};
+
+static struct ath79_spi_controller_data rb711gr100_spi0_cdata = {
+	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
+	.cs_line = 0,
+	.is_flash = true,
+};
+
+static struct ath79_spi_controller_data rb711gr100_spi1_cdata = {
+	.cs_type = ATH79_SPI_CS_TYPE_GPIO,
+	.cs_line = RB91X_GPIO_SSR_STROBE,
+};
+
+static struct spi_board_info rb711gr100_spi_info[] = {
+	{
+		.bus_num	= 0,
+		.chip_select	= 0,
+		.max_speed_hz	= 25000000,
+		.modalias	= "m25p80",
+		.platform_data  = &rb711gr100_spi_flash_data,
+		.controller_data = &rb711gr100_spi0_cdata
+	}, {
+		.bus_num	= 0,
+		.chip_select	= 1,
+		.max_speed_hz	= 10000000,
+		.modalias	= "74x164",
+		.platform_data	= &rb711gr100_ssr_data,
+		.controller_data = &rb711gr100_spi1_cdata
+	}
+};
+
+static struct ath79_spi_platform_data rb711gr100_spi_data __initdata = {
+	.bus_num = 0,
+	.num_chipselect = 2,
+};
+
+static struct gpio_led rb711gr100_leds[] __initdata = {
+	{
+		.name		= "rb:green:led1",
+		.gpio		= RB91X_GPIO_LED_1,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:led2",
+		.gpio		= RB91X_GPIO_LED_2,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:led3",
+		.gpio		= RB91X_GPIO_LED_3,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:led4",
+		.gpio		= RB91X_GPIO_LED_4,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:led5",
+		.gpio		= RB91X_GPIO_LED_5,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:user",
+		.gpio		= RB91X_GPIO_LED_USER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "rb:green:power",
+		.gpio		= RB91X_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+};
+
+static struct at803x_platform_data rb91x_at803x_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+
+static struct mdio_board_info rb91x_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &rb91x_at803x_data,
+	},
+};
+
+static void __init rb711gr100_init_partitions(const struct rb_info *info)
+{
+	rb711gr100_spi_partitions[0].size = info->hard_cfg_offs;
+	rb711gr100_spi_partitions[1].offset = info->hard_cfg_offs;
+
+	rb711gr100_spi_partitions[3].offset = info->soft_cfg_offs;
+}
+
+void __init rb711gr100_wlan_init(void)
+{
+	char *caldata;
+	u8 wlan_mac[ETH_ALEN];
+
+	caldata = rb_get_wlan_data();
+	if (caldata == NULL)
+		return;
+
+	ath79_init_mac(wlan_mac, ath79_mac_base, 1);
+	ath79_register_wmac(caldata + 0x1000, wlan_mac);
+
+	kfree(caldata);
+}
+
+#define RB_BOARD_INFO(_name, _flags)	\
+	{				\
+		.name = (_name),	\
+		.flags = (_flags),	\
+	}
+
+static const struct rb_board_info rb711gr100_boards[] __initconst = {
+	RB_BOARD_INFO("911G-2HPnD", 0),
+	RB_BOARD_INFO("911G-5HPnD", 0),
+	RB_BOARD_INFO("912UAG-2HPnD", RB91X_FLAG_USB | RB91X_FLAG_PCIE),
+	RB_BOARD_INFO("912UAG-5HPnD", RB91X_FLAG_USB | RB91X_FLAG_PCIE),
+};
+
+static u32 rb711gr100_get_flags(const struct rb_info *info)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rb711gr100_boards); i++) {
+		const struct rb_board_info *bi;
+
+		bi = &rb711gr100_boards[i];
+		if (strcmp(info->board_name, bi->name) == 0)
+			return bi->flags;
+	}
+
+	return 0;
+}
+
+static void __init rb711gr100_setup(void)
+{
+	const struct rb_info *info;
+	char buf[64];
+	u32 flags;
+
+	info = rb_init_info((void *) KSEG1ADDR(0x1f000000), 0x10000);
+	if (!info)
+		return;
+
+	scnprintf(buf, sizeof(buf), "Mikrotik RouterBOARD %s",
+		  (info->board_name) ? info->board_name : "");
+	mips_set_machine_name(buf);
+
+	rb711gr100_init_partitions(info);
+	ath79_register_spi(&rb711gr100_spi_data, rb711gr100_spi_info,
+			   ARRAY_SIZE(rb711gr100_spi_info));
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_RXD_DELAY |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(rb91x_mdio0_info,
+				    ARRAY_SIZE(rb91x_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_pll_data.pll_1000 = 0x02000000;
+
+	ath79_register_eth(0);
+
+	rb711gr100_wlan_init();
+
+	platform_device_register_data(NULL, "rb91x-nand", -1,
+				      &rb711gr100_nand_data,
+				      sizeof(rb711gr100_nand_data));
+
+	platform_device_register_data(NULL, "gpio-latch", -1,
+				      &rb711gr100_gpio_latch_data,
+				      sizeof(rb711gr100_gpio_latch_data));
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb711gr100_leds),
+				 rb711gr100_leds);
+
+	flags = rb711gr100_get_flags(info);
+
+	if (flags & RB91X_FLAG_USB)
+		ath79_register_usb();
+
+	if (flags & RB91X_FLAG_PCIE)
+		ath79_register_pci();
+
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_711GR100, "711Gr100", rb711gr100_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-rb922.c linux-4.1.13/arch/mips/ath79/mach-rb922.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-rb922.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-rb922.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,236 @@
+/*
+ *  MikroTik RouterBOARD 91X support
+ *
+ *  Copyright (C) 2015 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/phy-at803x.h>
+
+#include <asm/prom.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-spi.h"
+#include "machtypes.h"
+#include "pci.h"
+#include "routerboot.h"
+
+#define RB922_GPIO_LED_USR	12
+#define RB922_GPIO_USB_POWER	13
+#define RB922_GPIO_FAN_CTRL	14
+#define RB922_GPIO_BTN_RESET	20
+#define RB922_GPIO_NAND_NCE	23
+
+#define RB922_PHY_ADDR		4
+
+#define RB922_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RB922_KEYS_DEBOUNCE_INTERVAL	(3 * RB922_KEYS_POLL_INTERVAL)
+
+#define RB_ROUTERBOOT_OFFSET	0x0000
+#define RB_ROUTERBOOT_MIN_SIZE	0xb000
+#define RB_HARD_CFG_SIZE	0x1000
+#define RB_BIOS_OFFSET		0xd000
+#define RB_BIOS_SIZE		0x1000
+#define RB_SOFT_CFG_OFFSET	0xf000
+#define RB_SOFT_CFG_SIZE	0x1000
+
+static struct mtd_partition rb922gs_spi_partitions[] = {
+	{
+		.name		= "routerboot",
+		.offset		= RB_ROUTERBOOT_OFFSET,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "hard_config",
+		.size		= RB_HARD_CFG_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "bios",
+		.offset		= RB_BIOS_OFFSET,
+		.size		= RB_BIOS_SIZE,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "soft_config",
+		.size		= RB_SOFT_CFG_SIZE,
+	}
+};
+
+static struct flash_platform_data rb922gs_spi_flash_data = {
+	.parts		= rb922gs_spi_partitions,
+	.nr_parts	= ARRAY_SIZE(rb922gs_spi_partitions),
+};
+
+static struct gpio_led rb922gs_leds[] __initdata = {
+	{
+		.name		= "rb:green:user",
+		.gpio		= RB922_GPIO_LED_USR,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button rb922gs_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RB922_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RB922_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct at803x_platform_data rb922gs_at803x_data = {
+	.disable_smarteee = 1,
+};
+
+static struct mdio_board_info rb922gs_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = RB922_PHY_ADDR,
+		.platform_data = &rb922gs_at803x_data,
+	},
+};
+
+static void __init rb922gs_init_partitions(const struct rb_info *info)
+{
+	rb922gs_spi_partitions[0].size = info->hard_cfg_offs;
+	rb922gs_spi_partitions[1].offset = info->hard_cfg_offs;
+	rb922gs_spi_partitions[3].offset = info->soft_cfg_offs;
+}
+
+static void rb922gs_nand_select_chip(int chip_no)
+{
+	switch (chip_no) {
+	case 0:
+		gpio_set_value(RB922_GPIO_NAND_NCE, 0);
+		break;
+	default:
+		gpio_set_value(RB922_GPIO_NAND_NCE, 1);
+		break;
+	}
+	ndelay(500);
+}
+
+static struct nand_ecclayout rb922gs_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static int rb922gs_nand_scan_fixup(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	if (mtd->writesize == 512) {
+		/*
+		 * Use the OLD Yaffs-1 OOB layout, otherwise RouterBoot
+		 * will not be able to find the kernel that we load.
+		 */
+		chip->ecc.layout = &rb922gs_nand_ecclayout;
+	}
+
+	return 0;
+}
+
+static struct mtd_partition rb922gs_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static void __init rb922gs_nand_init(void)
+{
+	gpio_request_one(RB922_GPIO_NAND_NCE, GPIOF_OUT_INIT_HIGH, "NAND nCE");
+
+	ath79_nfc_set_scan_fixup(rb922gs_nand_scan_fixup);
+	ath79_nfc_set_parts(rb922gs_nand_partitions,
+			    ARRAY_SIZE(rb922gs_nand_partitions));
+	ath79_nfc_set_select_chip(rb922gs_nand_select_chip);
+	ath79_nfc_set_swap_dma(true);
+	ath79_register_nfc();
+}
+
+static void __init rb922gs_setup(void)
+{
+	const struct rb_info *info;
+	char buf[64];
+
+	info = rb_init_info((void *) KSEG1ADDR(0x1f000000), 0x10000);
+	if (!info)
+		return;
+
+	scnprintf(buf, sizeof(buf), "Mikrotik RouterBOARD %s",
+		  (info->board_name) ? info->board_name : "");
+	mips_set_machine_name(buf);
+
+	rb922gs_init_partitions(info);
+	ath79_register_m25p80(&rb922gs_spi_flash_data);
+
+	rb922gs_nand_init();
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(rb922gs_mdio0_info,
+				    ARRAY_SIZE(rb922gs_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(RB922_PHY_ADDR);
+	ath79_eth0_pll_data.pll_10 = 0x81001313;
+	ath79_eth0_pll_data.pll_100 = 0x81000101;
+	ath79_eth0_pll_data.pll_1000 = 0x8f000000;
+
+	ath79_register_eth(0);
+
+	ath79_register_pci();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb922gs_leds), rb922gs_leds);
+	ath79_register_gpio_keys_polled(-1, RB922_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rb922gs_gpio_keys),
+					rb922gs_gpio_keys);
+
+	/* NOTE:
+	 * This only supports the RB911G-5HPacD board for now. For other boards
+	 * more devices must be registered based on the hardware options which
+	 * can be found in the hardware configuration of RouterBOOT.
+	 */
+}
+
+MIPS_MACHINE_NONAME(ATH79_MACH_RB_922GS, "922gs", rb922gs_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-rb95x.c linux-4.1.13/arch/mips/ath79/mach-rb95x.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-rb95x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-rb95x.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,258 @@
+/*
+ *  MikroTik RouterBOARD 95X support
+ *
+ *  Copyright (C) 2012 Stijn Tintel <stijn@linux-ipv6.be>
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 Kamil Trzcinski <ayufan@ayufan.eu>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "rb95x: " fmt
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "routerboot.h"
+#include "dev-leds-gpio.h"
+
+#define RB95X_GPIO_NAND_NCE	14
+
+static struct mtd_partition rb95x_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct gpio_led rb951ui_leds_gpio[] __initdata = {
+	{
+		.name		= "rb:green:wlan",
+		.gpio		= 11,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:act",
+		.gpio		= 3,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port1",
+		.gpio		= 13,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port2",
+		.gpio		= 12,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port3",
+		.gpio		= 4,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port4",
+		.gpio		= 21,
+		.active_low	= 1,
+	}, {
+		.name		= "rb:green:port5",
+		.gpio		= 16,
+		.active_low	= 1,
+	}
+};
+
+static struct ar8327_pad_cfg rb95x_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data rb95x_ar8327_data = {
+	.pad0_cfg = &rb95x_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	}
+};
+
+static struct mdio_board_info rb95x_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &rb95x_ar8327_data,
+	},
+};
+
+void __init rb95x_wlan_init(void)
+{
+	char *art_buf;
+	u8 wlan_mac[ETH_ALEN];
+
+	art_buf = rb_get_wlan_data();
+	if (art_buf == NULL)
+		return;
+
+	ath79_init_mac(wlan_mac, ath79_mac_base, 11);
+	ath79_register_wmac(art_buf + 0x1000, wlan_mac);
+
+	kfree(art_buf);
+}
+
+static void rb95x_nand_select_chip(int chip_no)
+{
+	switch (chip_no) {
+	case 0:
+		gpio_set_value(RB95X_GPIO_NAND_NCE, 0);
+		break;
+	default:
+		gpio_set_value(RB95X_GPIO_NAND_NCE, 1);
+		break;
+	}
+	ndelay(500);
+}
+
+static struct nand_ecclayout rb95x_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static int rb95x_nand_scan_fixup(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	if (mtd->writesize == 512) {
+		/*
+		 * Use the OLD Yaffs-1 OOB layout, otherwise RouterBoot
+		 * will not be able to find the kernel that we load.
+		 */
+		chip->ecc.layout = &rb95x_nand_ecclayout;
+	}
+
+	return 0;
+}
+
+void __init rb95x_nand_init(void)
+{
+	gpio_request_one(RB95X_GPIO_NAND_NCE, GPIOF_OUT_INIT_HIGH, "NAND nCE");
+
+	ath79_nfc_set_scan_fixup(rb95x_nand_scan_fixup);
+	ath79_nfc_set_parts(rb95x_nand_partitions,
+			    ARRAY_SIZE(rb95x_nand_partitions));
+	ath79_nfc_set_select_chip(rb95x_nand_select_chip);
+	ath79_nfc_set_swap_dma(true);
+	ath79_register_nfc();
+}
+
+static int __init rb95x_setup(void)
+{
+	const struct rb_info *info;
+
+	info = rb_init_info((void *)(KSEG1ADDR(AR71XX_SPI_BASE)), 0x10000);
+	if (!info)
+		return -EINVAL;
+
+	rb95x_nand_init();
+
+	return 0;
+}
+
+static void __init rb951g_setup(void)
+{
+	if (rb95x_setup())
+		return;
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(0, 0x0);
+
+	mdiobus_register_board_info(rb95x_mdio0_info,
+				    ARRAY_SIZE(rb95x_mdio0_info));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	rb95x_wlan_init();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_951G, "951G", "MikroTik RouterBOARD 951G-2HnD",
+	     rb951g_setup);
+
+static void __init rb951ui_setup(void)
+{
+	if (rb95x_setup())
+		return;
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	gpio_request_one(20, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	gpio_request_one(2, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "POE power");
+
+	rb95x_wlan_init();
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rb951ui_leds_gpio),
+				 rb951ui_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_RB_951U, "951HnD", "MikroTik RouterBOARD 951Ui-2HnD",
+	     rb951ui_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-rbsxtlite.c linux-4.1.13/arch/mips/ath79/mach-rbsxtlite.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-rbsxtlite.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-rbsxtlite.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,238 @@
+/*
+ *  MikroTik RouterBOARD SXT Lite support
+ *
+ *  Copyright (C) 2012 Stijn Tintel <stijn@linux-ipv6.be>
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 Vyacheslav Adamanov <adamanov@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "sxtlite: " fmt
+
+#include <linux/phy.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/rle.h>
+#include <linux/routerboot.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-nfc.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "routerboot.h"
+#include <linux/ar8216_platform.h>
+
+#define SXTLITE_GPIO_NAND_NCE  14
+#define SXTLITE_GPIO_LED_USER 3
+#define SXTLITE_GPIO_LED_1 13
+#define SXTLITE_GPIO_LED_2 12
+#define SXTLITE_GPIO_LED_3 4
+#define SXTLITE_GPIO_LED_4 21
+#define SXTLITE_GPIO_LED_5 18
+#define SXTLITE_GPIO_LED_POWER 11
+
+#define SXTLITE_GPIO_BUZZER 19
+
+#define SXTLITE_GPIO_BTN_RESET 15
+
+#define SXTLITE_KEYS_POLL_INTERVAL 20
+#define SXTLITE_KEYS_DEBOUNCE_INTERVAL (3 * SXTLITE_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition rbsxtlite_nand_partitions[] = {
+	{
+		.name   = "booter",
+		.offset = 0,
+		.size   = (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name   = "kernel",
+		.offset = (256 * 1024),
+		.size   = (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name   = "rootfs",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = MTDPART_SIZ_FULL,
+	},
+};
+
+static struct gpio_led rbsxtlite_leds_gpio[] __initdata = {
+	{
+		.name		=	"rb:green:user",
+		.gpio		=	SXTLITE_GPIO_LED_USER,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led1",
+		.gpio		=	SXTLITE_GPIO_LED_1,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led2",
+		.gpio		=	SXTLITE_GPIO_LED_2,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led3",
+		.gpio		=	SXTLITE_GPIO_LED_3,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led4",
+		.gpio		=	SXTLITE_GPIO_LED_4,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:led5",
+		.gpio		=	SXTLITE_GPIO_LED_5,
+		.active_low	=	1,
+	},
+	{
+		.name		=	"rb:green:power",
+		.gpio		=	SXTLITE_GPIO_LED_POWER,
+	},
+};
+
+static struct gpio_keys_button rbsxtlite_gpio_keys[] __initdata = {
+	{
+		.desc		=	"Reset button",
+		.type		=	EV_KEY,
+		.code		=	KEY_RESTART,
+		.debounce_interval	=	SXTLITE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		=	SXTLITE_GPIO_BTN_RESET,
+		.active_low	=	0,
+	},
+};
+
+static int __init rbsxtlite_rbinfo_init(void)
+{
+	const struct rb_info *info;
+
+	info = rb_init_info((void *)(KSEG1ADDR(AR71XX_SPI_BASE)), 0x10000);
+	if (!info)
+		return -EINVAL;
+	return 0;
+
+}
+
+void __init rbsxtlite_wlan_init(void)
+{
+	char *art_buf;
+	u8 wlan_mac[ETH_ALEN];
+
+	art_buf = rb_get_wlan_data();
+	if (art_buf == NULL)
+		return;
+
+	ath79_init_mac(wlan_mac, ath79_mac_base, 1);
+	ath79_register_wmac(art_buf + 0x1000, wlan_mac);
+
+	kfree(art_buf);
+}
+
+static void rbsxtlite_nand_select_chip(int chip_no)
+{
+	switch (chip_no) {
+	case 0:
+		gpio_set_value(SXTLITE_GPIO_NAND_NCE, 0);
+		break;
+	default:
+		gpio_set_value(SXTLITE_GPIO_NAND_NCE, 1);
+		break;
+	}
+	ndelay(500);
+}
+
+static struct nand_ecclayout rbsxtlite_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos	 = { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static int rbsxtlite_nand_scan_fixup(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	if (mtd->writesize == 512) {
+		/*
+		* Use the OLD Yaffs-1 OOB layout, otherwise RouterBoot
+		* will not be able to find the kernel that we load.
+		*/
+		chip->ecc.layout = &rbsxtlite_nand_ecclayout;
+	}
+
+	return 0;
+}
+
+void __init rbsxtlite_gpio_init(void)
+{
+	gpio_request_one(SXTLITE_GPIO_NAND_NCE, GPIOF_OUT_INIT_HIGH, "NAND nCE");
+}
+
+void __init rbsxtlite_nand_init(void)
+{
+	ath79_nfc_set_scan_fixup(rbsxtlite_nand_scan_fixup);
+	ath79_nfc_set_parts(rbsxtlite_nand_partitions,
+			   ARRAY_SIZE(rbsxtlite_nand_partitions));
+	ath79_nfc_set_select_chip(rbsxtlite_nand_select_chip);
+	ath79_nfc_set_swap_dma(true);
+	ath79_register_nfc();
+}
+
+
+static void __init rbsxtlite_setup(void)
+{
+	if(rbsxtlite_rbinfo_init())
+		return;
+	rbsxtlite_nand_init();
+	rbsxtlite_wlan_init();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rbsxtlite_leds_gpio),
+				 rbsxtlite_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, SXTLITE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rbsxtlite_gpio_keys),
+					rbsxtlite_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC0 is left unused */
+
+	/* GMAC1 is connected to MAC0 on the internal switch */
+	/* The ethernet port connects to PHY P0, which connects to MAC1
+	   on the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+
+}
+
+
+MIPS_MACHINE(ATH79_MACH_RB_SXTLITE2ND, "sxt2n", "Mikrotik RouterBOARD SXT Lite2",
+	    rbsxtlite_setup);
+
+MIPS_MACHINE(ATH79_MACH_RB_SXTLITE5ND, "sxt5n", "Mikrotik RouterBOARD SXT Lite5",
+	    rbsxtlite_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-rw2458n.c linux-4.1.13/arch/mips/ath79/mach-rw2458n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-rw2458n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-rw2458n.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,91 @@
+/*
+ *  Redwave RW2458N support
+ *
+ *  Copyright (C) 2011-2013 Cezary Jackiewicz <cezary@eko.one.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define RW2458N_GPIO_LED_D3	1
+#define RW2458N_GPIO_LED_D4	0
+#define RW2458N_GPIO_LED_D5	11
+#define RW2458N_GPIO_LED_D6	7
+#define RW2458N_GPIO_BTN_RESET	12
+
+#define RW2458N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define RW2458N_KEYS_DEBOUNCE_INTERVAL	(3 * RW2458N_KEYS_POLL_INTERVAL)
+
+static struct gpio_keys_button rw2458n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = RW2458N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= RW2458N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+#define RW2458N_WAN_PHYMASK	BIT(4)
+
+static struct gpio_led rw2458n_leds_gpio[] __initdata = {
+	{
+		.name		= "rw2458n:green:d3",
+		.gpio		= RW2458N_GPIO_LED_D3,
+		.active_low	= 1,
+	}, {
+		.name		= "rw2458n:green:d4",
+		.gpio		= RW2458N_GPIO_LED_D4,
+		.active_low	= 1,
+	}, {
+		.name		= "rw2458n:green:d5",
+		.gpio		= RW2458N_GPIO_LED_D5,
+		.active_low	= 1,
+	}, {
+		.name		= "rw2458n:green:d6",
+		.gpio		= RW2458N_GPIO_LED_D6,
+		.active_low	= 1,
+	}
+};
+
+static void __init rw2458n_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~RW2458N_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(rw2458n_leds_gpio),
+				 rw2458n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, RW2458N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(rw2458n_gpio_keys),
+					rw2458n_gpio_keys);
+	ath79_register_usb();
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_RW2458N, "RW2458N", "Redwave RW2458N",
+	    rw2458n_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-smart-300.c linux-4.1.13/arch/mips/ath79/mach-smart-300.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-smart-300.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-smart-300.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,135 @@
+/*
+ *  NC-LINK SMART-300 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ag71xx_platform.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define SMART_300_GPIO_LED_WLAN		13
+#define SMART_300_GPIO_LED_WAN		18
+#define SMART_300_GPIO_LED_LAN4		19
+#define SMART_300_GPIO_LED_LAN3		12
+#define SMART_300_GPIO_LED_LAN2		21
+#define SMART_300_GPIO_LED_LAN1		20
+#define SMART_300_GPIO_LED_SYSTEM	15
+#define SMART_300_GPIO_LED_POWER	14
+
+#define SMART_300_GPIO_BTN_RESET	17
+#define SMART_300_GPIO_SW_RFKILL	16
+
+#define SMART_300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define SMART_300_KEYS_DEBOUNCE_INTERVAL (3 * SMART_300_KEYS_POLL_INTERVAL)
+
+#define SMART_300_GPIO_MASK        0x007fffff
+
+static const char *smart_300_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data smart_300_flash_data = {
+	.part_probes	= smart_300_part_probes,
+};
+
+static struct gpio_led smart_300_leds_gpio[] __initdata = {
+	{
+		.name		= "nc-link:green:lan1",
+		.gpio		= SMART_300_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:lan2",
+		.gpio		= SMART_300_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:lan3",
+		.gpio		= SMART_300_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:lan4",
+		.gpio		= SMART_300_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:system",
+		.gpio		= SMART_300_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:wan",
+		.gpio		= SMART_300_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "nc-link:green:wlan",
+		.gpio		= SMART_300_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button smart_300_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = SMART_300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= SMART_300_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static void __init smart_300_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(smart_300_leds_gpio),
+				 smart_300_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, SMART_300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(smart_300_gpio_keys),
+					smart_300_gpio_keys);
+
+	ath79_register_m25p80(&smart_300_flash_data);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+
+	gpio_request(SMART_300_GPIO_LED_POWER, "power");
+	gpio_direction_output(SMART_300_GPIO_LED_POWER, GPIOF_OUT_INIT_LOW);
+}
+
+MIPS_MACHINE(ATH79_MACH_SMART_300, "SMART-300", "NC-LINK SMART-300",
+	     smart_300_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tew-632brp.c linux-4.1.13/arch/mips/ath79/mach-tew-632brp.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tew-632brp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tew-632brp.c	2015-09-13 20:04:35.068524086 +0200
@@ -0,0 +1,111 @@
+/*
+ *  TrendNET TEW-632BRP board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define TEW_632BRP_GPIO_LED_STATUS	1
+#define TEW_632BRP_GPIO_LED_WPS		3
+#define TEW_632BRP_GPIO_LED_WLAN	6
+#define TEW_632BRP_GPIO_BTN_WPS		12
+#define TEW_632BRP_GPIO_BTN_RESET	21
+
+#define TEW_632BRP_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TEW_632BRP_KEYS_DEBOUNCE_INTERVAL (3 * TEW_632BRP_KEYS_POLL_INTERVAL)
+
+#define TEW_632BRP_CONFIG_ADDR	0x1f020000
+#define TEW_632BRP_CONFIG_SIZE	0x10000
+
+static struct gpio_led tew_632brp_leds_gpio[] __initdata = {
+	{
+		.name		= "tew-632brp:green:status",
+		.gpio		= TEW_632BRP_GPIO_LED_STATUS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:blue:wps",
+		.gpio		= TEW_632BRP_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tew-632brp:green:wlan",
+		.gpio		= TEW_632BRP_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tew_632brp_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_632BRP_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_632BRP_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_632BRP_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+#define TEW_632BRP_LAN_PHYMASK	BIT(0)
+#define TEW_632BRP_WAN_PHYMASK	BIT(4)
+#define TEW_632BRP_MDIO_MASK	(~(TEW_632BRP_LAN_PHYMASK | \
+				   TEW_632BRP_WAN_PHYMASK))
+
+static void __init tew_632brp_setup(void)
+{
+	const char *config = (char *) KSEG1ADDR(TEW_632BRP_CONFIG_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+	u8 *wlan_mac = NULL;
+
+	if (ath79_nvram_parse_mac_addr(config, TEW_632BRP_CONFIG_SIZE,
+				       "lan_mac=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+		wlan_mac = mac;
+	}
+
+	ath79_register_mdio(0, TEW_632BRP_MDIO_MASK);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = TEW_632BRP_LAN_PHYMASK;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = TEW_632BRP_WAN_PHYMASK;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew_632brp_leds_gpio),
+				 tew_632brp_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TEW_632BRP_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew_632brp_gpio_keys),
+					tew_632brp_gpio_keys);
+
+	ath79_register_wmac(eeprom, wlan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_632BRP, "TEW-632BRP", "TRENDnet TEW-632BRP",
+	     tew_632brp_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tew-673gru.c linux-4.1.13/arch/mips/ath79/mach-tew-673gru.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tew-673gru.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tew-673gru.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,198 @@
+/*
+ *  TRENDnet TEW-673GRU board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define TEW673GRU_GPIO_LCD_SCK		0
+#define TEW673GRU_GPIO_LCD_MOSI		1
+#define TEW673GRU_GPIO_LCD_MISO		2
+#define TEW673GRU_GPIO_LCD_CS		6
+
+#define TEW673GRU_GPIO_LED_WPS		9
+
+#define TEW673GRU_GPIO_BTN_RESET	3
+#define TEW673GRU_GPIO_BTN_WPS		8
+
+#define TEW673GRU_GPIO_RTL8366_SDA	5
+#define TEW673GRU_GPIO_RTL8366_SCK	7
+
+#define TEW673GRU_KEYS_POLL_INTERVAL	20 /* msecs */
+#define TEW673GRU_KEYS_DEBOUNCE_INTERVAL (3 * TEW673GRU_KEYS_POLL_INTERVAL)
+
+#define TEW673GRU_CAL0_OFFSET		0x1000
+#define TEW673GRU_CAL1_OFFSET		0x5000
+#define TEW673GRU_MAC0_OFFSET		0xffa0
+#define TEW673GRU_MAC1_OFFSET		0xffb4
+
+#define TEW673GRU_CAL_LOCATION_0	0x1f660000
+#define TEW673GRU_CAL_LOCATION_1	0x1f7f0000
+
+static struct gpio_led tew673gru_leds_gpio[] __initdata = {
+	{
+		.name		= "trendnet:blue:wps",
+		.gpio		= TEW673GRU_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tew673gru_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW673GRU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW673GRU_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW673GRU_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW673GRU_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_initval tew673gru_rtl8366s_initvals[] = {
+	{ .reg = 0x06, .val = 0x0108 },
+};
+
+static struct rtl8366_platform_data tew673gru_rtl8366s_data = {
+	.gpio_sda	= TEW673GRU_GPIO_RTL8366_SDA,
+	.gpio_sck	= TEW673GRU_GPIO_RTL8366_SCK,
+	.num_initvals	= ARRAY_SIZE(tew673gru_rtl8366s_initvals),
+	.initvals	= tew673gru_rtl8366s_initvals,
+};
+
+static struct platform_device tew673gru_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tew673gru_rtl8366s_data,
+	}
+};
+
+static struct spi_board_info tew673gru_spi_info[] = {
+	{
+		.bus_num	= 1,
+		.chip_select	= 0,
+		.max_speed_hz	= 400000,
+		.modalias	= "spidev",
+		.mode		= SPI_MODE_2,
+		.controller_data = (void *) TEW673GRU_GPIO_LCD_CS,
+	},
+};
+
+static struct spi_gpio_platform_data tew673gru_spi_data = {
+	.sck		= TEW673GRU_GPIO_LCD_SCK,
+	.miso		= TEW673GRU_GPIO_LCD_MISO,
+	.mosi		= TEW673GRU_GPIO_LCD_MOSI,
+	.num_chipselect = 1,
+};
+
+static struct platform_device tew673gru_spi_device = {
+	.name		= "spi_gpio",
+	.id		= 1,
+	.dev = {
+		.platform_data = &tew673gru_spi_data,
+	},
+};
+
+static bool __init tew673gru_is_caldata_valid(u8 *p)
+{
+	u16 *magic0, *magic1;
+
+	magic0 = (u16 *)(p + TEW673GRU_CAL0_OFFSET);
+	magic1 = (u16 *)(p + TEW673GRU_CAL1_OFFSET);
+
+	return (*magic0 == 0xa55a && *magic1 == 0xa55a);
+}
+
+static void __init tew673gru_wlan_init(void)
+{
+	u8 mac1[ETH_ALEN], mac2[ETH_ALEN];
+	u8 *caldata;
+
+	caldata = (u8 *) KSEG1ADDR(TEW673GRU_CAL_LOCATION_0);
+	if (!tew673gru_is_caldata_valid(caldata)) {
+		caldata = (u8 *)KSEG1ADDR(TEW673GRU_CAL_LOCATION_1);
+		if (!tew673gru_is_caldata_valid(caldata)) {
+			pr_err("no calibration data found\n");
+			return;
+		}
+	}
+
+	ath79_parse_ascii_mac(caldata + TEW673GRU_MAC0_OFFSET, mac1);
+	ath79_parse_ascii_mac(caldata + TEW673GRU_MAC1_OFFSET, mac2);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 2);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, 3);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init(caldata + TEW673GRU_CAL0_OFFSET, mac1,
+		      caldata + TEW673GRU_CAL1_OFFSET, mac2);
+}
+
+static void __init tew673gru_setup(void)
+{
+	tew673gru_wlan_init();
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.mii_bus_dev = &tew673gru_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+
+	ath79_eth1_data.mii_bus_dev = &tew673gru_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+	ath79_eth1_pll_data.pll_1000 = 0x11110000;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew673gru_leds_gpio),
+				 tew673gru_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TEW673GRU_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew673gru_gpio_keys),
+					tew673gru_gpio_keys);
+
+	ath79_register_usb();
+
+	platform_device_register(&tew673gru_rtl8366s_device);
+
+	spi_register_board_info(tew673gru_spi_info,
+				ARRAY_SIZE(tew673gru_spi_info));
+	platform_device_register(&tew673gru_spi_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_673GRU, "TEW-673GRU", "TRENDnet TEW-673GRU",
+	     tew673gru_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tew-712br.c linux-4.1.13/arch/mips/ath79/mach-tew-712br.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tew-712br.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tew-712br.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,153 @@
+/*
+ *  TRENDnet TEW-712BR board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TEW_712BR_GPIO_BTN_WPS		11
+#define TEW_712BR_GPIO_BTN_RESET	12
+
+#define TEW_712BR_GPIO_LED_LAN1		13
+#define TEW_712BR_GPIO_LED_LAN2		14
+#define TEW_712BR_GPIO_LED_LAN3		15
+#define TEW_712BR_GPIO_LED_LAN4		16
+#define TEW_712BR_GPIO_LED_POWER_GREEN	20
+#define TEW_712BR_GPIO_LED_POWER_ORANGE	27
+#define TEW_712BR_GPIO_LED_WAN_GREEN	17
+#define TEW_712BR_GPIO_LED_WAN_ORANGE	23
+#define TEW_712BR_GPIO_LED_WLAN		0
+#define TEW_712BR_GPIO_LED_WPS		26
+
+#define TEW_712BR_GPIO_WAN_LED_ENABLE	1
+
+#define TEW_712BR_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TEW_712BR_KEYS_DEBOUNCE_INTERVAL (3 * TEW_712BR_KEYS_POLL_INTERVAL)
+
+#define TEW_712BR_ART_ADDRESS		0x1f010000
+#define TEW_712BR_CALDATA_OFFSET	0x1000
+
+#define TEW_712BR_MAC_PART_ADDRESS	0x1f020000
+#define TEW_712BR_LAN_MAC_OFFSET	0x04
+#define TEW_712BR_WAN_MAC_OFFSET	0x16
+
+static struct gpio_led tew_712br_leds_gpio[] __initdata = {
+	{
+		.name		= "trendnet:green:lan1",
+		.gpio		= TEW_712BR_GPIO_LED_LAN1,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:lan2",
+		.gpio		= TEW_712BR_GPIO_LED_LAN2,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:lan3",
+		.gpio		= TEW_712BR_GPIO_LED_LAN3,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:lan4",
+		.gpio		= TEW_712BR_GPIO_LED_LAN4,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:blue:wps",
+		.gpio		= TEW_712BR_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "trendnet:green:power",
+		.gpio		= TEW_712BR_GPIO_LED_POWER_GREEN,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:orange:power",
+		.gpio		= TEW_712BR_GPIO_LED_POWER_ORANGE,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:wan",
+		.gpio		= TEW_712BR_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "trendnet:orange:wan",
+		.gpio		= TEW_712BR_GPIO_LED_WAN_ORANGE,
+		.active_low	= 0,
+	}, {
+		.name		= "trendnet:green:wlan",
+		.gpio		= TEW_712BR_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tew_712br_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_712BR_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_712BR_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_712BR_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_712BR_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tew_712br_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(TEW_712BR_ART_ADDRESS);
+	u8 *mac = (u8 *) KSEG1ADDR(TEW_712BR_MAC_PART_ADDRESS);
+	u8 lan_mac[ETH_ALEN];
+	u8 wan_mac[ETH_ALEN];
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	gpio_request_one(TEW_712BR_GPIO_WAN_LED_ENABLE,
+			 GPIOF_OUT_INIT_LOW, "WAN LED enable");
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew_712br_leds_gpio),
+				 tew_712br_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TEW_712BR_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew_712br_gpio_keys),
+					tew_712br_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_parse_ascii_mac(mac + TEW_712BR_LAN_MAC_OFFSET, lan_mac);
+	ath79_parse_ascii_mac(mac + TEW_712BR_WAN_MAC_OFFSET, wan_mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, wan_mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, lan_mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(art + TEW_712BR_CALDATA_OFFSET, wan_mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_712BR, "TEW-712BR",
+	     "TRENDnet TEW-712BR", tew_712br_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tew-732br.c linux-4.1.13/arch/mips/ath79/mach-tew-732br.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tew-732br.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tew-732br.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,127 @@
+/*
+ *  TRENDnet TEW-732BR board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TEW_732BR_GPIO_BTN_WPS		16
+#define TEW_732BR_GPIO_BTN_RESET	17
+
+#define TEW_732BR_GPIO_LED_POWER_GREEN	4
+#define TEW_732BR_GPIO_LED_POWER_AMBER	14
+#define TEW_732BR_GPIO_LED_PLANET_GREEN	12
+#define TEW_732BR_GPIO_LED_PLANET_AMBER 22
+
+#define TEW_732BR_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TEW_732BR_KEYS_DEBOUNCE_INTERVAL (3 * TEW_732BR_KEYS_POLL_INTERVAL)
+
+#define TEW_732BR_ART_ADDRESS		0x1fff0000
+#define TEW_732BR_CALDATA_OFFSET	0x1000
+#define TEW_732BR_LAN_MAC_OFFSET	0xffa0
+#define TEW_732BR_WAN_MAC_OFFSET	0xffb4
+
+static struct gpio_led tew_732br_leds_gpio[] __initdata = {
+	{
+		.name		= "trendnet:green:power",
+		.gpio		= TEW_732BR_GPIO_LED_POWER_GREEN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "trendnet:amber:power",
+		.gpio		= TEW_732BR_GPIO_LED_POWER_AMBER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "trendnet:green:wan",
+		.gpio		= TEW_732BR_GPIO_LED_PLANET_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "trendnet:amber:wan",
+		.gpio		= TEW_732BR_GPIO_LED_PLANET_AMBER,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tew_732br_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TEW_732BR_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_732BR_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TEW_732BR_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TEW_732BR_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static void __init tew_732br_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(TEW_732BR_ART_ADDRESS);
+	u8 lan_mac[ETH_ALEN];
+	u8 wan_mac[ETH_ALEN];
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tew_732br_leds_gpio),
+				 tew_732br_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TEW_732BR_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tew_732br_gpio_keys),
+					tew_732br_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_parse_ascii_mac(art + TEW_732BR_LAN_MAC_OFFSET, lan_mac);
+	ath79_parse_ascii_mac(art + TEW_732BR_WAN_MAC_OFFSET, wan_mac);
+
+	ath79_register_wmac(art + TEW_732BR_CALDATA_OFFSET, lan_mac);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	/* LAN: GMAC1 is connected to the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, lan_mac, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN: GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_init_mac(ath79_eth0_data.mac_addr, wan_mac, 0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TEW_732BR, "TEW-732BR", "TRENDnet TEW-732BR",
+	     tew_732br_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-mr11u.c linux-4.1.13/arch/mips/ath79/mach-tl-mr11u.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-mr11u.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-mr11u.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,183 @@
+/*
+ *  TP-LINK TL-MR11U/TL-MR3040 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_MR11U_GPIO_LED_3G		27
+#define TL_MR11U_GPIO_LED_WLAN		26
+#define TL_MR11U_GPIO_LED_LAN		17
+
+#define TL_MR11U_GPIO_BTN_WPS		20
+#define TL_MR11U_GPIO_BTN_RESET		11
+
+#define TL_MR11U_GPIO_USB_POWER		8
+#define TL_MR3040_GPIO_USB_POWER	18
+
+#define TL_MR3040_V2_GPIO_BTN_SW1	19
+#define TL_MR3040_V2_GPIO_BTN_SW2	20
+
+#define TL_MR11U_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR11U_KEYS_DEBOUNCE_INTERVAL	(3 * TL_MR11U_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr11u_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr11u_flash_data = {
+	.part_probes	= tl_mr11u_part_probes,
+};
+
+static struct gpio_led tl_mr11u_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR11U_GPIO_LED_3G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_MR11U_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_MR11U_GPIO_LED_LAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_mr11u_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR11U_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR11U_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_mr3040_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR11U_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw1",
+		.type		= EV_SW,
+		.code		= BTN_0,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3040_V2_GPIO_BTN_SW1,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw2",
+		.type		= EV_SW,
+		.code		= BTN_1,
+		.debounce_interval = TL_MR11U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3040_V2_GPIO_BTN_SW2,
+		.active_low	= 0,
+	}
+};
+
+static void __init common_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* Disable hardware control LAN1 and LAN2 LEDs, enabling GPIO14 and GPIO15 */
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_mr11u_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr11u_leds_gpio),
+				 tl_mr11u_leds_gpio);
+
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_mr11u_setup(void)
+{
+	common_setup();
+
+	ath79_register_gpio_keys_polled(-1, TL_MR11U_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr11u_gpio_keys),
+					tl_mr11u_gpio_keys);
+	gpio_request_one(TL_MR11U_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR11U, "TL-MR11U", "TP-LINK TL-MR11U",
+	     tl_mr11u_setup);
+
+static void __init tl_mr3040_setup(void)
+{
+	common_setup();
+
+	ath79_register_gpio_keys_polled(-1, TL_MR11U_KEYS_POLL_INTERVAL,
+					1, tl_mr11u_gpio_keys);
+	gpio_request_one(TL_MR3040_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3040, "TL-MR3040", "TP-LINK TL-MR3040",
+	     tl_mr3040_setup);
+
+static void __init tl_mr3040_v2_setup(void)
+{
+	common_setup();
+
+	ath79_register_gpio_keys_polled(-1, TL_MR11U_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr3040_v2_gpio_keys),
+					tl_mr3040_v2_gpio_keys);
+	gpio_request_one(TL_MR3040_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3040_V2, "TL-MR3040-v2", "TP-LINK TL-MR3040 v2",
+	     tl_mr3040_v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-mr13u.c linux-4.1.13/arch/mips/ath79/mach-tl-mr13u.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-mr13u.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-mr13u.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,107 @@
+/*
+ *  TP-LINK TL-MR13U board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_MR13U_GPIO_LED_SYSTEM	27
+
+#define TL_MR13U_GPIO_BTN_RESET		11
+#define TL_MR13U_GPIO_BTN_SW1		6
+#define TL_MR13U_GPIO_BTN_SW2		7
+
+#define TL_MR13U_GPIO_USB_POWER		18
+
+#define TL_MR13U_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR13U_KEYS_DEBOUNCE_INTERVAL	(3 * TL_MR13U_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr13u_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr13u_flash_data = {
+	.part_probes	= tl_mr13u_part_probes,
+};
+
+static struct gpio_led tl_mr13u_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_MR13U_GPIO_LED_SYSTEM,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_mr13u_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR13U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR13U_GPIO_BTN_RESET,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_MR13U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR13U_GPIO_BTN_SW1,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw2",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_MR13U_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR13U_GPIO_BTN_SW2,
+		.active_low	= 0,
+	},
+};
+
+static void __init tl_mr13u_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_mr13u_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr13u_leds_gpio),
+				 tl_mr13u_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_MR13U_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr13u_gpio_keys),
+					tl_mr13u_gpio_keys);
+
+	gpio_request_one(TL_MR13U_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR13U, "TL-MR13U", "TP-LINK TL-MR13U v1",
+	     tl_mr13u_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-mr3020.c linux-4.1.13/arch/mips/ath79/mach-tl-mr3020.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-mr3020.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-mr3020.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,126 @@
+/*
+ *  TP-LINK TL-MR3020 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_MR3020_GPIO_LED_3G		27
+#define TL_MR3020_GPIO_LED_WLAN		0
+#define TL_MR3020_GPIO_LED_LAN		17
+#define TL_MR3020_GPIO_LED_WPS		26
+
+#define TL_MR3020_GPIO_BTN_WPS		11
+#define TL_MR3020_GPIO_BTN_SW1		18
+#define TL_MR3020_GPIO_BTN_SW2		20
+
+#define TL_MR3020_GPIO_USB_POWER	8
+
+#define TL_MR3020_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR3020_KEYS_DEBOUNCE_INTERVAL	(3 * TL_MR3020_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr3020_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr3020_flash_data = {
+	.part_probes	= tl_mr3020_part_probes,
+};
+
+static struct gpio_led tl_mr3020_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3020_GPIO_LED_3G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_MR3020_GPIO_LED_WLAN,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_MR3020_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_MR3020_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_mr3020_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR3020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3020_GPIO_BTN_WPS,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_MR3020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3020_GPIO_BTN_SW1,
+		.active_low	= 0,
+	},
+	{
+		.desc		= "sw2",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_MR3020_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3020_GPIO_BTN_SW2,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_mr3020_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_mr3020_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3020_leds_gpio),
+				 tl_mr3020_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_MR3020_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr3020_gpio_keys),
+					tl_mr3020_gpio_keys);
+
+	gpio_request_one(TL_MR3020_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3020, "TL-MR3020", "TP-LINK TL-MR3020",
+	     tl_mr3020_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-mr3x20.c linux-4.1.13/arch/mips/ath79/mach-tl-mr3x20.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-mr3x20.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-mr3x20.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,147 @@
+/*
+ *  TP-LINK TL-MR3220/3420 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define TL_MR3X20_GPIO_LED_QSS		0
+#define TL_MR3X20_GPIO_LED_SYSTEM	1
+#define TL_MR3X20_GPIO_LED_3G		8
+
+#define TL_MR3X20_GPIO_BTN_RESET	11
+#define TL_MR3X20_GPIO_BTN_QSS		12
+
+#define TL_MR3X20_GPIO_USB_POWER	6
+
+#define TL_MR3X20_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_MR3X20_KEYS_DEBOUNCE_INTERVAL (3 * TL_MR3X20_KEYS_POLL_INTERVAL)
+
+static const char *tl_mr3x20_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_mr3x20_flash_data = {
+	.part_probes	= tl_mr3x20_part_probes,
+};
+
+static struct gpio_led tl_mr3x20_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_MR3X20_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_MR3X20_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3X20_GPIO_LED_3G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_mr3x20_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_MR3X20_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3X20_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_ap99_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_mr3x20_flash_data);
+
+	ath79_register_gpio_keys_polled(-1, TL_MR3X20_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_mr3x20_gpio_keys),
+					 tl_mr3x20_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap91_pci_init(ee, mac);
+}
+
+static void __init tl_mr3x20_usb_setup(void)
+{
+	/* enable power for the USB port */
+	gpio_request_one(TL_MR3X20_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+}
+
+static void __init tl_mr3220_setup(void)
+{
+	tl_ap99_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio),
+				 tl_mr3x20_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+	tl_mr3x20_usb_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3220, "TL-MR3220", "TP-LINK TL-MR3220",
+	     tl_mr3220_setup);
+
+static void __init tl_mr3420_setup(void)
+{
+	tl_ap99_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio),
+				 tl_mr3x20_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	tl_mr3x20_usb_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3420, "TL-MR3420", "TP-LINK TL-MR3420",
+	     tl_mr3420_setup);
+
+static void __init tl_wr841n_v7_setup(void)
+{
+	tl_ap99_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio) - 1,
+				 tl_mr3x20_leds_gpio);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V7, "TL-WR841N-v7",
+	     "TP-LINK TL-WR841N/ND v7", tl_wr841n_v7_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa701nd-v2.c linux-4.1.13/arch/mips/ath79/mach-tl-wa701nd-v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa701nd-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wa701nd-v2.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,116 @@
+/*
+ *  TP-LINK TL-WA701ND v2 board support
+ *
+ *  Copyright (C) 2015 Luigi Tarenga <luigi.tarenga@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WA701NDV2_GPIO_LED_WLAN	0
+#define TL_WA701NDV2_GPIO_LED_QSS	1
+#define TL_WA701NDV2_GPIO_LED_LAN	17
+#define TL_WA701NDV2_GPIO_LED_SYSTEM	27
+
+#define TL_WA701NDV2_GPIO_BTN_RESET	11
+#define TL_WA701NDV2_GPIO_BTN_QSS	26
+
+#define TL_WA701NDV2_GPIO_USB_POWER	8
+
+#define TL_WA701NDV2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA701NDV2_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WA701NDV2_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa701ndv2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa701ndv2_flash_data = {
+	.part_probes	= tl_wa701ndv2_part_probes,
+};
+
+static struct gpio_led tl_wa701ndv2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA701NDV2_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA701NDV2_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA701NDV2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA701NDV2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+        }
+};
+
+static struct gpio_keys_button tl_wa701ndv2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA701NDV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA701NDV2_GPIO_BTN_RESET,
+		.active_low	= 0,
+	} , {
+                .desc		= "qss",
+                .type		= EV_KEY,
+                .code		= KEY_WPS_BUTTON,
+                .debounce_interval = TL_WA701NDV2_KEYS_DEBOUNCE_INTERVAL,
+                .gpio		= TL_WA701NDV2_GPIO_BTN_QSS,
+                .active_low	= 0,
+        }
+
+};
+
+static void __init tl_wa701ndv2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa701ndv2_leds_gpio),
+				 tl_wa701ndv2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA701NDV2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa701ndv2_gpio_keys),
+					tl_wa701ndv2_gpio_keys);
+
+	gpio_request_one(TL_WA701NDV2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_m25p80(&tl_wa701ndv2_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	/* ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1); */
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA701ND_V2, "TL-WA701ND-v2",
+	     "TP-LINK TL-WA701ND v2", tl_wa701ndv2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa7210n-v2.c linux-4.1.13/arch/mips/ath79/mach-tl-wa7210n-v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa7210n-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wa7210n-v2.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,125 @@
+/*
+ *  TP-LINK TL-WA7210N v2.1 board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Nicolas Braud-Santoni <nicolas@braud-santoni.eu>
+ *  Copyright (C) 2014 Alexander List <alex@graz.funkfeuer.at>
+ *  Copyright (C) 2015 Hendrik Frenzel <hfrenzel@scunc.net>
+ *
+ *  rebased on TL-WA7510Nv1 support,
+ *    Copyright (C) 2012 Stefan Helmert <helst_listen@aol.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#include "common.h"
+
+#define TL_WA7210N_V2_GPIO_BTN_RESET    11
+#define TL_WA7210N_V2_KEYS_POLL_INT     20
+#define TL_WA7210N_V2_KEYS_DEBOUNCE_INT (3 * TL_WA7210N_V2_KEYS_POLL_INT)
+
+#define TL_WA7210N_V2_GPIO_LED_LAN  17
+#define TL_WA7210N_V2_GPIO_LED_SIG1 0
+#define TL_WA7210N_V2_GPIO_LED_SIG2 1
+#define TL_WA7210N_V2_GPIO_LED_SIG3 27
+#define TL_WA7210N_V2_GPIO_LED_SIG4 26
+
+#define  TL_WA7210N_V2_GPIO_LNA_EN 28
+
+static const char *tl_wa7210n_v2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct gpio_keys_button tl_wa7210n_v2_gpio_keys[] __initdata = {
+	{
+		.desc              = "reset",
+		.type              = EV_KEY,
+		.code              = KEY_RESTART,
+		.debounce_interval = TL_WA7210N_V2_KEYS_DEBOUNCE_INT,
+		.gpio              = TL_WA7210N_V2_GPIO_BTN_RESET,
+		.active_low        = 0,
+	},
+};
+
+static struct gpio_led tl_wa7210n_v2_leds_gpio[] __initdata = {
+	{
+		.name       = "tp-link:green:lan",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_LAN,
+		.active_low = 1,
+	}, {
+		.name       = "tp-link:green:signal1",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_SIG1,
+		.active_low = 0,
+	}, {
+		.name       = "tp-link:green:signal2",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_SIG2,
+		.active_low = 0,
+	}, {
+		.name       = "tp-link:green:signal3",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_SIG3,
+		.active_low = 1,
+	}, {
+		.name       = "tp-link:green:signal4",
+		.gpio       = TL_WA7210N_V2_GPIO_LED_SIG4,
+		.active_low = 1,
+	},
+};
+
+static struct flash_platform_data tl_wa7210n_v2_flash_data = {
+	.part_probes    = tl_wa7210n_v2_part_probes,
+};
+
+static void __init tl_wa7210n_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA7210N_V2_KEYS_POLL_INT,
+			ARRAY_SIZE(tl_wa7210n_v2_gpio_keys),
+			tl_wa7210n_v2_gpio_keys);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa7210n_v2_leds_gpio),
+			tl_wa7210n_v2_leds_gpio);
+
+	ath79_gpio_function_enable(TL_WA7210N_V2_GPIO_LNA_EN);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_wmac(ee, mac);
+
+	ath79_register_m25p80(&tl_wa7210n_v2_flash_data);
+
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA7210N_V2, "TL-WA7210N-v2", "TP-LINK TL-WA7210N v2",
+	tl_wa7210n_v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa830re-v2.c linux-4.1.13/arch/mips/ath79/mach-tl-wa830re-v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa830re-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wa830re-v2.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,132 @@
+/*
+ *  TP-LINK TL-WA830RE v2 board support
+ *
+ *  Copyright (C) 2014 Fredrik Jonson <fredrik@famjonson.se>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WA830REV2_GPIO_LED_WLAN	13
+#define TL_WA830REV2_GPIO_LED_QSS	15
+#define TL_WA830REV2_GPIO_LED_LAN	18
+#define TL_WA830REV2_GPIO_LED_SYSTEM	14
+
+#define TL_WA830REV2_GPIO_BTN_RESET	17
+#define TL_WA830REV2_GPIO_SW_RFKILL	16	/* WPS for MR3420 v2 */
+
+#define TL_WA830REV2_GPIO_USB_POWER	4
+
+#define TL_WA830REV2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA830REV2_KEYS_DEBOUNCE_INTERVAL (3 * TL_WA830REV2_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa830re_v2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa830re_v2_flash_data = {
+	.part_probes	= tl_wa830re_v2_part_probes,
+};
+
+static struct gpio_led tl_wa830re_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA830REV2_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA830REV2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA830REV2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA830REV2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wa830re_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA830REV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA830REV2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WA830REV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA830REV2_GPIO_SW_RFKILL,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_ap123_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	/* Configure OBS4 line, for GPIO 4*/
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				 AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	/* config gpio4 as normal gpio function */
+	ath79_gpio_output_select(TL_WA830REV2_GPIO_USB_POWER,
+				 AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(&tl_wa830re_v2_flash_data);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_wa830re_v2_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa830re_v2_leds_gpio) - 1,
+				 tl_wa830re_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WA830REV2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa830re_v2_gpio_keys),
+					tl_wa830re_v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA830RE_V2, "TL-WA830RE-v2", "TP-LINK TL-WA830RE v2",
+	     tl_wa830re_v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa901nd.c linux-4.1.13/arch/mips/ath79/mach-tl-wa901nd.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa901nd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wa901nd.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,127 @@
+/*
+ *  TP-LINK TL-WA901N/ND v1, TL-WA7510N v1 board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *  Copyright (C) 2012 Stefan Helmert <helst_listen@aol.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define TL_WA901ND_GPIO_LED_QSS		0
+#define TL_WA901ND_GPIO_LED_SYSTEM	1
+#define TL_WA901ND_GPIO_LED_LAN		13
+
+#define TL_WA901ND_GPIO_BTN_RESET	11
+#define TL_WA901ND_GPIO_BTN_QSS		12
+
+#define TL_WA901ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WA901ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa901nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa901nd_flash_data = {
+	.part_probes	= tl_wa901nd_part_probes,
+};
+
+static struct gpio_led tl_wa901nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA901ND_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA901ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA901ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WA901ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init common_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	/*
+	 * ath79_eth0 would be the WAN port, but is not connected.
+	 * ath79_eth1 connects to the internal switch chip, however
+	 * we have a single LAN port only.
+	 */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&tl_wa901nd_flash_data);
+}
+
+static void __init tl_wa901nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_leds_gpio),
+				 tl_wa901nd_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA901ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa901nd_gpio_keys),
+					tl_wa901nd_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND, "TL-WA901ND", "TP-LINK TL-WA901ND",
+	     tl_wa901nd_setup);
+
+static void __init tl_wa7510n_v1_setup(void)
+{
+	common_setup();
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA7510N_V1, "TL-WA7510N", "TP-LINK TL-WA7510N v1",
+	     tl_wa7510n_v1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa901nd-v2.c linux-4.1.13/arch/mips/ath79/mach-tl-wa901nd-v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wa901nd-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wa901nd-v2.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,104 @@
+/*
+ *  TP-LINK TL-WA901N/ND v2 board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Pieter Hollants <pieter@hollants.com>
+ *  Copyright (C) 2011 Jonathan Bennett <jbscience87@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WA901ND_V2_GPIO_LED_QSS		4
+#define TL_WA901ND_V2_GPIO_LED_SYSTEM		2
+#define TL_WA901ND_V2_GPIO_LED_WLAN		9
+
+#define TL_WA901ND_V2_GPIO_BTN_RESET		3
+#define TL_WA901ND_V2_GPIO_BTN_QSS		7
+
+#define TL_WA901ND_V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL	\
+					(3 * TL_WA901ND_V2_KEYS_POLL_INTERVAL)
+
+static const char *tl_wa901nd_v2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wa901nd_v2_flash_data = {
+	.part_probes	= tl_wa901nd_v2_part_probes,
+};
+
+static struct gpio_led tl_wa901nd_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_QSS,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA901ND_V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wa901nd_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WA901ND_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WA901ND_V2_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wa901nd_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = 0x00001000;
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.reset_bit = AR71XX_RESET_GE0_MAC |
+				    AR71XX_RESET_GE0_PHY;
+	ath79_register_eth(0);
+
+	ath79_register_m25p80(&tl_wa901nd_v2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa901nd_v2_leds_gpio),
+				 tl_wa901nd_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WA901ND_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa901nd_v2_gpio_keys),
+					tl_wa901nd_v2_gpio_keys);
+
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND_V2, "TL-WA901ND-v2",
+	     "TP-LINK TL-WA901ND v2", tl_wa901nd_v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wax50re.c linux-4.1.13/arch/mips/ath79/mach-tl-wax50re.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wax50re.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wax50re.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,313 @@
+/*
+ *  TP-LINK TL-WA750RE v1/TL-WA801ND v2/TL-WA850RE v1/TL-WA901ND v3
+ *  board support
+ *
+ *  Copyright (C) 2013 Martijn Zilverschoon <thefriedzombie@gmail.com>
+ *  Copyright (C) 2013 Jiri Pirko <jiri@resnulli.us>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WAX50RE_GPIO_LED_LAN		20
+#define TL_WAX50RE_GPIO_LED_WLAN	13
+#define TL_WAX50RE_GPIO_LED_RE		15
+#define TL_WAX50RE_GPIO_LED_SIGNAL1	0
+#define TL_WAX50RE_GPIO_LED_SIGNAL2	1
+#define TL_WAX50RE_GPIO_LED_SIGNAL3	2
+#define TL_WAX50RE_GPIO_LED_SIGNAL4	3
+#define TL_WAX50RE_GPIO_LED_SIGNAL5	4
+
+#define TL_WA860RE_GPIO_LED_WLAN_ORANGE	0
+#define TL_WA860RE_GPIO_LED_WLAN_GREEN	2
+#define TL_WA860RE_GPIO_LED_POWER_ORANGE	12
+#define TL_WA860RE_GPIO_LED_POWER_GREEN	14
+#define TL_WA860RE_GPIO_LED_LAN		20
+
+#define TL_WA801ND_V2_GPIO_LED_LAN	18
+#define TL_WA801ND_V2_GPIO_LED_SYSTEM	14
+
+#define TL_WAX50RE_GPIO_BTN_RESET	17
+#define TL_WAX50RE_GPIO_BTN_WPS		16
+
+#define TL_WA860RE_GPIO_BTN_RESET	17
+#define TL_WA860RE_GPIO_BTN_WPS		16
+#define TL_WA860RE_GPIO_BTN_ONOFF	11
+
+#define TL_WAX50RE_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL (3 * TL_WAX50RE_KEYS_POLL_INTERVAL)
+
+static const char *tl_wax50re_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wax50re_flash_data = {
+	.part_probes	= tl_wax50re_part_probes,
+};
+
+static struct gpio_led tl_wa750re_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:orange:lan",
+		.gpio		= TL_WAX50RE_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:wlan",
+		.gpio		= TL_WAX50RE_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:re",
+		.gpio		= TL_WAX50RE_GPIO_LED_RE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal1",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal2",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal3",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal4",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:signal5",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL5,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led tl_wa850re_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:lan",
+		.gpio		= TL_WAX50RE_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:wlan",
+		.gpio		= TL_WAX50RE_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:re",
+		.gpio		= TL_WAX50RE_GPIO_LED_RE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal1",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal2",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal3",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal4",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:blue:signal5",
+		.gpio		= TL_WAX50RE_GPIO_LED_SIGNAL5,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led tl_wa860re_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA860RE_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:power",
+		.gpio		= TL_WA860RE_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:power",
+		.gpio		= TL_WA860RE_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WA860RE_GPIO_LED_WLAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:orange:wlan",
+		.gpio		= TL_WA860RE_GPIO_LED_WLAN_ORANGE,
+		.active_low	= 1,
+	},
+};
+
+
+static struct gpio_keys_button tl_wax50re_gpio_keys[] __initdata = {
+	{
+		.desc		   = "Reset button",
+		.type		   = EV_KEY,
+		.code		   = KEY_RESTART,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WAX50RE_GPIO_BTN_RESET,
+		.active_low	   = 1,
+	}, {
+		.desc		   = "WPS",
+		.type		   = EV_KEY,
+		.code		   = KEY_WPS_BUTTON,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WAX50RE_GPIO_BTN_WPS,
+		.active_low	   = 1,
+	},
+};
+
+static struct gpio_keys_button tl_wa860re_gpio_keys[] __initdata = {
+	{
+		.desc		   = "Reset button",
+		.type		   = EV_KEY,
+		.code		   = KEY_RESTART,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WA860RE_GPIO_BTN_RESET,
+		.active_low	   = 1,
+	}, {
+		.desc		   = "WPS",
+		.type		   = EV_KEY,
+		.code		   = KEY_WPS_BUTTON,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WA860RE_GPIO_BTN_WPS,
+		.active_low	   = 1,
+	}, {
+		.desc		   = "ONOFF",
+		.type		   = EV_KEY,
+		.code		   = BTN_1,
+		.debounce_interval = TL_WAX50RE_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		   = TL_WA860RE_GPIO_BTN_ONOFF,
+		.active_low	   = 1,
+	},
+};
+
+static struct gpio_led tl_wa801nd_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan",
+		.gpio		= TL_WA801ND_V2_GPIO_LED_LAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WAX50RE_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WAX50RE_GPIO_LED_RE,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WA801ND_V2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static void __init tl_ap123_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wax50re_flash_data);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void  __init tl_wa750re_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa750re_leds_gpio),
+				 tl_wa750re_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys),
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA750RE, "TL-WA750RE", "TP-LINK TL-WA750RE",
+	     tl_wa750re_setup);
+
+static void __init tl_wa801nd_v2_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa801nd_v2_leds_gpio),
+			tl_wa801nd_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys),
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA801ND_V2, "TL-WA801ND-v2", "TP-LINK TL-WA801ND v2",
+	     tl_wa801nd_v2_setup);
+
+static void  __init tl_wa850re_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa850re_leds_gpio),
+				 tl_wa850re_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys),
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA850RE, "TL-WA850RE", "TP-LINK TL-WA850RE",
+	     tl_wa850re_setup);
+
+static void  __init tl_wa860re_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa860re_leds_gpio),
+				 tl_wa860re_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wa860re_gpio_keys),
+					tl_wa860re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA860RE, "TL-WA860RE", "TP-LINK TL-WA860RE",
+	     tl_wa860re_setup);
+
+static void __init tl_wa901nd_v3_setup(void)
+{
+	tl_ap123_setup();
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wa801nd_v2_leds_gpio),
+			tl_wa801nd_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WAX50RE_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wax50re_gpio_keys) - 1,
+					tl_wax50re_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WA901ND_V3, "TL-WA901ND-v3", "TP-LINK TL-WA901ND v3",
+	     tl_wa901nd_v3_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wdr3320-v2.c linux-4.1.13/arch/mips/ath79/mach-tl-wdr3320-v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wdr3320-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wdr3320-v2.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,146 @@
+/*
+ *  TP-LINK TL-WDR3320 v2 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2015 Weijie Gao <hackpascal@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WDR3320_GPIO_LED_WLAN5G		12
+#define WDR3320_GPIO_LED_SYSTEM		14
+#define WDR3320_GPIO_LED_QSS		15
+#define WDR3320_GPIO_LED_WAN		4
+#define WDR3320_GPIO_LED_LAN1		18
+#define WDR3320_GPIO_LED_LAN2		20
+#define WDR3320_GPIO_LED_LAN3		21
+#define WDR3320_GPIO_LED_LAN4		22
+
+#define WDR3320_GPIO_BTN_RESET		16
+
+#define WDR3320_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WDR3320_KEYS_DEBOUNCE_INTERVAL	(3 * WDR3320_KEYS_POLL_INTERVAL)
+
+#define WDR3320_WMAC_CALDATA_OFFSET	0x1000
+#define WDR3320_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *wdr3320_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data wdr3320_flash_data = {
+	.part_probes	= wdr3320_part_probes,
+};
+
+static struct gpio_led wdr3320_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:qss",
+		.gpio		= WDR3320_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= WDR3320_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan5g",
+		.gpio		= WDR3320_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wdr3320_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WDR3320_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR3320_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init wdr3320_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&wdr3320_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wdr3320_leds_gpio),
+				 wdr3320_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WDR3320_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wdr3320_gpio_keys),
+					wdr3320_gpio_keys);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_register_wmac(art + WDR3320_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	ap91_pci_init(art + WDR3320_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+
+	ath79_gpio_output_select(WDR3320_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_LED_LINK0);
+	ath79_gpio_output_select(WDR3320_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_LED_LINK1);
+	ath79_gpio_output_select(WDR3320_GPIO_LED_LAN3,
+				 AR934X_GPIO_OUT_LED_LINK2);
+	ath79_gpio_output_select(WDR3320_GPIO_LED_LAN4,
+				 AR934X_GPIO_OUT_LED_LINK3);
+	ath79_gpio_output_select(WDR3320_GPIO_LED_WAN,
+				 AR934X_GPIO_OUT_LED_LINK4);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR3320_V2, "TL-WDR3320-v2",
+	     "TP-LINK TL-WDR3320 v2",
+	     wdr3320_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wdr3500.c linux-4.1.13/arch/mips/ath79/mach-tl-wdr3500.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wdr3500.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wdr3500.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,169 @@
+/*
+ *  TP-LINK TL-WDR3500 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 Gui Iribarren <gui@altermundi.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WDR3500_GPIO_LED_USB		11
+#define WDR3500_GPIO_LED_WLAN2G		13
+#define WDR3500_GPIO_LED_SYSTEM		14
+#define WDR3500_GPIO_LED_QSS		15
+#define WDR3500_GPIO_LED_WAN		18
+#define WDR3500_GPIO_LED_LAN1		19
+#define WDR3500_GPIO_LED_LAN2		20
+#define WDR3500_GPIO_LED_LAN3		21
+#define WDR3500_GPIO_LED_LAN4		22
+
+#define WDR3500_GPIO_BTN_WPS		16
+#define WDR3500_GPIO_BTN_RFKILL		17
+
+#define WDR3500_GPIO_USB_POWER		12
+
+#define WDR3500_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WDR3500_KEYS_DEBOUNCE_INTERVAL	(3 * WDR3500_KEYS_POLL_INTERVAL)
+
+#define WDR3500_MAC0_OFFSET		0
+#define WDR3500_MAC1_OFFSET		6
+#define WDR3500_WMAC_CALDATA_OFFSET	0x1000
+#define WDR3500_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *wdr3500_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data wdr3500_flash_data = {
+	.part_probes	= wdr3500_part_probes,
+};
+
+static struct gpio_led wdr3500_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:qss",
+		.gpio		= WDR3500_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= WDR3500_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= WDR3500_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan2g",
+		.gpio		= WDR3500_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wdr3500_gpio_keys[] __initdata = {
+	{
+		.desc		= "QSS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WDR3500_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR3500_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WDR3500_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR3500_GPIO_BTN_RFKILL,
+	},
+};
+
+
+static void __init wdr3500_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&wdr3500_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wdr3500_leds_gpio),
+				 wdr3500_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WDR3500_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wdr3500_gpio_keys),
+					wdr3500_gpio_keys);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_register_wmac(art + WDR3500_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_init_mac(tmpmac, mac, 1);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	ap91_pci_init(art + WDR3500_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 2);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	gpio_request_one(WDR3500_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_gpio_output_select(WDR3500_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_LED_LINK3);
+	ath79_gpio_output_select(WDR3500_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_LED_LINK2);
+	ath79_gpio_output_select(WDR3500_GPIO_LED_LAN3,
+				 AR934X_GPIO_OUT_LED_LINK1);
+	ath79_gpio_output_select(WDR3500_GPIO_LED_LAN4,
+				 AR934X_GPIO_OUT_LED_LINK0);
+	ath79_gpio_output_select(WDR3500_GPIO_LED_WAN,
+				 AR934X_GPIO_OUT_LED_LINK4);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR3500, "TL-WDR3500",
+	     "TP-LINK TL-WDR3500",
+	     wdr3500_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wdr4300.c linux-4.1.13/arch/mips/ath79/mach-tl-wdr4300.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wdr4300.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wdr4300.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,206 @@
+/*
+ *  TP-LINK TL-WDR4300 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WDR4300_GPIO_LED_USB1		11
+#define WDR4300_GPIO_LED_USB2		12
+#define WDR4300_GPIO_LED_WLAN2G		13
+#define WDR4300_GPIO_LED_SYSTEM		14
+#define WDR4300_GPIO_LED_QSS		15
+
+#define WDR4300_GPIO_BTN_WPS		16
+#define WDR4300_GPIO_BTN_RFKILL		17
+
+#define WDR4300_GPIO_EXTERNAL_LNA0	18
+#define WDR4300_GPIO_EXTERNAL_LNA1	19
+
+#define WDR4300_GPIO_USB1_POWER		22
+#define WDR4300_GPIO_USB2_POWER		21
+
+#define WDR4300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WDR4300_KEYS_DEBOUNCE_INTERVAL	(3 * WDR4300_KEYS_POLL_INTERVAL)
+
+#define WDR4300_MAC0_OFFSET		0
+#define WDR4300_MAC1_OFFSET		6
+#define WDR4300_WMAC_CALDATA_OFFSET	0x1000
+#define WDR4300_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *wdr4300_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data wdr4300_flash_data = {
+	.part_probes	= wdr4300_part_probes,
+};
+
+static struct gpio_led wdr4300_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:qss",
+		.gpio		= WDR4300_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= WDR4300_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb1",
+		.gpio		= WDR4300_GPIO_LED_USB1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb2",
+		.gpio		= WDR4300_GPIO_LED_USB2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan2g",
+		.gpio		= WDR4300_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wdr4300_gpio_keys[] __initdata = {
+	{
+		.desc		= "QSS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR4300_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WDR4300_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info wdr4300_leds_ar8327[] __initconst = {
+	AR8327_LED_INFO(PHY0_0, HW, "tp-link:blue:wan"),
+	AR8327_LED_INFO(PHY1_0, HW, "tp-link:blue:lan1"),
+	AR8327_LED_INFO(PHY2_0, HW, "tp-link:blue:lan2"),
+	AR8327_LED_INFO(PHY3_0, HW, "tp-link:blue:lan3"),
+	AR8327_LED_INFO(PHY4_0, HW, "tp-link:blue:lan4"),
+};
+
+static struct ar8327_pad_cfg wdr4300_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wdr4300_ar8327_led_cfg = {
+	.led_ctrl0 = 0xc737c737,
+	.led_ctrl1 = 0x00000000,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x0030c300,
+	.open_drain = false,
+};
+
+static struct ar8327_platform_data wdr4300_ar8327_data = {
+	.pad0_cfg = &wdr4300_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wdr4300_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(wdr4300_leds_ar8327),
+	.leds = wdr4300_leds_ar8327,
+};
+
+static struct mdio_board_info wdr4300_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &wdr4300_ar8327_data,
+	},
+};
+
+static void __init wdr4300_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&wdr4300_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wdr4300_leds_gpio),
+				 wdr4300_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WDR4300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wdr4300_gpio_keys),
+					wdr4300_gpio_keys);
+
+	ath79_wmac_set_ext_lna_gpio(0, WDR4300_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, WDR4300_GPIO_EXTERNAL_LNA1);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ath79_register_wmac(art + WDR4300_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ap9x_pci_setup_wmac_led_pin(0, 0);
+	ap91_pci_init(art + WDR4300_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(wdr4300_mdio0_info,
+				    ARRAY_SIZE(wdr4300_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -2);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	gpio_request_one(WDR4300_GPIO_USB1_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB1 power");
+	gpio_request_one(WDR4300_GPIO_USB2_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB2 power");
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR4300, "TL-WDR4300",
+	     "TP-LINK TL-WDR3600/4300/4310",
+	     wdr4300_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wdr6500-v2.c linux-4.1.13/arch/mips/ath79/mach-tl-wdr6500-v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wdr6500-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wdr6500-v2.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,141 @@
+/*
+ *  TP-LINK TL-WDR6500 v2
+ *
+ *  Copyright (C) 2015 Weijie Gao <hackpascal@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define TL_WDR6500_V2_GPIO_LED_SYS	21
+#define TL_WDR6500_V2_GPIO_LED_WAN	18
+#define TL_WDR6500_V2_GPIO_LED_LAN1	17
+#define TL_WDR6500_V2_GPIO_LED_LAN2	16
+#define TL_WDR6500_V2_GPIO_LED_LAN3	15
+#define TL_WDR6500_V2_GPIO_LED_LAN4	14
+
+#define TL_WDR6500_V2_GPIO_BTN_RESET	1
+
+#define TL_WDR6500_V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WDR6500_V2_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WDR6500_V2_KEYS_POLL_INTERVAL)
+
+#define TL_WDR6500_V2_WMAC_CALDATA_OFFSET	0x1000
+#define TL_WDR6500_V2_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *tl_wdr6500_v2_part_probes[] = {
+	"tp-link-64k",
+	NULL,
+};
+
+static struct flash_platform_data tl_wdr6500_v2_flash_data = {
+	.part_probes	= tl_wdr6500_v2_part_probes,
+};
+
+static struct gpio_led tl_wdr6500_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:white:system",
+		.gpio		= TL_WDR6500_V2_GPIO_LED_SYS,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_wdr6500_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WDR6500_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WDR6500_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+
+static void __init tl_ap151_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f00fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&tl_wdr6500_v2_flash_data);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	/* LAN */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	ath79_init_mac(tmpmac, mac, -1);
+	ath79_register_wmac(ee + TL_WDR6500_V2_WMAC_CALDATA_OFFSET, tmpmac);
+
+	ath79_register_pci();
+
+	ath79_register_usb();
+}
+
+static void __init tl_wdr6500_v2_setup(void)
+{
+	tl_ap151_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wdr6500_v2_leds_gpio),
+				 tl_wdr6500_v2_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WDR6500_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wdr6500_v2_gpio_keys),
+					tl_wdr6500_v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WDR6500_V2, "TL-WDR6500-v2", "TP-LINK TL-WDR6500 v2",
+	     tl_wdr6500_v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr1041n-v2.c linux-4.1.13/arch/mips/ath79/mach-tl-wr1041n-v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr1041n-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr1041n-v2.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,138 @@
+/*
+ *  TP-LINK TL-WR1041 v2 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2011-2012 Anan Huang <axishero@foxmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR1041NV2_GPIO_BTN_RESET	14
+#define TL_WR1041NV2_GPIO_LED_WPS	13
+#define TL_WR1041NV2_GPIO_LED_WLAN	11
+
+#define TL_WR1041NV2_GPIO_LED_SYSTEM	12
+
+#define TL_WR1041NV2_KEYS_POLL_INTERVAL		20	/* msecs */
+#define TL_WR1041NV2_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR1041NV2_KEYS_POLL_INTERVAL)
+
+#define TL_WR1041NV2_PCIE_CALDATA_OFFSET	0x5000
+
+static const char *tl_wr1041nv2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr1041nv2_flash_data = {
+	.part_probes	= tl_wr1041nv2_part_probes,
+};
+
+static struct gpio_led tl_wr1041nv2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1041NV2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR1041NV2_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1041NV2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr1041nv2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1041NV2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1041NV2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct ar8327_pad_cfg db120_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data db120_ar8327_data = {
+	.pad0_cfg = &db120_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	}
+};
+
+static struct mdio_board_info db120_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &db120_ar8327_data,
+	},
+};
+
+static void __init tl_wr1041nv2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr1041nv2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1041nv2_leds_gpio),
+				 tl_wr1041nv2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR1041NV2_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(tl_wr1041nv2_gpio_keys),
+					 tl_wr1041nv2_gpio_keys);
+	ath79_register_wmac(ee, mac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+
+	mdiobus_register_board_info(db120_mdio0_info,
+				    ARRAY_SIZE(db120_mdio0_info));
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1041N_V2, "TL-WR1041N-v2",
+	     "TP-LINK TL-WR1041N v2", tl_wr1041nv2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr1043nd.c linux-4.1.13/arch/mips/ath79/mach-tl-wr1043nd.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr1043nd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr1043nd.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,141 @@
+/*
+ *  TP-LINK TL-WR1043N/ND board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR1043ND_GPIO_LED_USB        1
+#define TL_WR1043ND_GPIO_LED_SYSTEM     2
+#define TL_WR1043ND_GPIO_LED_QSS        5
+#define TL_WR1043ND_GPIO_LED_WLAN       9
+
+#define TL_WR1043ND_GPIO_BTN_RESET      3
+#define TL_WR1043ND_GPIO_BTN_QSS        7
+
+#define TL_WR1043ND_GPIO_RTL8366_SDA	18
+#define TL_WR1043ND_GPIO_RTL8366_SCK	19
+
+#define TL_WR1043ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR1043ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr1043nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr1043nd_flash_data = {
+	.part_probes	= tl_wr1043nd_part_probes,
+};
+
+static struct gpio_led tl_wr1043nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= TL_WR1043ND_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1043ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR1043ND_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1043ND_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr1043nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR1043ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void tl_wr1043nd_rtl8366rb_hw_reset(bool active)
+{
+	if (active)
+		ath79_device_reset_set(AR71XX_RESET_GE0_PHY);
+	else
+		ath79_device_reset_clear(AR71XX_RESET_GE0_PHY);
+}
+
+static struct rtl8366_platform_data tl_wr1043nd_rtl8366rb_data = {
+	.gpio_sda	= TL_WR1043ND_GPIO_RTL8366_SDA,
+	.gpio_sck	= TL_WR1043ND_GPIO_RTL8366_SCK,
+	.hw_reset	= tl_wr1043nd_rtl8366rb_hw_reset,
+};
+
+static struct platform_device tl_wr1043nd_rtl8366rb_device = {
+	.name		= RTL8366RB_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tl_wr1043nd_rtl8366rb_data,
+	}
+};
+
+static void __init tl_wr1043nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	tl_wr1043nd_rtl8366rb_hw_reset(true);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.mii_bus_dev = &tl_wr1043nd_rtl8366rb_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x1a000000;
+
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(&tl_wr1043nd_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1043nd_leds_gpio),
+				 tl_wr1043nd_leds_gpio);
+
+	platform_device_register(&tl_wr1043nd_rtl8366rb_device);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR1043ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr1043nd_gpio_keys),
+					tl_wr1043nd_gpio_keys);
+
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1043ND, "TL-WR1043ND", "TP-LINK TL-WR1043ND",
+	     tl_wr1043nd_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr1043nd-v2.c linux-4.1.13/arch/mips/ath79/mach-tl-wr1043nd-v2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr1043nd-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr1043nd-v2.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,215 @@
+/*
+ * TP-LINK TL-WR1043ND v2 board support
+ *
+ * Copyright (c) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ *   Copyright (c) 2012 Qualcomm Atheros
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR1043_V2_GPIO_LED_WLAN	12
+#define TL_WR1043_V2_GPIO_LED_USB	15
+#define TL_WR1043_V2_GPIO_LED_WPS	18
+#define TL_WR1043_V2_GPIO_LED_SYSTEM	19
+
+#define TL_WR1043_V2_GPIO_BTN_RESET	16
+#define TL_WR1043_V2_GPIO_BTN_RFKILL	17
+
+#define TL_WR1043_V2_GPIO_USB_POWER	21
+
+#define TL_WR1043_V2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR1043_V2_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR1043_V2_KEYS_POLL_INTERVAL)
+
+#define TL_WR1043_V2_WMAC_CALDATA_OFFSET	0x1000
+
+static const char *wr1043nd_v2_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data wr1043nd_v2_flash_data = {
+	.part_probes	= wr1043nd_v2_part_probes,
+};
+
+static struct gpio_led tl_wr1043_v2_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR1043_V2_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR1043_V2_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR1043_V2_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= TL_WR1043_V2_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr1043_v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR1043_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043_V2_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR1043_V2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR1043_V2_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info tl_wr1043_leds_ar8327[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "tp-link:green:lan4"),
+	AR8327_LED_INFO(PHY1_0, HW, "tp-link:green:lan3"),
+	AR8327_LED_INFO(PHY2_0, HW, "tp-link:green:lan2"),
+	AR8327_LED_INFO(PHY3_0, HW, "tp-link:green:lan1"),
+	AR8327_LED_INFO(PHY4_0, HW, "tp-link:green:wan"),
+};
+
+/* GMAC0 of the AR8327 switch is connected to the QCA9558 SoC via SGMII */
+static struct ar8327_pad_cfg wr1043nd_v2_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+/* GMAC6 of the AR8327 switch is connected to the QCA9558 SoC via RGMII */
+static struct ar8327_pad_cfg wr1043nd_v2_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wr1043nd_v2_ar8327_led_cfg = {
+	.led_ctrl0 = 0xcc35cc35,
+	.led_ctrl1 = 0xca35ca35,
+	.led_ctrl2 = 0xc935c935,
+	.led_ctrl3 = 0x03ffff00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data wr1043nd_v2_ar8327_data = {
+	.pad0_cfg = &wr1043nd_v2_ar8327_pad0_cfg,
+	.pad6_cfg = &wr1043nd_v2_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wr1043nd_v2_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(tl_wr1043_leds_ar8327),
+	.leds = tl_wr1043_leds_ar8327,
+};
+
+static struct mdio_board_info wr1043nd_v2_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &wr1043nd_v2_ar8327_data,
+	},
+};
+
+static void __init tl_wr1043nd_v2_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(&wr1043nd_v2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr1043_v2_leds_gpio),
+				 tl_wr1043_v2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR1043_V2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr1043_v2_gpio_keys),
+					tl_wr1043_v2_gpio_keys);
+
+	ath79_register_wmac(art + TL_WR1043_V2_WMAC_CALDATA_OFFSET, mac);
+
+	mdiobus_register_board_info(wr1043nd_v2_mdio0_info,
+				    ARRAY_SIZE(wr1043nd_v2_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	gpio_request_one(TL_WR1043_V2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR1043ND_V2, "TL-WR1043ND-v2",
+	     "TP-LINK TL-WR1043ND v2", tl_wr1043nd_v2_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr2543n.c linux-4.1.13/arch/mips/ath79/mach-tl-wr2543n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr2543n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr2543n.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,156 @@
+/*
+ *  TP-LINK TL-WR2543N/ND board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/rtl8367.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define TL_WR2543N_GPIO_LED_WPS        0
+#define TL_WR2543N_GPIO_LED_USB        8
+
+/* The WLAN LEDs use GPIOs on the discrete AR9380 wmac */
+#define TL_WR2543N_GPIO_WMAC_LED_WLAN2G 0
+#define TL_WR2543N_GPIO_WMAC_LED_WLAN5G 1
+
+#define TL_WR2543N_GPIO_BTN_RESET      11
+#define TL_WR2543N_GPIO_BTN_WPS        12
+
+#define TL_WR2543N_GPIO_RTL8367_SDA	1
+#define TL_WR2543N_GPIO_RTL8367_SCK	6
+
+#define TL_WR2543N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR2543N_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR2543N_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr2543n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr2543n_flash_data = {
+	.part_probes	= tl_wr2543n_part_probes,
+};
+
+static struct gpio_led tl_wr2543n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:usb",
+		.gpio		= TL_WR2543N_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wps",
+		.gpio		= TL_WR2543N_GPIO_LED_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led tl_wr2543n_wmac_leds_gpio[] = {
+	{
+		.name		= "tp-link:green:wlan5g",
+		.gpio		= TL_WR2543N_GPIO_WMAC_LED_WLAN5G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr2543n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR2543N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR2543N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR2543N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR2543N_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8367_extif_config tl_wr2543n_rtl8367_extif0_cfg = {
+	.mode = RTL8367_EXTIF_MODE_RGMII,
+	.txdelay = 1,
+	.rxdelay = 0,
+	.ability = {
+		.force_mode = 1,
+		.txpause = 1,
+		.rxpause = 1,
+		.link = 1,
+		.duplex = 1,
+		.speed = RTL8367_PORT_SPEED_1000,
+	},
+};
+
+static struct rtl8367_platform_data tl_wr2543n_rtl8367_data = {
+	.gpio_sda	= TL_WR2543N_GPIO_RTL8367_SDA,
+	.gpio_sck	= TL_WR2543N_GPIO_RTL8367_SCK,
+	.extif0_cfg	= &tl_wr2543n_rtl8367_extif0_cfg,
+};
+
+static struct platform_device tl_wr2543n_rtl8367_device = {
+	.name		= RTL8367_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &tl_wr2543n_rtl8367_data,
+	}
+};
+
+static void __init tl_wr2543n_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr2543n_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr2543n_leds_gpio),
+				 tl_wr2543n_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR2543N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr2543n_gpio_keys),
+					tl_wr2543n_gpio_keys);
+	ath79_register_usb();
+
+	/*
+	 * The ath9k driver uses this pin for its default led device, which is
+	 * named ath9k-phy0, and reflects activity on either the 2 GHz or 5 GHz
+	 * bands. This pin is connected to the WR2543's 2GHz WLAN LED.
+	 */
+	ap9x_pci_setup_wmac_led_pin(0, TL_WR2543N_GPIO_WMAC_LED_WLAN2G);
+
+	/*
+	 * We also have the driver set up an led device for the WR2543's
+	 * separate 5 GHz WLAN LED in case the user wants it.
+	 */
+	ap9x_pci_setup_wmac_leds(0, tl_wr2543n_wmac_leds_gpio,
+				 ARRAY_SIZE(tl_wr2543n_wmac_leds_gpio));
+	ap91_pci_init(eeprom, mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_eth0_data.mii_bus_dev = &tl_wr2543n_rtl8367_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_pll_data.pll_1000 = 0x1a000000;
+
+	ath79_register_eth(0);
+
+	platform_device_register(&tl_wr2543n_rtl8367_device);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR2543N, "TL-WR2543N", "TP-LINK TL-WR2543N/ND",
+	     tl_wr2543n_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr703n.c linux-4.1.13/arch/mips/ath79/mach-tl-wr703n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr703n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr703n.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,118 @@
+/*
+ *  TP-LINK TL-WR703N/TL-MR10U board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR703N_GPIO_LED_SYSTEM	27
+#define TL_WR703N_GPIO_BTN_RESET	11
+
+#define TL_WR703N_GPIO_USB_POWER	8
+
+#define TL_MR10U_GPIO_USB_POWER		18
+
+#define TL_WR703N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR703N_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR703N_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr703n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr703n_flash_data = {
+	.part_probes	= tl_wr703n_part_probes,
+};
+
+static struct gpio_led tl_wr703n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR703N_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr703n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR703N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR703N_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}
+};
+
+static void __init common_setup(unsigned usb_power_gpio, bool sec_ethernet)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_wr703n_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr703n_leds_gpio),
+				 tl_wr703n_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR703N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr703n_gpio_keys),
+					tl_wr703n_gpio_keys);
+
+	gpio_request_one(usb_power_gpio,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+
+	if (sec_ethernet)
+	{
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+		ath79_register_eth(1);
+	}
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_mr10u_setup(void)
+{
+	common_setup(TL_MR10U_GPIO_USB_POWER, false);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR10U, "TL-MR10U", "TP-LINK TL-MR10U",
+	     tl_mr10u_setup);
+
+static void __init tl_wr703n_setup(void)
+{
+	common_setup(TL_WR703N_GPIO_USB_POWER, false);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR703N, "TL-WR703N", "TP-LINK TL-WR703N v1",
+	     tl_wr703n_setup);
+
+static void __init tl_wr710n_setup(void)
+{
+	common_setup(TL_WR703N_GPIO_USB_POWER, true);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR710N, "TL-WR710N", "TP-LINK TL-WR710N v1",
+	     tl_wr710n_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr720n-v3.c linux-4.1.13/arch/mips/ath79/mach-tl-wr720n-v3.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr720n-v3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr720n-v3.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,108 @@
+/*
+ *  TP-LINK TL-WR720N board support
+ *
+ *  Copyright (C) 2011 dongyuqi <729650915@qq.com>
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2013 yousong <yszhou4tech@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR720N_GPIO_LED_SYSTEM	27
+#define TL_WR720N_GPIO_BTN_RESET	11
+#define TL_WR720N_GPIO_BTN_SW1		18
+#define TL_WR720N_GPIO_BTN_SW2		20
+
+#define TL_WR720N_GPIO_USB_POWER	8
+
+#define TL_WR720N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR720N_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR720N_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr720n_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr720n_flash_data = {
+	.part_probes	= tl_wr720n_part_probes,
+};
+
+static struct gpio_led tl_wr720n_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR720N_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr720n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR720N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR720N_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}, {
+		.desc		= "sw1",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = TL_WR720N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR720N_GPIO_BTN_SW1,
+		.active_low = 0,
+	}, {
+		.desc		= "sw2",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = TL_WR720N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR720N_GPIO_BTN_SW2,
+		.active_low = 0,
+	}
+};
+
+static void __init tl_wr720n_v3_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* disable PHY_SWAP and PHY_ADDR_SWAP bits */
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_m25p80(&tl_wr720n_flash_data);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr720n_leds_gpio),
+					tl_wr720n_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TL_WR720N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr720n_gpio_keys),
+					tl_wr720n_gpio_keys);
+
+	gpio_request_one(TL_WR720N_GPIO_USB_POWER,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"USB power");
+	ath79_register_usb();
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 2);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR720N_V3, "TL-WR720N-v3", "TP-LINK TL-WR720N v3/v4",
+		tl_wr720n_v3_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr741nd.c linux-4.1.13/arch/mips/ath79/mach-tl-wr741nd.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr741nd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr741nd.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,130 @@
+/*
+ *  TP-LINK TL-WR741ND board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define TL_WR741ND_GPIO_LED_QSS		0
+#define TL_WR741ND_GPIO_LED_SYSTEM	1
+#define TL_WR741ND_GPIO_LED_LAN1	13
+#define TL_WR741ND_GPIO_LED_LAN2	14
+#define TL_WR741ND_GPIO_LED_LAN3	15
+#define TL_WR741ND_GPIO_LED_LAN4	16
+#define TL_WR741ND_GPIO_LED_WAN		17
+
+#define TL_WR741ND_GPIO_BTN_RESET	11
+#define TL_WR741ND_GPIO_BTN_QSS		12
+
+#define TL_WR741ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR741ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR741ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr741nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr741nd_flash_data = {
+	.part_probes	= tl_wr741nd_part_probes,
+};
+
+static struct gpio_led tl_wr741nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR741ND_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR741ND_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR741ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR741ND_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr741nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_wr741nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr741nd_flash_data);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr741nd_leds_gpio),
+				 tl_wr741nd_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR741ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr741nd_gpio_keys),
+					tl_wr741nd_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+	ap91_pci_init(ee, mac);
+}
+MIPS_MACHINE(ATH79_MACH_TL_WR741ND, "TL-WR741ND", "TP-LINK TL-WR741ND",
+	     tl_wr741nd_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr741nd-v4.c linux-4.1.13/arch/mips/ath79/mach-tl-wr741nd-v4.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr741nd-v4.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr741nd-v4.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,187 @@
+/*
+ *  TP-LINK TL-WR741ND v4/TL-MR3220 v2 board support
+ *
+ *  Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR741NDV4_GPIO_BTN_RESET	11
+#define TL_WR741NDV4_GPIO_BTN_WPS	26
+
+#define TL_WR741NDV4_GPIO_LED_WLAN	0
+#define TL_WR741NDV4_GPIO_LED_QSS	1
+#define TL_WR741NDV4_GPIO_LED_WAN	13
+#define TL_WR741NDV4_GPIO_LED_LAN1	14
+#define TL_WR741NDV4_GPIO_LED_LAN2	15
+#define TL_WR741NDV4_GPIO_LED_LAN3	16
+#define TL_WR741NDV4_GPIO_LED_LAN4	17
+#define TL_WR741NDV4_GPIO_LED_SYSTEM	27
+
+#define TL_MR3220V2_GPIO_BTN_WPS	11
+#define TL_MR3220V2_GPIO_BTN_WIFI	24
+
+#define TL_MR3220V2_GPIO_LED_3G		26
+#define TL_MR3220V2_GPIO_USB_POWER	8
+
+#define TL_WR741NDV4_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR741NDV4_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr741ndv4_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr741ndv4_flash_data = {
+	.part_probes	= tl_wr741ndv4_part_probes,
+};
+
+static struct gpio_led tl_wr741ndv4_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN1,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN2,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN3,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR741NDV4_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR741NDV4_GPIO_LED_QSS,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR741NDV4_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR741NDV4_GPIO_LED_WAN,
+		.active_low	= 0,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR741NDV4_GPIO_LED_WLAN,
+		.active_low	= 0,
+	}, {
+		/* the 3G LED is only present on the MR3220 v2 */
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3220V2_GPIO_LED_3G,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tl_wr741ndv4_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741NDV4_GPIO_BTN_RESET,
+		.active_low	= 0,
+	}, {
+		.desc		= "WPS",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR741NDV4_GPIO_BTN_WPS,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button tl_mr3220v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3220V2_GPIO_BTN_WPS,
+		.active_low	= 0,
+	}, {
+		.desc		= "WIFI button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR741NDV4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_MR3220V2_GPIO_BTN_WIFI,
+		.active_low	= 0,
+	}
+};
+
+static void __init tl_ap121_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_setup_ar933x_phy4_switch(true, true);
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(&tl_wr741ndv4_flash_data);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_wr741ndv4_setup(void)
+{
+	tl_ap121_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr741ndv4_leds_gpio) - 1,
+				 tl_wr741ndv4_leds_gpio);
+	ath79_register_gpio_keys_polled(1, TL_WR741NDV4_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr741ndv4_gpio_keys),
+					tl_wr741ndv4_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR741ND_V4, "TL-WR741ND-v4",
+	     "TP-LINK TL-WR741ND v4", tl_wr741ndv4_setup);
+
+static void __init tl_mr3220v2_setup(void)
+{
+	tl_ap121_setup();
+
+	gpio_request_one(TL_MR3220V2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr741ndv4_leds_gpio),
+				 tl_wr741ndv4_leds_gpio);
+	ath79_register_gpio_keys_polled(1, TL_WR741NDV4_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr3220v2_gpio_keys),
+					tl_mr3220v2_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3220_V2, "TL-MR3220-v2",
+	     "TP-LINK TL-MR3220 v2", tl_mr3220v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr841n.c linux-4.1.13/arch/mips/ath79/mach-tl-wr841n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr841n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr841n.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,140 @@
+/*
+ *  TP-LINK TL-WR841N/ND v1 board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define TL_WR841ND_V1_GPIO_LED_SYSTEM		2
+#define TL_WR841ND_V1_GPIO_LED_QSS_GREEN	4
+#define TL_WR841ND_V1_GPIO_LED_QSS_RED		5
+
+#define TL_WR841ND_V1_GPIO_BTN_RESET		3
+#define TL_WR841ND_V1_GPIO_BTN_QSS		7
+
+#define TL_WR841ND_V1_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL \
+				(3 * TL_WR841ND_V1_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition tl_wr841n_v1_partitions[] = {
+	{
+		.name		= "redboot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x280000,
+	}, {
+		.name		= "config",
+		.offset		= 0x3e0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3c0000,
+	}
+};
+
+static struct flash_platform_data tl_wr841n_v1_flash_data = {
+	.parts		= tl_wr841n_v1_partitions,
+	.nr_parts	= ARRAY_SIZE(tl_wr841n_v1_partitions),
+};
+
+static struct gpio_led tl_wr841n_v1_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:red:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR841ND_V1_GPIO_LED_QSS_GREEN,
+	}
+};
+
+static struct gpio_keys_button tl_wr841n_v1_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR841ND_V1_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841ND_V1_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr841n_v1_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr841n_v1_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr841n_v1_dsa_chip,
+};
+
+static void __init tl_wr841n_v1_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_dsa(&ath79_eth0_device.dev, &ath79_mdio0_device.dev,
+			   &tl_wr841n_v1_dsa_data);
+
+	ath79_register_m25p80(&tl_wr841n_v1_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v1_leds_gpio),
+				 tl_wr841n_v1_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR841ND_V1_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v1_gpio_keys),
+					tl_wr841n_v1_gpio_keys);
+	ath79_register_pci();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V1, "TL-WR841N-v1.5", "TP-LINK TL-WR841N v1",
+	     tl_wr841n_v1_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr841n-v8.c linux-4.1.13/arch/mips/ath79/mach-tl-wr841n-v8.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr841n-v8.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr841n-v8.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,286 @@
+/*
+ *  TP-LINK TL-WR841N/ND v8/TL-MR3420 v2 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR841NV8_GPIO_LED_WLAN	13
+#define TL_WR841NV8_GPIO_LED_QSS	15
+#define TL_WR841NV8_GPIO_LED_WAN	18
+#define TL_WR841NV8_GPIO_LED_LAN1	19
+#define TL_WR841NV8_GPIO_LED_LAN2	20
+#define TL_WR841NV8_GPIO_LED_LAN3	21
+#define TL_WR841NV8_GPIO_LED_LAN4	12
+#define TL_WR841NV8_GPIO_LED_SYSTEM	14
+
+#define TL_WR841NV8_GPIO_BTN_RESET	17
+#define TL_WR841NV8_GPIO_SW_RFKILL	16	/* WPS for MR3420 v2 */
+
+#define TL_MR3420V2_GPIO_LED_3G	11
+#define TL_MR3420V2_GPIO_USB_POWER	4
+
+#define TL_WR941NDV5_GPIO_LED_WLAN	13
+#define TL_WR941NDV5_GPIO_LED_QSS	15
+#define TL_WR941NDV5_GPIO_LED_WAN	18
+#define TL_WR941NDV5_GPIO_LED_LAN1	19
+#define TL_WR941NDV5_GPIO_LED_LAN2	20
+#define TL_WR941NDV5_GPIO_LED_LAN3	2
+#define TL_WR941NDV5_GPIO_LED_LAN4	3
+#define TL_WR941NDV5_GPIO_LED_SYSTEM	14
+
+#define TL_WR841NV8_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR841NV8_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr841n_v8_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr841n_v8_flash_data = {
+	.part_probes	= tl_wr841n_v8_part_probes,
+};
+
+static struct gpio_led tl_wr841n_v8_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR841NV8_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR841NV8_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR841NV8_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR841NV8_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR841NV8_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR841NV8_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR841NV8_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR841NV8_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		/* the 3G LED is only present on the MR3420 v2 */
+		.name		= "tp-link:green:3g",
+		.gpio		= TL_MR3420V2_GPIO_LED_3G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr841n_v8_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV8_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "RFKILL switch",
+		.type		= EV_SW,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV8_GPIO_SW_RFKILL,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button tl_mr3420v2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV8_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "WPS",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR841NV8_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV8_GPIO_SW_RFKILL,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led tl_wr941nd_v5_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR941NDV5_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR941NDV5_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR941NDV5_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR941NDV5_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR941NDV5_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR941NDV5_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR941NDV5_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR941NDV5_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static void __init tl_ap123_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* Disable JTAG, enabling GPIOs 0-3 */
+	/* Configure OBS4 line, for GPIO 4*/
+	ath79_gpio_function_setup(AR934X_GPIO_FUNC_JTAG_DISABLE,
+				 AR934X_GPIO_FUNC_CLK_OBS4_EN);
+
+	/* config gpio4 as normal gpio function */
+	ath79_gpio_output_select(TL_MR3420V2_GPIO_USB_POWER,
+				 AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_m25p80(&tl_wr841n_v8_flash_data);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, -1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+}
+
+static void __init tl_wr841n_v8_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v8_leds_gpio) - 1,
+				 tl_wr841n_v8_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV8_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v8_gpio_keys),
+					tl_wr841n_v8_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V8, "TL-WR841N-v8", "TP-LINK TL-WR841N/ND v8",
+	     tl_wr841n_v8_setup);
+
+
+static void __init tl_wr842n_v2_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v8_leds_gpio),
+				 tl_wr841n_v8_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV8_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v8_gpio_keys),
+					tl_wr841n_v8_gpio_keys);
+
+	gpio_request_one(TL_MR3420V2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR842N_V2, "TL-WR842N-v2", "TP-LINK TL-WR842N/ND v2",
+	     tl_wr842n_v2_setup);
+
+static void __init tl_mr3420v2_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v8_leds_gpio),
+				tl_wr841n_v8_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV8_KEYS_POLL_INTERVAL,
+				ARRAY_SIZE(tl_mr3420v2_gpio_keys),
+				tl_mr3420v2_gpio_keys);
+
+	/* enable power for the USB port */
+	gpio_request_one(TL_MR3420V2_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_MR3420_V2, "TL-MR3420-v2", "TP-LINK TL-MR3420 v2",
+	     tl_mr3420v2_setup);
+
+
+static void __init tl_wr941nd_v5_setup(void)
+{
+	tl_ap123_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_v5_leds_gpio),
+				 tl_wr941nd_v5_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV8_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v8_gpio_keys),
+					tl_wr841n_v8_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR941ND_V5, "TL-WR941ND-v5", "TP-LINK TL-WR941N/ND v5",
+	     tl_wr941nd_v5_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr841n-v9.c linux-4.1.13/arch/mips/ath79/mach-tl-wr841n-v9.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr841n-v9.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr841n-v9.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,144 @@
+/*
+ *  TP-LINK TL-WR841N/ND v9
+ *
+ *  Copyright (C) 2014 Matthias Schiffer <mschiffer@universe-factory.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR841NV9_GPIO_LED_WLAN	13
+#define TL_WR841NV9_GPIO_LED_QSS	3
+#define TL_WR841NV9_GPIO_LED_WAN	4
+#define TL_WR841NV9_GPIO_LED_LAN1	16
+#define TL_WR841NV9_GPIO_LED_LAN2	15
+#define TL_WR841NV9_GPIO_LED_LAN3	14
+#define TL_WR841NV9_GPIO_LED_LAN4	11
+
+#define TL_WR841NV9_GPIO_BTN_RESET	12
+#define TL_WR841NV9_GPIO_BTN_WIFI	17
+
+#define TL_WR841NV9_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR841NV9_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr841n_v9_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr841n_v9_flash_data = {
+	.part_probes	= tl_wr841n_v9_part_probes,
+};
+
+static struct gpio_led tl_wr841n_v9_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:lan1",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan2",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan3",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:lan4",
+		.gpio		= TL_WR841NV9_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR841NV9_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wan",
+		.gpio		= TL_WR841NV9_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR841NV9_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr841n_v9_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV9_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "WIFI button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR841NV9_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR841NV9_GPIO_BTN_WIFI,
+		.active_low	= 1,
+	}
+};
+
+
+static void __init tl_ap143_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(&tl_wr841n_v9_flash_data);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 0);
+	ath79_register_eth(1);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_register_eth(0);
+
+	ath79_init_mac(tmpmac, mac, 0);
+	ath79_register_wmac(ee, tmpmac);
+}
+
+static void __init tl_wr841n_v9_setup(void)
+{
+	tl_ap143_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr841n_v9_leds_gpio),
+				 tl_wr841n_v9_leds_gpio);
+
+	ath79_register_gpio_keys_polled(1, TL_WR841NV9_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr841n_v9_gpio_keys),
+					tl_wr841n_v9_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR841N_V9, "TL-WR841N-v9", "TP-LINK TL-WR841N/ND v9",
+	     tl_wr841n_v9_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr941nd.c linux-4.1.13/arch/mips/ath79/mach-tl-wr941nd.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr941nd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr941nd.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,121 @@
+/*
+ *  TP-LINK TL-WR941ND board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-dsa.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TL_WR941ND_GPIO_LED_SYSTEM	2
+#define TL_WR941ND_GPIO_LED_QSS_RED	4
+#define TL_WR941ND_GPIO_LED_QSS_GREEN	5
+#define TL_WR941ND_GPIO_LED_WLAN	9
+
+#define TL_WR941ND_GPIO_BTN_RESET	3
+#define TL_WR941ND_GPIO_BTN_QSS		7
+
+#define TL_WR941ND_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TL_WR941ND_KEYS_DEBOUNCE_INTERVAL (3 * TL_WR941ND_KEYS_POLL_INTERVAL)
+
+static const char *tl_wr941nd_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr941nd_flash_data = {
+	.part_probes	= tl_wr941nd_part_probes,
+};
+
+static struct gpio_led tl_wr941nd_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:green:system",
+		.gpio		= TL_WR941ND_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tp-link:red:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_RED,
+	}, {
+		.name		= "tp-link:green:qss",
+		.gpio		= TL_WR941ND_GPIO_LED_QSS_GREEN,
+	}, {
+		.name		= "tp-link:green:wlan",
+		.gpio		= TL_WR941ND_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button tl_wr941nd_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = TL_WR941ND_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static struct dsa_chip_data tl_wr941nd_dsa_chip = {
+	.port_names[0]  = "wan",
+	.port_names[1]  = "lan1",
+	.port_names[2]  = "lan2",
+	.port_names[3]  = "lan3",
+	.port_names[4]  = "lan4",
+	.port_names[5]  = "cpu",
+};
+
+static struct dsa_platform_data tl_wr941nd_dsa_data = {
+	.nr_chips	= 1,
+	.chip		= &tl_wr941nd_dsa_chip,
+};
+
+static void __init tl_wr941nd_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_dsa(&ath79_eth0_device.dev, &ath79_mdio0_device.dev,
+			   &tl_wr941nd_dsa_data);
+
+	ath79_register_m25p80(&tl_wr941nd_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_leds_gpio),
+				 tl_wr941nd_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR941ND_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr941nd_gpio_keys),
+					tl_wr941nd_gpio_keys);
+	ath79_register_wmac(eeprom, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR941ND, "TL-WR941ND", "TP-LINK TL-WR941ND",
+	     tl_wr941nd_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr941nd-v6.c linux-4.1.13/arch/mips/ath79/mach-tl-wr941nd-v6.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tl-wr941nd-v6.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tl-wr941nd-v6.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,149 @@
+/*
+ *  TP-LINK TL-WR941N/ND v6 board support
+ *
+ *  Copyright (C) 2015 Matthias Schiffer <mschiffer@universe-factory.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+
+#define TL_WR941ND_V6_GPIO_LED_QSS		3
+#define TL_WR941ND_V6_GPIO_LED_WAN		14
+#define TL_WR941ND_V6_GPIO_LED_WAN_RED		15
+#define TL_WR941ND_V6_GPIO_LED_LAN1		7
+#define TL_WR941ND_V6_GPIO_LED_LAN2		6
+#define TL_WR941ND_V6_GPIO_LED_LAN3		5
+#define TL_WR941ND_V6_GPIO_LED_LAN4		4
+#define TL_WR941ND_V6_GPIO_LED_WLAN		8
+#define TL_WR941ND_V6_GPIO_LED_SYSTEM		18
+
+#define TL_WR941ND_V6_GPIO_BTN_RESET		1
+#define TL_WR941ND_V6_GPIO_BTN_RFKILL		2
+
+#define TL_WR941ND_V6_KEYS_POLL_INTERVAL	20
+#define TL_WR941ND_V6_KEYS_DEBOUNCE_INTERVAL	(3 * TL_WR941ND_V6_KEYS_POLL_INTERVAL)
+
+
+static struct gpio_led tl_wr941nd_v6_leds_gpio[] __initdata = {
+	{
+		.name		= "tp-link:blue:qss",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_QSS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wan",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_WAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:red:wan",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_WAN_RED,
+		.active_low	= 0,
+	},
+	{
+		.name		= "tp-link:blue:lan1",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:lan2",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:lan3",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:lan4",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:wlan",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "tp-link:blue:system",
+		.gpio		= TL_WR941ND_V6_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button tl_wr941nd_v6_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TL_WR941ND_V6_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_V6_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = TL_WR941ND_V6_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TL_WR941ND_V6_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	}
+};
+
+
+static const char *tl_wr941n_v6_part_probes[] = {
+	"tp-link",
+	NULL,
+};
+
+static struct flash_platform_data tl_wr941n_v6_flash_data = {
+	.part_probes	= tl_wr941n_v6_part_probes,
+};
+
+
+static void __init tl_wr941nd_v6_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(&tl_wr941n_v6_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tl_wr941nd_v6_leds_gpio),
+				 tl_wr941nd_v6_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, TL_WR941ND_V6_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_wr941nd_v6_gpio_keys),
+					tl_wr941nd_v6_gpio_keys);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, -1);
+
+	ath79_switch_data.phy4_mii_en = 1;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, mac);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_TL_WR941ND_V6, "TL-WR941ND-v6", "TP-LINK TL-WR941N/ND v6",
+	     tl_wr941nd_v6_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-tube2h.c linux-4.1.13/arch/mips/ath79/mach-tube2h.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-tube2h.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-tube2h.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,118 @@
+/*
+ *  ALFA NETWORK Tube2H board support
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define TUBE2H_GPIO_LED_SIGNAL4		0
+#define TUBE2H_GPIO_LED_SIGNAL3		1
+#define TUBE2H_GPIO_LED_SIGNAL2		13
+#define TUBE2H_GPIO_LED_LAN		17
+#define TUBE2H_GPIO_LED_SIGNAL1		27
+#define TUBE2H_GPIO_EXT_LNA		28
+
+#define TUBE2H_GPIO_BTN_RESET		12
+
+#define TUBE2H_KEYS_POLL_INTERVAL	20	/* msecs */
+#define TUBE2H_KEYS_DEBOUNCE_INTERVAL	(3 * TUBE2H_KEYS_POLL_INTERVAL)
+
+#define TUBE2H_ART_ADDRESS		0x1f7f0000
+#define TUBE2H_LAN_MAC_OFFSET		0x06
+#define TUBE2H_CALDATA_OFFSET		0x1000
+
+static struct gpio_led tube2h_leds_gpio[] __initdata = {
+	{
+		.name		= "alfa:blue:lan",
+		.gpio		= TUBE2H_GPIO_LED_LAN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "alfa:red:signal1",
+		.gpio		= TUBE2H_GPIO_LED_SIGNAL1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "alfa:orange:signal2",
+		.gpio		= TUBE2H_GPIO_LED_SIGNAL2,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:green:signal3",
+		.gpio		= TUBE2H_GPIO_LED_SIGNAL3,
+		.active_low	= 0,
+	},
+	{
+		.name		= "alfa:green:signal4",
+		.gpio		= TUBE2H_GPIO_LED_SIGNAL4,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button tube2h_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = TUBE2H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= TUBE2H_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init tube2h_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(TUBE2H_ART_ADDRESS);
+	u32 t;
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_JTAG_DISABLE |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	/* Ensure that GPIO26 and GPIO27 are controllable by software */
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	gpio_request_one(TUBE2H_GPIO_EXT_LNA,
+			GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			"external LNA0");
+
+	ath79_register_wmac(art + TUBE2H_CALDATA_OFFSET, NULL);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(tube2h_leds_gpio),
+				 tube2h_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, TUBE2H_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(tube2h_gpio_keys),
+					tube2h_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + TUBE2H_LAN_MAC_OFFSET, 0);
+	ath79_register_mdio(0, 0x0);
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_TUBE2H, "TUBE2H", "ALFA NETWORK Tube2H",
+	     tube2h_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/machtypes.h linux-4.1.13/arch/mips/ath79/machtypes.h
--- linux-4.1.13.orig/arch/mips/ath79/machtypes.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/machtypes.h	2015-12-04 19:57:05.957975089 +0100
@@ -16,12 +16,224 @@
 
 enum ath79_mach_type {
 	ATH79_MACH_GENERIC = 0,
+	ATH79_MACH_ALFA_AP96,		/* ALFA Network AP96 board */
+	ATH79_MACH_ALFA_NX,		/* ALFA Network N2/N5 board */
+	ATH79_MACH_ALL0258N,		/* Allnet ALL0258N */
+	ATH79_MACH_ALL0305,		/* Allnet ALL0305 */
+	ATH79_MACH_ALL0315N,		/* Allnet ALL0315N */
+	ATH79_MACH_ANTMINER_S1,	/* Antminer S1 */
+	ATH79_MACH_ANTMINER_S3,	/* Antminer S3 */
+	ATH79_MACH_ARDUINO_YUN,		/* Yun */
+	ATH79_MACH_AP113,		/* Atheros AP113 reference board */
 	ATH79_MACH_AP121,		/* Atheros AP121 reference board */
+	ATH79_MACH_AP121_MINI,		/* Atheros AP121-MINI reference board */
+	ATH79_MACH_AP132,		/* Atheros AP132 reference board */
+	ATH79_MACH_AP135_020,		/* Atheros AP135-020 reference board */
 	ATH79_MACH_AP136_010,		/* Atheros AP136-010 reference board */
+	ATH79_MACH_AP136_020,		/* Atheros AP136-020 reference board */
+	ATH79_MACH_AP143,		/* Atheros AP143 reference board */
+	ATH79_MACH_AP147_010,		/* Atheros AP147-010 reference board */
+	ATH79_MACH_AP152,		/* Atheros AP152 reference board */
 	ATH79_MACH_AP81,		/* Atheros AP81 reference board */
+	ATH79_MACH_AP83,		/* Atheros AP83 */
+	ATH79_MACH_AP96,		/* Atheros AP96 */
+	ATH79_MACH_ARCHER_C5,		/* TP-LINK Archer C5 board */
+	ATH79_MACH_ARCHER_C7,		/* TP-LINK Archer C7 board */
+	ATH79_MACH_AW_NR580,		/* AzureWave AW-NR580 */
+	ATH79_MACH_BHU_BXU2000N2_A1,	/* BHU BXU2000n-2 A1 */
+	ATH79_MACH_BSB,			/* Smart Electronics Black Swift board */
+	ATH79_MACH_CAP4200AG,		/* Senao CAP4200AG */
+	ATH79_MACH_CARAMBOLA2,		/* 8devices Carambola2 */
+	ATH79_MACH_CF_E316N_V2,		/* COMFAST CF-E316N v2 */
+	ATH79_MACH_CPE510,		/* TP-LINK CPE510 */
 	ATH79_MACH_DB120,		/* Atheros DB120 reference board */
 	ATH79_MACH_PB44,		/* Atheros PB44 reference board */
+	ATH79_MACH_DGL_5500_A1,		/* D-link DGL-5500 rev. A1 */
+	ATH79_MACH_DHP_1565_A1,		/* D-Link DHP-1565 rev. A1 */
+	ATH79_MACH_DIR_505_A1,		/* D-Link DIR-505 rev. A1 */
+	ATH79_MACH_DIR_600_A1,		/* D-Link DIR-600 rev. A1 */
+	ATH79_MACH_DIR_615_C1,		/* D-Link DIR-615 rev. C1 */
+	ATH79_MACH_DIR_615_E1,		/* D-Link DIR-615 rev. E1 */
+	ATH79_MACH_DIR_615_E4,		/* D-Link DIR-615 rev. E4 */
+	ATH79_MACH_DIR_615_I1,		/* D-Link DIR-615 rev. I1 */
+	ATH79_MACH_DIR_825_B1,		/* D-Link DIR-825 rev. B1 */
+	ATH79_MACH_DIR_825_C1,		/* D-Link DIR-825 rev. C1 */
+	ATH79_MACH_DIR_835_A1,		/* D-Link DIR-835 rev. A1 */
+	ATH79_MACH_DLAN_HOTSPOT,	/* devolo dLAN Hotspot */
+	ATH79_MACH_DLAN_PRO_500_WP,	/* devolo dLAN pro 500 Wireless+ */
+	ATH79_MACH_DLAN_PRO_1200_AC,	/* devolo dLAN pro 1200+ WiFi ac*/
+	ATH79_MACH_DRAGINO2,		/* Dragino Version 2 */
+	ATH79_MACH_ESR900,		/* EnGenius ESR900 */
+	ATH79_MACH_EW_DORIN,		/* embedded wireless Dorin Platform */
+	ATH79_MACH_EW_DORIN_ROUTER,	/* embedded wireless Dorin Router Platform */
+	ATH79_MACH_EAP300V2,		/* EnGenius EAP300 v2 */
+	ATH79_MACH_EAP7660D,		/* Senao EAP7660D */
+	ATH79_MACH_EL_M150,		/* EasyLink EL-M150 */
+	ATH79_MACH_EL_MINI,		/* EasyLink EL-MINI */
+	ATH79_MACH_ESR1750,		/* EnGenius ESR1750 */
+	ATH79_MACH_EPG5000,		/* EnGenius EPG5000 */
+	ATH79_MACH_F9K1115V2,		/* Belkin AC1750DB */
+	ATH79_MACH_GL_AR150,    /* GL-AR150 support */
+	ATH79_MACH_GL_AR300,		/* GL-AR300 */
+	ATH79_MACH_GL_DOMINO,		/* Domino */
+	ATH79_MACH_GL_INET,		/* GL-CONNECT GL-INET */
+	ATH79_MACH_GS_MINIBOX_V1,	/* Gainstrong MiniBox V1.0 */
+	ATH79_MACH_GS_OOLITE,           /* GS OOLITE V1.0 */
+	ATH79_MACH_HIWIFI_HC6361,	/* HiWiFi HC6361 */
+	ATH79_MACH_JA76PF,		/* jjPlus JA76PF */
+	ATH79_MACH_JA76PF2,		/* jjPlus JA76PF2 */
+	ATH79_MACH_JWAP003,		/* jjPlus JWAP003 */
+	ATH79_MACH_HORNET_UB,		/* ALFA Networks Hornet-UB */
+	ATH79_MACH_MR12,		/* Cisco Meraki MR12 */
+	ATH79_MACH_MR16,		/* Cisco Meraki MR16 */
+	ATH79_MACH_MR1750,		/* OpenMesh MR1750 */
+	ATH79_MACH_MR600V2,		/* OpenMesh MR600v2 */
+	ATH79_MACH_MR600,		/* OpenMesh MR600 */
+	ATH79_MACH_MR900,		/* OpenMesh MR900 */
+	ATH79_MACH_MR900v2,		/* OpenMesh MR900v2 */
+	ATH79_MACH_MYNET_N600,		/* WD My Net N600 */
+	ATH79_MACH_MYNET_N750,		/* WD My Net N750 */
+	ATH79_MACH_MYNET_REXT,		/* WD My Net Wi-Fi Range Extender */
+	ATH79_MACH_MZK_W04NU,		/* Planex MZK-W04NU */
+	ATH79_MACH_MZK_W300NH,		/* Planex MZK-W300NH */
+	ATH79_MACH_NBG460N,		/* Zyxel NBG460N/550N/550NH */
+	ATH79_MACH_NBG6616,		/* Zyxel NBG6616 */
+	ATH79_MACH_NBG6716,		/* Zyxel NBG6716 */
+	ATH79_MACH_OM2P_HSv2,		/* OpenMesh OM2P-HSv2 */
+	ATH79_MACH_OM2P_HS,		/* OpenMesh OM2P-HS */
+	ATH79_MACH_OM2P_LC,		/* OpenMesh OM2P-LC */
+	ATH79_MACH_OM2Pv2,		/* OpenMesh OM2Pv2 */
+	ATH79_MACH_OM2P,		/* OpenMesh OM2P */
+	ATH79_MACH_OM5P_AN,		/* OpenMesh OM5P-AN */
+	ATH79_MACH_OM5P,		/* OpenMesh OM5P */
+	ATH79_MACH_ONION_OMEGA,		/* ONION OMEGA */
+	ATH79_MACH_PB42,		/* Atheros PB42 */
+	ATH79_MACH_PB92,		/* Atheros PB92 */
+	ATH79_MACH_QIHOO_C301,		/* Qihoo 360 C301 */
+	ATH79_MACH_R6100,		/* NETGEAR R6100 */
+	ATH79_MACH_RB_411,		/* MikroTik RouterBOARD 411/411A/411AH */
+	ATH79_MACH_RB_411U,		/* MikroTik RouterBOARD 411U */
+	ATH79_MACH_RB_433,		/* MikroTik RouterBOARD 433/433AH */
+	ATH79_MACH_RB_433U,		/* MikroTik RouterBOARD 433UAH */
+	ATH79_MACH_RB_435G,		/* MikroTik RouterBOARD 435G */
+	ATH79_MACH_RB_450G,		/* MikroTik RouterBOARD 450G */
+	ATH79_MACH_RB_450,		/* MikroTik RouterBOARD 450 */
+	ATH79_MACH_RB_493,		/* Mikrotik RouterBOARD 493/493AH */
+	ATH79_MACH_RB_493G,		/* Mikrotik RouterBOARD 493G */
+	ATH79_MACH_RB_711GR100,		/* Mikrotik RouterBOARD 911/912 boards */
+	ATH79_MACH_RB_750,		/* MikroTik RouterBOARD 750 */
+	ATH79_MACH_RB_750G_R3,		/* MikroTik RouterBOARD 750GL */
+	ATH79_MACH_RB_751,		/* MikroTik RouterBOARD 751 */
+	ATH79_MACH_RB_751G,		/* Mikrotik RouterBOARD 751G */
+	ATH79_MACH_RB_922GS,		/* Mikrotik RouterBOARD 911/922GS boards */
+	ATH79_MACH_RB_951G,		/* Mikrotik RouterBOARD 951G */
+	ATH79_MACH_RB_951U,		/* Mikrotik RouterBOARD 951Ui-2HnD */
+	ATH79_MACH_RB_2011G,		/* Mikrotik RouterBOARD 2011UAS-2HnD */
+	ATH79_MACH_RB_2011L,		/* Mikrotik RouterBOARD 2011L */
+	ATH79_MACH_RB_2011US,		/* Mikrotik RouterBOARD 2011UAS */
+	ATH79_MACH_RB_2011R5,		/* Mikrotik RouterBOARD 2011UiAS(-2Hnd) */
+	ATH79_MACH_RB_SXTLITE2ND,	/* Mikrotik RouterBOARD SXT Lite 2nD */
+	ATH79_MACH_RB_SXTLITE5ND,	/* Mikrotik RouterBOARD SXT Lite 5nD */
+	ATH79_MACH_RW2458N,		/* Redwave RW2458N */
+	ATH79_MACH_SMART_300,		/* NC-LINK SMART-300 */
+	ATH79_MACH_TEW_632BRP,		/* TRENDnet TEW-632BRP */
+	ATH79_MACH_TEW_673GRU,		/* TRENDnet TEW-673GRU */
+	ATH79_MACH_TEW_712BR,		/* TRENDnet TEW-712BR */
+	ATH79_MACH_TEW_732BR,		/* TRENDnet TEW-732BR */
+	ATH79_MACH_MC_MAC1200R,		/* MERCURY MAC1200R*/
+	ATH79_MACH_TL_MR10U,		/* TP-LINK TL-MR10U */
+	ATH79_MACH_TL_MR11U,		/* TP-LINK TL-MR11U */
+	ATH79_MACH_TL_MR13U,		/* TP-LINK TL-MR13U */
+	ATH79_MACH_TL_MR3020,		/* TP-LINK TL-MR3020 */
+	ATH79_MACH_TL_MR3040,		/* TP-LINK TL-MR3040 */
+	ATH79_MACH_TL_MR3040_V2,	/* TP-LINK TL-MR3040 v2 */
+	ATH79_MACH_TL_MR3220,		/* TP-LINK TL-MR3220 */
+	ATH79_MACH_TL_MR3220_V2,	/* TP-LINK TL-MR3220 v2 */
+	ATH79_MACH_TL_MR3420,		/* TP-LINK TL-MR3420 */
+	ATH79_MACH_TL_MR3420_V2,	/* TP-LINK TL-MR3420 v2 */
+	ATH79_MACH_TL_WA701ND_V2,       /* TP-LINK TL-WA701ND v2 */
+	ATH79_MACH_TL_WA750RE,		/* TP-LINK TL-WA750RE */
+       ATH79_MACH_TL_WA7210N_V2,       /* TP-LINK TL-WA7210N v2 */
+	ATH79_MACH_TL_WA7510N_V1,	/* TP-LINK TL-WA7510N v1*/
+	ATH79_MACH_TL_WA850RE,		/* TP-LINK TL-WA850RE */
+	ATH79_MACH_TL_WA860RE,		/* TP-LINK TL-WA860RE */
+	ATH79_MACH_TL_WA801ND_V2,	/* TP-LINK TL-WA801ND v2 */
+	ATH79_MACH_TL_WA830RE_V2,	/* TP-LINK TL-WA830RE v2 */
+	ATH79_MACH_TL_WA901ND,		/* TP-LINK TL-WA901ND */
+	ATH79_MACH_TL_WA901ND_V2,	/* TP-LINK TL-WA901ND v2 */
+	ATH79_MACH_TL_WA901ND_V3,	/* TP-LINK TL-WA901ND v3 */
+	ATH79_MACH_TL_WDR3320_V2,	/* TP-LINK TL-WDR3320 v2 */
+	ATH79_MACH_TL_WDR3500,		/* TP-LINK TL-WDR3500 */
+	ATH79_MACH_TL_WDR4300,		/* TP-LINK TL-WDR4300 */
+	ATH79_MACH_TL_WDR6500_V2,	/* TP-LINK TL-WDR6500 v2 */
+	ATH79_MACH_TL_WDR4900_V2,	/* TP-LINK TL-WDR4900 v2 */
+	ATH79_MACH_TL_WR1041N_V2,	/* TP-LINK TL-WR1041N v2 */
+	ATH79_MACH_TL_WR1043ND,		/* TP-LINK TL-WR1043ND */
+	ATH79_MACH_TL_WR1043ND_V2,	/* TP-LINK TL-WR1043ND v2 */
+	ATH79_MACH_TL_WR2543N,		/* TP-LINK TL-WR2543N/ND */
+	ATH79_MACH_TL_WR703N,		/* TP-LINK TL-WR703N */
+	ATH79_MACH_TL_WR710N,		/* TP-LINK TL-WR710N */
+	ATH79_MACH_TL_WR720N_V3,	/* TP-LINK TL-WR720N v3/v4 */
+	ATH79_MACH_TL_WR741ND,		/* TP-LINK TL-WR741ND */
+	ATH79_MACH_TL_WR741ND_V4,	/* TP-LINK TL-WR741ND  v4*/
+	ATH79_MACH_TL_WR841N_V1,	/* TP-LINK TL-WR841N v1 */
+	ATH79_MACH_TL_WR841N_V7,	/* TP-LINK TL-WR841N/ND v7 */
+	ATH79_MACH_TL_WR841N_V8,	/* TP-LINK TL-WR841N/ND v8 */
+	ATH79_MACH_TL_WR841N_V9,	/* TP-LINK TL-WR841N/ND v9 */
+	ATH79_MACH_TL_WR842N_V2,	/* TP-LINK TL-WR842N/ND v2 */
+	ATH79_MACH_TL_WR941ND,		/* TP-LINK TL-WR941ND */
+	ATH79_MACH_TL_WR941ND_V5,	/* TP-LINK TL-WR941ND v5 */
+	ATH79_MACH_TL_WR941ND_V6,	/* TP-LINK TL-WR941ND v6 */
+	ATH79_MACH_TUBE2H,		/* Alfa Network Tube2H */
+	ATH79_MACH_UBNT_AIRGW,		/* Ubiquiti AirGateway */
+	ATH79_MACH_UBNT_AIRGWP,		/* Ubiquiti AirGateway Pro */
+	ATH79_MACH_UBNT_AIRROUTER,	/* Ubiquiti AirRouter */
+	ATH79_MACH_UBNT_BULLET_M,	/* Ubiquiti Bullet M */
+	ATH79_MACH_UBNT_LOCO_M_XW, 	/* Ubiquiti Loco M XW */
+	ATH79_MACH_UBNT_LSSR71,		/* Ubiquiti LS-SR71 */
+	ATH79_MACH_UBNT_LSX,		/* Ubiquiti LSX */
+	ATH79_MACH_UBNT_NANO_M, 	/* Ubiquiti NanoStation M */
+	ATH79_MACH_UBNT_NANO_M_XW, 	/* Ubiquiti NanoStation M XW */
+	ATH79_MACH_UBNT_ROCKET_M,	/* Ubiquiti Rocket M */
+	ATH79_MACH_UBNT_ROCKET_M_XW,	/* Ubiquiti Rocket M XW*/
+	ATH79_MACH_UBNT_ROCKET_M_TI,	/* Ubiquiti Rocket M TI*/
+	ATH79_MACH_UBNT_RSPRO,		/* Ubiquiti RouterStation Pro */
+	ATH79_MACH_UBNT_RS,		/* Ubiquiti RouterStation */
+	ATH79_MACH_UBNT_UAP_PRO,	/* Ubiquiti UniFi AP Pro */
+	ATH79_MACH_UBNT_UNIFI, 		/* Ubiquiti Unifi */
+	ATH79_MACH_UBNT_UNIFI_OUTDOOR,	/* Ubiquiti UnifiAP Outdoor */
+	ATH79_MACH_UBNT_UNIFI_OUTDOOR_PLUS, /* Ubiquiti UnifiAP Outdoor+ */
 	ATH79_MACH_UBNT_XM,		/* Ubiquiti Networks XM board rev 1.0 */
+	ATH79_MACH_WEIO,			/* WeIO board */
+	ATH79_MACH_WHR_G301N,		/* Buffalo WHR-G301N */
+	ATH79_MACH_WHR_HP_G300N,	/* Buffalo WHR-HP-G300N */
+	ATH79_MACH_WHR_HP_GN,		/* Buffalo WHR-HP-GN */
+	ATH79_MACH_WLAE_AG300N,		/* Buffalo WLAE-AG300N */
+	ATH79_MACH_WLR8100,		/* SITECOM WLR-8100 */
+	ATH79_MACH_WNDAP360,		/* NETGEAR WNDAP360 */
+	ATH79_MACH_WNDR3700,		/* NETGEAR WNDR3700/WNDR3800/WNDRMAC */
+	ATH79_MACH_WNDR3700_V4,		/* NETGEAR WNDR3700v4 */
+	ATH79_MACH_WNDR4300,		/* NETGEAR WNDR4300 */
+	ATH79_MACH_WNR2000,		/* NETGEAR WNR2000 */
+	ATH79_MACH_WNR2000_V3,		/* NETGEAR WNR2000 v3 */
+	ATH79_MACH_WNR2000_V4,		/* NETGEAR WNR2000 v4 */
+	ATH79_MACH_WNR2200,		/* NETGEAR WNR2200 */
+	ATH79_MACH_WNR612_V2,		/* NETGEAR WNR612 v2 */
+	ATH79_MACH_WNR1000_V2,		/* NETGEAR WNR1000 v2 */
+	ATH79_MACH_WP543,		/* Compex WP543 */
+	ATH79_MACH_WPE72,		/* Compex WPE72 */
+	ATH79_MACH_WPJ344,		/* Compex WPJ344 */
+	ATH79_MACH_WPJ531,		/* Compex WPJ531 */
+	ATH79_MACH_WPJ558,		/* Compex WPJ558 */
+	ATH79_MACH_WRT160NL,		/* Linksys WRT160NL */
+	ATH79_MACH_WRT400N,		/* Linksys WRT400N */
+	ATH79_MACH_WZR_HP_AG300H,	/* Buffalo WZR-HP-AG300H */
+	ATH79_MACH_WZR_HP_G300NH,	/* Buffalo WZR-HP-G300NH */
+	ATH79_MACH_WZR_HP_G300NH2,	/* Buffalo WZR-HP-G300NH2 */
+	ATH79_MACH_WZR_HP_G450H,	/* Buffalo WZR-HP-G450H */
+	ATH79_MACH_WZR_450HP2,		/* Buffalo WZR-450HP2 */
+	ATH79_MACH_ZCN_1523H_2,		/* Zcomax ZCN-1523H-2-xx */
+	ATH79_MACH_ZCN_1523H_5,		/* Zcomax ZCN-1523H-5-xx */
 };
 
 #endif /* _ATH79_MACHTYPE_H */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ubnt.c linux-4.1.13/arch/mips/ath79/mach-ubnt.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ubnt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ubnt.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,205 @@
+/*
+ *  Ubiquiti RouterStation support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008 Ubiquiti <support@ubnt.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define UBNT_RS_GPIO_LED_RF	2
+#define UBNT_RS_GPIO_SW4	8
+
+#define UBNT_LS_SR71_GPIO_LED_D25	0
+#define UBNT_LS_SR71_GPIO_LED_D26	1
+#define UBNT_LS_SR71_GPIO_LED_D24	2
+#define UBNT_LS_SR71_GPIO_LED_D23	4
+#define UBNT_LS_SR71_GPIO_LED_D22	5
+#define UBNT_LS_SR71_GPIO_LED_D27	6
+#define UBNT_LS_SR71_GPIO_LED_D28	7
+
+#define UBNT_KEYS_POLL_INTERVAL		20	/* msecs */
+#define UBNT_KEYS_DEBOUNCE_INTERVAL	(3 * UBNT_KEYS_POLL_INTERVAL)
+
+static struct gpio_led ubnt_rs_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:rf",
+		.gpio		= UBNT_RS_GPIO_LED_RF,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_led ubnt_ls_sr71_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:d22",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D22,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d23",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D23,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d24",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D24,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d25",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D25,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:red:d26",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D26,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d27",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D27,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:d28",
+		.gpio		= UBNT_LS_SR71_GPIO_LED_D28,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button ubnt_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = UBNT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= UBNT_RS_GPIO_SW4,
+		.active_low	= 1,
+	}
+};
+
+static const char *ubnt_part_probes[] = {
+	"RedBoot",
+	NULL,
+};
+
+static struct flash_platform_data ubnt_flash_data = {
+	.part_probes	= ubnt_part_probes,
+};
+
+static void __init ubnt_generic_setup(void)
+{
+	ath79_register_m25p80(&ubnt_flash_data);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ubnt_gpio_keys),
+					ubnt_gpio_keys);
+	ath79_register_pci();
+}
+
+#define UBNT_RS_WAN_PHYMASK	BIT(20)
+#define UBNT_RS_LAN_PHYMASK	(BIT(16) | BIT(17) | BIT(18) | BIT(19))
+
+static void __init ubnt_rs_setup(void)
+{
+	ubnt_generic_setup();
+
+	ath79_register_mdio(0, ~(UBNT_RS_WAN_PHYMASK | UBNT_RS_LAN_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = UBNT_RS_WAN_PHYMASK;
+
+	/*
+	 * There is Secondary MAC address duplicate problem with some
+	 * UBNT HW batches.  Do not increase Secondary MAC address by 1
+	 * but do workaround with 'Locally Administrated' bit.
+	 */
+	ath79_init_local_mac(ath79_eth1_data.mac_addr, ath79_mac_base);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.speed = SPEED_100;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+				 ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_RS, "UBNT-RS", "Ubiquiti RouterStation",
+	     ubnt_rs_setup);
+
+#define UBNT_RSPRO_WAN_PHYMASK	BIT(4)
+#define UBNT_RSPRO_LAN_PHYMASK	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+static void __init ubnt_rspro_setup(void)
+{
+	ubnt_generic_setup();
+
+	ath79_register_mdio(0, ~(UBNT_RSPRO_WAN_PHYMASK |
+				 UBNT_RSPRO_LAN_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = UBNT_RSPRO_WAN_PHYMASK;
+
+	/*
+	 * There is Secondary MAC address duplicate problem with some
+	 * UBNT HW batches.  Do not increase Secondary MAC address by 1
+	 * but do workaround with 'Locally Administrated' bit.
+	 */
+	ath79_init_local_mac(ath79_eth1_data.mac_addr, ath79_mac_base);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = UBNT_RSPRO_LAN_PHYMASK;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_rs_leds_gpio),
+				 ubnt_rs_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_RSPRO, "UBNT-RSPRO", "Ubiquiti RouterStation Pro",
+	     ubnt_rspro_setup);
+
+static void __init ubnt_lsx_setup(void)
+{
+	ubnt_generic_setup();
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_LSX, "UBNT-LSX", "Ubiquiti LSX", ubnt_lsx_setup);
+
+#define UBNT_LSSR71_PHY_MASK	BIT(1)
+
+static void __init ubnt_lssr71_setup(void)
+{
+	ubnt_generic_setup();
+
+	ath79_register_mdio(0, ~UBNT_LSSR71_PHY_MASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = UBNT_LSSR71_PHY_MASK;
+
+	ath79_register_eth(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_ls_sr71_leds_gpio),
+				 ubnt_ls_sr71_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_LSSR71, "UBNT-LS-SR71", "Ubiquiti LS-SR71",
+	     ubnt_lssr71_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-ubnt-xm.c linux-4.1.13/arch/mips/ath79/mach-ubnt-xm.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-ubnt-xm.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-ubnt-xm.c	2015-12-04 19:57:04.386077932 +0100
@@ -12,15 +12,26 @@
 
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/platform_device.h>
 #include <linux/ath9k_platform.h>
+#include <linux/etherdevice.h>
+#include <linux/ar8216_platform.h>
 
+#include <asm/mach-ath79/ath79.h>
 #include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
 
-#include "machtypes.h"
+#include <linux/platform_data/phy-at803x.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
-#include "dev-spi.h"
-#include "pci.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
 
 #define UBNT_XM_GPIO_LED_L1		0
 #define UBNT_XM_GPIO_LED_L2		1
@@ -32,23 +43,23 @@
 #define UBNT_XM_KEYS_POLL_INTERVAL	20
 #define UBNT_XM_KEYS_DEBOUNCE_INTERVAL	(3 * UBNT_XM_KEYS_POLL_INTERVAL)
 
-#define UBNT_XM_EEPROM_ADDR		(u8 *) KSEG1ADDR(0x1fff1000)
+#define UBNT_XM_EEPROM_ADDR		0x1fff1000
 
 static struct gpio_led ubnt_xm_leds_gpio[] __initdata = {
 	{
-		.name		= "ubnt-xm:red:link1",
+		.name		= "ubnt:red:link1",
 		.gpio		= UBNT_XM_GPIO_LED_L1,
 		.active_low	= 0,
 	}, {
-		.name		= "ubnt-xm:orange:link2",
+		.name		= "ubnt:orange:link2",
 		.gpio		= UBNT_XM_GPIO_LED_L2,
 		.active_low	= 0,
 	}, {
-		.name		= "ubnt-xm:green:link3",
+		.name		= "ubnt:green:link3",
 		.gpio		= UBNT_XM_GPIO_LED_L3,
 		.active_low	= 0,
 	}, {
-		.name		= "ubnt-xm:green:link4",
+		.name		= "ubnt:green:link4",
 		.gpio		= UBNT_XM_GPIO_LED_L4,
 		.active_low	= 0,
 	},
@@ -65,62 +76,625 @@
 	}
 };
 
-static struct spi_board_info ubnt_xm_spi_info[] = {
+#define UBNT_M_WAN_PHYMASK	BIT(4)
+
+static void __init ubnt_xm_init(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(UBNT_XM_EEPROM_ADDR);
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_xm_leds_gpio),
+				 ubnt_xm_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(ubnt_xm_gpio_keys),
+					ubnt_xm_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+	ap91_pci_init(eeprom, NULL);
+
+	ath79_register_mdio(0, ~UBNT_M_WAN_PHYMASK);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_XM,
+	     "UBNT-XM",
+	     "Ubiquiti Networks XM (rev 1.0) board",
+	     ubnt_xm_init);
+
+MIPS_MACHINE(ATH79_MACH_UBNT_BULLET_M, "UBNT-BM", "Ubiquiti Bullet M",
+	     ubnt_xm_init);
+
+static void __init ubnt_rocket_m_setup(void)
+{
+	ubnt_xm_init();
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_ROCKET_M, "UBNT-RM", "Ubiquiti Rocket M",
+	     ubnt_rocket_m_setup);
+
+static void __init ubnt_nano_m_setup(void)
+{
+	ubnt_xm_init();
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_NANO_M, "UBNT-NM", "Ubiquiti Nanostation M",
+	     ubnt_nano_m_setup);
+
+static struct gpio_led ubnt_airrouter_leds_gpio[] __initdata = {
 	{
-		.bus_num	= 0,
-		.chip_select	= 0,
-		.max_speed_hz	= 25000000,
-		.modalias	= "mx25l6405d",
+		.name		= "ubnt:green:globe",
+		.gpio		= 0,
+		.active_low	= 1,
+	}, {
+	        .name		= "ubnt:green:power",
+		.gpio		= 11,
+		.active_low	= 1,
+		.default_state  = LEDS_GPIO_DEFSTATE_ON,
 	}
 };
 
-static struct ath79_spi_platform_data ubnt_xm_spi_data = {
-	.bus_num		= 0,
-	.num_chipselect		= 1,
+static void __init ubnt_airrouter_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_mdio(0, ~UBNT_M_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_local_mac(ath79_eth1_data.mac_addr, mac1);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+	ath79_register_usb();
+
+	ap91_pci_init(ee, NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_airrouter_leds_gpio),
+				 ubnt_airrouter_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_AIRROUTER, "UBNT-AR", "Ubiquiti AirRouter",
+	     ubnt_airrouter_setup);
+
+static struct gpio_led ubnt_unifi_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:orange:dome",
+		.gpio		= 1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:dome",
+		.gpio		= 0,
+		.active_low	= 0,
+	}
 };
 
-#ifdef CONFIG_PCI
-static struct ath9k_platform_data ubnt_xm_eeprom_data;
+static struct gpio_led ubnt_unifi_outdoor_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:orange:front",
+		.gpio		= 1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:front",
+		.gpio		= 0,
+		.active_low	= 0,
+	}
+};
 
-static int ubnt_xm_pci_plat_dev_init(struct pci_dev *dev)
+static struct gpio_led ubnt_unifi_outdoor_plus_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:white:front",
+		.gpio		= 1,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:blue:front",
+		.gpio		= 0,
+		.active_low	= 0,
+	}
+};
+
+
+static void __init ubnt_unifi_setup(void)
 {
-	switch (PCI_SLOT(dev->devfn)) {
-	case 0:
-		dev->dev.platform_data = &ubnt_xm_eeprom_data;
-		break;
+	u8 *mac = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~UBNT_M_WAN_PHYMASK);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_register_eth(0);
+
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_unifi_leds_gpio),
+				 ubnt_unifi_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UNIFI, "UBNT-UF", "Ubiquiti UniFi",
+	     ubnt_unifi_setup);
+
+
+#define UBNT_UNIFIOD_PRI_PHYMASK	BIT(4)
+#define UBNT_UNIFIOD_2ND_PHYMASK	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+static void __init ubnt_unifi_outdoor_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~(UBNT_UNIFIOD_PRI_PHYMASK |
+				 UBNT_UNIFIOD_2ND_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_unifi_outdoor_leds_gpio),
+				 ubnt_unifi_outdoor_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UNIFI_OUTDOOR, "UBNT-U20",
+	     "Ubiquiti UniFiAP Outdoor",
+	     ubnt_unifi_outdoor_setup);
+
+
+static void __init ubnt_unifi_outdoor_plus_setup(void)
+{
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac2 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_mdio(0, ~(UBNT_UNIFIOD_PRI_PHYMASK |
+				 UBNT_UNIFIOD_2ND_PHYMASK));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 0);
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ap91_pci_init(ee, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_unifi_outdoor_plus_leds_gpio),
+				 ubnt_unifi_outdoor_plus_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UNIFI_OUTDOOR_PLUS, "UBNT-UOP",
+	     "Ubiquiti UniFiAP Outdoor+",
+	     ubnt_unifi_outdoor_plus_setup);
+
+
+static struct gpio_led ubnt_uap_pro_gpio_leds[] __initdata = {
+	{
+		.name		= "ubnt:white:dome",
+		.gpio		= 12,
+	}, {
+		.name		= "ubnt:blue:dome",
+		.gpio		= 13,
+	}
+};
+
+static struct gpio_keys_button uap_pro_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= UBNT_XM_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= 17,
+		.active_low		= 1,
 	}
+};
+
+static struct ar8327_pad_cfg uap_pro_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data uap_pro_ar8327_data = {
+	.pad0_cfg = &uap_pro_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info uap_pro_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &uap_pro_ar8327_data,
+	},
+};
+
+#define UAP_PRO_MAC0_OFFSET		0x0000
+#define UAP_PRO_MAC1_OFFSET		0x0006
+#define UAP_PRO_WMAC_CALDATA_OFFSET	0x1000
+#define UAP_PRO_PCI_CALDATA_OFFSET	0x5000
+
+static void __init ubnt_uap_pro_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_uap_pro_gpio_leds),
+				 ubnt_uap_pro_gpio_leds);
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(uap_pro_gpio_keys),
+                                        uap_pro_gpio_keys);
+
+	ath79_register_wmac(eeprom + UAP_PRO_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(eeprom + UAP_PRO_PCI_CALDATA_OFFSET, NULL);
+
+	ath79_register_mdio(0, 0x0);
+	mdiobus_register_board_info(uap_pro_mdio0_info,
+				    ARRAY_SIZE(uap_pro_mdio0_info));
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       eeprom + UAP_PRO_MAC0_OFFSET, 0);
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_UAP_PRO, "UAP-PRO", "Ubiquiti UniFi AP Pro",
+	     ubnt_uap_pro_setup);
+
+#define UBNT_XW_GPIO_LED_L1		11
+#define UBNT_XW_GPIO_LED_L2		16
+#define UBNT_XW_GPIO_LED_L3		13
+#define UBNT_XW_GPIO_LED_L4		14
+
+static struct gpio_led ubnt_xw_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:red:link1",
+		.gpio		= UBNT_XW_GPIO_LED_L1,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:orange:link2",
+		.gpio		= UBNT_XW_GPIO_LED_L2,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link3",
+		.gpio		= UBNT_XW_GPIO_LED_L3,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link4",
+		.gpio		= UBNT_XW_GPIO_LED_L4,
+		.active_low	= 1,
+	},
+};
+
+#define UBNT_ROCKET_TI_GPIO_LED_L1	16
+#define UBNT_ROCKET_TI_GPIO_LED_L2	17
+#define UBNT_ROCKET_TI_GPIO_LED_L3	18
+#define UBNT_ROCKET_TI_GPIO_LED_L4	19
+#define UBNT_ROCKET_TI_GPIO_LED_L5	20
+#define UBNT_ROCKET_TI_GPIO_LED_L6	21
+static struct gpio_led ubnt_rocket_ti_leds_gpio[] __initdata = {
+	{
+		.name		= "ubnt:green:link1",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L1,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link2",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L2,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link3",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L3,
+		.active_low	= 1,
+	}, {
+		.name		= "ubnt:green:link4",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L4,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link5",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L5,
+		.active_low	= 0,
+	}, {
+		.name		= "ubnt:green:link6",
+		.gpio		= UBNT_ROCKET_TI_GPIO_LED_L6,
+		.active_low	= 0,
+	},
+};
 
-	return 0;
+static void __init ubnt_xw_init(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_xw_leds_gpio),
+				 ubnt_xw_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+
+	ath79_register_wmac(eeprom + UAP_PRO_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(eeprom + UAP_PRO_PCI_CALDATA_OFFSET, NULL);
+
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_MII_GMAC0 | AR934X_ETH_CFG_MII_GMAC0_SLAVE);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       eeprom + UAP_PRO_MAC0_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
 }
 
-static void __init ubnt_xm_pci_init(void)
+static void __init ubnt_nano_m_xw_setup(void)
 {
-	memcpy(ubnt_xm_eeprom_data.eeprom_data, UBNT_XM_EEPROM_ADDR,
-	       sizeof(ubnt_xm_eeprom_data.eeprom_data));
+	ubnt_xw_init();
 
-	ath79_pci_set_plat_dev_init(ubnt_xm_pci_plat_dev_init);
-	ath79_register_pci();
+	/* GMAC0 is connected to an AR8326 switch */
+	ath79_register_mdio(0, ~(BIT(0) | BIT(1) | BIT(5)));
+	ath79_eth0_data.phy_mask = (BIT(0) | BIT(1) | BIT(5));
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_register_eth(0);
 }
-#else
-static inline void ubnt_xm_pci_init(void) {}
-#endif /* CONFIG_PCI */
 
-static void __init ubnt_xm_init(void)
+static void __init ubnt_loco_m_xw_setup(void)
 {
-	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_xm_leds_gpio),
-				 ubnt_xm_leds_gpio);
+	ubnt_xw_init();
 
+	ath79_register_mdio(0, ~BIT(1));
+	ath79_eth0_data.phy_mask = BIT(1);
+	ath79_register_eth(0);
+}
+
+static void __init ubnt_rocket_m_xw_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_xw_leds_gpio),
+				 ubnt_xw_leds_gpio);
 	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
-					ARRAY_SIZE(ubnt_xm_gpio_keys),
-					ubnt_xm_gpio_keys);
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
 
-	ath79_register_spi(&ubnt_xm_spi_data, ubnt_xm_spi_info,
-			   ARRAY_SIZE(ubnt_xm_spi_info));
+	ath79_register_wmac(eeprom + UAP_PRO_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(eeprom + UAP_PRO_PCI_CALDATA_OFFSET, NULL);
 
-	ubnt_xm_pci_init();
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       eeprom + UAP_PRO_MAC0_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_mdio(0, ~BIT(4));
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
 }
 
-MIPS_MACHINE(ATH79_MACH_UBNT_XM,
-	     "UBNT-XM",
-	     "Ubiquiti Networks XM (rev 1.0) board",
-	     ubnt_xm_init);
+static struct at803x_platform_data ubnt_rocket_m_ti_at803_data = {
+	.disable_smarteee = 1,
+	.enable_rgmii_rx_delay = 1,
+	.enable_rgmii_tx_delay = 1,
+};
+static struct mdio_board_info ubnt_rocket_m_ti_mdio_info[] = {
+        {
+                .bus_id = "ag71xx-mdio.0",
+                .phy_addr = 4,
+                .platform_data = &ubnt_rocket_m_ti_at803_data,
+        },
+};
+
+static void __init ubnt_rocket_m_ti_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_rocket_ti_leds_gpio),
+				 ubnt_rocket_ti_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+                                        ARRAY_SIZE(ubnt_xm_gpio_keys),
+                                        ubnt_xm_gpio_keys);
+
+	ap91_pci_init(eeprom + 0x1000, NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+	ath79_setup_ar934x_eth_rx_delay(3, 3);
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       eeprom + UAP_PRO_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+		       eeprom + UAP_PRO_MAC1_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	mdiobus_register_board_info(ubnt_rocket_m_ti_mdio_info,
+			ARRAY_SIZE(ubnt_rocket_m_ti_mdio_info));
+	ath79_register_mdio(0, 0x0);
+
+
+	ath79_eth0_data.phy_mask = BIT(4);
+	/* read out from vendor */
+	ath79_eth0_pll_data.pll_1000 = 0x2000000;
+	ath79_eth0_pll_data.pll_10 = 0x1313;
+	ath79_register_eth(0);
+
+	ath79_register_mdio(1, 0x0);
+	ath79_eth1_data.phy_mask = BIT(3);
+	ath79_register_eth(1);
+}
+
+
+MIPS_MACHINE(ATH79_MACH_UBNT_NANO_M_XW, "UBNT-NM-XW", "Ubiquiti Nanostation M XW",
+	     ubnt_nano_m_xw_setup);
+
+MIPS_MACHINE(ATH79_MACH_UBNT_LOCO_M_XW, "UBNT-LOCO-XW", "Ubiquiti Loco M XW",
+	     ubnt_loco_m_xw_setup);
+
+MIPS_MACHINE(ATH79_MACH_UBNT_ROCKET_M_XW, "UBNT-RM-XW", "Ubiquiti Rocket M XW",
+	     ubnt_rocket_m_xw_setup);
+
+MIPS_MACHINE(ATH79_MACH_UBNT_ROCKET_M_TI, "UBNT-RM-TI", "Ubiquiti Rocket M TI",
+	     ubnt_rocket_m_ti_setup);
+
+static struct gpio_led ubnt_airgateway_gpio_leds[] __initdata = {
+	{
+		.name	   = "ubnt:blue:wlan",
+		.gpio	   = 0,
+	}, {
+		.name	   = "ubnt:white:status",
+		.gpio	   = 1,
+	},
+};
+
+static struct gpio_keys_button airgateway_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval	= UBNT_XM_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 1,
+	}
+};
+
+static void __init ubnt_airgateway_setup(void)
+{
+	u32 t;
+	u8 *mac0 = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac1 = (u8 *) KSEG1ADDR(0x1fff0000 + ETH_ALEN);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				     AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+	t |= AR933X_BOOTSTRAP_MDIO_GPIO_EN;
+	ath79_reset_wr(AR933X_RESET_REG_BOOTSTRAP, t);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_airgateway_gpio_leds),
+				 ubnt_airgateway_gpio_leds);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(airgateway_gpio_keys),
+					airgateway_gpio_keys);
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac0, 0);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_register_eth(1);
+	ath79_register_eth(0);
+
+	ath79_register_wmac(ee, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_AIRGW, "UBNT-AGW", "Ubiquiti AirGateway",
+	     ubnt_airgateway_setup);
+
+static struct gpio_led ubnt_airgateway_pro_gpio_leds[] __initdata = {
+	{
+		.name	   = "ubnt:blue:wlan",
+		.gpio	   = 13,
+	}, {
+		.name	   = "ubnt:white:status",
+		.gpio	   = 17,
+	},
+};
+
+
+static struct gpio_keys_button airgateway_pro_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval	= UBNT_XM_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 1,
+	}
+};
+
+static void __init ubnt_airgateway_pro_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac0 = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(ubnt_airgateway_pro_gpio_leds),
+				 ubnt_airgateway_pro_gpio_leds);
+
+	ath79_register_gpio_keys_polled(-1, UBNT_XM_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(airgateway_pro_gpio_keys),
+					airgateway_pro_gpio_keys);
+
+	ath79_register_wmac(eeprom + UAP_PRO_WMAC_CALDATA_OFFSET, NULL);
+	ap91_pci_init(eeprom + UAP_PRO_PCI_CALDATA_OFFSET, NULL);
+
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* GMAC0 is left unused in this configuration */
+
+	/* GMAC1 is connected to MAC0 on the internal switch */
+	/* The PoE/WAN port connects to port 5 on the internal switch */
+	/* The LAN port connects to port 4 on the internal switch */
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac0, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_UBNT_AIRGWP, "UBNT-AGWP", "Ubiquiti AirGateway Pro",
+	     ubnt_airgateway_pro_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-weio.c linux-4.1.13/arch/mips/ath79/mach-weio.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-weio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-weio.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,140 @@
+/**
+ * WEIO Web Of Things Platform
+ *
+ * Copyright (C) 2013 Drasko DRASKOVIC and Uros PETREVSKI
+ *
+ *              ##      ## ######## ####  #######  
+ *              ##  ##  ## ##        ##  ##     ## 
+ *              ##  ##  ## ##        ##  ##     ## 
+ *              ##  ##  ## ######    ##  ##     ## 
+ *              ##  ##  ## ##        ##  ##     ## 
+ *              ##  ##  ## ##        ##  ##     ## 
+ *               ###  ###  ######## ####  #######
+ *
+ *                   Web Of Things Platform
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Authors : 
+ * Drasko DRASKOVIC <drasko.draskovic@gmail.com>
+ * Uros PETREVSKI <uros@nodesign.net>
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WEIO_GPIO_LED_STA		1
+#define WEIO_GPIO_LED_AP		16
+
+#define WEIO_GPIO_BTN_AP		20
+#define WEIO_GPIO_BTN_RESET		23
+
+#define WEIO_KEYS_POLL_INTERVAL		20	/* msecs */
+#define WEIO_KEYS_DEBOUNCE_INTERVAL	(3 * WEIO_KEYS_POLL_INTERVAL)
+
+#define WEIO_MAC0_OFFSET			0x0000
+#define WEIO_MAC1_OFFSET			0x0006
+#define WEIO_CALDATA_OFFSET			0x1000
+#define WEIO_WMAC_MAC_OFFSET		0x1002
+
+static struct gpio_led weio_leds_gpio[] __initdata = {
+	{
+		.name		= "weio:green:sta",
+		.gpio		= WEIO_GPIO_LED_STA,
+		.active_low	= 1,
+		.default_state = LEDS_GPIO_DEFSTATE_ON,
+	},
+	{
+		.name		= "weio:green:ap",
+		.gpio		= WEIO_GPIO_LED_AP,
+		.active_low	= 1,
+		.default_state = LEDS_GPIO_DEFSTATE_ON,
+	}
+};
+
+static struct gpio_keys_button weio_gpio_keys[] __initdata = {
+	{
+		.desc		= "ap button",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = WEIO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WEIO_GPIO_BTN_AP,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "soft-reset button",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.debounce_interval = WEIO_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WEIO_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct i2c_gpio_platform_data weio_i2c_gpio_data = {
+	.sda_pin        = 18,
+	.scl_pin        = 19,
+};
+
+static struct platform_device weio_i2c_gpio = {
+	.name           = "i2c-gpio",
+	.id             = 0,
+	.dev            = {
+		.platform_data  = &weio_i2c_gpio_data,
+	},
+};
+
+static void __init weio_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_wmac(art + WEIO_CALDATA_OFFSET, art + WEIO_WMAC_MAC_OFFSET);
+}
+
+static void __init weio_setup(void)
+{
+	weio_common_setup();
+
+	ath79_gpio_function_disable(AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	platform_device_register(&weio_i2c_gpio);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(weio_leds_gpio),
+				weio_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WEIO_KEYS_POLL_INTERVAL,
+				ARRAY_SIZE(weio_gpio_keys),
+				weio_gpio_keys);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_WEIO, "WEIO", "WeIO board", weio_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-whr-hp-g300n.c linux-4.1.13/arch/mips/ath79/mach-whr-hp-g300n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-whr-hp-g300n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-whr-hp-g300n.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,155 @@
+/*
+ *  Buffalo WHR-HP-G300N board support
+ *
+ *  based on ...
+ *
+ *  TP-LINK TL-WR741ND board support
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define WHRHPG300N_GPIO_LED_SECURITY		0
+#define WHRHPG300N_GPIO_LED_DIAG		1
+#define WHRHPG300N_GPIO_LED_ROUTER		6
+
+#define WHRHPG300N_GPIO_BTN_ROUTER_ON		7
+#define WHRHPG300N_GPIO_BTN_ROUTER_AUTO		8
+#define WHRHPG300N_GPIO_BTN_RESET		11
+#define WHRHPG300N_GPIO_BTN_AOSS		12
+#define WHRHPG300N_GPIO_LED_LAN1		13
+#define WHRHPG300N_GPIO_LED_LAN2		14
+#define WHRHPG300N_GPIO_LED_LAN3		15
+#define WHRHPG300N_GPIO_LED_LAN4		16
+#define WHRHPG300N_GPIO_LED_WAN			17
+
+#define	WHRHPG300N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WHRHPG300N_KEYS_DEBOUNCE_INTERVAL (3 * WHRHPG300N_KEYS_POLL_INTERVAL)
+
+#define WHRHPG300N_MAC_OFFSET		0x20c
+
+static struct gpio_led whrhpg300n_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= WHRHPG300N_GPIO_LED_SECURITY,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:diag",
+		.gpio		= WHRHPG300N_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:router",
+		.gpio		= WHRHPG300N_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:wan",
+		.gpio		= WHRHPG300N_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan1",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan2",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan3",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN3,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:lan4",
+		.gpio		= WHRHPG300N_GPIO_LED_LAN4,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button whrhpg300n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WHRHPG300N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss/wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.gpio		= WHRHPG300N_GPIO_BTN_AOSS,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.gpio		= WHRHPG300N_GPIO_BTN_ROUTER_ON,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.gpio		= WHRHPG300N_GPIO_BTN_ROUTER_AUTO,
+		.debounce_interval = WHRHPG300N_KEYS_DEBOUNCE_INTERVAL,
+		.active_low	= 1,
+	}
+};
+
+static void __init whrhpg300n_setup(void)
+{
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = (u8 *) KSEG1ADDR(ee + WHRHPG300N_MAC_OFFSET);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(whrhpg300n_leds_gpio),
+				 whrhpg300n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WHRHPG300N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(whrhpg300n_gpio_keys),
+					whrhpg300n_gpio_keys);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN ports */
+	ath79_register_eth(1);
+	/* WAN port */
+	ath79_register_eth(0);
+
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+
+	ap91_pci_init(ee, mac);
+}
+
+MIPS_MACHINE(ATH79_MACH_WHR_HP_G300N, "WHR-HP-G300N", "Buffalo WHR-HP-G300N",
+	     whrhpg300n_setup);
+
+MIPS_MACHINE(ATH79_MACH_WHR_G301N, "WHR-G301N", "Buffalo WHR-G301N",
+	     whrhpg300n_setup);
+
+MIPS_MACHINE(ATH79_MACH_WHR_HP_GN, "WHR-HP-GN", "Buffalo WHR-HP-GN",
+	     whrhpg300n_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wlae-ag300n.c linux-4.1.13/arch/mips/ath79/mach-wlae-ag300n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wlae-ag300n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wlae-ag300n.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,114 @@
+/*
+ *  Buffalo WLAE-AG300N board support
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WLAEAG300N_MAC_OFFSET		0x20c
+#define WLAEAG300N_KEYS_POLL_INTERVAL	20      /* msecs */
+#define WLAEAG300N_KEYS_DEBOUNCE_INTERVAL (3 * WLAEAG300N_KEYS_POLL_INTERVAL)
+
+
+static struct gpio_led wlaeag300n_leds_gpio[] __initdata = {
+	/*
+	 * Note: Writing 1 into GPIO 13 will power down the device.
+	 */
+	{
+		.name		= "buffalo:green:wireless",
+		.gpio		= 14,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:wireless",
+		.gpio		= 15,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:status",
+		.gpio		= 16,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:status",
+		.gpio		= 17,
+		.active_low	= 1,
+	}
+};
+
+
+static struct gpio_keys_button wlaeag300n_gpio_keys[] __initdata = {
+	{
+		.desc		= "function",
+		.type		= EV_KEY,
+		.code		= KEY_MODE,
+		.debounce_interval = WLAEAG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 0,
+		.active_low	= 1,
+	}, {
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WLAEAG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 1,
+		.active_low	= 1,
+	}, {
+		.desc		= "power",
+		.type		= EV_KEY,
+		.code		= KEY_POWER,
+		.debounce_interval = WLAEAG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WLAEAG300N_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 1,
+	}
+};
+
+static void __init wlaeag300n_setup(void)
+{
+	u8 *eeprom1 = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac1 = eeprom1 + WLAEAG300N_MAC_OFFSET;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac1, 1);
+
+	ath79_register_mdio(0, ~(BIT(0) | BIT(4)));
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = BIT(4);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wlaeag300n_leds_gpio),
+					wlaeag300n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WLAEAG300N_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wlaeag300n_gpio_keys),
+					 wlaeag300n_gpio_keys);
+
+	ath79_register_m25p80(NULL);
+
+	ap91_pci_init(eeprom1, mac1);
+}
+
+MIPS_MACHINE(ATH79_MACH_WLAE_AG300N, "WLAE-AG300N",
+	     "Buffalo WLAE-AG300N", wlaeag300n_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wlr8100.c linux-4.1.13/arch/mips/ath79/mach-wlr8100.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wlr8100.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wlr8100.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,206 @@
+/*
+ * Sitecom X8 AC1750 WLR-8100 board support
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WLR8100_GPIO_LED_USB		4
+#define WLR8100_GPIO_LED_WLAN_5G	12
+#define WLR8100_GPIO_LED_WLAN_2G	13
+#define WLR8100_GPIO_LED_STATUS_RED	14
+#define WLR8100_GPIO_LED_WPS_RED	15
+#define WLR8100_GPIO_LED_STATUS_AMBER	19
+#define WLR8100_GPIO_LED_WPS_GREEN	20
+
+#define WLR8100_GPIO_BTN_WPS		16
+#define WLR8100_GPIO_BTN_RFKILL		21
+
+#define WLR8100_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WLR8100_KEYS_DEBOUNCE_INTERVAL	(3 * WLR8100_KEYS_POLL_INTERVAL)
+
+#define WLR8100_MAC0_OFFSET		0
+#define WLR8100_MAC1_OFFSET		6
+#define WLR8100_WMAC_CALDATA_OFFSET	0x1000
+#define WLR8100_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led wlr8100_leds_gpio[] __initdata = {
+	{
+		.name		= "wlr8100:amber:status",
+		.gpio		= WLR8100_GPIO_LED_STATUS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:red:status",
+		.gpio		= WLR8100_GPIO_LED_STATUS_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:green:wps",
+		.gpio		= WLR8100_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:red:wps",
+		.gpio		= WLR8100_GPIO_LED_WPS_RED,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:red:wlan-2g",
+		.gpio		= WLR8100_GPIO_LED_WLAN_2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wlr8100:red:usb",
+		.gpio		= WLR8100_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wlr8100_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WLR8100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WLR8100_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WLR8100_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WLR8100_GPIO_BTN_RFKILL,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg wlr8100_ar8327_pad0_cfg;
+static struct ar8327_pad_cfg wlr8100_ar8327_pad6_cfg;
+
+static struct ar8327_platform_data wlr8100_ar8327_data = {
+	.pad0_cfg = &wlr8100_ar8327_pad0_cfg,
+	.pad6_cfg = &wlr8100_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info wlr8100_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &wlr8100_ar8327_data,
+	},
+};
+
+static void __init wlr8100_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wlr8100_leds_gpio),
+				 wlr8100_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WLR8100_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wlr8100_gpio_keys),
+					wlr8100_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + WLR8100_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + WLR8100_MAC0_OFFSET, 0);
+
+	mdiobus_register_board_info(wlr8100_mdio0_info,
+				    ARRAY_SIZE(wlr8100_mdio0_info));
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected tot eh SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(1);
+}
+
+static void __init wlr8100_010_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/* GMAC0 of the AR8337 switch is connected to GMAC0 via RGMII */
+	wlr8100_ar8327_pad0_cfg.mode = AR8327_PAD_MAC_RGMII;
+	wlr8100_ar8327_pad0_cfg.txclk_delay_en = true;
+	wlr8100_ar8327_pad0_cfg.rxclk_delay_en = true;
+	wlr8100_ar8327_pad0_cfg.txclk_delay_sel = AR8327_CLK_DELAY_SEL1;
+	wlr8100_ar8327_pad0_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2;
+	wlr8100_ar8327_pad0_cfg.mac06_exchange_en = true;
+
+	/* GMAC6 of the AR8337 switch is connected to GMAC1 via SGMII */
+	wlr8100_ar8327_pad6_cfg.mode = AR8327_PAD_MAC_SGMII;
+	wlr8100_ar8327_pad6_cfg.rxclk_delay_en = true;
+	wlr8100_ar8327_pad6_cfg.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0;
+
+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	wlr8100_common_setup();
+	ap91_pci_init(art + WLR8100_PCIE_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WLR8100, "WLR8100",
+	     "Sitecom WLR-8100",
+	     wlr8100_010_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wndap360.c linux-4.1.13/arch/mips/ath79/mach-wndap360.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wndap360.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wndap360.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,105 @@
+/*
+ *  Netgear WNDAP360 board support (proper leds / button support missing)
+ *
+ *  Based on AP96
+ *  Copyright (C) 2013 Jacek Kikiewicz
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2010 Atheros Communications
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define WNDAP360_GPIO_LED_POWER_ORANGE		0
+#define WNDAP360_GPIO_LED_POWER_GREEN		2
+
+/* Reset button - next to the power connector */
+#define WNDAP360_GPIO_BTN_RESET			8
+
+#define WNDAP360_KEYS_POLL_INTERVAL		20	/* msecs */
+#define WNDAP360_KEYS_DEBOUNCE_INTERVAL	(3 * WNDAP360_KEYS_POLL_INTERVAL)
+
+#define WNDAP360_WMAC0_MAC_OFFSET		0x120c
+#define WNDAP360_WMAC1_MAC_OFFSET		0x520c
+#define WNDAP360_CALDATA0_OFFSET		0x1000
+#define WNDAP360_CALDATA1_OFFSET		0x5000
+
+/*
+ * WNDAP360 this still uses leds definitions from AP96
+ *
+ */
+static struct gpio_led wndap360_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNDAP360_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:orange:power",
+		.gpio		= WNDAP360_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+        }
+};
+
+static struct gpio_keys_button wndap360_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNDAP360_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDAP360_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+#define WNDAP360_LAN_PHYMASK 0x0f
+
+static void __init wndap360_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_mdio(0, ~(WNDAP360_LAN_PHYMASK));
+
+	/* Reusing wifi MAC with offset of 1 as eth0 MAC */
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+		       art + WNDAP360_WMAC0_MAC_OFFSET, 1);
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = WNDAP360_LAN_PHYMASK;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wndap360_leds_gpio),
+					wndap360_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNDAP360_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wndap360_gpio_keys),
+					 wndap360_gpio_keys);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	ap94_pci_init(art + WNDAP360_CALDATA0_OFFSET,
+		      art + WNDAP360_WMAC0_MAC_OFFSET,
+		      art + WNDAP360_CALDATA1_OFFSET,
+		      art + WNDAP360_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNDAP360, "WNDAP360", "Netgear WNDAP360", wndap360_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wndr3700.c linux-4.1.13/arch/mips/ath79/mach-wndr3700.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wndr3700.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wndr3700.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,172 @@
+/*
+ *  Netgear WNDR3700 board support
+ *
+ *  Copyright (C) 2009 Marco Porsch
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WNDR3700_GPIO_LED_WPS_ORANGE	0
+#define WNDR3700_GPIO_LED_POWER_ORANGE	1
+#define WNDR3700_GPIO_LED_POWER_GREEN	2
+#define WNDR3700_GPIO_LED_WPS_GREEN	4
+#define WNDR3700_GPIO_LED_WAN_GREEN	6
+
+#define WNDR3700_GPIO_BTN_WPS		3
+#define WNDR3700_GPIO_BTN_RESET		8
+#define WNDR3700_GPIO_BTN_WIFI		11
+
+#define WNDR3700_GPIO_RTL8366_SDA	5
+#define WNDR3700_GPIO_RTL8366_SCK	7
+
+#define WNDR3700_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNDR3700_KEYS_DEBOUNCE_INTERVAL (3 * WNDR3700_KEYS_POLL_INTERVAL)
+
+#define WNDR3700_ETH0_MAC_OFFSET	0
+#define WNDR3700_ETH1_MAC_OFFSET	0x6
+
+#define WNDR3700_WMAC0_MAC_OFFSET	0
+#define WNDR3700_WMAC1_MAC_OFFSET	0xc
+#define WNDR3700_CALDATA0_OFFSET	0x1000
+#define WNDR3700_CALDATA1_OFFSET	0x5000
+
+static struct gpio_led wndr3700_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:orange:power",
+		.gpio		= WNDR3700_GPIO_LED_POWER_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:orange:wps",
+		.gpio		= WNDR3700_GPIO_LED_WPS_ORANGE,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wan",
+		.gpio		= WNDR3700_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wndr3700_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}, {
+		.desc		= "wifi",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WNDR3700_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR3700_GPIO_BTN_WIFI,
+		.active_low	= 1,
+	}
+};
+
+static struct rtl8366_platform_data wndr3700_rtl8366s_data = {
+	.gpio_sda	= WNDR3700_GPIO_RTL8366_SDA,
+	.gpio_sck	= WNDR3700_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wndr3700_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wndr3700_rtl8366s_data,
+	}
+};
+
+static void __init wndr3700_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	/*
+	 * The eth0 and wmac0 interfaces share the same MAC address which
+	 * can lead to problems if operated unbridged. Set the locally
+	 * administered bit on the eth0 MAC to make it unique.
+	 */
+	ath79_init_local_mac(ath79_eth0_data.mac_addr,
+			     art + WNDR3700_ETH0_MAC_OFFSET);
+	ath79_eth0_pll_data.pll_1000 = 0x11110000;
+	ath79_eth0_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr,
+			art + WNDR3700_ETH1_MAC_OFFSET, 0);
+	ath79_eth1_pll_data.pll_1000 = 0x11110000;
+	ath79_eth1_data.mii_bus_dev = &wndr3700_rtl8366s_device.dev;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wndr3700_leds_gpio),
+				 wndr3700_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNDR3700_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wndr3700_gpio_keys),
+					wndr3700_gpio_keys);
+
+	platform_device_register(&wndr3700_rtl8366s_device);
+	platform_device_register_simple("wndr3700-led-usb", -1, NULL, 0);
+
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	/* 2.4 GHz uses the first fixed antenna group (1, 0, 1, 0) */
+	ap9x_pci_setup_wmac_gpio(0, (0xf << 6), (0xa << 6));
+
+	/* 5 GHz uses the second fixed antenna group (0, 1, 1, 0) */
+	ap9x_pci_setup_wmac_gpio(1, (0xf << 6), (0x6 << 6));
+
+	ap94_pci_init(art + WNDR3700_CALDATA0_OFFSET,
+		      art + WNDR3700_WMAC0_MAC_OFFSET,
+		      art + WNDR3700_CALDATA1_OFFSET,
+		      art + WNDR3700_WMAC1_MAC_OFFSET);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNDR3700, "WNDR3700",
+	     "NETGEAR WNDR3700/WNDR3800/WNDRMAC",
+	     wndr3700_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wndr4300.c linux-4.1.13/arch/mips/ath79/mach-wndr4300.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wndr4300.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wndr4300.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,210 @@
+/*
+ *  NETGEAR WNDR3700v4/WNDR4300 board support
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2014 Ralph Perlich <rpsoft@arcor.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/platform/ar934x_nfc.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-nfc.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+/* AR9344 GPIOs */
+#define WNDR4300_GPIO_LED_POWER_GREEN	0
+#define WNDR4300_GPIO_LED_POWER_AMBER	2
+#define WNDR4300_GPIO_LED_USB		13
+#define WNDR4300_GPIO_LED_WAN_GREEN	1
+#define WNDR4300_GPIO_LED_WAN_AMBER	3
+#define WNDR4300_GPIO_LED_WLAN2G	11
+#define WNDR4300_GPIO_LED_WLAN5G	14
+#define WNDR4300_GPIO_LED_WPS_GREEN	16
+#define WNDR4300_GPIO_LED_WPS_AMBER	17
+
+#define WNDR4300_GPIO_BTN_RESET		21
+#define WNDR4300_GPIO_BTN_WIRELESS	15
+#define WNDR4300_GPIO_BTN_WPS		12
+
+/* AR9580 GPIOs */
+#define WNDR4300_GPIO_USB_5V		0
+
+#define WNDR4300_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNDR4300_KEYS_DEBOUNCE_INTERVAL	(3 * WNDR4300_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wndr4300_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNDR4300_GPIO_LED_POWER_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:power",
+		.gpio		= WNDR4300_GPIO_LED_POWER_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wan",
+		.gpio		= WNDR4300_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:wan",
+		.gpio		= WNDR4300_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:usb",
+		.gpio		= WNDR4300_GPIO_LED_USB,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wps",
+		.gpio		= WNDR4300_GPIO_LED_WPS_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:wps",
+		.gpio		= WNDR4300_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wlan2g",
+		.gpio		= WNDR4300_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:blue:wlan5g",
+		.gpio		= WNDR4300_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wndr4300_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR4300_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR4300_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Wireless button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WNDR4300_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNDR4300_GPIO_BTN_WIRELESS,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg wndr4300_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wndr4300_ar8327_led_cfg = {
+	.led_ctrl0 = 0xc737c737,
+	.led_ctrl1 = 0x00000000,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x0030c300,
+	.open_drain = false,
+};
+
+static struct ar8327_platform_data wndr4300_ar8327_data = {
+	.pad0_cfg = &wndr4300_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wndr4300_ar8327_led_cfg,
+};
+
+static struct mdio_board_info wndr4300_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &wndr4300_ar8327_data,
+	},
+};
+
+static void __init wndr4300_setup(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(wndr4300_leds_gpio); i++)
+		ath79_gpio_output_select(wndr4300_leds_gpio[i].gpio,
+					 AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wndr4300_leds_gpio),
+				 wndr4300_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WNDR4300_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wndr4300_gpio_keys),
+					wndr4300_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(wndr4300_mdio0_info,
+				    ARRAY_SIZE(wndr4300_mdio0_info));
+
+	ath79_register_mdio(0, 0x0);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_nfc_set_ecc_mode(AR934X_NFC_ECC_HW);
+	ath79_register_nfc();
+	ath79_register_usb();
+
+	ath79_register_wmac_simple();
+
+	/* enable power for the USB port */
+	ap9x_pci_setup_wmac_gpio(0, BIT(WNDR4300_GPIO_USB_5V),
+				 BIT(WNDR4300_GPIO_USB_5V));
+
+	ap91_pci_init_simple();
+}
+
+MIPS_MACHINE(ATH79_MACH_WNDR3700_V4, "WNDR3700_V4", "NETGEAR WNDR3700v4",
+	     wndr4300_setup);
+MIPS_MACHINE(ATH79_MACH_WNDR4300, "WNDR4300", "NETGEAR WNDR4300",
+	     wndr4300_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wnr2000.c linux-4.1.13/arch/mips/ath79/mach-wnr2000.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wnr2000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wnr2000.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,145 @@
+/*
+ *  NETGEAR WNR2000 board support
+ *
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008-2009 Andy Boyett <agb@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WNR2000_GPIO_LED_PWR_GREEN	14
+#define WNR2000_GPIO_LED_PWR_AMBER	7
+#define WNR2000_GPIO_LED_WPS		4
+#define WNR2000_GPIO_LED_WLAN		6
+#define WNR2000_GPIO_BTN_RESET		21
+#define WNR2000_GPIO_BTN_WPS		8
+
+#define WNR2000_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNR2000_KEYS_DEBOUNCE_INTERVAL	(3 * WNR2000_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wnr2000_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x040000,
+		.size		= 0x010000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x050000,
+		.size		= 0x240000,
+	}, {
+		.name		= "user-config",
+		.offset		= 0x290000,
+		.size		= 0x010000,
+	}, {
+		.name		= "uImage",
+		.offset		= 0x2a0000,
+		.size		= 0x120000,
+	}, {
+		.name		= "language_table",
+		.offset		= 0x3c0000,
+		.size		= 0x020000,
+	}, {
+		.name		= "rootfs_checksum",
+		.offset		= 0x3e0000,
+		.size		= 0x010000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct flash_platform_data wnr2000_flash_data = {
+	.parts		= wnr2000_partitions,
+	.nr_parts	= ARRAY_SIZE(wnr2000_partitions),
+};
+
+static struct gpio_led wnr2000_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:power",
+		.gpio		= WNR2000_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wps",
+		.gpio		= WNR2000_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:blue:wlan",
+		.gpio		= WNR2000_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr2000_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000_GPIO_BTN_RESET,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000_GPIO_BTN_WPS,
+	}
+};
+
+static void __init wnr2000_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, eeprom, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.has_ar8216 = 1;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, eeprom, 1);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&wnr2000_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr2000_leds_gpio),
+				 wnr2000_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNR2000_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wnr2000_gpio_keys),
+					wnr2000_gpio_keys);
+
+	ath79_register_wmac(eeprom, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR2000, "WNR2000", "NETGEAR WNR2000", wnr2000_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wnr2000-v3.c linux-4.1.13/arch/mips/ath79/mach-wnr2000-v3.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wnr2000-v3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wnr2000-v3.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,140 @@
+/*
+ *  NETGEAR WNR2000v3/WNR612v2/WNR1000v2 board support
+ *
+ *  Copytight (C) 2013 Mathieu Olivari <mathieu.olivari@gmail.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008-2009 Andy Boyett <agb@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define WNR2000V3_GPIO_LED_WAN_GREEN	0
+#define WNR2000V3_GPIO_LED_LAN1_AMBER	1
+#define WNR2000V3_GPIO_LED_LAN4_AMBER	12
+#define WNR2000V3_GPIO_LED_PWR_GREEN	14
+#define WNR2000V3_GPIO_BTN_WPS		11
+
+#define WNR612V2_GPIO_LED_PWR_GREEN	11
+
+#define WNR1000V2_GPIO_LED_PWR_AMBER	1
+#define WNR1000V2_GPIO_LED_PWR_GREEN	11
+
+#define WNR2000V3_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WNR2000V3_KEYS_DEBOUNCE_INTERVAL	(3 * WNR2000V3_KEYS_POLL_INTERVAL)
+
+#define WNR2000V3_MAC0_OFFSET		0
+#define WNR2000V3_MAC1_OFFSET		6
+#define WNR2000V3_PCIE_CALDATA_OFFSET	0x1000
+
+static struct gpio_led wnr2000v3_leds_gpio[] __initdata = {
+	{
+		.name		= "wnr2000v3:green:power",
+		.gpio		= WNR2000V3_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "wnr2000v3:green:wan",
+		.gpio		= WNR2000V3_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wnr612v2_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNR612V2_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led wnr1000v2_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNR1000V2_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:power",
+		.gpio		= WNR1000V2_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wnr2000v3_gpio_keys[] __initdata = {
+	{
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000V3_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V3_GPIO_BTN_WPS,
+	}
+};
+
+static void __init wnr_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+WNR2000V3_MAC0_OFFSET, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+WNR2000V3_MAC1_OFFSET, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+	ap91_pci_init(art + WNR2000V3_PCIE_CALDATA_OFFSET, NULL);
+}
+
+static void __init wnr2000v3_setup(void)
+{
+	wnr_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr2000v3_leds_gpio),
+				 wnr2000v3_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNR2000V3_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wnr2000v3_gpio_keys),
+					wnr2000v3_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR2000_V3, "WNR2000V3", "NETGEAR WNR2000 V3", wnr2000v3_setup);
+
+static void __init wnr612v2_setup(void)
+{
+	wnr_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr612v2_leds_gpio),
+				 wnr612v2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR612_V2, "WNR612V2", "NETGEAR WNR612 V2", wnr612v2_setup);
+
+static void __init wnr1000v2_setup(void)
+{
+	wnr_common_setup();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr1000v2_leds_gpio),
+				 wnr1000v2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR1000_V2, "WNR1000V2", "NETGEAR WNR1000 V2", wnr1000v2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wnr2000-v4.c linux-4.1.13/arch/mips/ath79/mach-wnr2000-v4.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wnr2000-v4.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wnr2000-v4.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,214 @@
+/*
+ *  NETGEAR WNR2000v4 board support
+ *
+ *  Copyright (C) 2015 Michael Bazzinotti <mbazzinotti@gmail.com>
+ *  Copyright (C) 2014 Michal Burtin <mburtin@gmail.com>
+ *  Copyright (C) 2013 Mathieu Olivari <mathieu.olivari@gmail.com>
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *  Copyright (C) 2008-2009 Andy Boyett <agb@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+/* AR9341 GPIOs */
+#define WNR2000V4_GPIO_LED_PWR_GREEN      0
+#define WNR2000V4_GPIO_LED_PWR_AMBER      1
+#define WNR2000V4_GPIO_LED_WPS            2
+#define WNR2000V4_GPIO_LED_WLAN           12
+#define WNR2000V4_GPIO_LED_LAN1_GREEN     13
+#define WNR2000V4_GPIO_LED_LAN2_GREEN     14
+#define WNR2000V4_GPIO_LED_LAN3_GREEN     15
+#define WNR2000V4_GPIO_LED_LAN4_GREEN     16
+#define WNR2000V4_GPIO_LED_LAN1_AMBER     18
+#define WNR2000V4_GPIO_LED_LAN2_AMBER     19
+#define WNR2000V4_GPIO_LED_LAN3_AMBER     20
+#define WNR2000V4_GPIO_LED_LAN4_AMBER     21
+#define WNR2000V4_GPIO_LED_WAN_GREEN      17
+#define WNR2000V4_GPIO_LED_WAN_AMBER      22
+/* Buttons */
+#define WNR2000V4_GPIO_BTN_WPS            3
+#define WNR2000V4_GPIO_BTN_RESET          4
+#define WNR2000V4_GPIO_BTN_WLAN           11
+#define WNR2000V4_KEYS_POLL_INTERVAL      20      /* msecs */
+#define WNR2000V4_KEYS_DEBOUNCE_INTERVAL  (3 * WNR2000V4_KEYS_POLL_INTERVAL)
+
+
+/* ART offsets */
+#define WNR2000V4_MAC0_OFFSET             0       /* WAN/WLAN0 MAC   */
+#define WNR2000V4_MAC1_OFFSET             6       /* Eth-switch0 MAC */
+
+static struct gpio_led wnr2000v4_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:green:power",
+		.gpio		= WNR2000V4_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+		.default_trigger = "default-on",
+	},
+	{
+		.name		= "netgear:amber:status",
+		.gpio		= WNR2000V4_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wan",
+		.gpio		= WNR2000V4_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:wan",
+		.gpio		= WNR2000V4_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:blue:wlan",
+		.gpio		= WNR2000V4_GPIO_LED_WLAN,
+		.active_low	= 1,
+	},
+	/* LAN LEDS */
+	{
+		.name		= "netgear:green:lan1",
+		.gpio		= WNR2000V4_GPIO_LED_LAN1_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:lan2",
+		.gpio		= WNR2000V4_GPIO_LED_LAN2_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:lan3",
+		.gpio		= WNR2000V4_GPIO_LED_LAN3_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:lan4",
+		.gpio		= WNR2000V4_GPIO_LED_LAN4_GREEN,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:lan1",
+		.gpio		= WNR2000V4_GPIO_LED_LAN1_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:lan2",
+		.gpio		= WNR2000V4_GPIO_LED_LAN2_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:lan3",
+		.gpio		= WNR2000V4_GPIO_LED_LAN3_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:amber:lan4",
+		.gpio		= WNR2000V4_GPIO_LED_LAN4_AMBER,
+		.active_low	= 1,
+	},
+	{
+		.name		= "netgear:green:wps",
+		.gpio		= WNR2000V4_GPIO_LED_WPS,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wnr2000v4_gpio_keys[] __initdata = {
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WNR2000V4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V4_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WNR2000V4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V4_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WLAN button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WNR2000V4_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WNR2000V4_GPIO_BTN_WLAN,
+		.active_low	= 1,
+	},
+};
+
+static void __init wnr_common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *ee  = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_register_mdio(1, 0x0);
+
+	ath79_register_usb();
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+WNR2000V4_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+WNR2000V4_MAC1_OFFSET, 0);
+
+	/* GMAC0 is connected to the PHY0 of the internal switch, GE0 */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = BIT(4);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the internal switch, GE1 */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_register_eth(1);
+
+	ath79_register_wmac(ee, art);
+}
+
+static void __init wnr2000v4_setup(void)
+{
+	int i;
+
+	wnr_common_setup();
+
+	/* Ensure no LED has an internal MUX signal, otherwise
+	control of LED could be lost... This is especially important
+	for most green LEDS (Eth,WAN).. who arrive in this function with
+	MUX signals set. */
+	for (i = 0; i < ARRAY_SIZE(wnr2000v4_leds_gpio); i++)
+		ath79_gpio_output_select(wnr2000v4_leds_gpio[i].gpio,
+					AR934X_GPIO_OUT_GPIO);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr2000v4_leds_gpio),
+				 wnr2000v4_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WNR2000V4_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wnr2000v4_gpio_keys),
+					wnr2000v4_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR2000_V4, "WNR2000V4", "NETGEAR WNR2000 V4", wnr2000v4_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wnr2200.c linux-4.1.13/arch/mips/ath79/mach-wnr2200.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wnr2200.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wnr2200.c	2015-11-21 17:22:11.759223549 +0100
@@ -0,0 +1,137 @@
+/*
+ *  NETGEAR WNR2200 board support
+ *
+ *  Copyright (C) 2013 Aidan Kissane <aidankissane at googlemail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WNR2200_GPIO_LED_LAN2_AMBER	0
+#define WNR2200_GPIO_LED_LAN4_AMBER	1
+#define WNR2200_GPIO_LED_WPS		5
+#define WNR2200_GPIO_LED_WAN_GREEN	7
+#define WNR2200_GPIO_LED_USB		8
+#define WNR2200_GPIO_LED_LAN3_AMBER	11
+#define WNR2200_GPIO_LED_WAN_AMBER	12
+#define WNR2200_GPIO_LED_LAN1_GREEN	13
+#define WNR2200_GPIO_LED_LAN2_GREEN	14
+#define WNR2200_GPIO_LED_LAN3_GREEN	15
+#define WNR2200_GPIO_LED_LAN4_GREEN	16
+#define WNR2200_GPIO_LED_PWR_AMBER	21
+#define WNR2200_GPIO_LED_PWR_GREEN	22
+#define WNR2200_GPIO_USB_5V		4
+#define WNR2200_GPIO_USB_POWER		24
+
+#define WNR2200_KEYS_POLL_INTERVAL	20 /* msecs */
+#define WNR2200_KEYS_DEBOUNCE_INTERVAL	(3 * WNR2200_KEYS_POLL_INTERVAL)
+
+#define WNR2200_MAC0_OFFSET		0
+#define WNR2200_MAC1_OFFSET		6
+#define WNR2200_PCIE_CALDATA_OFFSET	0x1000
+
+static struct gpio_led wnr2200_leds_gpio[] __initdata = {
+	{
+		.name		= "netgear:amber:lan2",
+		.gpio		= WNR2200_GPIO_LED_LAN2_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan4",
+		.gpio		= WNR2200_GPIO_LED_LAN4_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wps",
+		.gpio		= WNR2200_GPIO_LED_WPS,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:wan",
+		.gpio		= WNR2200_GPIO_LED_WAN_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:usb",
+		.gpio		= WNR2200_GPIO_LED_USB,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:lan3",
+		.gpio		= WNR2200_GPIO_LED_LAN3_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:wan",
+		.gpio		= WNR2200_GPIO_LED_WAN_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan1",
+		.gpio		= WNR2200_GPIO_LED_LAN1_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan2",
+		.gpio		= WNR2200_GPIO_LED_LAN2_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan3",
+		.gpio		= WNR2200_GPIO_LED_LAN3_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:lan4",
+		.gpio		= WNR2200_GPIO_LED_LAN4_GREEN,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:amber:power",
+		.gpio		= WNR2200_GPIO_LED_PWR_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "netgear:green:power",
+		.gpio		= WNR2200_GPIO_LED_PWR_GREEN,
+		.active_low	= 1,
+	}
+};
+
+static void __init wnr2200_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art+WNR2200_MAC0_OFFSET, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, art+WNR2200_MAC1_OFFSET, 0);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(NULL);
+	ap91_pci_init(art + WNR2200_PCIE_CALDATA_OFFSET, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wnr2200_leds_gpio),
+					wnr2200_leds_gpio);
+
+	/* enable power for the USB port */
+	ap9x_pci_setup_wmac_gpio(0,
+		BIT(WNR2200_GPIO_USB_5V),
+		BIT(WNR2200_GPIO_USB_5V));
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_WNR2200, "WNR2200", "NETGEAR WNR2200", wnr2200_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wp543.c linux-4.1.13/arch/mips/ath79/mach-wp543.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wp543.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wp543.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,109 @@
+/*
+ *  Compex WP543/WPJ543 board support
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define WP543_GPIO_SW6		2
+#define WP543_GPIO_LED_1	3
+#define WP543_GPIO_LED_2	4
+#define WP543_GPIO_LED_WLAN	5
+#define WP543_GPIO_LED_CONN	6
+#define WP543_GPIO_LED_DIAG	7
+#define WP543_GPIO_SW4		8
+
+#define WP543_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WP543_KEYS_DEBOUNCE_INTERVAL	(3 * WP543_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wp543_leds_gpio[] __initdata = {
+	{
+		.name		= "wp543:green:led1",
+		.gpio		= WP543_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:led2",
+		.gpio		= WP543_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:wlan",
+		.gpio		= WP543_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:conn",
+		.gpio		= WP543_GPIO_LED_CONN,
+		.active_low	= 1,
+	}, {
+		.name		= "wp543:green:diag",
+		.gpio		= WP543_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wp543_gpio_keys[] __initdata = {
+	{
+		.desc		= "sw6",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WP543_GPIO_SW6,
+		.active_low	= 1,
+	}, {
+		.desc		= "sw4",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WP543_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WP543_GPIO_SW4,
+		.active_low	= 1,
+	}
+};
+
+static const char *wp543_part_probes[] = {
+	"MyLoader",
+	NULL,
+};
+
+static struct flash_platform_data wp543_flash_data = {
+	.part_probes	= wp543_part_probes,
+};
+
+static void __init wp543_setup(void)
+{
+	ath79_register_m25p80(&wp543_flash_data);
+
+	ath79_register_mdio(0, 0xfffffff0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = 0x0f;
+	ath79_eth0_data.reset_bit = AR71XX_RESET_GE0_MAC |
+				    AR71XX_RESET_GE0_PHY;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+	ath79_register_pci();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wp543_leds_gpio),
+					wp543_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WP543_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wp543_gpio_keys),
+					 wp543_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WP543, "WP543", "Compex WP543", wp543_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wpe72.c linux-4.1.13/arch/mips/ath79/mach-wpe72.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wpe72.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wpe72.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,97 @@
+/*
+ *  Compex WPE72 board support
+ *
+ *  Copyright (C) 2012 Johnathan Boyce<jon.boyce@globalreach.eu.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+#include "pci.h"
+
+#define WPE72_GPIO_RESET	12
+#define WPE72_GPIO_LED_DIAG	13
+#define WPE72_GPIO_LED_1	14
+#define WPE72_GPIO_LED_2	15
+#define WPE72_GPIO_LED_3	16
+#define WPE72_GPIO_LED_4	17
+
+#define WPE72_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WPE72_KEYS_DEBOUNCE_INTERVAL	(3 * WPE72_KEYS_POLL_INTERVAL)
+
+static struct gpio_led wpe72_leds_gpio[] __initdata = {
+	{
+		.name		= "wpe72:green:led1",
+		.gpio		= WPE72_GPIO_LED_1,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:led2",
+		.gpio		= WPE72_GPIO_LED_2,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:led3",
+		.gpio		= WPE72_GPIO_LED_3,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:led4",
+		.gpio		= WPE72_GPIO_LED_4,
+		.active_low	= 1,
+	}, {
+		.name		= "wpe72:green:diag",
+		.gpio		= WPE72_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wpe72_gpio_keys[] __initdata = {
+	{
+		.desc           = "reset",
+		.type           = EV_KEY,
+		.code           = KEY_RESTART,
+		.debounce_interval = WPE72_KEYS_DEBOUNCE_INTERVAL,
+		.gpio           = WPE72_GPIO_RESET,
+		.active_low	= 1,
+	}
+};
+
+static const char *wpe72_part_probes[] = {
+	"MyLoader",
+	NULL,
+};
+
+static struct flash_platform_data wpe72_flash_data = {
+	.part_probes	= wpe72_part_probes,
+};
+
+static void __init wpe72_setup(void)
+{
+	ath79_register_m25p80(&wpe72_flash_data);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, ath79_mac_base, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, ath79_mac_base, 1);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+	ath79_register_pci();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wpe72_leds_gpio),
+				 wpe72_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WPE72_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpe72_gpio_keys),
+					wpe72_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPE72, "WPE72", "Compex WPE72", wpe72_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wpj344.c linux-4.1.13/arch/mips/ath79/mach-wpj344.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wpj344.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wpj344.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,175 @@
+/*
+ * Compex WPJ344 board support
+ *
+ * Copyright (c) 2011 Qualcomm Atheros
+ * Copyright (c) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-usb.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WPJ344_GPIO_LED_SIG1	15
+#define WPJ344_GPIO_LED_SIG2	20
+#define WPJ344_GPIO_LED_SIG3	21
+#define WPJ344_GPIO_LED_SIG4	22
+#define WPJ344_GPIO_LED_STATUS	14
+
+#define WPJ344_GPIO_BTN_RESET	12
+
+#define WPJ344_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WPJ344_KEYS_DEBOUNCE_INTERVAL	(3 * WPJ344_KEYS_POLL_INTERVAL)
+
+#define WPJ344_MAC0_OFFSET		0
+#define WPJ344_MAC1_OFFSET		6
+#define WPJ344_WMAC_CALDATA_OFFSET	0x1000
+#define WPJ344_PCIE_CALDATA_OFFSET	0x5000
+
+static struct gpio_led wpj344_leds_gpio[] __initdata = {
+	{
+		.name		= "wpj344:green:status",
+		.gpio		= WPJ344_GPIO_LED_STATUS,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj344:red:sig1",
+		.gpio		= WPJ344_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj344:yellow:sig2",
+		.gpio		= WPJ344_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj344:green:sig3",
+		.gpio		= WPJ344_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj344:green:sig4",
+		.gpio		= WPJ344_GPIO_LED_SIG4,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wpj344_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WPJ344_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WPJ344_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg wpj344_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wpj344_ar8327_led_cfg = {
+	.led_ctrl0 = 0x00000000,
+	.led_ctrl1 = 0xc737c737,
+	.led_ctrl2 = 0x00000000,
+	.led_ctrl3 = 0x00c30c00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data wpj344_ar8327_data = {
+	.pad0_cfg = &wpj344_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wpj344_ar8327_led_cfg,
+};
+
+static struct mdio_board_info wpj344_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &wpj344_ar8327_data,
+	},
+};
+
+static void __init wpj344_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wpj344_leds_gpio),
+				 wpj344_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WPJ344_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpj344_gpio_keys),
+					wpj344_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + WPJ344_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+
+	mdiobus_register_board_info(wpj344_mdio0_info,
+					ARRAY_SIZE(wpj344_mdio0_info));
+
+	ath79_register_mdio(1, 0x0);
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + WPJ344_MAC0_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + WPJ344_MAC1_OFFSET, 0);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_SW_ONLY_MODE);
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPJ344, "WPJ344", "Compex WPJ344", wpj344_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wpj531.c linux-4.1.13/arch/mips/ath79/mach-wpj531.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wpj531.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wpj531.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,143 @@
+/*
+ * Compex WPJ531 board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "pci.h"
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WPJ531_GPIO_LED_SIG1    14
+#define WPJ531_GPIO_LED_SIG2    15
+#define WPJ531_GPIO_LED_SIG3    22
+#define WPJ531_GPIO_LED_SIG4    23
+#define WPJ531_GPIO_BUZZER      4
+
+#define WPJ531_GPIO_BTN_RESET   17
+
+#define WPJ531_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WPJ531_KEYS_DEBOUNCE_INTERVAL	(3 * WPJ531_KEYS_POLL_INTERVAL)
+
+#define WPJ531_MAC0_OFFSET		0x10
+#define WPJ531_MAC1_OFFSET		0x18
+#define WPJ531_WMAC_CALDATA_OFFSET	0x1000
+#define WPJ531_PCIE_CALDATA_OFFSET	0x5000
+
+#define WPJ531_ART_SIZE		0x8000
+
+static struct gpio_led wpj531_leds_gpio[] __initdata = {
+	{
+		.name		= "wpj531:red:sig1",
+		.gpio		= WPJ531_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj531:yellow:sig2",
+		.gpio		= WPJ531_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj531:green:sig3",
+		.gpio		= WPJ531_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj531:green:sig4",
+		.gpio		= WPJ531_GPIO_LED_SIG4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj531:buzzer",
+		.gpio		= WPJ531_GPIO_BUZZER,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button wpj531_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WPJ531_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WPJ531_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static void __init common_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f02e000);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_setup_ar933x_phy4_switch(false, false);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac + WPJ531_MAC0_OFFSET, 0);
+	ath79_register_eth(0);
+
+	/* WAN */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac + WPJ531_MAC1_OFFSET, 0);
+	ath79_register_eth(1);
+
+	ath79_register_wmac(art + WPJ531_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+	ath79_register_usb();
+}
+
+static void __init wpj531_setup(void)
+{
+	common_setup();
+
+	ath79_register_leds_gpio(-1,
+				ARRAY_SIZE(wpj531_leds_gpio),
+				wpj531_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1,
+					WPJ531_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpj531_gpio_keys),
+					wpj531_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPJ531, "WPJ531", "Compex WPJ531", wpj531_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wpj558.c linux-4.1.13/arch/mips/ath79/mach-wpj558.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wpj558.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wpj558.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,177 @@
+/*
+ * Compex WPJ558 board support
+ *
+ * Copyright (c) 2012 Qualcomm Atheros
+ * Copyright (c) 2012-2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "pci.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-eth.h"
+#include "dev-usb.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WPJ558_GPIO_LED_SIG1	14
+#define WPJ558_GPIO_LED_SIG2	15
+#define WPJ558_GPIO_LED_SIG3	22
+#define WPJ558_GPIO_LED_SIG4	23
+#define WPJ558_GPIO_BUZZER		4
+
+#define WPJ558_GPIO_BTN_RESET	17
+
+#define WPJ558_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WPJ558_KEYS_DEBOUNCE_INTERVAL	(3 * WPJ558_KEYS_POLL_INTERVAL)
+
+#define WPJ558_MAC_OFFSET			0x1002
+#define WPJ558_WMAC_CALDATA_OFFSET	0x1000
+
+static struct gpio_led wpj558_leds_gpio[] __initdata = {
+	{
+		.name		= "wpj558:red:sig1",
+		.gpio		= WPJ558_GPIO_LED_SIG1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj558:yellow:sig2",
+		.gpio		= WPJ558_GPIO_LED_SIG2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj558:green:sig3",
+		.gpio		= WPJ558_GPIO_LED_SIG3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj558:green:sig4",
+		.gpio		= WPJ558_GPIO_LED_SIG4,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wpj558:buzzer",
+		.gpio		= WPJ558_GPIO_BUZZER,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button wpj558_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WPJ558_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WPJ558_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+};
+
+static struct ar8327_pad_cfg wpj558_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_pad_cfg wpj558_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_platform_data wpj558_ar8327_data = {
+	.pad0_cfg = &wpj558_ar8327_pad0_cfg,
+	.pad6_cfg = &wpj558_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+static struct mdio_board_info wpj558_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &wpj558_ar8327_data,
+	},
+};
+
+static void __init wpj558_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wpj558_leds_gpio),
+					wpj558_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WPJ558_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wpj558_gpio_keys),
+					wpj558_gpio_keys);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + WPJ558_WMAC_CALDATA_OFFSET, NULL);
+
+	ath79_register_pci();
+
+	mdiobus_register_board_info(wpj558_mdio0_info,
+					ARRAY_SIZE(wpj558_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + WPJ558_MAC_OFFSET, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + WPJ558_MAC_OFFSET, 0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to an AR8327 switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_WPJ558, "WPJ558", "Compex WPJ558", wpj558_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wrt160nl.c linux-4.1.13/arch/mips/ath79/mach-wrt160nl.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wrt160nl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wrt160nl.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,126 @@
+/*
+ *  Linksys WRT160NL board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "nvram.h"
+#include "machtypes.h"
+
+#define WRT160NL_GPIO_LED_POWER		14
+#define WRT160NL_GPIO_LED_WPS_AMBER	9
+#define WRT160NL_GPIO_LED_WPS_BLUE	8
+#define WRT160NL_GPIO_LED_WLAN		6
+
+#define WRT160NL_GPIO_BTN_WPS		7
+#define WRT160NL_GPIO_BTN_RESET		21
+
+#define WRT160NL_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT160NL_KEYS_DEBOUNCE_INTERVAL	(3 * WRT160NL_KEYS_POLL_INTERVAL)
+
+#define WRT160NL_NVRAM_ADDR	0x1f7e0000
+#define WRT160NL_NVRAM_SIZE	0x10000
+
+static const char *wrt160nl_part_probes[] = {
+	"cybertan",
+	NULL,
+};
+
+static struct flash_platform_data wrt160nl_flash_data = {
+	.part_probes	= wrt160nl_part_probes,
+};
+
+static struct gpio_led wrt160nl_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt160nl:blue:power",
+		.gpio		= WRT160NL_GPIO_LED_POWER,
+		.active_low	= 1,
+		.default_trigger = "default-on",
+	}, {
+		.name		= "wrt160nl:amber:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wps",
+		.gpio		= WRT160NL_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt160nl:blue:wlan",
+		.gpio		= WRT160NL_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wrt160nl_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WRT160NL_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wps",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT160NL_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WRT160NL_GPIO_BTN_WPS,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt160nl_setup(void)
+{
+	const char *nvram = (char *) KSEG1ADDR(WRT160NL_NVRAM_ADDR);
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 mac[6];
+
+	if (ath79_nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+				       "lan_hwaddr=", mac) == 0) {
+		ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+		ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+	}
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.phy_mask = 0x01;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&wrt160nl_flash_data);
+
+	ath79_register_usb();
+
+	if (ath79_nvram_parse_mac_addr(nvram, WRT160NL_NVRAM_SIZE,
+				       "wl0_hwaddr=", mac) == 0)
+		ath79_register_wmac(eeprom, mac);
+	else
+		ath79_register_wmac(eeprom, NULL);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wrt160nl_leds_gpio),
+				 wrt160nl_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WRT160NL_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wrt160nl_gpio_keys),
+					wrt160nl_gpio_keys);
+}
+
+MIPS_MACHINE(ATH79_MACH_WRT160NL, "WRT160NL", "Linksys WRT160NL",
+	     wrt160nl_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wrt400n.c linux-4.1.13/arch/mips/ath79/mach-wrt400n.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wrt400n.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wrt400n.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,161 @@
+/*
+ *  Linksys WRT400N board support
+ *
+ *  Copyright (C) 2009-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2009 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "machtypes.h"
+
+#define WRT400N_GPIO_LED_POWER		1
+#define WRT400N_GPIO_LED_WPS_BLUE	4
+#define WRT400N_GPIO_LED_WPS_AMBER	5
+#define WRT400N_GPIO_LED_WLAN		6
+
+#define WRT400N_GPIO_BTN_RESET		8
+#define WRT400N_GPIO_BTN_WLSEC		3
+
+#define WRT400N_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WRT400N_KEYS_DEBOUNE_INTERVAL	(3 * WRT400N_KEYS_POLL_INTERVAL)
+
+#define WRT400N_MAC_ADDR_OFFSET		0x120c
+#define WRT400N_CALDATA0_OFFSET		0x1000
+#define WRT400N_CALDATA1_OFFSET		0x5000
+
+static struct mtd_partition wrt400n_partitions[] = {
+	{
+		.name		= "uboot",
+		.offset		= 0,
+		.size		= 0x030000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "env",
+		.offset		= 0x030000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "linux",
+		.offset		= 0x040000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x180000,
+		.size		= 0x630000,
+	}, {
+		.name		= "nvram",
+		.offset		= 0x7b0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "factory",
+		.offset		= 0x7c0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "language",
+		.offset		= 0x7d0000,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "caldata",
+		.offset		= 0x7f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x040000,
+		.size		= 0x770000,
+	}
+};
+
+static struct flash_platform_data wrt400n_flash_data = {
+	.parts		= wrt400n_partitions,
+	.nr_parts	= ARRAY_SIZE(wrt400n_partitions),
+};
+
+static struct gpio_led wrt400n_leds_gpio[] __initdata = {
+	{
+		.name		= "wrt400n:blue:wps",
+		.gpio		= WRT400N_GPIO_LED_WPS_BLUE,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:amber:wps",
+		.gpio		= WRT400N_GPIO_LED_WPS_AMBER,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:blue:wlan",
+		.gpio		= WRT400N_GPIO_LED_WLAN,
+		.active_low	= 1,
+	}, {
+		.name		= "wrt400n:blue:power",
+		.gpio		= WRT400N_GPIO_LED_POWER,
+		.active_low	= 0,
+		.default_trigger = "default-on",
+	}
+};
+
+static struct gpio_keys_button wrt400n_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
+		.gpio		= WRT400N_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "wlsec",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WRT400N_KEYS_DEBOUNE_INTERVAL,
+		.gpio		= WRT400N_GPIO_BTN_WLSEC,
+		.active_low	= 1,
+	}
+};
+
+static void __init wrt400n_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac = art + WRT400N_MAC_ADDR_OFFSET;
+
+	ath79_register_mdio(0, 0x0);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 1);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 2);
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_m25p80(&wrt400n_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wrt400n_leds_gpio),
+				 wrt400n_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WRT400N_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wrt400n_gpio_keys),
+					wrt400n_gpio_keys);
+
+	ap94_pci_init(art + WRT400N_CALDATA0_OFFSET, NULL,
+		      art + WRT400N_CALDATA1_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_WRT400N, "WRT400N", "Linksys WRT400N", wrt400n_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wzr-450hp2.c linux-4.1.13/arch/mips/ath79/mach-wzr-450hp2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wzr-450hp2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wzr-450hp2.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,221 @@
+/*
+ * Buffalo WZR-450HP2 board support
+ *
+ * Copyright (c) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Based on the Qualcomm Atheros AP135/AP136 reference board support code
+ *   Copyright (c) 2012 Qualcomm Atheros
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WZR_450HP2_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WZR_450HP2_KEYS_DEBOUNCE_INTERVAL (3 * WZR_450HP2_KEYS_POLL_INTERVAL)
+
+#define WZR_450HP2_WMAC_CALDATA_OFFSET	0x1000
+
+static struct mtd_partition wzrhpg450h_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x0ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0050000,
+		.size		= 0x0f90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x0fe0000,
+		.size		= 0x0010000,
+	}
+};
+
+static struct flash_platform_data wzr_450hp2_flash_data = {
+	.parts		= wzrhpg450h_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg450h_partitions),
+};
+
+static struct gpio_led wzr_450hp2_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:green:wps",
+		.gpio		= 3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:system",
+		.gpio		= 20,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:wlan",
+		.gpio		= 18,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wzr_450hp2_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZR_450HP2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 17,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "RFKILL button",
+		.type		= EV_KEY,
+		.code		= KEY_RFKILL,
+		.debounce_interval = WZR_450HP2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 21,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info wzr_450hp2_leds_ar8327[] = {
+	AR8327_LED_INFO(PHY0_0, HW, "buffalo:green:lan1"),
+	AR8327_LED_INFO(PHY1_0, HW, "buffalo:green:lan2"),
+	AR8327_LED_INFO(PHY2_0, HW, "buffalo:green:lan3"),
+	AR8327_LED_INFO(PHY3_0, HW, "buffalo:green:lan4"),
+	AR8327_LED_INFO(PHY4_0, HW, "buffalo:green:wan"),
+};
+
+/* GMAC0 of the AR8327 switch is connected to the QCA9558 SoC via SGMII */
+static struct ar8327_pad_cfg wzr_450hp2_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+/* GMAC6 of the AR8327 switch is connected to the QCA9558 SoC via RGMII */
+static struct ar8327_pad_cfg wzr_450hp2_ar8327_pad6_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg wzr_450hp2_ar8327_led_cfg = {
+	.led_ctrl0 = 0xcc35cc35,
+	.led_ctrl1 = 0xca35ca35,
+	.led_ctrl2 = 0xc935c935,
+	.led_ctrl3 = 0x03ffff00,
+	.open_drain = true,
+};
+
+static struct ar8327_platform_data wzr_450hp2_ar8327_data = {
+	.pad0_cfg = &wzr_450hp2_ar8327_pad0_cfg,
+	.pad6_cfg = &wzr_450hp2_ar8327_pad6_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.port6_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &wzr_450hp2_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(wzr_450hp2_leds_ar8327),
+	.leds = wzr_450hp2_leds_ar8327,
+};
+
+static struct mdio_board_info wzr_450hp2_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &wzr_450hp2_ar8327_data,
+	},
+};
+
+static void __init wzr_450hp2_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 *mac_wan = art;
+	u8 *mac_lan = mac_wan + ETH_ALEN;
+
+	ath79_register_m25p80(&wzr_450hp2_flash_data);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzr_450hp2_leds_gpio),
+				 wzr_450hp2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WZR_450HP2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wzr_450hp2_gpio_keys),
+					wzr_450hp2_gpio_keys);
+
+	ath79_register_wmac(art + WZR_450HP2_WMAC_CALDATA_OFFSET, mac_lan);
+
+	mdiobus_register_board_info(wzr_450hp2_mdio0_info,
+				    ARRAY_SIZE(wzr_450hp2_mdio0_info));
+	ath79_register_mdio(0, 0x0);
+
+	ath79_setup_qca955x_eth_cfg(QCA955X_ETH_CFG_RGMII_EN);
+
+	/* GMAC0 is connected to the RMGII interface */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x56000000;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac_wan, 0);
+	ath79_register_eth(0);
+
+	/* GMAC1 is connected to the SGMII interface */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_pll_data.pll_1000 = 0x03000101;
+
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac_lan, 0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_450HP2, "WZR-450HP2",
+	     "Buffalo WZR-450HP2", wzr_450hp2_setup);
+
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wzr-hp-ag300h.c linux-4.1.13/arch/mips/ath79/mach-wzr-hp-ag300h.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wzr-hp-ag300h.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wzr-hp-ag300h.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,205 @@
+/*
+ *  Buffalo WZR-HP-AG300H board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WZRHPAG300H_MAC_OFFSET		0x20c
+#define WZRHPAG300H_KEYS_POLL_INTERVAL	20      /* msecs */
+#define WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPAG300H_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wzrhpag300h_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct flash_platform_data wzrhpag300h_flash_data = {
+	.parts      = wzrhpag300h_flash_partitions,
+	.nr_parts   = ARRAY_SIZE(wzrhpag300h_flash_partitions),
+};
+
+static struct gpio_led wzrhpag300h_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 1,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led wzrhpag300h_wmac0_leds_gpio[] = {
+        {
+                .name           = "buffalo:amber:band2g",
+                .gpio           = 1,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:green:usb",
+                .gpio           = 3,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:green:band2g",
+                .gpio           = 5,
+                .active_low     = 1,
+	},
+};
+
+static struct gpio_led wzrhpag300h_wmac1_leds_gpio[] = {
+        {
+                .name           = "buffalo:green:band5g",
+                .gpio           = 1,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:green:router",
+                .gpio           = 3,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:blue:movie_engine",
+                .gpio           = 4,
+                .active_low     = 1,
+	},
+        {
+                .name           = "buffalo:amber:band5g",
+                .gpio           = 5,
+                .active_low     = 1,
+	},
+};
+
+static struct gpio_keys_button wzrhpag300h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 3,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 5,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_SW,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 6,
+		.active_low	= 1,
+	}, {
+		.desc		= "router_off",
+		.type		= EV_SW,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 1,
+	}, {
+		.desc		= "movie_engine",
+		.type		= EV_SW,
+		.code		= BTN_7,
+		.debounce_interval = WZRHPAG300H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 8,
+		.active_low	= 1,
+	}
+};
+
+static void __init wzrhpag300h_setup(void)
+{
+	u8 *eeprom1 = (u8 *) KSEG1ADDR(0x1f051000);
+	u8 *eeprom2 = (u8 *) KSEG1ADDR(0x1f055000);
+	u8 *mac1 = eeprom1 + WZRHPAG300H_MAC_OFFSET;
+	u8 *mac2 = eeprom2 + WZRHPAG300H_MAC_OFFSET;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac1, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac2, 1);
+
+	ath79_register_mdio(0, ~(BIT(0) | BIT(4)));
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = BIT(4);
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	gpio_request_one(2, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpag300h_leds_gpio),
+					wzrhpag300h_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WZRHPAG300H_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpag300h_gpio_keys),
+					 wzrhpag300h_gpio_keys);
+
+	ath79_register_m25p80_multi(&wzrhpag300h_flash_data);
+
+	ap94_pci_init(eeprom1, mac1, eeprom2, mac2);
+
+	ap9x_pci_setup_wmac_led_pin(0, 1);
+	ap9x_pci_setup_wmac_led_pin(1, 5);
+
+	ap9x_pci_setup_wmac_leds(0, wzrhpag300h_wmac0_leds_gpio,
+				ARRAY_SIZE(wzrhpag300h_wmac0_leds_gpio));
+	ap9x_pci_setup_wmac_leds(1, wzrhpag300h_wmac1_leds_gpio,
+				ARRAY_SIZE(wzrhpag300h_wmac1_leds_gpio));
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_AG300H, "WZR-HP-AG300H",
+	     "Buffalo WZR-HP-AG300H/WZR-600DHP", wzrhpag300h_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wzr-hp-g300nh2.c linux-4.1.13/arch/mips/ath79/mach-wzr-hp-g300nh2.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wzr-hp-g300nh2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wzr-hp-g300nh2.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,170 @@
+/*
+ *  Buffalo WZR-HP-G300NH2 board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2011 Mark Deneen <mdeneen@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WZRHPG300NH2_MAC_OFFSET		0x20c
+#define WZRHPG300NH2_KEYS_POLL_INTERVAL     20      /* msecs */
+#define WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG300NH2_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wzrhpg300nh2_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f90000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1ff0000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct flash_platform_data wzrhpg300nh2_flash_data = {
+	.parts          = wzrhpg300nh2_flash_partitions,
+	.nr_parts       = ARRAY_SIZE(wzrhpg300nh2_flash_partitions),
+};
+
+static struct gpio_led wzrhpg300nh2_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 16,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_led wzrhpg300nh2_wmac_leds_gpio[] = {
+	{
+		.name           = "buffalo:blue:usb",
+		.gpio           = 4,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:orange:security",
+		.gpio           = 6,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:green:router",
+		.gpio           = 7,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:blue:movie_engine_on",
+		.gpio           = 8,
+		.active_low     = 1,
+	},
+	{
+		.name           = "buffalo:blue:movie_engine_off",
+		.gpio           = 9,
+		.active_low     = 1,
+	},
+};
+
+/* The AOSS button is wmac gpio 12 */
+static struct gpio_keys_button wzrhpg300nh2_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 1,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 1,
+	}, {
+		.desc		= "qos",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 11,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG300NH2_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 8,
+		.active_low	= 0,
+	},
+};
+
+static void __init wzrhpg300nh2_setup(void)
+{
+
+	u8 *eeprom = (u8 *)   KSEG1ADDR(0x1f051000);
+	u8 *mac0   = eeprom + WZRHPG300NH2_MAC_OFFSET;
+	/* There is an eth1 but it is not connected to the switch */
+
+	ath79_register_m25p80_multi(&wzrhpg300nh2_flash_data);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+	ath79_register_mdio(0, ~(BIT(0)));
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac0, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_eth(0);
+
+	/* gpio13 is usb power.  Turn it on. */
+	gpio_request_one(13, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpg300nh2_leds_gpio),
+				 wzrhpg300nh2_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, WZRHPG300NH2_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wzrhpg300nh2_gpio_keys),
+					wzrhpg300nh2_gpio_keys);
+	ap9x_pci_setup_wmac_led_pin(0, 5);
+	ap9x_pci_setup_wmac_leds(0, wzrhpg300nh2_wmac_leds_gpio,
+				ARRAY_SIZE(wzrhpg300nh2_wmac_leds_gpio));
+
+	ap91_pci_init(eeprom, mac0);
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_G300NH2, "WZR-HP-G300NH2",
+	     "Buffalo WZR-HP-G300NH2", wzrhpg300nh2_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wzr-hp-g300nh.c linux-4.1.13/arch/mips/ath79/mach-wzr-hp-g300nh.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wzr-hp-g300nh.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wzr-hp-g300nh.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,279 @@
+/*
+ *  Buffalo WZR-HP-G300NH board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/nxp_74hc153.h>
+#include <linux/rtl8366.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define WZRHPG300NH_GPIO_LED_USB	0
+#define WZRHPG300NH_GPIO_LED_DIAG	1
+#define WZRHPG300NH_GPIO_LED_WIRELESS	6
+#define WZRHPG300NH_GPIO_LED_SECURITY	17
+#define WZRHPG300NH_GPIO_LED_ROUTER	18
+
+#define WZRHPG300NH_GPIO_RTL8366_SDA	19
+#define WZRHPG300NH_GPIO_RTL8366_SCK	20
+
+#define WZRHPG300NH_GPIO_74HC153_S0	9
+#define WZRHPG300NH_GPIO_74HC153_S1	11
+#define WZRHPG300NH_GPIO_74HC153_1Y	12
+#define WZRHPG300NH_GPIO_74HC153_2Y	14
+
+#define WZRHPG300NH_GPIO_EXP_BASE	32
+#define WZRHPG300NH_GPIO_BTN_AOSS	(WZRHPG300NH_GPIO_EXP_BASE + 0)
+#define WZRHPG300NH_GPIO_BTN_RESET	(WZRHPG300NH_GPIO_EXP_BASE + 1)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_ON	(WZRHPG300NH_GPIO_EXP_BASE + 2)
+#define WZRHPG300NH_GPIO_BTN_QOS_ON	(WZRHPG300NH_GPIO_EXP_BASE + 3)
+#define WZRHPG300NH_GPIO_BTN_USB	(WZRHPG300NH_GPIO_EXP_BASE + 5)
+#define WZRHPG300NH_GPIO_BTN_ROUTER_AUTO (WZRHPG300NH_GPIO_EXP_BASE + 6)
+#define WZRHPG300NH_GPIO_BTN_QOS_OFF	(WZRHPG300NH_GPIO_EXP_BASE + 7)
+
+#define WZRHPG300NH_KEYS_POLL_INTERVAL	20	/* msecs */
+#define WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG300NH_KEYS_POLL_INTERVAL)
+
+#define WZRHPG300NH_MAC_OFFSET		0x20c
+
+static struct mtd_partition wzrhpg300nh_flash_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f60000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1fc0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "art",
+		.offset		= 0x1fe0000,
+		.size		= 0x0020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}
+};
+
+static struct physmap_flash_data wzrhpg300nh_flash_data = {
+	.width		= 2,
+	.parts		= wzrhpg300nh_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg300nh_flash_partitions),
+};
+
+#define WZRHPG300NH_FLASH_BASE	0x1e000000
+#define WZRHPG300NH_FLASH_SIZE	(32 * 1024 * 1024)
+
+static struct resource wzrhpg300nh_flash_resources[] = {
+	[0] = {
+		.start	= WZRHPG300NH_FLASH_BASE,
+		.end	= WZRHPG300NH_FLASH_BASE + WZRHPG300NH_FLASH_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device wzrhpg300nh_flash_device = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.resource	= wzrhpg300nh_flash_resources,
+	.num_resources	= ARRAY_SIZE(wzrhpg300nh_flash_resources),
+	.dev		= {
+		.platform_data = &wzrhpg300nh_flash_data,
+	}
+};
+
+static struct gpio_led wzrhpg300nh_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= WZRHPG300NH_GPIO_LED_SECURITY,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:wireless",
+		.gpio		= WZRHPG300NH_GPIO_LED_WIRELESS,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:green:router",
+		.gpio		= WZRHPG300NH_GPIO_LED_ROUTER,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:red:diag",
+		.gpio		= WZRHPG300NH_GPIO_LED_DIAG,
+		.active_low	= 1,
+	}, {
+		.name		= "buffalo:blue:usb",
+		.gpio		= WZRHPG300NH_GPIO_LED_USB,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_button wzrhpg300nh_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_AOSS,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_USB,
+		.active_low	= 1,
+	}, {
+		.desc		= "qos_on",
+		.type		= EV_KEY,
+		.code		= BTN_3,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "qos_off",
+		.type		= EV_KEY,
+		.code		= BTN_4,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_QOS_OFF,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_on",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_ON,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_auto",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPG300NH_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= WZRHPG300NH_GPIO_BTN_ROUTER_AUTO,
+		.active_low	= 0,
+	}
+};
+
+static struct nxp_74hc153_platform_data wzrhpg300nh_74hc153_data = {
+	.gpio_base	= WZRHPG300NH_GPIO_EXP_BASE,
+	.gpio_pin_s0	= WZRHPG300NH_GPIO_74HC153_S0,
+	.gpio_pin_s1	= WZRHPG300NH_GPIO_74HC153_S1,
+	.gpio_pin_1y	= WZRHPG300NH_GPIO_74HC153_1Y,
+	.gpio_pin_2y	= WZRHPG300NH_GPIO_74HC153_2Y,
+};
+
+static struct platform_device wzrhpg300nh_74hc153_device = {
+	.name		= NXP_74HC153_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_74hc153_data,
+	}
+};
+
+static struct rtl8366_platform_data wzrhpg300nh_rtl8366_data = {
+	.gpio_sda	= WZRHPG300NH_GPIO_RTL8366_SDA,
+	.gpio_sck	= WZRHPG300NH_GPIO_RTL8366_SCK,
+};
+
+static struct platform_device wzrhpg300nh_rtl8366s_device = {
+	.name		= RTL8366S_DRIVER_NAME,
+	.id		= -1,
+	.dev = {
+		.platform_data	= &wzrhpg300nh_rtl8366_data,
+	}
+};
+
+static struct platform_device wzrhpg300nh_rtl8366rb_device = {
+	.name           = RTL8366RB_DRIVER_NAME,
+	.id             = -1,
+	.dev = {
+		.platform_data  = &wzrhpg300nh_rtl8366_data,
+	}
+};
+
+static void __init wzrhpg300nh_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1fff1000);
+	u8 *mac = eeprom + WZRHPG300NH_MAC_OFFSET;
+	bool hasrtl8366rb = false;
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	if (rtl8366_smi_detect(&wzrhpg300nh_rtl8366_data) == RTL8366_TYPE_RB)
+		hasrtl8366rb = true;
+
+	if (hasrtl8366rb) {
+		ath79_eth0_pll_data.pll_1000 = 0x1f000000;
+		ath79_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+		ath79_eth1_pll_data.pll_1000 = 0x100;
+		ath79_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366rb_device.dev;
+	} else {
+		ath79_eth0_pll_data.pll_1000 = 0x1e000100;
+		ath79_eth0_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+		ath79_eth1_pll_data.pll_1000 = 0x1e000100;
+		ath79_eth1_data.mii_bus_dev = &wzrhpg300nh_rtl8366s_device.dev;
+	}
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth1_data.phy_mask = 0x10;
+
+	ath79_register_eth(0);
+	ath79_register_eth(1);
+
+	ath79_register_usb();
+	ath79_register_wmac(eeprom, NULL);
+
+	platform_device_register(&wzrhpg300nh_74hc153_device);
+	platform_device_register(&wzrhpg300nh_flash_device);
+
+	if (hasrtl8366rb)
+		platform_device_register(&wzrhpg300nh_rtl8366rb_device);
+	else
+		platform_device_register(&wzrhpg300nh_rtl8366s_device);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpg300nh_leds_gpio),
+					wzrhpg300nh_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WZRHPG300NH_KEYS_POLL_INTERVAL,
+					 ARRAY_SIZE(wzrhpg300nh_gpio_keys),
+					 wzrhpg300nh_gpio_keys);
+
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_G300NH, "WZR-HP-G300NH",
+	     "Buffalo WZR-HP-G300NH", wzrhpg300nh_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-wzr-hp-g450h.c linux-4.1.13/arch/mips/ath79/mach-wzr-hp-g450h.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-wzr-hp-g450h.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-wzr-hp-g450h.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,165 @@
+/*
+ *  Buffalo WZR-HP-G450G board support
+ *
+ *  Copyright (C) 2011 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ath9k_platform.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+#define WZRHPG450H_KEYS_POLL_INTERVAL     20      /* msecs */
+#define WZRHPG450H_KEYS_DEBOUNCE_INTERVAL (3 * WZRHPG450H_KEYS_POLL_INTERVAL)
+
+static struct mtd_partition wzrhpg450h_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x0040000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "u-boot-env",
+		.offset		= 0x0040000,
+		.size		= 0x0010000,
+	}, {
+		.name		= "ART",
+		.offset		= 0x0050000,
+		.size		= 0x0010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x0060000,
+		.size		= 0x1f80000,
+	}, {
+		.name		= "user_property",
+		.offset		= 0x1fe0000,
+		.size		= 0x0020000,
+	}
+};
+
+static struct flash_platform_data wzrhpg450h_flash_data = {
+	.parts		= wzrhpg450h_partitions,
+	.nr_parts	= ARRAY_SIZE(wzrhpg450h_partitions),
+};
+
+static struct gpio_led wzrhpg450h_leds_gpio[] __initdata = {
+	{
+		.name		= "buffalo:red:diag",
+		.gpio		= 14,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:orange:security",
+		.gpio		= 13,
+		.active_low	= 1,
+	},
+};
+
+
+static struct gpio_led wzrhpg450h_wmac_leds_gpio[] = {
+	{
+		.name		= "buffalo:blue:movie_engine",
+		.gpio		= 13,
+		.active_low	= 1,
+	},
+	{
+		.name		= "buffalo:green:router",
+		.gpio		= 14,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button wzrhpg450h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 6,
+		.active_low	= 1,
+	}, {
+		.desc		= "usb",
+		.type		= EV_KEY,
+		.code		= BTN_2,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 1,
+		.active_low	= 1,
+	}, {
+		.desc		= "aoss",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 8,
+		.active_low	= 1,
+	}, {
+		.desc		= "movie_engine",
+		.type		= EV_KEY,
+		.code		= BTN_6,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 7,
+		.active_low	= 0,
+	}, {
+		.desc		= "router_off",
+		.type		= EV_KEY,
+		.code		= BTN_5,
+		.debounce_interval = WZRHPG450H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= 12,
+		.active_low	= 0,
+	}
+};
+
+
+static void __init wzrhpg450h_init(void)
+{
+	u8 *ee = (u8 *) KSEG1ADDR(0x1f051000);
+	u8 *mac = (u8 *) ee + 2;
+
+	ath79_register_m25p80_multi(&wzrhpg450h_flash_data);
+
+	ath79_register_mdio(0, ~BIT(0));
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.speed = SPEED_1000;
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(wzrhpg450h_leds_gpio),
+				 wzrhpg450h_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, WZRHPG450H_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(wzrhpg450h_gpio_keys),
+					wzrhpg450h_gpio_keys);
+
+	ath79_register_eth(0);
+
+	gpio_request_one(16, GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+	ath79_register_usb();
+
+	ap91_pci_init(ee, NULL);
+	ap9x_pci_get_wmac_data(0)->tx_gain_buffalo = true;
+	ap9x_pci_get_wmac_data(1)->tx_gain_buffalo = true;
+	ap9x_pci_setup_wmac_led_pin(0, 15);
+	ap9x_pci_setup_wmac_leds(0, wzrhpg450h_wmac_leds_gpio,
+				 ARRAY_SIZE(wzrhpg450h_wmac_leds_gpio));
+}
+
+MIPS_MACHINE(ATH79_MACH_WZR_HP_G450H, "WZR-HP-G450H", "Buffalo WZR-HP-G450H",
+	     wzrhpg450h_init);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/mach-zcn-1523h.c linux-4.1.13/arch/mips/ath79/mach-zcn-1523h.c
--- linux-4.1.13.orig/arch/mips/ath79/mach-zcn-1523h.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/mach-zcn-1523h.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,154 @@
+/*
+ *  Zcomax ZCN-1523H-2-8/5-16 board support
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-eth.h"
+#include "dev-m25p80.h"
+#include "dev-ap9x-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "machtypes.h"
+
+#define ZCN_1523H_GPIO_BTN_RESET	0
+#define ZCN_1523H_GPIO_LED_INIT		11
+#define ZCN_1523H_GPIO_LED_LAN1		17
+
+#define ZCN_1523H_2_GPIO_LED_WEAK	13
+#define ZCN_1523H_2_GPIO_LED_MEDIUM	14
+#define ZCN_1523H_2_GPIO_LED_STRONG	15
+
+#define ZCN_1523H_5_GPIO_LAN2_POWER	1
+#define ZCN_1523H_5_GPIO_LED_LAN2	13
+#define ZCN_1523H_5_GPIO_LED_WEAK	14
+#define ZCN_1523H_5_GPIO_LED_MEDIUM	15
+#define ZCN_1523H_5_GPIO_LED_STRONG	16
+
+#define ZCN_1523H_KEYS_POLL_INTERVAL	20	/* msecs */
+#define ZCN_1523H_KEYS_DEBOUNCE_INTERVAL (3 * ZCN_1523H_KEYS_POLL_INTERVAL)
+
+static struct gpio_keys_button zcn_1523h_gpio_keys[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = ZCN_1523H_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= ZCN_1523H_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:amber:init",
+		.gpio		= ZCN_1523H_GPIO_LED_INIT,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan1",
+		.gpio		= ZCN_1523H_GPIO_LED_LAN1,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_2_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_2_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_2_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_2_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led zcn_1523h_5_leds_gpio[] __initdata = {
+	{
+		.name		= "zcn-1523h:red:weak",
+		.gpio		= ZCN_1523H_5_GPIO_LED_WEAK,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:amber:medium",
+		.gpio		= ZCN_1523H_5_GPIO_LED_MEDIUM,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:strong",
+		.gpio		= ZCN_1523H_5_GPIO_LED_STRONG,
+		.active_low	= 1,
+	}, {
+		.name		= "zcn-1523h:green:lan2",
+		.gpio		= ZCN_1523H_5_GPIO_LED_LAN2,
+		.active_low	= 1,
+	}
+};
+
+static void __init zcn_1523h_generic_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f7e0004);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	ath79_gpio_function_disable(AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN |
+				    AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN);
+
+	ath79_register_m25p80(NULL);
+
+	ath79_register_leds_gpio(0, ARRAY_SIZE(zcn_1523h_leds_gpio),
+					zcn_1523h_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, ZCN_1523H_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(zcn_1523h_gpio_keys),
+					zcn_1523h_gpio_keys);
+
+	ap91_pci_init(ee, mac);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr, mac, 0);
+	ath79_init_mac(ath79_eth1_data.mac_addr, mac, 1);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN1 port */
+	ath79_register_eth(0);
+}
+
+static void __init zcn_1523h_2_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap9x_pci_setup_wmac_gpio(0, BIT(9), 0);
+
+	ath79_register_leds_gpio(1, ARRAY_SIZE(zcn_1523h_2_leds_gpio),
+				 zcn_1523h_2_leds_gpio);
+}
+
+MIPS_MACHINE(ATH79_MACH_ZCN_1523H_2, "ZCN-1523H-2", "Zcomax ZCN-1523H-2",
+	     zcn_1523h_2_setup);
+
+static void __init zcn_1523h_5_setup(void)
+{
+	zcn_1523h_generic_setup();
+	ap9x_pci_setup_wmac_gpio(0, BIT(8), 0);
+
+	ath79_register_leds_gpio(1, ARRAY_SIZE(zcn_1523h_5_leds_gpio),
+				 zcn_1523h_5_leds_gpio);
+
+	/* LAN2 port */
+	ath79_register_eth(1);
+}
+
+MIPS_MACHINE(ATH79_MACH_ZCN_1523H_5, "ZCN-1523H-5", "Zcomax ZCN-1523H-5",
+	     zcn_1523h_5_setup);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/Makefile linux-4.1.13/arch/mips/ath79/Makefile
--- linux-4.1.13.orig/arch/mips/ath79/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/Makefile	2015-12-04 19:57:05.957975089 +0100
@@ -17,18 +17,169 @@
 # Devices
 #
 obj-y					+= dev-common.o
+obj-$(CONFIG_ATH79_DEV_AP9X_PCI)	+= dev-ap9x-pci.o
+obj-$(CONFIG_ATH79_DEV_DSA)		+= dev-dsa.o
+obj-$(CONFIG_ATH79_DEV_ETH)		+= dev-eth.o
 obj-$(CONFIG_ATH79_DEV_GPIO_BUTTONS)	+= dev-gpio-buttons.o
 obj-$(CONFIG_ATH79_DEV_LEDS_GPIO)	+= dev-leds-gpio.o
+obj-$(CONFIG_ATH79_DEV_M25P80)		+= dev-m25p80.o
+obj-$(CONFIG_ATH79_DEV_NFC)		+= dev-nfc.o
 obj-$(CONFIG_ATH79_DEV_SPI)		+= dev-spi.o
 obj-$(CONFIG_ATH79_DEV_USB)		+= dev-usb.o
 obj-$(CONFIG_ATH79_DEV_WMAC)		+= dev-wmac.o
 
 #
+# Miscellaneous objects
+#
+obj-$(CONFIG_ATH79_NVRAM)		+= nvram.o
+obj-$(CONFIG_ATH79_PCI_ATH9K_FIXUP)	+= pci-ath9k-fixup.o
+obj-$(CONFIG_ATH79_ROUTERBOOT)		+= routerboot.o
+
+#
 # Machines
 #
+obj-$(CONFIG_ATH79_MACH_ALFA_AP96)	+= mach-alfa-ap96.o
+obj-$(CONFIG_ATH79_MACH_ALFA_NX)	+= mach-alfa-nx.o
+obj-$(CONFIG_ATH79_MACH_ALL0258N)	+= mach-all0258n.o
+obj-$(CONFIG_ATH79_MACH_ALL0315N)	+= mach-all0315n.o
+obj-$(CONFIG_ATH79_MACH_ANTMINER_S1)+= mach-antminer-s1.o
+obj-$(CONFIG_ATH79_MACH_ANTMINER_S3)+= mach-antminer-s3.o
+obj-$(CONFIG_ATH79_MACH_ARDUINO_YUN)	+= mach-arduino-yun.o
+obj-$(CONFIG_ATH79_MACH_AP113)		+= mach-ap113.o
 obj-$(CONFIG_ATH79_MACH_AP121)		+= mach-ap121.o
+obj-$(CONFIG_ATH79_MACH_AP132)		+= mach-ap132.o
 obj-$(CONFIG_ATH79_MACH_AP136)		+= mach-ap136.o
+obj-$(CONFIG_ATH79_MACH_AP143)		+= mach-ap143.o
+obj-$(CONFIG_ATH79_MACH_AP147)		+= mach-ap147.o
+obj-$(CONFIG_ATH79_MACH_AP152)		+= mach-ap152.o
 obj-$(CONFIG_ATH79_MACH_AP81)		+= mach-ap81.o
+obj-$(CONFIG_ATH79_MACH_AP83)		+= mach-ap83.o
+obj-$(CONFIG_ATH79_MACH_AP96)		+= mach-ap96.o
+obj-$(CONFIG_ATH79_MACH_ARCHER_C7)	+= mach-archer-c7.o
+obj-$(CONFIG_ATH79_MACH_AW_NR580)	+= mach-aw-nr580.o
+obj-$(CONFIG_ATH79_MACH_BHU_BXU2000N2_A)+= mach-bhu-bxu2000n2-a.o
+obj-$(CONFIG_ATH79_MACH_BSB)		+= mach-bsb.o
+obj-$(CONFIG_ATH79_MACH_CAP4200AG)	+= mach-cap4200ag.o
+obj-$(CONFIG_ATH79_MACH_CF_E316N_V2)	+= mach-cf-e316n-v2.o
+obj-$(CONFIG_ATH79_MACH_CPE510)		+= mach-cpe510.o
 obj-$(CONFIG_ATH79_MACH_DB120)		+= mach-db120.o
+obj-$(CONFIG_ATH79_MACH_DLAN_HOTSPOT)	+= mach-dlan-hotspot.o
+obj-$(CONFIG_ATH79_MACH_DLAN_PRO_500_WP)	+= mach-dlan-pro-500-wp.o
+obj-$(CONFIG_ATH79_MACH_DLAN_PRO_1200_AC)	+= mach-dlan-pro-1200-ac.o
+obj-$(CONFIG_ATH79_MACH_DGL_5500_A1)	+= mach-dgl-5500-a1.o
+obj-$(CONFIG_ATH79_MACH_DHP_1565_A1)	+= mach-dhp-1565-a1.o
+obj-$(CONFIG_ATH79_MACH_DIR_505_A1)	+= mach-dir-505-a1.o
+obj-$(CONFIG_ATH79_MACH_DIR_600_A1)	+= mach-dir-600-a1.o
+obj-$(CONFIG_ATH79_MACH_DIR_615_C1)	+= mach-dir-615-c1.o
+obj-$(CONFIG_ATH79_MACH_DIR_615_I1)	+= mach-dir-615-i1.o
+obj-$(CONFIG_ATH79_MACH_DIR_825_B1)	+= mach-dir-825-b1.o
+obj-$(CONFIG_ATH79_MACH_DIR_825_C1)	+= mach-dir-825-c1.o
+obj-$(CONFIG_ATH79_MACH_DRAGINO2)	+= mach-dragino2.o
+obj-$(CONFIG_ATH79_MACH_ESR900)	+= mach-esr900.o
+obj-$(CONFIG_ATH79_MACH_EW_DORIN)	+= mach-ew-dorin.o
+obj-$(CONFIG_ATH79_MACH_EAP300V2)	+= mach-eap300v2.o
+obj-$(CONFIG_ATH79_MACH_EAP7660D)	+= mach-eap7660d.o
+obj-$(CONFIG_ATH79_MACH_EL_M150)	+= mach-el-m150.o
+obj-$(CONFIG_ATH79_MACH_EL_MINI)	+= mach-el-mini.o
+obj-$(CONFIG_ATH79_MACH_EPG5000)	+= mach-epg5000.o
+obj-$(CONFIG_ATH79_MACH_ESR1750)	+= mach-esr1750.o
+obj-$(CONFIG_ATH79_MACH_F9K1115V2)	+= mach-f9k1115v2.o
+obj-$(CONFIG_ATH79_MACH_GL_AR150)   += mach-gl-ar150.o
+obj-$(CONFIG_ATH79_MACH_GL_AR300)	+= mach-gl-ar300.o
+obj-$(CONFIG_ATH79_MACH_GL_DOMINO)		+= mach-gl-domino.o
+obj-$(CONFIG_ATH79_MACH_GL_INET)	+= mach-gl-inet.o
+obj-$(CONFIG_ATH79_MACH_GS_MINIBOX_V1)	+= mach-gs-minibox-v1.o
+obj-$(CONFIG_ATH79_MACH_GS_OOLITE)	+= mach-gs-oolite.o
+obj-$(CONFIG_ATH79_MACH_HIWIFI_HC6361)	+= mach-hiwifi-hc6361.o
+obj-$(CONFIG_ATH79_MACH_JA76PF)		+= mach-ja76pf.o
+obj-$(CONFIG_ATH79_MACH_JWAP003)	+= mach-jwap003.o
+obj-$(CONFIG_ATH79_MACH_HORNET_UB)	+= mach-hornet-ub.o
+obj-$(CONFIG_ATH79_MACH_MC_MAC1200R)     += mach-mc-mac1200r.o
+obj-$(CONFIG_ATH79_MACH_MR12)		+= mach-mr12.o
+obj-$(CONFIG_ATH79_MACH_MR16)		+= mach-mr16.o
+obj-$(CONFIG_ATH79_MACH_MR1750)		+= mach-mr1750.o
+obj-$(CONFIG_ATH79_MACH_MR600)		+= mach-mr600.o
+obj-$(CONFIG_ATH79_MACH_MR900)		+= mach-mr900.o
+obj-$(CONFIG_ATH79_MACH_MYNET_N600)	+= mach-mynet-n600.o
+obj-$(CONFIG_ATH79_MACH_MYNET_N750)	+= mach-mynet-n750.o
+obj-$(CONFIG_ATH79_MACH_MYNET_REXT)	+= mach-mynet-rext.o
+obj-$(CONFIG_ATH79_MACH_MZK_W04NU)	+= mach-mzk-w04nu.o
+obj-$(CONFIG_ATH79_MACH_MZK_W300NH)	+= mach-mzk-w300nh.o
+obj-$(CONFIG_ATH79_MACH_NBG460N)	+= mach-nbg460n.o
+obj-$(CONFIG_ATH79_MACH_OM2P)		+= mach-om2p.o
+obj-$(CONFIG_ATH79_MACH_OM5P)		+= mach-om5p.o
+obj-$(CONFIG_ATH79_MACH_ONION_OMEGA)  += mach-onion-omega.o
+obj-$(CONFIG_ATH79_MACH_PB42)		+= mach-pb42.o
 obj-$(CONFIG_ATH79_MACH_PB44)		+= mach-pb44.o
+obj-$(CONFIG_ATH79_MACH_PB92)		+= mach-pb92.o
+obj-$(CONFIG_ATH79_MACH_QIHOO_C301)	+= mach-qihoo-c301.o
+obj-$(CONFIG_ATH79_MACH_R6100)		+= mach-r6100.o
+obj-$(CONFIG_ATH79_MACH_RB4XX)		+= mach-rb4xx.o
+obj-$(CONFIG_ATH79_MACH_RB750)		+= mach-rb750.o
+obj-$(CONFIG_ATH79_MACH_RB91X)		+= mach-rb91x.o
+obj-$(CONFIG_ATH79_MACH_RB922)		+= mach-rb922.o
+obj-$(CONFIG_ATH79_MACH_RB95X)		+= mach-rb95x.o
+obj-$(CONFIG_ATH79_MACH_RB2011)		+= mach-rb2011.o
+obj-$(CONFIG_ATH79_MACH_RBSXTLITE)	+= mach-rbsxtlite.o
+obj-$(CONFIG_ATH79_MACH_RW2458N)	+= mach-rw2458n.o
+obj-$(CONFIG_ATH79_MACH_SMART_300)	+= mach-smart-300.o
+obj-$(CONFIG_ATH79_MACH_TEW_632BRP)	+= mach-tew-632brp.o
+obj-$(CONFIG_ATH79_MACH_TEW_673GRU)	+= mach-tew-673gru.o
+obj-$(CONFIG_ATH79_MACH_TEW_712BR)	+= mach-tew-712br.o
+obj-$(CONFIG_ATH79_MACH_TEW_732BR)	+= mach-tew-732br.o
+obj-$(CONFIG_ATH79_MACH_TL_MR11U)	+= mach-tl-mr11u.o
+obj-$(CONFIG_ATH79_MACH_TL_MR13U)	+= mach-tl-mr13u.o
+obj-$(CONFIG_ATH79_MACH_TL_MR3020)	+= mach-tl-mr3020.o
+obj-$(CONFIG_ATH79_MACH_TL_MR3X20)	+= mach-tl-mr3x20.o
+obj-$(CONFIG_ATH79_MACH_TL_WAX50RE)     += mach-tl-wax50re.o
+obj-$(CONFIG_ATH79_MACH_TL_WA701ND_V2)	+= mach-tl-wa701nd-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WA7210N_V2)	+= mach-tl-wa7210n-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WA830RE_V2)	+= mach-tl-wa830re-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WA901ND)	+= mach-tl-wa901nd.o
+obj-$(CONFIG_ATH79_MACH_TL_WA901ND_V2)	+= mach-tl-wa901nd-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WDR3320_V2)  += mach-tl-wdr3320-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WDR3500)     += mach-tl-wdr3500.o
+obj-$(CONFIG_ATH79_MACH_TL_WDR4300)     += mach-tl-wdr4300.o
+obj-$(CONFIG_ATH79_MACH_TL_WDR6500_V2)  += mach-tl-wdr6500-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WR741ND)	+= mach-tl-wr741nd.o
+obj-$(CONFIG_ATH79_MACH_TL_WR741ND_V4)	+= mach-tl-wr741nd-v4.o
+obj-$(CONFIG_ATH79_MACH_TL_WR841N_V1)	+= mach-tl-wr841n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR841N_V8)	+= mach-tl-wr841n-v8.o
+obj-$(CONFIG_ATH79_MACH_TL_WR841N_V9)	+= mach-tl-wr841n-v9.o
+obj-$(CONFIG_ATH79_MACH_TL_WR941ND)	+= mach-tl-wr941nd.o
+obj-$(CONFIG_ATH79_MACH_TL_WR941ND_V6)	+= mach-tl-wr941nd-v6.o
+obj-$(CONFIG_ATH79_MACH_TL_WR1041N_V2)	+= mach-tl-wr1041n-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WR1043ND)	+= mach-tl-wr1043nd.o
+obj-$(CONFIG_ATH79_MACH_TL_WR1043ND_V2)	+= mach-tl-wr1043nd-v2.o
+obj-$(CONFIG_ATH79_MACH_TL_WR2543N)	+= mach-tl-wr2543n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR703N)	+= mach-tl-wr703n.o
+obj-$(CONFIG_ATH79_MACH_TL_WR720N_V3)	+= mach-tl-wr720n-v3.o
+obj-$(CONFIG_ATH79_MACH_TUBE2H)		+= mach-tube2h.o
+obj-$(CONFIG_ATH79_MACH_UBNT)		+= mach-ubnt.o
 obj-$(CONFIG_ATH79_MACH_UBNT_XM)	+= mach-ubnt-xm.o
+obj-$(CONFIG_ATH79_MACH_WEIO)		+= mach-weio.o
+obj-$(CONFIG_ATH79_MACH_WHR_HP_G300N)	+= mach-whr-hp-g300n.o
+obj-$(CONFIG_ATH79_MACH_WLAE_AG300N)	+= mach-wlae-ag300n.o
+obj-$(CONFIG_ATH79_MACH_WLR8100)	+= mach-wlr8100.o
+obj-$(CONFIG_ATH79_MACH_WNDAP360)	+= mach-wndap360.o
+obj-$(CONFIG_ATH79_MACH_WNDR3700)	+= mach-wndr3700.o
+obj-$(CONFIG_ATH79_MACH_WNDR4300)	+= mach-wndr4300.o
+obj-$(CONFIG_ATH79_MACH_WNR2000)	+= mach-wnr2000.o
+obj-$(CONFIG_ATH79_MACH_WNR2000_V3)	+= mach-wnr2000-v3.o
+obj-$(CONFIG_ATH79_MACH_WNR2000_V4)	+= mach-wnr2000-v4.o
+obj-$(CONFIG_ATH79_MACH_WNR2200)	+= mach-wnr2200.o
+obj-$(CONFIG_ATH79_MACH_WP543)		+= mach-wp543.o
+obj-$(CONFIG_ATH79_MACH_WPE72)		+= mach-wpe72.o
+obj-$(CONFIG_ATH79_MACH_WPJ344)	+= mach-wpj344.o
+obj-$(CONFIG_ATH79_MACH_WPJ531)	+= mach-wpj531.o
+obj-$(CONFIG_ATH79_MACH_WPJ558)	+= mach-wpj558.o
+obj-$(CONFIG_ATH79_MACH_WRT160NL)	+= mach-wrt160nl.o
+obj-$(CONFIG_ATH79_MACH_WRT400N)	+= mach-wrt400n.o
+obj-$(CONFIG_ATH79_MACH_WZR_HP_G300NH)	+= mach-wzr-hp-g300nh.o
+obj-$(CONFIG_ATH79_MACH_WZR_HP_G300NH2)	+= mach-wzr-hp-g300nh2.o
+obj-$(CONFIG_ATH79_MACH_WZR_HP_AG300H)	+= mach-wzr-hp-ag300h.o
+obj-$(CONFIG_ATH79_MACH_WZR_HP_G450H)	+= mach-wzr-hp-g450h.o
+obj-$(CONFIG_ATH79_MACH_WZR_450HP2)	+= mach-wzr-450hp2.o
+obj-$(CONFIG_ATH79_MACH_ZCN_1523H)	+= mach-zcn-1523h.o
+obj-$(CONFIG_ATH79_MACH_CARAMBOLA2)	+= mach-carambola2.o
+obj-$(CONFIG_ATH79_MACH_NBG6716)	+= mach-nbg6716.o
diff -Nur linux-4.1.13.orig/arch/mips/ath79/nvram.c linux-4.1.13/arch/mips/ath79/nvram.c
--- linux-4.1.13.orig/arch/mips/ath79/nvram.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/nvram.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,80 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include "nvram.h"
+
+char *ath79_nvram_find_var(const char *name, const char *buf, unsigned buf_len)
+{
+	unsigned len = strlen(name);
+	char *cur, *last;
+
+	if (buf_len == 0 || len == 0)
+		return NULL;
+
+	if (buf_len < len)
+		return NULL;
+
+	if (len == 1)
+		return memchr(buf, (int) *name, buf_len);
+
+	last = (char *) buf + buf_len - len;
+	for (cur = (char *) buf; cur <= last; cur++)
+		if (cur[0] == name[0] && memcmp(cur, name, len) == 0)
+			return cur + len;
+
+	return NULL;
+}
+
+int ath79_nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			       const char *name, char *mac)
+{
+	char *buf;
+	char *mac_str;
+	int ret;
+	int t;
+
+	buf = vmalloc(nvram_len);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, nvram, nvram_len);
+	buf[nvram_len - 1] = '\0';
+
+	mac_str = ath79_nvram_find_var(name, buf, nvram_len);
+	if (!mac_str) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	if (strlen(mac_str) == 19 && mac_str[0] == '"' && mac_str[18] == '"') {
+		mac_str[18] = 0;
+		mac_str++;
+	}
+
+	t = sscanf(mac_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+		   &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if (t != 6) {
+		ret = -EINVAL;
+		goto free;
+	}
+
+	ret = 0;
+
+free:
+	vfree(buf);
+	return ret;
+}
diff -Nur linux-4.1.13.orig/arch/mips/ath79/nvram.h linux-4.1.13/arch/mips/ath79/nvram.h
--- linux-4.1.13.orig/arch/mips/ath79/nvram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/nvram.h	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,19 @@
+/*
+ *  Atheros AR71xx minimal nvram support
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_NVRAM_H
+#define _ATH79_NVRAM_H
+
+char *ath79_nvram_find_var(const char *name, const char *buf,
+			   unsigned buf_len);
+int ath79_nvram_parse_mac_addr(const char *nvram, unsigned nvram_len,
+			       const char *name, char *mac);
+
+#endif /* _ATH79_NVRAM_H */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/pci-ath9k-fixup.c linux-4.1.13/arch/mips/ath79/pci-ath9k-fixup.c
--- linux-4.1.13.orig/arch/mips/ath79/pci-ath9k-fixup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/pci-ath9k-fixup.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,126 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+struct ath9k_fixup {
+	u16		*cal_data;
+	unsigned	slot;
+};
+
+static int ath9k_num_fixups;
+static struct ath9k_fixup ath9k_fixups[2];
+
+static void ath9k_pci_fixup(struct pci_dev *dev)
+{
+	void __iomem *mem;
+	u16 *cal_data = NULL;
+	u16 cmd;
+	u32 bar0;
+	u32 val;
+	unsigned i;
+
+	for (i = 0; i < ath9k_num_fixups; i++) {
+		if (ath9k_fixups[i].cal_data == NULL)
+			continue;
+
+		if (ath9k_fixups[i].slot != PCI_SLOT(dev->devfn))
+			continue;
+
+		cal_data = ath9k_fixups[i].cal_data;
+		break;
+	}
+
+	if (cal_data == NULL)
+		return;
+
+	if (*cal_data != 0xa55a) {
+		pr_err("pci %s: invalid calibration data\n", pci_name(dev));
+		return;
+	}
+
+	pr_info("pci %s: fixup device configuration\n", pci_name(dev));
+
+	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
+	if (!mem) {
+		pr_err("pci %s: ioremap error\n", pci_name(dev));
+		return;
+	}
+
+	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
+
+	switch (ath79_soc) {
+	case ATH79_SOC_AR7161:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
+				       AR71XX_PCI_MEM_BASE);
+		break;
+	case ATH79_SOC_AR7240:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
+		break;
+
+	case ATH79_SOC_AR7241:
+	case ATH79_SOC_AR7242:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+	case ATH79_SOC_AR9344:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+
+	default:
+		BUG();
+	}
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	/* set pointer to first reg address */
+	cal_data += 3;
+	while (*cal_data != 0xffff) {
+		u32 reg;
+		reg = *cal_data++;
+		val = *cal_data++;
+		val |= (*cal_data++) << 16;
+
+		__raw_writel(val, mem + reg);
+		udelay(100);
+	}
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
+	dev->vendor = val & 0xffff;
+	dev->device = (val >> 16) & 0xffff;
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
+	dev->revision = val & 0xff;
+	dev->class = val >> 8; /* upper 3 bytes */
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
+
+	iounmap(mem);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ath9k_pci_fixup);
+
+void __init pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data)
+{
+	if (ath9k_num_fixups >= ARRAY_SIZE(ath9k_fixups))
+		return;
+
+	ath9k_fixups[ath9k_num_fixups].slot = slot;
+	ath9k_fixups[ath9k_num_fixups].cal_data = cal_data;
+	ath9k_num_fixups++;
+}
diff -Nur linux-4.1.13.orig/arch/mips/ath79/pci-ath9k-fixup.h linux-4.1.13/arch/mips/ath79/pci-ath9k-fixup.h
--- linux-4.1.13.orig/arch/mips/ath79/pci-ath9k-fixup.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/pci-ath9k-fixup.h	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,6 @@
+#ifndef _PCI_ATH9K_FIXUP
+#define _PCI_ATH9K_FIXUP
+
+void pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data) __init;
+
+#endif /* _PCI_ATH9K_FIXUP */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/pci.c linux-4.1.13/arch/mips/ath79/pci.c
--- linux-4.1.13.orig/arch/mips/ath79/pci.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/pci.c	2015-12-04 19:57:05.593998902 +0100
@@ -13,6 +13,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/export.h>
 #include <linux/pci.h>
 #include <linux/resource.h>
 #include <linux/platform_device.h>
@@ -25,6 +26,9 @@
 static const struct ath79_pci_irq *ath79_pci_irq_map __initdata;
 static unsigned ath79_pci_nr_irqs __initdata;
 
+static unsigned long (*__ath79_pci_swizzle_b)(unsigned long port);
+static unsigned long (*__ath79_pci_swizzle_w)(unsigned long port);
+
 static const struct ath79_pci_irq ar71xx_pci_irq_map[] __initconst = {
 	{
 		.slot	= 17,
@@ -49,6 +53,15 @@
 	}
 };
 
+static const struct ath79_pci_irq qca953x_pci_irq_map[] __initconst = {
+	{
+		.bus	= 0,
+		.slot	= 0,
+		.pin	= 1,
+		.irq	= ATH79_PCI_IRQ(0),
+	},
+};
+
 static const struct ath79_pci_irq qca955x_pci_irq_map[] __initconst = {
 	{
 		.bus	= 0,
@@ -64,6 +77,21 @@
 	},
 };
 
+static const struct ath79_pci_irq qca956x_pci_irq_map[] __initconst = {
+	{
+		.bus    = 0,
+		.slot   = 0,
+		.pin    = 1,
+		.irq    = ATH79_PCI_IRQ(0),
+	},
+	{
+		.bus    = 1,
+		.slot   = 0,
+		.pin    = 1,
+		.irq    = ATH79_PCI_IRQ(1),
+	},
+};
+
 int __init pcibios_map_irq(const struct pci_dev *dev, uint8_t slot, uint8_t pin)
 {
 	int irq = -1;
@@ -79,9 +107,15 @@
 			   soc_is_ar9344()) {
 			ath79_pci_irq_map = ar724x_pci_irq_map;
 			ath79_pci_nr_irqs = ARRAY_SIZE(ar724x_pci_irq_map);
+		} else if (soc_is_qca953x()) {
+			ath79_pci_irq_map = qca953x_pci_irq_map;
+			ath79_pci_nr_irqs = ARRAY_SIZE(qca953x_pci_irq_map);
 		} else if (soc_is_qca955x()) {
 			ath79_pci_irq_map = qca955x_pci_irq_map;
 			ath79_pci_nr_irqs = ARRAY_SIZE(qca955x_pci_irq_map);
+		} else if (soc_is_qca9561()) {
+			ath79_pci_irq_map = qca956x_pci_irq_map;
+			ath79_pci_nr_irqs = ARRAY_SIZE(qca956x_pci_irq_map);
 		} else {
 			pr_crit("pci %s: invalid irq map\n",
 				pci_name((struct pci_dev *) dev));
@@ -212,12 +246,50 @@
 	return pdev;
 }
 
+static inline bool ar71xx_is_pci_addr(unsigned long port)
+{
+	unsigned long phys = CPHYSADDR(port);
+
+	return (phys >= AR71XX_PCI_MEM_BASE &&
+		phys < AR71XX_PCI_MEM_BASE + AR71XX_PCI_MEM_SIZE);
+}
+
+static unsigned long ar71xx_pci_swizzle_b(unsigned long port)
+{
+	return ar71xx_is_pci_addr(port) ? port ^ 3 : port;
+}
+
+static unsigned long ar71xx_pci_swizzle_w(unsigned long port)
+{
+	return ar71xx_is_pci_addr(port) ? port ^ 2 : port;
+}
+
+unsigned long ath79_pci_swizzle_b(unsigned long port)
+{
+	if (__ath79_pci_swizzle_b)
+		return __ath79_pci_swizzle_b(port);
+
+	return port;
+}
+EXPORT_SYMBOL(ath79_pci_swizzle_b);
+
+unsigned long ath79_pci_swizzle_w(unsigned long port)
+{
+	if (__ath79_pci_swizzle_w)
+		return __ath79_pci_swizzle_w(port);
+
+	return port;
+}
+EXPORT_SYMBOL(ath79_pci_swizzle_w);
+
 int __init ath79_register_pci(void)
 {
 	struct platform_device *pdev = NULL;
 
 	if (soc_is_ar71xx()) {
 		pdev = ath79_register_pci_ar71xx();
+		__ath79_pci_swizzle_b = ar71xx_pci_swizzle_b;
+		__ath79_pci_swizzle_w = ar71xx_pci_swizzle_w;
 	} else if (soc_is_ar724x()) {
 		pdev = ath79_register_pci_ar724x(-1,
 						 AR724X_PCI_CFG_BASE,
@@ -243,6 +315,15 @@
 						 AR724X_PCI_MEM_SIZE,
 						 0,
 						 ATH79_IP2_IRQ(0));
+	} else if (soc_is_qca9533()) {
+		pdev = ath79_register_pci_ar724x(0,
+						 QCA953X_PCI_CFG_BASE0,
+						 QCA953X_PCI_CTRL_BASE0,
+						 QCA953X_PCI_CRP_BASE0,
+						 QCA953X_PCI_MEM_BASE0,
+						 QCA953X_PCI_MEM_SIZE,
+						 0,
+						 ATH79_IP2_IRQ(0));
 	} else if (soc_is_qca9558()) {
 		pdev = ath79_register_pci_ar724x(0,
 						 QCA955X_PCI_CFG_BASE0,
@@ -261,6 +342,15 @@
 						 QCA955X_PCI_MEM_SIZE,
 						 1,
 						 ATH79_IP3_IRQ(2));
+	} else if (soc_is_qca9561()) {
+		pdev = ath79_register_pci_ar724x(0,
+						 QCA956X_PCI_CFG_BASE1,
+						 QCA956X_PCI_CTRL_BASE1,
+						 QCA956X_PCI_CRP_BASE1,
+						 QCA956X_PCI_MEM_BASE1,
+						 QCA956X_PCI_MEM_SIZE,
+						 1,
+						 ATH79_IP3_IRQ(2));
 	} else {
 		/* No PCI support */
 		return -ENODEV;
diff -Nur linux-4.1.13.orig/arch/mips/ath79/prom.c linux-4.1.13/arch/mips/ath79/prom.c
--- linux-4.1.13.orig/arch/mips/ath79/prom.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/prom.c	2015-12-04 19:57:05.482006229 +0100
@@ -19,12 +19,114 @@
 #include <asm/bootinfo.h>
 #include <asm/addrspace.h>
 #include <asm/fw/fw.h>
+#include <asm/fw/myloader/myloader.h>
 
 #include "common.h"
 
+static char ath79_cmdline_buf[COMMAND_LINE_SIZE] __initdata;
+
+static void __init ath79_prom_append_cmdline(const char *name,
+					      const char *value)
+{
+	snprintf(ath79_cmdline_buf, sizeof(ath79_cmdline_buf),
+		 " %s=%s", name, value);
+	strlcat(arcs_cmdline, ath79_cmdline_buf, sizeof(arcs_cmdline));
+}
+
+#ifdef CONFIG_IMAGE_CMDLINE_HACK
+extern char __image_cmdline[];
+
+static int __init ath79_use_image_cmdline(void)
+{
+	char *p = __image_cmdline;
+	int replace = 0;
+
+	if (*p == '-') {
+		replace = 1;
+		p++;
+	}
+
+	if (*p == '\0')
+		return 0;
+
+	if (replace) {
+		strlcpy(arcs_cmdline, p, sizeof(arcs_cmdline));
+	} else {
+		strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
+		strlcat(arcs_cmdline, p, sizeof(arcs_cmdline));
+	}
+
+	/* Validate and setup environment pointer */
+	if (fw_arg2 < CKSEG0)
+		_fw_envp = NULL;
+	else
+		_fw_envp = (int *)fw_arg2;
+
+	return 1;
+}
+#else
+static inline int ath79_use_image_cmdline(void) { return 0; }
+#endif
+
+static int __init ath79_prom_init_myloader(void)
+{
+	struct myloader_info *mylo;
+	char mac_buf[32];
+	unsigned char *mac;
+
+	mylo = myloader_get_info();
+	if (!mylo)
+		return 0;
+
+	switch (mylo->did) {
+	case DEVID_COMPEX_WP543:
+		ath79_prom_append_cmdline("board", "WP543");
+		break;
+	case DEVID_COMPEX_WPE72:
+		ath79_prom_append_cmdline("board", "WPE72");
+		break;
+	default:
+		pr_warn("prom: unknown device id: %x\n", mylo->did);
+		return 0;
+	}
+
+	mac = mylo->macs[0];
+	snprintf(mac_buf, sizeof(mac_buf), "%02x:%02x:%02x:%02x:%02x:%02x",
+		 mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+	ath79_prom_append_cmdline("ethaddr", mac_buf);
+
+	ath79_use_image_cmdline();
+
+	return 1;
+}
+
 void __init prom_init(void)
 {
-	fw_init_cmdline();
+	const char *env;
+
+	if (ath79_prom_init_myloader())
+		return;
+
+	if (!ath79_use_image_cmdline())
+		fw_init_cmdline();
+
+	env = fw_getenv("ethaddr");
+	if (env)
+		ath79_prom_append_cmdline("ethaddr", env);
+
+	env = fw_getenv("board");
+	if (env) {
+		/* Workaround for buggy bootloaders */
+		if (strcmp(env, "RouterStation") == 0 ||
+		    strcmp(env, "Ubiquiti AR71xx-based board") == 0)
+			env = "UBNT-RS";
+
+		if (strcmp(env, "RouterStation PRO") == 0)
+			env = "UBNT-RSPRO";
+
+		ath79_prom_append_cmdline("board", env);
+	}
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	/* Read the initrd address from the firmware environment */
@@ -34,6 +136,13 @@
 		initrd_end = initrd_start + fw_getenvl("initrd_size");
 	}
 #endif
+
+	if (strstr(arcs_cmdline, "board=750Gr3") ||
+	    strstr(arcs_cmdline, "board=951G") ||
+	    strstr(arcs_cmdline, "board=2011L") ||
+	    strstr(arcs_cmdline, "board=711Gr100") ||
+	    strstr(arcs_cmdline, "board=922gs"))
+		ath79_prom_append_cmdline("console", "ttyS0,115200");
 }
 
 void __init prom_free_prom_memory(void)
diff -Nur linux-4.1.13.orig/arch/mips/ath79/routerboot.c linux-4.1.13/arch/mips/ath79/routerboot.c
--- linux-4.1.13.orig/arch/mips/ath79/routerboot.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/routerboot.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,358 @@
+/*
+ *  RouterBoot helper routines
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#define pr_fmt(fmt) "rb: " fmt
+
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/routerboot.h>
+#include <linux/rle.h>
+#include <linux/lzo.h>
+
+#include "routerboot.h"
+
+#define RB_BLOCK_SIZE		0x1000
+#define RB_ART_SIZE		0x10000
+#define RB_MAGIC_ERD		0x00455244	/* extended radio data */
+
+static struct rb_info rb_info;
+
+static u32 get_u32(void *buf)
+{
+	u8 *p = buf;
+
+	return ((u32) p[3] + ((u32) p[2] << 8) + ((u32) p[1] << 16) +
+	       ((u32) p[0] << 24));
+}
+
+static u16 get_u16(void *buf)
+{
+	u8 *p = buf;
+
+	return (u16) p[1] + ((u16) p[0] << 8);
+}
+
+__init int
+routerboot_find_magic(u8 *buf, unsigned int buflen, u32 *offset, bool hard)
+{
+	u32 magic_ref = hard ? RB_MAGIC_HARD : RB_MAGIC_SOFT;
+	u32 magic;
+	u32 cur = *offset;
+
+	while (cur < buflen) {
+		magic = get_u32(buf + cur);
+		if (magic == magic_ref) {
+			*offset = cur;
+			return 0;
+		}
+
+		cur += 0x1000;
+	}
+
+	return -ENOENT;
+}
+
+__init int
+routerboot_find_tag(u8 *buf, unsigned int buflen, u16 tag_id,
+		    u8 **tag_data, u16 *tag_len)
+{
+	uint32_t magic;
+	bool align = false;
+	int ret;
+
+	if (buflen < 4)
+		return -EINVAL;
+
+	magic = get_u32(buf);
+	switch (magic) {
+	case RB_MAGIC_ERD:
+		align = true;
+		/* fall trough */
+	case RB_MAGIC_HARD:
+		/* skip magic value */
+		buf += 4;
+		buflen -= 4;
+		break;
+
+	case RB_MAGIC_SOFT:
+		if (buflen < 8)
+			return -EINVAL;
+
+		/* skip magic and CRC value */
+		buf += 8;
+		buflen -= 8;
+
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	ret = -ENOENT;
+	while (buflen > 2) {
+		u16 id;
+		u16 len;
+
+		len = get_u16(buf);
+		buf += 2;
+		buflen -= 2;
+
+		if (buflen < 2)
+			break;
+
+		id = get_u16(buf);
+		buf += 2;
+		buflen -= 2;
+
+		if (id == RB_ID_TERMINATOR)
+			break;
+
+		if (buflen < len)
+			break;
+
+		if (id == tag_id) {
+			if (tag_len)
+				*tag_len = len;
+			if (tag_data)
+				*tag_data = buf;
+			ret = 0;
+			break;
+		}
+
+		if (align)
+			len = (len + 3) / 4;
+
+		buf += len;
+		buflen -= len;
+	}
+
+	return ret;
+}
+
+static inline int
+rb_find_hard_cfg_tag(u16 tag_id, u8 **tag_data, u16 *tag_len)
+{
+	if (!rb_info.hard_cfg_data ||
+	    !rb_info.hard_cfg_size)
+		return -ENOENT;
+
+	return routerboot_find_tag(rb_info.hard_cfg_data,
+				   rb_info.hard_cfg_size,
+				   tag_id, tag_data, tag_len);
+}
+
+__init const char *
+rb_get_board_name(void)
+{
+	u16 tag_len;
+	u8 *tag;
+	int err;
+
+	err = rb_find_hard_cfg_tag(RB_ID_BOARD_NAME, &tag, &tag_len);
+	if (err)
+		return NULL;
+
+	return tag;
+}
+
+__init u32
+rb_get_hw_options(void)
+{
+	u16 tag_len;
+	u8 *tag;
+	int err;
+
+	err = rb_find_hard_cfg_tag(RB_ID_HW_OPTIONS, &tag, &tag_len);
+	if (err)
+		return 0;
+
+	return get_u32(tag);
+}
+
+static void * __init
+__rb_get_wlan_data(u16 id)
+{
+	u16 tag_len;
+	u8 *tag;
+	void *buf;
+	int err;
+	u32 magic;
+	size_t src_done;
+	size_t dst_done;
+
+	err = rb_find_hard_cfg_tag(RB_ID_WLAN_DATA, &tag, &tag_len);
+	if (err) {
+		pr_err("no calibration data found\n");
+		goto err;
+	}
+
+	buf = kmalloc(RB_ART_SIZE, GFP_KERNEL);
+	if (buf == NULL) {
+		pr_err("no memory for calibration data\n");
+		goto err;
+	}
+
+	magic = get_u32(tag);
+	if (magic == RB_MAGIC_ERD) {
+		u8 *erd_data;
+		u16 erd_len;
+
+		if (id == 0)
+			goto err_free;
+
+		err = routerboot_find_tag(tag, tag_len, id,
+					  &erd_data, &erd_len);
+		if (err) {
+			pr_err("no ERD data found for id %u\n", id);
+			goto err_free;
+		}
+
+		dst_done = RB_ART_SIZE;
+		err = lzo1x_decompress_safe(erd_data, erd_len, buf, &dst_done);
+		if (err) {
+			pr_err("unable to decompress calibration data %d\n",
+			       err);
+			goto err_free;
+		}
+	} else {
+		if (id != 0)
+			goto err_free;
+
+		err = rle_decode((char *) tag, tag_len, buf, RB_ART_SIZE,
+				 &src_done, &dst_done);
+		if (err) {
+			pr_err("unable to decode calibration data\n");
+			goto err_free;
+		}
+	}
+
+	return buf;
+
+err_free:
+	kfree(buf);
+err:
+	return NULL;
+}
+
+__init void *
+rb_get_wlan_data(void)
+{
+	return __rb_get_wlan_data(0);
+}
+
+__init void *
+rb_get_ext_wlan_data(u16 id)
+{
+	return __rb_get_wlan_data(id);
+}
+
+__init const struct rb_info *
+rb_init_info(void *data, unsigned int size)
+{
+	unsigned int offset;
+
+	if (size == 0 || (size % RB_BLOCK_SIZE) != 0)
+		return NULL;
+
+	for (offset = 0; offset < size; offset += RB_BLOCK_SIZE) {
+		u32 magic;
+
+		magic = get_u32(data + offset);
+		switch (magic) {
+		case RB_MAGIC_HARD:
+			rb_info.hard_cfg_offs = offset;
+			break;
+
+		case RB_MAGIC_SOFT:
+			rb_info.soft_cfg_offs = offset;
+			break;
+		}
+	}
+
+	if (!rb_info.hard_cfg_offs) {
+		pr_err("could not find a valid RouterBOOT hard config\n");
+		return NULL;
+	}
+
+	if (!rb_info.soft_cfg_offs) {
+		pr_err("could not find a valid RouterBOOT soft config\n");
+		return NULL;
+	}
+
+	rb_info.hard_cfg_size = RB_BLOCK_SIZE;
+	rb_info.hard_cfg_data = kmemdup(data + rb_info.hard_cfg_offs,
+					RB_BLOCK_SIZE, GFP_KERNEL);
+	if (!rb_info.hard_cfg_data)
+		return NULL;
+
+	rb_info.board_name = rb_get_board_name();
+	rb_info.hw_options = rb_get_hw_options();
+
+	return &rb_info;
+}
+
+static char *rb_ext_wlan_data;
+
+static ssize_t
+rb_ext_wlan_data_read(struct file *filp, struct kobject *kobj,
+		      struct bin_attribute *attr, char *buf,
+		      loff_t off, size_t count)
+{
+         if (off + count > attr->size)
+                 return -EFBIG;
+
+         memcpy(buf, &rb_ext_wlan_data[off], count);
+
+         return count;
+}
+
+static const struct bin_attribute rb_ext_wlan_data_attr = {
+	.attr = {
+		.name = "ext_wlan_data",
+		.mode = S_IRUSR | S_IWUSR,
+	},
+	.read = rb_ext_wlan_data_read,
+	.size = RB_ART_SIZE,
+};
+
+static int __init rb_sysfs_init(void)
+{
+	struct kobject *rb_kobj;
+	int ret;
+
+	rb_ext_wlan_data = rb_get_ext_wlan_data(1);
+	if (rb_ext_wlan_data == NULL)
+		return -ENOENT;
+
+	rb_kobj = kobject_create_and_add("routerboot", firmware_kobj);
+	if (rb_kobj == NULL) {
+		ret = -ENOMEM;
+		pr_err("unable to create sysfs entry\n");
+		goto err_free_wlan_data;
+	}
+
+	ret = sysfs_create_bin_file(rb_kobj, &rb_ext_wlan_data_attr);
+	if (ret) {
+		pr_err("unable to create sysfs file, %d\n", ret);
+		goto err_put_kobj;
+	}
+
+	return 0;
+
+err_put_kobj:
+	kobject_put(rb_kobj);
+err_free_wlan_data:
+	kfree(rb_ext_wlan_data);
+	return ret;
+}
+
+late_initcall(rb_sysfs_init);
diff -Nur linux-4.1.13.orig/arch/mips/ath79/routerboot.h linux-4.1.13/arch/mips/ath79/routerboot.h
--- linux-4.1.13.orig/arch/mips/ath79/routerboot.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/routerboot.h	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,63 @@
+/*
+ *  RouterBoot definitions
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_ROUTERBOOT_H_
+#define _ATH79_ROUTERBOOT_H_
+
+struct rb_info {
+	unsigned int hard_cfg_offs;
+	unsigned int hard_cfg_size;
+	void *hard_cfg_data;
+	unsigned int soft_cfg_offs;
+
+	const char *board_name;
+	u32 hw_options;
+};
+
+#ifdef CONFIG_ATH79_ROUTERBOOT
+const struct rb_info *rb_init_info(void *data, unsigned int size);
+void *rb_get_wlan_data(void);
+void *rb_get_ext_wlan_data(u16 id);
+
+int routerboot_find_tag(u8 *buf, unsigned int buflen, u16 tag_id,
+			u8 **tag_data, u16 *tag_len);
+int routerboot_find_magic(u8 *buf, unsigned int buflen, u32 *offset, bool hard);
+#else
+static inline const struct rb_info *
+rb_init_info(void *data, unsigned int size)
+{
+	return NULL;
+}
+
+static inline void *rb_get_wlan_data(void)
+{
+	return NULL;
+}
+
+static inline void *rb_get_wlan_data(u16 id)
+{
+	return NULL;
+}
+
+static inline int
+routerboot_find_tag(u8 *buf, unsigned int buflen, u16 tag_id,
+		    u8 **tag_data, u16 *tag_len)
+{
+	return -ENOENT;
+}
+
+static inline int
+routerboot_find_magic(u8 *buf, unsigned int buflen, u32 *offset, bool hard)
+{
+	return -ENOENT;
+}
+#endif
+
+#endif /* _ATH79_ROUTERBOOT_H_ */
diff -Nur linux-4.1.13.orig/arch/mips/ath79/setup.c linux-4.1.13/arch/mips/ath79/setup.c
--- linux-4.1.13.orig/arch/mips/ath79/setup.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/ath79/setup.c	2015-12-04 19:57:04.482071652 +0100
@@ -40,6 +40,7 @@
 
 static void ath79_restart(char *command)
 {
+	local_irq_disable();
 	ath79_device_reset_set(AR71XX_RESET_FULL_CHIP);
 	for (;;)
 		if (cpu_wait)
@@ -59,6 +60,7 @@
 	u32 major;
 	u32 minor;
 	u32 rev = 0;
+	u32 ver = 1;
 
 	id = ath79_reset_rr(AR71XX_RESET_REG_REV_ID);
 	major = id & REV_ID_MAJOR_MASK;
@@ -151,6 +153,17 @@
 		rev = id & AR934X_REV_ID_REVISION_MASK;
 		break;
 
+	case REV_ID_MAJOR_QCA9533_V2:
+		ver = 2;
+		ath79_soc_rev = 2;
+		/* drop through */
+
+	case REV_ID_MAJOR_QCA9533:
+		ath79_soc = ATH79_SOC_QCA9533;
+		chip = "9533";
+		rev = id & QCA953X_REV_ID_REVISION_MASK;
+		break;
+
 	case REV_ID_MAJOR_QCA9556:
 		ath79_soc = ATH79_SOC_QCA9556;
 		chip = "9556";
@@ -163,14 +176,30 @@
 		rev = id & QCA955X_REV_ID_REVISION_MASK;
 		break;
 
+	case REV_ID_MAJOR_TP9343:
+		ath79_soc = ATH79_SOC_TP9343;
+		chip = "9343";
+		rev = id & QCA956X_REV_ID_REVISION_MASK;
+		break;
+
+	case REV_ID_MAJOR_QCA9561:
+		ath79_soc = ATH79_SOC_QCA9561;
+		chip = "9561";
+		rev = id & QCA956X_REV_ID_REVISION_MASK;
+		break;
+
 	default:
 		panic("ath79: unknown SoC, id:0x%08x", id);
 	}
 
-	ath79_soc_rev = rev;
+	if (ver == 1)
+		ath79_soc_rev = rev;
 
-	if (soc_is_qca955x())
-		sprintf(ath79_sys_type, "Qualcomm Atheros QCA%s rev %u",
+	if (soc_is_qca953x() || soc_is_qca955x() || soc_is_qca9561())
+		sprintf(ath79_sys_type, "Qualcomm Atheros QCA%s ver %u rev %u",
+			chip, ver, rev);
+	else if (soc_is_tp9343())
+		sprintf(ath79_sys_type, "Qualcomm Atheros TP%s rev %u",
 			chip, rev);
 	else
 		sprintf(ath79_sys_type, "Atheros AR%s rev %u", chip, rev);
@@ -235,6 +264,8 @@
 	mips_hpt_frequency = cpu_clk_rate / 2;
 }
 
+__setup("board=", mips_machtype_setup);
+
 static int __init ath79_setup(void)
 {
 	ath79_gpio_init();
diff -Nur linux-4.1.13.orig/arch/mips/fw/lib/cmdline.c linux-4.1.13/arch/mips/fw/lib/cmdline.c
--- linux-4.1.13.orig/arch/mips/fw/lib/cmdline.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/fw/lib/cmdline.c	2015-12-04 19:57:04.014102269 +0100
@@ -35,6 +35,7 @@
 	else
 		_fw_envp = (int *)fw_arg2;
 
+	arcs_cmdline[0] = '\0';
 	for (i = 1; i < fw_argc; i++) {
 		strlcat(arcs_cmdline, fw_argv(i), COMMAND_LINE_SIZE);
 		if (i < (fw_argc - 1))
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/checksum.h linux-4.1.13/arch/mips/include/asm/checksum.h
--- linux-4.1.13.orig/arch/mips/include/asm/checksum.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/checksum.h	2015-12-04 19:57:05.913977967 +0100
@@ -134,26 +134,30 @@
 	const unsigned int *stop = word + ihl;
 	unsigned int csum;
 	int carry;
+	unsigned int w;
 
-	csum = word[0];
-	csum += word[1];
-	carry = (csum < word[1]);
+	csum = net_hdr_word(word++);
+
+	w = net_hdr_word(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[2];
-	carry = (csum < word[2]);
+	w = net_hdr_word(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[3];
-	carry = (csum < word[3]);
+	w = net_hdr_word(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	word += 4;
 	do {
-		csum += *word;
-		carry = (csum < *word);
+		w = net_hdr_word(word++);
+		csum += w;
+		carry = (csum < w);
 		csum += carry;
-		word++;
 	} while (word != stop);
 
 	return csum_fold(csum);
@@ -212,73 +216,6 @@
 	return csum_fold(csum_partial(buff, len, 0));
 }
 
-#define _HAVE_ARCH_IPV6_CSUM
-static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
-					  const struct in6_addr *daddr,
-					  __u32 len, unsigned short proto,
-					  __wsum sum)
-{
-	__wsum tmp;
-
-	__asm__(
-	"	.set	push		# csum_ipv6_magic\n"
-	"	.set	noreorder	\n"
-	"	.set	noat		\n"
-	"	addu	%0, %5		# proto (long in network byte order)\n"
-	"	sltu	$1, %0, %5	\n"
-	"	addu	%0, $1		\n"
-
-	"	addu	%0, %6		# csum\n"
-	"	sltu	$1, %0, %6	\n"
-	"	lw	%1, 0(%2)	# four words source address\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 4(%2)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 8(%2)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 12(%2)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 0(%3)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 4(%3)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 8(%3)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 12(%3)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	addu	%0, $1		# Add final carry\n"
-	"	.set	pop"
-	: "=&r" (sum), "=&r" (tmp)
-	: "r" (saddr), "r" (daddr),
-	  "0" (htonl(len)), "r" (htonl(proto)), "r" (sum));
-
-	return csum_fold(sum);
-}
-
 #include <asm-generic/checksum.h>
 #endif /* CONFIG_GENERIC_CSUM */
 
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/fw/myloader/myloader.h linux-4.1.13/arch/mips/include/asm/fw/myloader/myloader.h
--- linux-4.1.13.orig/arch/mips/include/asm/fw/myloader/myloader.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/fw/myloader/myloader.h	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,34 @@
+/*
+ *  Compex's MyLoader specific definitions
+ *
+ *  Copyright (C) 2006-2008 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ASM_MIPS_FW_MYLOADER_H
+#define _ASM_MIPS_FW_MYLOADER_H
+
+#include <linux/myloader.h>
+
+struct myloader_info {
+	uint32_t	vid;
+	uint32_t	did;
+	uint32_t	svid;
+	uint32_t	sdid;
+	uint8_t		macs[MYLO_ETHADDR_COUNT][6];
+};
+
+#ifdef CONFIG_MYLOADER
+extern struct myloader_info *myloader_get_info(void) __init;
+#else
+static inline struct myloader_info *myloader_get_info(void)
+{
+	return NULL;
+}
+#endif /* CONFIG_MYLOADER */
+
+#endif /* _ASM_MIPS_FW_MYLOADER_H */
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/ag71xx_platform.h linux-4.1.13/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
--- linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/ag71xx_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mach-ath79/ag71xx_platform.h	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,65 @@
+/*
+ *  Atheros AR71xx SoC specific platform data definitions
+ *
+ *  Copyright (C) 2008-2012 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_ATH79_PLATFORM_H
+#define __ASM_MACH_ATH79_PLATFORM_H
+
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+#include <linux/spi/spi.h>
+
+struct ag71xx_switch_platform_data {
+	u8		phy4_mii_en:1;
+	u8		phy_poll_mask;
+};
+
+struct ag71xx_platform_data {
+	phy_interface_t	phy_if_mode;
+	u32		phy_mask;
+	int		speed;
+	int		duplex;
+	u32		reset_bit;
+	u8		mac_addr[ETH_ALEN];
+	struct device	*mii_bus_dev;
+
+	u8		has_gbit:1;
+	u8		is_ar91xx:1;
+	u8		is_ar7240:1;
+	u8		is_ar724x:1;
+	u8		has_ar8216:1;
+
+	struct ag71xx_switch_platform_data *switch_data;
+
+	void		(*ddr_flush)(void);
+	void		(*set_speed)(int speed);
+
+	u32		fifo_cfg1;
+	u32		fifo_cfg2;
+	u32		fifo_cfg3;
+
+	unsigned int	max_frame_len;
+	unsigned int	desc_pktlen_mask;
+};
+
+struct ag71xx_mdio_platform_data {
+	u32		phy_mask;
+	u8		builtin_switch:1;
+	u8		is_ar7240:1;
+	u8		is_ar9330:1;
+	u8		is_ar934x:1;
+	unsigned long	mdio_clock;
+	unsigned long	ref_clock;
+
+	void		(*reset)(struct mii_bus *bus);
+};
+
+#endif /* __ASM_MACH_ATH79_PLATFORM_H */
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/ar71xx_regs.h linux-4.1.13/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
--- linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/ar71xx_regs.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mach-ath79/ar71xx_regs.h	2015-12-04 19:57:05.893979276 +0100
@@ -20,6 +20,10 @@
 #include <linux/bitops.h>
 
 #define AR71XX_APB_BASE		0x18000000
+#define AR71XX_GE0_BASE		0x19000000
+#define AR71XX_GE0_SIZE		0x10000
+#define AR71XX_GE1_BASE		0x1a000000
+#define AR71XX_GE1_SIZE		0x10000
 #define AR71XX_EHCI_BASE	0x1b000000
 #define AR71XX_EHCI_SIZE	0x1000
 #define AR71XX_OHCI_BASE	0x1c000000
@@ -39,6 +43,8 @@
 #define AR71XX_PLL_SIZE		0x100
 #define AR71XX_RESET_BASE	(AR71XX_APB_BASE + 0x00060000)
 #define AR71XX_RESET_SIZE	0x100
+#define AR71XX_MII_BASE		(AR71XX_APB_BASE + 0x00070000)
+#define AR71XX_MII_SIZE		0x100
 
 #define AR71XX_PCI_MEM_BASE	0x10000000
 #define AR71XX_PCI_MEM_SIZE	0x07000000
@@ -81,18 +87,39 @@
 
 #define AR933X_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
 #define AR933X_UART_SIZE	0x14
+#define AR933X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+#define AR933X_GMAC_SIZE	0x04
 #define AR933X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
 #define AR933X_WMAC_SIZE	0x20000
 #define AR933X_EHCI_BASE	0x1b000000
 #define AR933X_EHCI_SIZE	0x1000
 
+#define AR934X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+#define AR934X_GMAC_SIZE	0x14
 #define AR934X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
 #define AR934X_WMAC_SIZE	0x20000
 #define AR934X_EHCI_BASE	0x1b000000
 #define AR934X_EHCI_SIZE	0x200
+#define AR934X_NFC_BASE		0x1b000200
+#define AR934X_NFC_SIZE		0xb8
 #define AR934X_SRIF_BASE	(AR71XX_APB_BASE + 0x00116000)
 #define AR934X_SRIF_SIZE	0x1000
 
+#define QCA953X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+#define QCA953X_GMAC_SIZE	0x14
+#define QCA953X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+#define QCA953X_WMAC_SIZE	0x20000
+#define QCA953X_EHCI_BASE	0x1b000000
+#define QCA953X_EHCI_SIZE	0x200
+#define QCA953X_SRIF_BASE	(AR71XX_APB_BASE + 0x00116000)
+#define QCA953X_SRIF_SIZE	0x1000
+
+#define QCA953X_PCI_CFG_BASE0	0x14000000
+#define QCA953X_PCI_CTRL_BASE0	(AR71XX_APB_BASE + 0x000f0000)
+#define QCA953X_PCI_CRP_BASE0	(AR71XX_APB_BASE + 0x000c0000)
+#define QCA953X_PCI_MEM_BASE0	0x10000000
+#define QCA953X_PCI_MEM_SIZE	0x02000000
+
 #define QCA955X_PCI_MEM_BASE0	0x10000000
 #define QCA955X_PCI_MEM_BASE1	0x12000000
 #define QCA955X_PCI_MEM_SIZE	0x02000000
@@ -106,11 +133,40 @@
 #define QCA955X_PCI_CTRL_BASE1	(AR71XX_APB_BASE + 0x00280000)
 #define QCA955X_PCI_CTRL_SIZE	0x100
 
+#define QCA955X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+#define QCA955X_GMAC_SIZE	0x40
 #define QCA955X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
 #define QCA955X_WMAC_SIZE	0x20000
 #define QCA955X_EHCI0_BASE	0x1b000000
 #define QCA955X_EHCI1_BASE	0x1b400000
 #define QCA955X_EHCI_SIZE	0x1000
+#define QCA955X_NFC_BASE	0x1b800200
+#define QCA955X_NFC_SIZE	0xb8
+
+#define QCA956X_PCI_MEM_BASE1	0x12000000
+#define QCA956X_PCI_MEM_SIZE	0x02000000
+#define QCA956X_PCI_CFG_BASE1	0x16000000
+#define QCA956X_PCI_CFG_SIZE	0x1000
+#define QCA956X_PCI_CRP_BASE1	(AR71XX_APB_BASE + 0x00250000)
+#define QCA956X_PCI_CRP_SIZE	0x1000
+#define QCA956X_PCI_CTRL_BASE1	(AR71XX_APB_BASE + 0x00280000)
+#define QCA956X_PCI_CTRL_SIZE	0x100
+
+#define QCA956X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
+#define QCA956X_WMAC_SIZE	0x20000
+#define QCA956X_EHCI0_BASE	0x1b000000
+#define QCA956X_EHCI1_BASE	0x1b400000
+#define QCA956X_EHCI_SIZE	0x200
+#define QCA956X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
+#define QCA956X_GMAC_SIZE	0x64
+
+#define AR9300_OTP_BASE		0x14000
+#define AR9300_OTP_STATUS	0x15f18
+#define AR9300_OTP_STATUS_TYPE		0x7
+#define AR9300_OTP_STATUS_VALID		0x4
+#define AR9300_OTP_STATUS_ACCESS_BUSY	0x2
+#define AR9300_OTP_STATUS_SM_BUSY	0x1
+#define AR9300_OTP_READ_DATA	0x15f1c
 
 /*
  * DDR_CTRL block
@@ -149,6 +205,12 @@
 #define AR934X_DDR_REG_FLUSH_PCIE	0xa8
 #define AR934X_DDR_REG_FLUSH_WMAC	0xac
 
+#define QCA953X_DDR_REG_FLUSH_GE0	0x9c
+#define QCA953X_DDR_REG_FLUSH_GE1	0xa0
+#define QCA953X_DDR_REG_FLUSH_USB	0xa4
+#define QCA953X_DDR_REG_FLUSH_PCIE	0xa8
+#define QCA953X_DDR_REG_FLUSH_WMAC	0xac
+
 /*
  * PLL block
  */
@@ -166,6 +228,9 @@
 #define AR71XX_AHB_DIV_SHIFT		20
 #define AR71XX_AHB_DIV_MASK		0x7
 
+#define AR71XX_ETH0_PLL_SHIFT		17
+#define AR71XX_ETH1_PLL_SHIFT		19
+
 #define AR724X_PLL_REG_CPU_CONFIG	0x00
 #define AR724X_PLL_REG_PCIE_CONFIG	0x18
 
@@ -178,6 +243,8 @@
 #define AR724X_DDR_DIV_SHIFT		22
 #define AR724X_DDR_DIV_MASK		0x3
 
+#define AR7242_PLL_REG_ETH0_INT_CLOCK	0x2c
+
 #define AR913X_PLL_REG_CPU_CONFIG	0x00
 #define AR913X_PLL_REG_ETH_CONFIG	0x04
 #define AR913X_PLL_REG_ETH0_INT_CLOCK	0x14
@@ -190,6 +257,9 @@
 #define AR913X_AHB_DIV_SHIFT		19
 #define AR913X_AHB_DIV_MASK		0x1
 
+#define AR913X_ETH0_PLL_SHIFT		20
+#define AR913X_ETH1_PLL_SHIFT		22
+
 #define AR933X_PLL_CPU_CONFIG_REG	0x00
 #define AR933X_PLL_CLOCK_CTRL_REG	0x08
 
@@ -211,6 +281,8 @@
 #define AR934X_PLL_CPU_CONFIG_REG		0x00
 #define AR934X_PLL_DDR_CONFIG_REG		0x04
 #define AR934X_PLL_CPU_DDR_CLK_CTRL_REG		0x08
+#define AR934X_PLL_SWITCH_CLOCK_CONTROL_REG	0x24
+#define AR934X_PLL_ETH_XMII_CONTROL_REG		0x2c
 
 #define AR934X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
 #define AR934X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
@@ -243,9 +315,51 @@
 #define AR934X_PLL_CPU_DDR_CLK_CTRL_DDRCLK_FROM_DDRPLL	BIT(21)
 #define AR934X_PLL_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL	BIT(24)
 
+#define AR934X_PLL_SWITCH_CLOCK_CONTROL_MDIO_CLK_SEL	BIT(6)
+
+#define QCA953X_PLL_CPU_CONFIG_REG		0x00
+#define QCA953X_PLL_DDR_CONFIG_REG		0x04
+#define QCA953X_PLL_CLK_CTRL_REG		0x08
+#define QCA953X_PLL_SWITCH_CLOCK_CONTROL_REG	0x24
+#define QCA953X_PLL_ETH_XMII_CONTROL_REG	0x2c
+#define QCA953X_PLL_ETH_SGMII_CONTROL_REG	0x48
+
+#define QCA953X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
+#define QCA953X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
+#define QCA953X_PLL_CPU_CONFIG_NINT_SHIFT	6
+#define QCA953X_PLL_CPU_CONFIG_NINT_MASK	0x3f
+#define QCA953X_PLL_CPU_CONFIG_REFDIV_SHIFT	12
+#define QCA953X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
+#define QCA953X_PLL_CPU_CONFIG_OUTDIV_SHIFT	19
+#define QCA953X_PLL_CPU_CONFIG_OUTDIV_MASK	0x7
+
+#define QCA953X_PLL_DDR_CONFIG_NFRAC_SHIFT	0
+#define QCA953X_PLL_DDR_CONFIG_NFRAC_MASK	0x3ff
+#define QCA953X_PLL_DDR_CONFIG_NINT_SHIFT	10
+#define QCA953X_PLL_DDR_CONFIG_NINT_MASK	0x3f
+#define QCA953X_PLL_DDR_CONFIG_REFDIV_SHIFT	16
+#define QCA953X_PLL_DDR_CONFIG_REFDIV_MASK	0x1f
+#define QCA953X_PLL_DDR_CONFIG_OUTDIV_SHIFT	23
+#define QCA953X_PLL_DDR_CONFIG_OUTDIV_MASK	0x7
+
+#define QCA953X_PLL_CLK_CTRL_CPU_PLL_BYPASS		BIT(2)
+#define QCA953X_PLL_CLK_CTRL_DDR_PLL_BYPASS		BIT(3)
+#define QCA953X_PLL_CLK_CTRL_AHB_PLL_BYPASS		BIT(4)
+#define QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT		5
+#define QCA953X_PLL_CLK_CTRL_CPU_POST_DIV_MASK		0x1f
+#define QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT		10
+#define QCA953X_PLL_CLK_CTRL_DDR_POST_DIV_MASK		0x1f
+#define QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT		15
+#define QCA953X_PLL_CLK_CTRL_AHB_POST_DIV_MASK		0x1f
+#define QCA953X_PLL_CLK_CTRL_CPUCLK_FROM_CPUPLL		BIT(20)
+#define QCA953X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL		BIT(21)
+#define QCA953X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
+
 #define QCA955X_PLL_CPU_CONFIG_REG		0x00
 #define QCA955X_PLL_DDR_CONFIG_REG		0x04
 #define QCA955X_PLL_CLK_CTRL_REG		0x08
+#define QCA955X_PLL_ETH_XMII_CONTROL_REG	0x28
+#define QCA955X_PLL_ETH_SGMII_CONTROL_REG	0x48
 
 #define QCA955X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
 #define QCA955X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
@@ -278,6 +392,49 @@
 #define QCA955X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL		BIT(21)
 #define QCA955X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
 
+#define QCA956X_PLL_CPU_CONFIG_REG			0x00
+#define QCA956X_PLL_CPU_CONFIG1_REG			0x04
+#define QCA956X_PLL_DDR_CONFIG_REG			0x08
+#define QCA956X_PLL_DDR_CONFIG1_REG			0x0c
+#define QCA956X_PLL_CLK_CTRL_REG			0x10
+
+#define QCA956X_PLL_CPU_CONFIG_REFDIV_SHIFT		12
+#define QCA956X_PLL_CPU_CONFIG_REFDIV_MASK		0x1f
+#define QCA956X_PLL_CPU_CONFIG_OUTDIV_SHIFT		19
+#define QCA956X_PLL_CPU_CONFIG_OUTDIV_MASK		0x7
+
+#define QCA956X_PLL_CPU_CONFIG1_NFRAC_L_SHIFT		0
+#define QCA956X_PLL_CPU_CONFIG1_NFRAC_L_MASK		0x1f
+#define QCA956X_PLL_CPU_CONFIG1_NFRAC_H_SHIFT		5
+#define QCA956X_PLL_CPU_CONFIG1_NFRAC_H_MASK		0x1fff
+#define QCA956X_PLL_CPU_CONFIG1_NINT_SHIFT		18
+#define QCA956X_PLL_CPU_CONFIG1_NINT_MASK		0x1ff
+
+#define QCA956X_PLL_DDR_CONFIG_REFDIV_SHIFT		16
+#define QCA956X_PLL_DDR_CONFIG_REFDIV_MASK		0x1f
+#define QCA956X_PLL_DDR_CONFIG_OUTDIV_SHIFT		23
+#define QCA956X_PLL_DDR_CONFIG_OUTDIV_MASK		0x7
+
+#define QCA956X_PLL_DDR_CONFIG1_NFRAC_L_SHIFT		0
+#define QCA956X_PLL_DDR_CONFIG1_NFRAC_L_MASK		0x1f
+#define QCA956X_PLL_DDR_CONFIG1_NFRAC_H_SHIFT		5
+#define QCA956X_PLL_DDR_CONFIG1_NFRAC_H_MASK		0x1fff
+#define QCA956X_PLL_DDR_CONFIG1_NINT_SHIFT		18
+#define QCA956X_PLL_DDR_CONFIG1_NINT_MASK		0x1ff
+
+#define QCA956X_PLL_CLK_CTRL_CPU_PLL_BYPASS		BIT(2)
+#define QCA956X_PLL_CLK_CTRL_DDR_PLL_BYPASS		BIT(3)
+#define QCA956X_PLL_CLK_CTRL_AHB_PLL_BYPASS		BIT(4)
+#define QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT		5
+#define QCA956X_PLL_CLK_CTRL_CPU_POST_DIV_MASK		0x1f
+#define QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT		10
+#define QCA956X_PLL_CLK_CTRL_DDR_POST_DIV_MASK		0x1f
+#define QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT		15
+#define QCA956X_PLL_CLK_CTRL_AHB_POST_DIV_MASK		0x1f
+#define QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_DDRPLL	BIT(20)
+#define QCA956X_PLL_CLK_CTRL_CPU_DDRCLK_FROM_CPUPLL	BIT(21)
+#define QCA956X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
+
 /*
  * USB_CONFIG block
  */
@@ -317,10 +474,19 @@
 #define AR934X_RESET_REG_BOOTSTRAP		0xb0
 #define AR934X_RESET_REG_PCIE_WMAC_INT_STATUS	0xac
 
+#define QCA953X_RESET_REG_RESET_MODULE		0x1c
+#define QCA953X_RESET_REG_BOOTSTRAP		0xb0
+#define QCA953X_RESET_REG_PCIE_WMAC_INT_STATUS	0xac
+
 #define QCA955X_RESET_REG_RESET_MODULE		0x1c
 #define QCA955X_RESET_REG_BOOTSTRAP		0xb0
 #define QCA955X_RESET_REG_EXT_INT_STATUS	0xac
 
+#define QCA956X_RESET_REG_RESET_MODULE		0x1c
+#define QCA956X_RESET_REG_BOOTSTRAP		0xb0
+#define QCA956X_RESET_REG_EXT_INT_STATUS	0xac
+
+#define MISC_INT_MIPS_SI_TIMERINT_MASK	BIT(28)
 #define MISC_INT_ETHSW			BIT(12)
 #define MISC_INT_TIMER4			BIT(10)
 #define MISC_INT_TIMER3			BIT(9)
@@ -370,16 +536,104 @@
 #define AR913X_RESET_USB_HOST		BIT(5)
 #define AR913X_RESET_USB_PHY		BIT(4)
 
+#define AR933X_RESET_GE1_MDIO		BIT(23)
+#define AR933X_RESET_GE0_MDIO		BIT(22)
+#define AR933X_RESET_GE1_MAC		BIT(13)
 #define AR933X_RESET_WMAC		BIT(11)
+#define AR933X_RESET_GE0_MAC		BIT(9)
 #define AR933X_RESET_USB_HOST		BIT(5)
 #define AR933X_RESET_USB_PHY		BIT(4)
 #define AR933X_RESET_USBSUS_OVERRIDE	BIT(3)
 
+#define AR934X_RESET_HOST		BIT(31)
+#define AR934X_RESET_SLIC		BIT(30)
+#define AR934X_RESET_HDMA		BIT(29)
+#define AR934X_RESET_EXTERNAL		BIT(28)
+#define AR934X_RESET_RTC		BIT(27)
+#define AR934X_RESET_PCIE_EP_INT	BIT(26)
+#define AR934X_RESET_CHKSUM_ACC		BIT(25)
+#define AR934X_RESET_FULL_CHIP		BIT(24)
+#define AR934X_RESET_GE1_MDIO		BIT(23)
+#define AR934X_RESET_GE0_MDIO		BIT(22)
+#define AR934X_RESET_CPU_NMI		BIT(21)
+#define AR934X_RESET_CPU_COLD		BIT(20)
+#define AR934X_RESET_HOST_RESET_INT	BIT(19)
+#define AR934X_RESET_PCIE_EP		BIT(18)
+#define AR934X_RESET_UART1		BIT(17)
+#define AR934X_RESET_DDR		BIT(16)
+#define AR934X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
+#define AR934X_RESET_NANDF		BIT(14)
+#define AR934X_RESET_GE1_MAC		BIT(13)
+#define AR934X_RESET_ETH_SWITCH_ANALOG	BIT(12)
 #define AR934X_RESET_USB_PHY_ANALOG	BIT(11)
+#define AR934X_RESET_HOST_DMA_INT	BIT(10)
+#define AR934X_RESET_GE0_MAC		BIT(9)
+#define AR934X_RESET_ETH_SWITCH		BIT(8)
+#define AR934X_RESET_PCIE_PHY		BIT(7)
+#define AR934X_RESET_PCIE		BIT(6)
 #define AR934X_RESET_USB_HOST		BIT(5)
 #define AR934X_RESET_USB_PHY		BIT(4)
 #define AR934X_RESET_USBSUS_OVERRIDE	BIT(3)
+#define AR934X_RESET_LUT		BIT(2)
+#define AR934X_RESET_MBOX		BIT(1)
+#define AR934X_RESET_I2S		BIT(0)
+
+#define QCA953X_RESET_USB_EXT_PWR	BIT(29)
+#define QCA953X_RESET_EXTERNAL		BIT(28)
+#define QCA953X_RESET_RTC		BIT(27)
+#define QCA953X_RESET_FULL_CHIP		BIT(24)
+#define QCA953X_RESET_GE1_MDIO		BIT(23)
+#define QCA953X_RESET_GE0_MDIO		BIT(22)
+#define QCA953X_RESET_CPU_NMI		BIT(21)
+#define QCA953X_RESET_CPU_COLD		BIT(20)
+#define QCA953X_RESET_DDR		BIT(16)
+#define QCA953X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
+#define QCA953X_RESET_GE1_MAC		BIT(13)
+#define QCA953X_RESET_ETH_SWITCH_ANALOG	BIT(12)
+#define QCA953X_RESET_USB_PHY_ANALOG	BIT(11)
+#define QCA953X_RESET_GE0_MAC		BIT(9)
+#define QCA953X_RESET_ETH_SWITCH	BIT(8)
+#define QCA953X_RESET_PCIE_PHY		BIT(7)
+#define QCA953X_RESET_PCIE		BIT(6)
+#define QCA953X_RESET_USB_HOST		BIT(5)
+#define QCA953X_RESET_USB_PHY		BIT(4)
+#define QCA953X_RESET_USBSUS_OVERRIDE	BIT(3)
+
+#define QCA955X_RESET_HOST		BIT(31)
+#define QCA955X_RESET_SLIC		BIT(30)
+#define QCA955X_RESET_HDMA		BIT(29)
+#define QCA955X_RESET_EXTERNAL		BIT(28)
+#define QCA955X_RESET_RTC		BIT(27)
+#define QCA955X_RESET_PCIE_EP_INT	BIT(26)
+#define QCA955X_RESET_CHKSUM_ACC	BIT(25)
+#define QCA955X_RESET_FULL_CHIP		BIT(24)
+#define QCA955X_RESET_GE1_MDIO		BIT(23)
+#define QCA955X_RESET_GE0_MDIO		BIT(22)
+#define QCA955X_RESET_CPU_NMI		BIT(21)
+#define QCA955X_RESET_CPU_COLD		BIT(20)
+#define QCA955X_RESET_HOST_RESET_INT	BIT(19)
+#define QCA955X_RESET_PCIE_EP		BIT(18)
+#define QCA955X_RESET_UART1		BIT(17)
+#define QCA955X_RESET_DDR		BIT(16)
+#define QCA955X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
+#define QCA955X_RESET_NANDF		BIT(14)
+#define QCA955X_RESET_GE1_MAC		BIT(13)
+#define QCA955X_RESET_SGMII_ANALOG	BIT(12)
+#define QCA955X_RESET_USB_PHY_ANALOG	BIT(11)
+#define QCA955X_RESET_HOST_DMA_INT	BIT(10)
+#define QCA955X_RESET_GE0_MAC		BIT(9)
+#define QCA955X_RESET_SGMII		BIT(8)
+#define QCA955X_RESET_PCIE_PHY		BIT(7)
+#define QCA955X_RESET_PCIE		BIT(6)
+#define QCA955X_RESET_USB_HOST		BIT(5)
+#define QCA955X_RESET_USB_PHY		BIT(4)
+#define QCA955X_RESET_USBSUS_OVERRIDE	BIT(3)
+#define QCA955X_RESET_LUT		BIT(2)
+#define QCA955X_RESET_MBOX		BIT(1)
+#define QCA955X_RESET_I2S		BIT(0)
 
+#define AR933X_BOOTSTRAP_MDIO_GPIO_EN	BIT(18)
+#define AR933X_BOOTSTRAP_EEPBUSY	BIT(4)
 #define AR933X_BOOTSTRAP_REF_CLK_40	BIT(0)
 
 #define AR934X_BOOTSTRAP_SW_OPTION8	BIT(23)
@@ -398,8 +652,17 @@
 #define AR934X_BOOTSTRAP_SDRAM_DISABLED BIT(1)
 #define AR934X_BOOTSTRAP_DDR1		BIT(0)
 
+#define QCA953X_BOOTSTRAP_SW_OPTION2	BIT(12)
+#define QCA953X_BOOTSTRAP_SW_OPTION1	BIT(11)
+#define QCA953X_BOOTSTRAP_EJTAG_MODE	BIT(5)
+#define QCA953X_BOOTSTRAP_REF_CLK_40	BIT(4)
+#define QCA953X_BOOTSTRAP_SDRAM_DISABLED BIT(1)
+#define QCA953X_BOOTSTRAP_DDR1		BIT(0)
+
 #define QCA955X_BOOTSTRAP_REF_CLK_40	BIT(4)
 
+#define QCA956X_BOOTSTRAP_REF_CLK_40	BIT(2)
+
 #define AR934X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
 #define AR934X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
 #define AR934X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
@@ -418,6 +681,24 @@
 	 AR934X_PCIE_WMAC_INT_PCIE_RC1 | AR934X_PCIE_WMAC_INT_PCIE_RC2 | \
 	 AR934X_PCIE_WMAC_INT_PCIE_RC3)
 
+#define QCA953X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
+#define QCA953X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
+#define QCA953X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
+#define QCA953X_PCIE_WMAC_INT_WMAC_RXHP		BIT(3)
+#define QCA953X_PCIE_WMAC_INT_PCIE_RC		BIT(4)
+#define QCA953X_PCIE_WMAC_INT_PCIE_RC0		BIT(5)
+#define QCA953X_PCIE_WMAC_INT_PCIE_RC1		BIT(6)
+#define QCA953X_PCIE_WMAC_INT_PCIE_RC2		BIT(7)
+#define QCA953X_PCIE_WMAC_INT_PCIE_RC3		BIT(8)
+#define QCA953X_PCIE_WMAC_INT_WMAC_ALL \
+	(QCA953X_PCIE_WMAC_INT_WMAC_MISC | QCA953X_PCIE_WMAC_INT_WMAC_TX | \
+	 QCA953X_PCIE_WMAC_INT_WMAC_RXLP | QCA953X_PCIE_WMAC_INT_WMAC_RXHP)
+
+#define QCA953X_PCIE_WMAC_INT_PCIE_ALL \
+	(QCA953X_PCIE_WMAC_INT_PCIE_RC | QCA953X_PCIE_WMAC_INT_PCIE_RC0 | \
+	 QCA953X_PCIE_WMAC_INT_PCIE_RC1 | QCA953X_PCIE_WMAC_INT_PCIE_RC2 | \
+	 QCA953X_PCIE_WMAC_INT_PCIE_RC3)
+
 #define QCA955X_EXT_INT_WMAC_MISC		BIT(0)
 #define QCA955X_EXT_INT_WMAC_TX			BIT(1)
 #define QCA955X_EXT_INT_WMAC_RXLP		BIT(2)
@@ -449,6 +730,37 @@
 	 QCA955X_EXT_INT_PCIE_RC2_INT1 | QCA955X_EXT_INT_PCIE_RC2_INT2 | \
 	 QCA955X_EXT_INT_PCIE_RC2_INT3)
 
+#define QCA956X_EXT_INT_WMAC_MISC		BIT(0)
+#define QCA956X_EXT_INT_WMAC_TX			BIT(1)
+#define QCA956X_EXT_INT_WMAC_RXLP		BIT(2)
+#define QCA956X_EXT_INT_WMAC_RXHP		BIT(3)
+#define QCA956X_EXT_INT_PCIE_RC1		BIT(4)
+#define QCA956X_EXT_INT_PCIE_RC1_INT0		BIT(5)
+#define QCA956X_EXT_INT_PCIE_RC1_INT1		BIT(6)
+#define QCA956X_EXT_INT_PCIE_RC1_INT2		BIT(7)
+#define QCA956X_EXT_INT_PCIE_RC1_INT3		BIT(8)
+#define QCA956X_EXT_INT_PCIE_RC2		BIT(12)
+#define QCA956X_EXT_INT_PCIE_RC2_INT0		BIT(13)
+#define QCA956X_EXT_INT_PCIE_RC2_INT1		BIT(14)
+#define QCA956X_EXT_INT_PCIE_RC2_INT2		BIT(15)
+#define QCA956X_EXT_INT_PCIE_RC2_INT3		BIT(16)
+#define QCA956X_EXT_INT_USB1			BIT(24)
+#define QCA956X_EXT_INT_USB2			BIT(28)
+
+#define QCA956X_EXT_INT_WMAC_ALL \
+	(QCA956X_EXT_INT_WMAC_MISC | QCA956X_EXT_INT_WMAC_TX | \
+	 QCA956X_EXT_INT_WMAC_RXLP | QCA956X_EXT_INT_WMAC_RXHP)
+
+#define QCA956X_EXT_INT_PCIE_RC1_ALL \
+	(QCA956X_EXT_INT_PCIE_RC1 | QCA956X_EXT_INT_PCIE_RC1_INT0 | \
+	 QCA956X_EXT_INT_PCIE_RC1_INT1 | QCA956X_EXT_INT_PCIE_RC1_INT2 | \
+	 QCA956X_EXT_INT_PCIE_RC1_INT3)
+
+#define QCA956X_EXT_INT_PCIE_RC2_ALL \
+	(QCA956X_EXT_INT_PCIE_RC2 | QCA956X_EXT_INT_PCIE_RC2_INT0 | \
+	 QCA956X_EXT_INT_PCIE_RC2_INT1 | QCA956X_EXT_INT_PCIE_RC2_INT2 | \
+	 QCA956X_EXT_INT_PCIE_RC2_INT3)
+
 #define REV_ID_MAJOR_MASK		0xfff0
 #define REV_ID_MAJOR_AR71XX		0x00a0
 #define REV_ID_MAJOR_AR913X		0x00b0
@@ -460,8 +772,12 @@
 #define REV_ID_MAJOR_AR9341		0x0120
 #define REV_ID_MAJOR_AR9342		0x1120
 #define REV_ID_MAJOR_AR9344		0x2120
+#define REV_ID_MAJOR_QCA9533		0x0140
+#define REV_ID_MAJOR_QCA9533_V2		0x0160
 #define REV_ID_MAJOR_QCA9556		0x0130
 #define REV_ID_MAJOR_QCA9558		0x1130
+#define REV_ID_MAJOR_TP9343		0x0150
+#define REV_ID_MAJOR_QCA9561		0x1150
 
 #define AR71XX_REV_ID_MINOR_MASK	0x3
 #define AR71XX_REV_ID_MINOR_AR7130	0x0
@@ -482,8 +798,12 @@
 
 #define AR934X_REV_ID_REVISION_MASK	0xf
 
+#define QCA953X_REV_ID_REVISION_MASK	0xf
+
 #define QCA955X_REV_ID_REVISION_MASK	0xf
 
+#define QCA956X_REV_ID_REVISION_MASK	0xf
+
 /*
  * SPI block
  */
@@ -520,16 +840,65 @@
 #define AR71XX_GPIO_REG_INT_PENDING	0x20
 #define AR71XX_GPIO_REG_INT_ENABLE	0x24
 #define AR71XX_GPIO_REG_FUNC		0x28
+#define AR71XX_GPIO_REG_FUNC_2		0x30
 
+#define AR934X_GPIO_REG_OUT_FUNC0	0x2c
+#define AR934X_GPIO_REG_OUT_FUNC1	0x30
+#define AR934X_GPIO_REG_OUT_FUNC2	0x34
+#define AR934X_GPIO_REG_OUT_FUNC3	0x38
+#define AR934X_GPIO_REG_OUT_FUNC4	0x3c
+#define AR934X_GPIO_REG_OUT_FUNC5	0x40
 #define AR934X_GPIO_REG_FUNC		0x6c
 
+#define QCA953X_GPIO_REG_OUT_FUNC0	0x2c
+#define QCA953X_GPIO_REG_OUT_FUNC1	0x30
+#define QCA953X_GPIO_REG_OUT_FUNC2	0x34
+#define QCA953X_GPIO_REG_OUT_FUNC3	0x38
+#define QCA953X_GPIO_REG_OUT_FUNC4	0x3c
+#define QCA953X_GPIO_REG_IN_ENABLE0	0x44
+#define QCA953X_GPIO_REG_FUNC		0x6c
+
+#define QCA953X_GPIO_OUT_MUX_SPI_CS1		10
+#define QCA953X_GPIO_OUT_MUX_SPI_CS2		11
+#define QCA953X_GPIO_OUT_MUX_SPI_CS0		9
+#define QCA953X_GPIO_OUT_MUX_SPI_CLK		8
+#define QCA953X_GPIO_OUT_MUX_SPI_MOSI		12
+#define QCA953X_GPIO_OUT_MUX_LED_LINK1		41
+#define QCA953X_GPIO_OUT_MUX_LED_LINK2		42
+#define QCA953X_GPIO_OUT_MUX_LED_LINK3		43
+#define QCA953X_GPIO_OUT_MUX_LED_LINK4		44
+#define QCA953X_GPIO_OUT_MUX_LED_LINK5		45
+
+#define QCA955X_GPIO_REG_OUT_FUNC0	0x2c
+#define QCA955X_GPIO_REG_OUT_FUNC1	0x30
+#define QCA955X_GPIO_REG_OUT_FUNC2	0x34
+#define QCA955X_GPIO_REG_OUT_FUNC3	0x38
+#define QCA955X_GPIO_REG_OUT_FUNC4	0x3c
+#define QCA955X_GPIO_REG_OUT_FUNC5	0x40
+#define QCA955X_GPIO_REG_FUNC		0x6c
+
+#define QCA956X_GPIO_REG_OUT_FUNC0	0x2c
+#define QCA956X_GPIO_REG_OUT_FUNC1	0x30
+#define QCA956X_GPIO_REG_OUT_FUNC2	0x34
+#define QCA956X_GPIO_REG_OUT_FUNC3	0x38
+#define QCA956X_GPIO_REG_OUT_FUNC4	0x3c
+#define QCA956X_GPIO_REG_OUT_FUNC5	0x40
+#define QCA956X_GPIO_REG_IN_ENABLE0	0x44
+#define QCA956X_GPIO_REG_IN_ENABLE3	0x50
+#define QCA956X_GPIO_REG_FUNC		0x6c
+
+#define QCA956X_GPIO_OUT_MUX_GE0_MDO	32
+#define QCA956X_GPIO_OUT_MUX_GE0_MDC	33
+
 #define AR71XX_GPIO_COUNT		16
 #define AR7240_GPIO_COUNT		18
 #define AR7241_GPIO_COUNT		20
 #define AR913X_GPIO_COUNT		22
 #define AR933X_GPIO_COUNT		30
 #define AR934X_GPIO_COUNT		23
+#define QCA953X_GPIO_COUNT		18
 #define QCA955X_GPIO_COUNT		24
+#define QCA956X_GPIO_COUNT		23
 
 /*
  * SRIF block
@@ -552,4 +921,185 @@
 #define AR934X_SRIF_DPLL2_OUTDIV_SHIFT	13
 #define AR934X_SRIF_DPLL2_OUTDIV_MASK	0x7
 
+#define QCA953X_SRIF_CPU_DPLL1_REG	0x1c0
+#define QCA953X_SRIF_CPU_DPLL2_REG	0x1c4
+#define QCA953X_SRIF_CPU_DPLL3_REG	0x1c8
+
+#define QCA953X_SRIF_DDR_DPLL1_REG	0x240
+#define QCA953X_SRIF_DDR_DPLL2_REG	0x244
+#define QCA953X_SRIF_DDR_DPLL3_REG	0x248
+
+#define QCA953X_SRIF_DPLL1_REFDIV_SHIFT	27
+#define QCA953X_SRIF_DPLL1_REFDIV_MASK	0x1f
+#define QCA953X_SRIF_DPLL1_NINT_SHIFT	18
+#define QCA953X_SRIF_DPLL1_NINT_MASK	0x1ff
+#define QCA953X_SRIF_DPLL1_NFRAC_MASK	0x0003ffff
+
+#define QCA953X_SRIF_DPLL2_LOCAL_PLL	BIT(30)
+#define QCA953X_SRIF_DPLL2_OUTDIV_SHIFT	13
+#define QCA953X_SRIF_DPLL2_OUTDIV_MASK	0x7
+
+#define AR71XX_GPIO_FUNC_STEREO_EN		BIT(17)
+#define AR71XX_GPIO_FUNC_SLIC_EN		BIT(16)
+#define AR71XX_GPIO_FUNC_SPI_CS2_EN		BIT(13)
+#define AR71XX_GPIO_FUNC_SPI_CS1_EN		BIT(12)
+#define AR71XX_GPIO_FUNC_UART_EN		BIT(8)
+#define AR71XX_GPIO_FUNC_USB_OC_EN		BIT(4)
+#define AR71XX_GPIO_FUNC_USB_CLK_EN		BIT(0)
+
+#define AR724X_GPIO_FUNC_GE0_MII_CLK_EN		BIT(19)
+#define AR724X_GPIO_FUNC_SPI_EN			BIT(18)
+#define AR724X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
+#define AR724X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
+#define AR724X_GPIO_FUNC_CLK_OBS5_EN		BIT(12)
+#define AR724X_GPIO_FUNC_CLK_OBS4_EN		BIT(11)
+#define AR724X_GPIO_FUNC_CLK_OBS3_EN		BIT(10)
+#define AR724X_GPIO_FUNC_CLK_OBS2_EN		BIT(9)
+#define AR724X_GPIO_FUNC_CLK_OBS1_EN		BIT(8)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
+#define AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
+#define AR724X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
+#define AR724X_GPIO_FUNC_UART_EN		BIT(1)
+#define AR724X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
+
+#define AR933X_GPIO_FUNC2_JUMPSTART_DISABLE 	BIT(9)
+
+#define AR913X_GPIO_FUNC_WMAC_LED_EN		BIT(22)
+#define AR913X_GPIO_FUNC_EXP_PORT_CS_EN		BIT(21)
+#define AR913X_GPIO_FUNC_I2S_REFCLKEN		BIT(20)
+#define AR913X_GPIO_FUNC_I2S_MCKEN		BIT(19)
+#define AR913X_GPIO_FUNC_I2S1_EN		BIT(18)
+#define AR913X_GPIO_FUNC_I2S0_EN		BIT(17)
+#define AR913X_GPIO_FUNC_SLIC_EN		BIT(16)
+#define AR913X_GPIO_FUNC_UART_RTSCTS_EN		BIT(9)
+#define AR913X_GPIO_FUNC_UART_EN		BIT(8)
+#define AR913X_GPIO_FUNC_USB_CLK_EN		BIT(4)
+
+#define AR933X_GPIO_FUNC_SPDIF2TCK		BIT(31)
+#define AR933X_GPIO_FUNC_SPDIF_EN		BIT(30)
+#define AR933X_GPIO_FUNC_I2SO_22_18_EN		BIT(29)
+#define AR933X_GPIO_FUNC_I2S_MCK_EN		BIT(27)
+#define AR933X_GPIO_FUNC_I2SO_EN		BIT(26)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_DUPL	BIT(25)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_COLL	BIT(24)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_ACT	BIT(23)
+#define AR933X_GPIO_FUNC_SPI_EN			BIT(18)
+#define AR933X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
+#define AR933X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
+#define AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
+#define AR933X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
+#define AR933X_GPIO_FUNC_UART_EN		BIT(1)
+#define AR933X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
+
+#define AR934X_GPIO_FUNC_CLK_OBS7_EN		BIT(9)
+#define AR934X_GPIO_FUNC_CLK_OBS6_EN		BIT(8)
+#define AR934X_GPIO_FUNC_CLK_OBS5_EN		BIT(7)
+#define AR934X_GPIO_FUNC_CLK_OBS4_EN		BIT(6)
+#define AR934X_GPIO_FUNC_CLK_OBS3_EN		BIT(5)
+#define AR934X_GPIO_FUNC_CLK_OBS2_EN		BIT(4)
+#define AR934X_GPIO_FUNC_CLK_OBS1_EN		BIT(3)
+#define AR934X_GPIO_FUNC_CLK_OBS0_EN		BIT(2)
+#define AR934X_GPIO_FUNC_JTAG_DISABLE		BIT(1)
+
+#define AR934X_GPIO_OUT_GPIO		0
+#define AR934X_GPIO_OUT_SPI_CS1	7
+#define AR934X_GPIO_OUT_LED_LINK0	41
+#define AR934X_GPIO_OUT_LED_LINK1	42
+#define AR934X_GPIO_OUT_LED_LINK2	43
+#define AR934X_GPIO_OUT_LED_LINK3	44
+#define AR934X_GPIO_OUT_LED_LINK4	45
+#define AR934X_GPIO_OUT_EXT_LNA0	46
+#define AR934X_GPIO_OUT_EXT_LNA1	47
+
+#define QCA955X_GPIO_OUT_GPIO		0
+
+/*
+ * MII_CTRL block
+ */
+#define AR71XX_MII_REG_MII0_CTRL	0x00
+#define AR71XX_MII_REG_MII1_CTRL	0x04
+
+#define AR71XX_MII_CTRL_IF_MASK		3
+#define AR71XX_MII_CTRL_SPEED_SHIFT	4
+#define AR71XX_MII_CTRL_SPEED_MASK	3
+#define AR71XX_MII_CTRL_SPEED_10	0
+#define AR71XX_MII_CTRL_SPEED_100	1
+#define AR71XX_MII_CTRL_SPEED_1000	2
+
+#define AR71XX_MII0_CTRL_IF_GMII	0
+#define AR71XX_MII0_CTRL_IF_MII		1
+#define AR71XX_MII0_CTRL_IF_RGMII	2
+#define AR71XX_MII0_CTRL_IF_RMII	3
+
+#define AR71XX_MII1_CTRL_IF_RGMII	0
+#define AR71XX_MII1_CTRL_IF_RMII	1
+
+/*
+ * AR933X GMAC interface
+ */
+#define AR933X_GMAC_REG_ETH_CFG		0x00
+
+#define AR933X_ETH_CFG_RGMII_GE0	BIT(0)
+#define AR933X_ETH_CFG_MII_GE0		BIT(1)
+#define AR933X_ETH_CFG_GMII_GE0		BIT(2)
+#define AR933X_ETH_CFG_MII_GE0_MASTER	BIT(3)
+#define AR933X_ETH_CFG_MII_GE0_SLAVE	BIT(4)
+#define AR933X_ETH_CFG_MII_GE0_ERR_EN	BIT(5)
+#define AR933X_ETH_CFG_SW_PHY_SWAP	BIT(7)
+#define AR933X_ETH_CFG_SW_PHY_ADDR_SWAP	BIT(8)
+#define AR933X_ETH_CFG_RMII_GE0		BIT(9)
+#define AR933X_ETH_CFG_RMII_GE0_SPD_10	0
+#define AR933X_ETH_CFG_RMII_GE0_SPD_100	BIT(10)
+
+/*
+ * AR934X GMAC Interface
+ */
+#define AR934X_GMAC_REG_ETH_CFG		0x00
+
+#define AR934X_ETH_CFG_RGMII_GMAC0	BIT(0)
+#define AR934X_ETH_CFG_MII_GMAC0	BIT(1)
+#define AR934X_ETH_CFG_GMII_GMAC0	BIT(2)
+#define AR934X_ETH_CFG_MII_GMAC0_MASTER	BIT(3)
+#define AR934X_ETH_CFG_MII_GMAC0_SLAVE	BIT(4)
+#define AR934X_ETH_CFG_MII_GMAC0_ERR_EN	BIT(5)
+#define AR934X_ETH_CFG_SW_ONLY_MODE	BIT(6)
+#define AR934X_ETH_CFG_SW_PHY_SWAP	BIT(7)
+#define AR934X_ETH_CFG_SW_APB_ACCESS	BIT(9)
+#define AR934X_ETH_CFG_RMII_GMAC0	BIT(10)
+#define AR933X_ETH_CFG_MII_CNTL_SPEED	BIT(11)
+#define AR934X_ETH_CFG_RMII_GMAC0_MASTER BIT(12)
+#define AR933X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
+#define AR934X_ETH_CFG_RXD_DELAY        BIT(14)
+#define AR934X_ETH_CFG_RXD_DELAY_MASK   0x3
+#define AR934X_ETH_CFG_RXD_DELAY_SHIFT  14
+#define AR934X_ETH_CFG_RDV_DELAY        BIT(16)
+#define AR934X_ETH_CFG_RDV_DELAY_MASK   0x3
+#define AR934X_ETH_CFG_RDV_DELAY_SHIFT  16
+
+/*
+ * QCA953X GMAC Interface
+ */
+#define QCA953X_GMAC_REG_ETH_CFG		0x00
+
+#define QCA953X_ETH_CFG_SW_ONLY_MODE		BIT(6)
+#define QCA953X_ETH_CFG_SW_PHY_SWAP		BIT(7)
+#define QCA953X_ETH_CFG_SW_APB_ACCESS		BIT(9)
+#define QCA953X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
+
+/*
+ * QCA955X GMAC Interface
+ */
+
+#define QCA955X_GMAC_REG_ETH_CFG	0x00
+
+#define QCA955X_ETH_CFG_RGMII_EN	BIT(0)
+#define QCA955X_ETH_CFG_GE0_SGMII	BIT(6)
+
 #endif /* __ASM_MACH_AR71XX_REGS_H */
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/ath79.h linux-4.1.13/arch/mips/include/asm/mach-ath79/ath79.h
--- linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/ath79.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mach-ath79/ath79.h	2015-12-04 19:57:04.482071652 +0100
@@ -32,8 +32,11 @@
 	ATH79_SOC_AR9341,
 	ATH79_SOC_AR9342,
 	ATH79_SOC_AR9344,
+	ATH79_SOC_QCA9533,
 	ATH79_SOC_QCA9556,
 	ATH79_SOC_QCA9558,
+	ATH79_SOC_TP9343,
+	ATH79_SOC_QCA9561,
 };
 
 extern enum ath79_soc_type ath79_soc;
@@ -100,6 +103,16 @@
 	return soc_is_ar9341() || soc_is_ar9342() || soc_is_ar9344();
 }
 
+static inline int soc_is_qca9533(void)
+{
+	return ath79_soc == ATH79_SOC_QCA9533;
+}
+
+static inline int soc_is_qca953x(void)
+{
+	return soc_is_qca9533();
+}
+
 static inline int soc_is_qca9556(void)
 {
 	return ath79_soc == ATH79_SOC_QCA9556;
@@ -115,7 +128,23 @@
 	return soc_is_qca9556() || soc_is_qca9558();
 }
 
+static inline int soc_is_tp9343(void)
+{
+	return ath79_soc == ATH79_SOC_TP9343;
+}
+ 
+static inline int soc_is_qca9561(void)
+{
+	return ath79_soc == ATH79_SOC_QCA9561;
+}
+
+static inline int soc_is_qca956x(void)
+{
+	return soc_is_tp9343() || soc_is_qca9561();
+}
+
 extern void __iomem *ath79_ddr_base;
+extern void __iomem *ath79_gpio_base;
 extern void __iomem *ath79_pll_base;
 extern void __iomem *ath79_reset_base;
 
@@ -132,6 +161,7 @@
 static inline void ath79_reset_wr(unsigned reg, u32 val)
 {
 	__raw_writel(val, ath79_reset_base + reg);
+	(void) __raw_readl(ath79_reset_base + reg); /* flush */
 }
 
 static inline u32 ath79_reset_rr(unsigned reg)
@@ -141,5 +171,9 @@
 
 void ath79_device_reset_set(u32 mask);
 void ath79_device_reset_clear(u32 mask);
+u32 ath79_device_reset_get(u32 mask);
+
+void ath79_flash_acquire(void);
+void ath79_flash_release(void);
 
 #endif /* __ASM_MACH_ATH79_H */
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/ath79_spi_platform.h linux-4.1.13/arch/mips/include/asm/mach-ath79/ath79_spi_platform.h
--- linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/ath79_spi_platform.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mach-ath79/ath79_spi_platform.h	2015-12-04 19:57:03.962105671 +0100
@@ -16,8 +16,15 @@
 	unsigned	num_chipselect;
 };
 
+enum ath79_spi_cs_type {
+	ATH79_SPI_CS_TYPE_INTERNAL,
+	ATH79_SPI_CS_TYPE_GPIO,
+};
+
 struct ath79_spi_controller_data {
-	unsigned	gpio;
+	enum ath79_spi_cs_type cs_type;
+	unsigned cs_line;
+	bool is_flash;
 };
 
 #endif /* _ATH79_SPI_PLATFORM_H */
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/cpu-feature-overrides.h linux-4.1.13/arch/mips/include/asm/mach-ath79/cpu-feature-overrides.h
--- linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/cpu-feature-overrides.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mach-ath79/cpu-feature-overrides.h	2015-12-04 19:57:03.826114569 +0100
@@ -36,6 +36,7 @@
 #define cpu_has_mdmx		0
 #define cpu_has_mips3d		0
 #define cpu_has_smartmips	0
+#define cpu_has_rixi		0
 
 #define cpu_has_mips32r1	1
 #define cpu_has_mips32r2	1
@@ -43,6 +44,7 @@
 #define cpu_has_mips64r2	0
 
 #define cpu_has_mipsmt		0
+#define cpu_has_userlocal	0
 
 #define cpu_has_64bits		0
 #define cpu_has_64bit_zero_reg	0
@@ -51,5 +53,9 @@
 
 #define cpu_dcache_line_size()	32
 #define cpu_icache_line_size()	32
+#define cpu_has_vtag_icache	0
+#define cpu_has_dc_aliases	1
+#define cpu_has_ic_fills_f_dc	0
+#define cpu_has_pindexed_dcache	0
 
 #endif /* __ASM_MACH_ATH79_CPU_FEATURE_OVERRIDES_H */
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/irq.h linux-4.1.13/arch/mips/include/asm/mach-ath79/irq.h
--- linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/irq.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mach-ath79/irq.h	2015-12-04 19:57:05.370013557 +0100
@@ -10,7 +10,7 @@
 #define __ASM_MACH_ATH79_IRQ_H
 
 #define MIPS_CPU_IRQ_BASE	0
-#define NR_IRQS			51
+#define NR_IRQS			83
 
 #define ATH79_CPU_IRQ(_x)	(MIPS_CPU_IRQ_BASE + (_x))
 
@@ -30,6 +30,10 @@
 #define ATH79_IP3_IRQ_COUNT     3
 #define ATH79_IP3_IRQ(_x)       (ATH79_IP3_IRQ_BASE + (_x))
 
+#define ATH79_GPIO_IRQ_BASE	(ATH79_IP3_IRQ_BASE + ATH79_IP3_IRQ_COUNT)
+#define ATH79_GPIO_IRQ_COUNT	32
+#define ATH79_GPIO_IRQ(_x)	(ATH79_GPIO_IRQ_BASE + (_x))
+
 #include_next <irq.h>
 
 #endif /* __ASM_MACH_ATH79_IRQ_H */
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/mach-rb750.h linux-4.1.13/arch/mips/include/asm/mach-ath79/mach-rb750.h
--- linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/mach-rb750.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mach-ath79/mach-rb750.h	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,84 @@
+/*
+ *  MikroTik RouterBOARD 750 definitions
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+#ifndef _MACH_RB750_H
+#define _MACH_RB750_H
+
+#include <linux/bitops.h>
+
+#define RB750_GPIO_LVC573_LE	0	/* Latch enable on LVC573 */
+#define RB750_GPIO_NAND_IO0	1	/* NAND I/O 0 */
+#define RB750_GPIO_NAND_IO1	2	/* NAND I/O 1 */
+#define RB750_GPIO_NAND_IO2	3	/* NAND I/O 2 */
+#define RB750_GPIO_NAND_IO3	4	/* NAND I/O 3 */
+#define RB750_GPIO_NAND_IO4	5	/* NAND I/O 4 */
+#define RB750_GPIO_NAND_IO5	6	/* NAND I/O 5 */
+#define RB750_GPIO_NAND_IO6	7	/* NAND I/O 6 */
+#define RB750_GPIO_NAND_IO7	8	/* NAND I/O 7 */
+#define RB750_GPIO_NAND_NCE	11	/* NAND Chip Enable (active low) */
+#define RB750_GPIO_NAND_RDY	12	/* NAND Ready */
+#define RB750_GPIO_NAND_CLE	14	/* NAND Command Latch Enable */
+#define RB750_GPIO_NAND_ALE	15	/* NAND Address Latch Enable */
+#define RB750_GPIO_NAND_NRE	16	/* NAND Read Enable (active low) */
+#define RB750_GPIO_NAND_NWE	17	/* NAND Write Enable (active low) */
+
+#define RB750_GPIO_BTN_RESET	1
+#define RB750_GPIO_SPI_CS0	2
+#define RB750_GPIO_LED_ACT	12
+#define RB750_GPIO_LED_PORT1	13
+#define RB750_GPIO_LED_PORT2	14
+#define RB750_GPIO_LED_PORT3	15
+#define RB750_GPIO_LED_PORT4	16
+#define RB750_GPIO_LED_PORT5	17
+
+#define RB750_LED_ACT		BIT(RB750_GPIO_LED_ACT)
+#define RB750_LED_PORT1		BIT(RB750_GPIO_LED_PORT1)
+#define RB750_LED_PORT2		BIT(RB750_GPIO_LED_PORT2)
+#define RB750_LED_PORT3		BIT(RB750_GPIO_LED_PORT3)
+#define RB750_LED_PORT4		BIT(RB750_GPIO_LED_PORT4)
+#define RB750_LED_PORT5		BIT(RB750_GPIO_LED_PORT5)
+#define RB750_NAND_NCE		BIT(RB750_GPIO_NAND_NCE)
+
+#define RB750_LVC573_LE		BIT(RB750_GPIO_LVC573_LE)
+
+#define RB750_LED_BITS	(RB750_LED_PORT1 | RB750_LED_PORT2 | RB750_LED_PORT3 | \
+			 RB750_LED_PORT4 | RB750_LED_PORT5 | RB750_LED_ACT)
+
+#define RB7XX_GPIO_NAND_NCE	0
+#define RB7XX_GPIO_MON		9
+#define RB7XX_GPIO_LED_ACT	11
+#define RB7XX_GPIO_USB_POWERON	13
+
+#define RB7XX_NAND_NCE		BIT(RB7XX_GPIO_NAND_NCE)
+#define RB7XX_LED_ACT		BIT(RB7XX_GPIO_LED_ACT)
+#define RB7XX_MONITOR		BIT(RB7XX_GPIO_MON)
+#define RB7XX_USB_POWERON	BIT(RB7XX_GPIO_USB_POWERON)
+
+struct rb750_led_data {
+	char	*name;
+	char	*default_trigger;
+	u32	mask;
+	int	active_low;
+};
+
+struct rb750_led_platform_data {
+	int			num_leds;
+	struct rb750_led_data	*leds;
+	void			(*latch_change)(u32 clear, u32 set);
+};
+
+struct rb7xx_nand_platform_data {
+	u32 nce_line;
+
+	void (*enable_pins)(void);
+	void (*disable_pins)(void);
+	void (*latch_change)(u32, u32);
+};
+
+#endif /* _MACH_RB750_H */
\ No newline at end of file
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/mangle-port.h linux-4.1.13/arch/mips/include/asm/mach-ath79/mangle-port.h
--- linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/mangle-port.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mach-ath79/mangle-port.h	2015-12-04 19:57:03.970105148 +0100
@@ -0,0 +1,37 @@
+/*
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file was derived from: inlude/asm-mips/mach-generic/mangle-port.h
+ *      Copyright (C) 2003, 2004 Ralf Baechle
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_ATH79_MANGLE_PORT_H
+#define __ASM_MACH_ATH79_MANGLE_PORT_H
+
+#ifdef CONFIG_PCI
+extern unsigned long (ath79_pci_swizzle_b)(unsigned long port);
+extern unsigned long (ath79_pci_swizzle_w)(unsigned long port);
+#else
+#define ath79_pci_swizzle_b(port) (port)
+#define ath79_pci_swizzle_w(port) (port)
+#endif
+
+#define __swizzle_addr_b(port)	ath79_pci_swizzle_b(port)
+#define __swizzle_addr_w(port)	ath79_pci_swizzle_w(port)
+#define __swizzle_addr_l(port)	(port)
+#define __swizzle_addr_q(port)	(port)
+
+# define ioswabb(a, x)           (x)
+# define __mem_ioswabb(a, x)     (x)
+# define ioswabw(a, x)           (x)
+# define __mem_ioswabw(a, x)     cpu_to_le16(x)
+# define ioswabl(a, x)           (x)
+# define __mem_ioswabl(a, x)     cpu_to_le32(x)
+# define ioswabq(a, x)           (x)
+# define __mem_ioswabq(a, x)     cpu_to_le64(x)
+
+#endif /* __ASM_MACH_ATH79_MANGLE_PORT_H */
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h linux-4.1.13/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h
--- linux-4.1.13.orig/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mach-ath79/rb4xx_cpld.h	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,48 @@
+/*
+ * SPI driver definitions for the CPLD chip on the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#define CPLD_GPIO_nLED1		0
+#define CPLD_GPIO_nLED2		1
+#define CPLD_GPIO_nLED3		2
+#define CPLD_GPIO_nLED4		3
+#define CPLD_GPIO_FAN		4
+#define CPLD_GPIO_ALE		5
+#define CPLD_GPIO_CLE		6
+#define CPLD_GPIO_nCE		7
+#define CPLD_GPIO_nLED5		8
+
+#define CPLD_NUM_GPIOS		9
+
+#define CPLD_CFG_nLED1		BIT(CPLD_GPIO_nLED1)
+#define CPLD_CFG_nLED2		BIT(CPLD_GPIO_nLED2)
+#define CPLD_CFG_nLED3		BIT(CPLD_GPIO_nLED3)
+#define CPLD_CFG_nLED4		BIT(CPLD_GPIO_nLED4)
+#define CPLD_CFG_FAN		BIT(CPLD_GPIO_FAN)
+#define CPLD_CFG_ALE		BIT(CPLD_GPIO_ALE)
+#define CPLD_CFG_CLE		BIT(CPLD_GPIO_CLE)
+#define CPLD_CFG_nCE		BIT(CPLD_GPIO_nCE)
+#define CPLD_CFG_nLED5		BIT(CPLD_GPIO_nLED5)
+
+struct rb4xx_cpld_platform_data {
+	unsigned	gpio_base;
+};
+
+extern int rb4xx_cpld_change_cfg(unsigned mask, unsigned value);
+extern int rb4xx_cpld_read(unsigned char *rx_buf,
+			   const unsigned char *verify_buf,
+			   unsigned cnt);
+extern int rb4xx_cpld_read_from(unsigned addr,
+				unsigned char *rx_buf,
+				const unsigned char *verify_buf,
+				unsigned cnt);
+extern int rb4xx_cpld_write(const unsigned char *buf, unsigned count);
diff -Nur linux-4.1.13.orig/arch/mips/include/asm/mips_machine.h linux-4.1.13/arch/mips/include/asm/mips_machine.h
--- linux-4.1.13.orig/arch/mips/include/asm/mips_machine.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/include/asm/mips_machine.h	2015-12-04 19:57:03.826114569 +0100
@@ -36,6 +36,18 @@
 	.mach_setup	= _setup,				\
 };
 
+#define MIPS_MACHINE_NONAME(_type, _id, _setup)		\
+static const char machine_id_##_type[] __initconst		\
+			__aligned(1) = _id;			\
+static struct mips_machine machine_##_type			\
+		__used __section(.mips.machines.init) =		\
+{								\
+	.mach_type	= _type,				\
+	.mach_id	= machine_id_##_type,			\
+	.mach_name	= NULL,					\
+	.mach_setup	= _setup,				\
+};
+
 extern long __mips_machines_start;
 extern long __mips_machines_end;
 
diff -Nur linux-4.1.13.orig/arch/mips/Kconfig linux-4.1.13/arch/mips/Kconfig
--- linux-4.1.13.orig/arch/mips/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/Kconfig	2015-12-04 19:57:03.986104101 +0100
@@ -1070,6 +1070,9 @@
 config MIPS_NILE4
 	bool
 
+config MYLOADER
+	bool
+
 config SYNC_R4K
 	bool
 
diff -Nur linux-4.1.13.orig/arch/mips/Makefile linux-4.1.13/arch/mips/Makefile
--- linux-4.1.13.orig/arch/mips/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/arch/mips/Makefile	2015-12-04 19:57:03.982104363 +0100
@@ -216,6 +216,7 @@
 #
 libs-$(CONFIG_FW_ARC)		+= arch/mips/fw/arc/
 libs-$(CONFIG_FW_CFE)		+= arch/mips/fw/cfe/
+libs-$(CONFIG_MYLOADER)		+= arch/mips/fw/myloader/
 libs-$(CONFIG_FW_SNIPROM)	+= arch/mips/fw/sni/
 libs-y				+= arch/mips/fw/lib/
 
diff -Nur linux-4.1.13.orig/drivers/gpio/gpio-74x164.c linux-4.1.13/drivers/gpio/gpio-74x164.c
--- linux-4.1.13.orig/drivers/gpio/gpio-74x164.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/gpio/gpio-74x164.c	2015-12-04 19:57:03.930107765 +0100
@@ -12,6 +12,7 @@
 #include <linux/init.h>
 #include <linux/mutex.h>
 #include <linux/spi/spi.h>
+#include <linux/spi/74x164.h>
 #include <linux/gpio.h>
 #include <linux/of_gpio.h>
 #include <linux/slab.h>
@@ -107,8 +108,18 @@
 static int gen_74x164_probe(struct spi_device *spi)
 {
 	struct gen_74x164_chip *chip;
+	struct gen_74x164_chip_platform_data *pdata;
+	struct device_node *np;
 	int ret;
 
+	pdata = spi->dev.platform_data;
+	np = spi->dev.of_node;
+
+	if (!np && !pdata) {
+		dev_err(&spi->dev, "No configuration data available.\n");
+		return -EINVAL;
+	}
+
 	/*
 	 * bits_per_word cannot be configured in platform data
 	 */
@@ -130,18 +141,28 @@
 	chip->gpio_chip.set = gen_74x164_set_value;
 	chip->gpio_chip.base = -1;
 
-	if (of_property_read_u32(spi->dev.of_node, "registers-number",
-				 &chip->registers)) {
-		dev_err(&spi->dev,
-			"Missing registers-number property in the DT.\n");
-		return -EINVAL;
+	if (np) {
+		if (of_property_read_u32(spi->dev.of_node, "registers-number", &chip->registers)) {
+			dev_err(&spi->dev, "Missing registers-number property in the DT.\n");
+			ret = -EINVAL;
+			goto exit_destroy;
+		}
+	} else if (pdata) {
+		chip->gpio_chip.base = pdata->base;
+		chip->registers = pdata->num_registers;
 	}
 
+	if (!chip->registers)
+		chip->registers = 1;
+
 	chip->gpio_chip.ngpio = GEN_74X164_NUMBER_GPIOS * chip->registers;
 	chip->buffer = devm_kzalloc(&spi->dev, chip->registers, GFP_KERNEL);
 	if (!chip->buffer)
 		return -ENOMEM;
 
+	if (pdata && pdata->init_data)
+		memcpy(chip->buffer, pdata->init_data, chip->registers);
+
 	chip->gpio_chip.can_sleep = true;
 	chip->gpio_chip.dev = &spi->dev;
 	chip->gpio_chip.owner = THIS_MODULE;
@@ -174,17 +195,19 @@
 	return 0;
 }
 
+#ifdef CONFIG_OF
 static const struct of_device_id gen_74x164_dt_ids[] = {
 	{ .compatible = "fairchild,74hc595" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, gen_74x164_dt_ids);
+#endif /* CONFIG_OF */
 
 static struct spi_driver gen_74x164_driver = {
 	.driver = {
 		.name		= "74x164",
 		.owner		= THIS_MODULE,
-		.of_match_table	= gen_74x164_dt_ids,
+		.of_match_table	= of_match_ptr(gen_74x164_dt_ids),
 	},
 	.probe		= gen_74x164_probe,
 	.remove		= gen_74x164_remove,
diff -Nur linux-4.1.13.orig/drivers/gpio/gpio-latch.c linux-4.1.13/drivers/gpio/gpio-latch.c
--- linux-4.1.13.orig/drivers/gpio/gpio-latch.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/gpio/gpio-latch.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,220 @@
+/*
+ *  GPIO latch driver
+ *
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#include <linux/platform_data/gpio-latch.h>
+
+struct gpio_latch_chip {
+	struct gpio_chip gc;
+
+	struct mutex mutex;
+	struct mutex latch_mutex;
+	bool latch_enabled;
+	int le_gpio;
+	bool le_active_low;
+	int *gpios;
+};
+
+static inline struct gpio_latch_chip *to_gpio_latch_chip(struct gpio_chip *gc)
+{
+	return container_of(gc, struct gpio_latch_chip, gc);
+}
+
+static void gpio_latch_lock(struct gpio_latch_chip *glc, bool enable)
+{
+	mutex_lock(&glc->mutex);
+
+	if (enable)
+		glc->latch_enabled = true;
+
+	if (glc->latch_enabled)
+		mutex_lock(&glc->latch_mutex);
+}
+
+static void gpio_latch_unlock(struct gpio_latch_chip *glc, bool disable)
+{
+	if (glc->latch_enabled)
+		mutex_unlock(&glc->latch_mutex);
+
+	if (disable)
+		glc->latch_enabled = true;
+
+	mutex_unlock(&glc->mutex);
+}
+
+static int
+gpio_latch_get(struct gpio_chip *gc, unsigned offset)
+{
+	struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
+	int ret;
+
+	gpio_latch_lock(glc, false);
+	ret = gpio_get_value(glc->gpios[offset]);
+	gpio_latch_unlock(glc, false);
+
+	return ret;
+}
+
+static void
+gpio_latch_set(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
+	bool enable_latch = false;
+	bool disable_latch = false;
+	int gpio;
+
+	gpio = glc->gpios[offset];
+
+	if (gpio == glc->le_gpio) {
+		enable_latch = value ^ glc->le_active_low;
+		disable_latch = !enable_latch;
+	}
+
+	gpio_latch_lock(glc, enable_latch);
+	gpio_set_value(gpio, value);
+	gpio_latch_unlock(glc, disable_latch);
+}
+
+static int
+gpio_latch_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
+	int ret;
+
+	gpio_latch_lock(glc, false);
+	ret = gpio_direction_input(glc->gpios[offset]);
+	gpio_latch_unlock(glc, false);
+
+	return ret;
+}
+
+static int
+gpio_latch_direction_output(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct gpio_latch_chip *glc = to_gpio_latch_chip(gc);
+	bool enable_latch = false;
+	bool disable_latch = false;
+	int gpio;
+	int ret;
+
+	gpio = glc->gpios[offset];
+
+	if (gpio == glc->le_gpio) {
+		enable_latch = value ^ glc->le_active_low;
+		disable_latch = !enable_latch;
+	}
+
+	gpio_latch_lock(glc, enable_latch);
+	ret = gpio_direction_output(gpio, value);
+	gpio_latch_unlock(glc, disable_latch);
+
+	return ret;
+}
+
+static int gpio_latch_probe(struct platform_device *pdev)
+{
+	struct gpio_latch_chip *glc;
+	struct gpio_latch_platform_data *pdata;
+	struct gpio_chip *gc;
+	int size;
+	int ret;
+	int i;
+
+	pdata = dev_get_platdata(&pdev->dev);
+	if (!pdata)
+		return -EINVAL;
+
+	if (pdata->le_gpio_index >= pdata->num_gpios ||
+	    !pdata->num_gpios ||
+	    !pdata->gpios)
+		return -EINVAL;
+
+	for (i = 0; i < pdata->num_gpios; i++) {
+		int gpio = pdata->gpios[i];
+
+		ret = devm_gpio_request(&pdev->dev, gpio,
+					GPIO_LATCH_DRIVER_NAME);
+		if (ret)
+			return ret;
+	}
+
+	glc = devm_kzalloc(&pdev->dev, sizeof(*glc), GFP_KERNEL);
+	if (!glc)
+		return -ENOMEM;
+
+	mutex_init(&glc->mutex);
+	mutex_init(&glc->latch_mutex);
+
+	size = pdata->num_gpios * sizeof(glc->gpios[0]);
+	glc->gpios = devm_kzalloc(&pdev->dev, size , GFP_KERNEL);
+	if (!glc->gpios)
+		return -ENOMEM;
+
+	memcpy(glc->gpios, pdata->gpios, size);
+
+	glc->le_gpio = glc->gpios[pdata->le_gpio_index];
+	glc->le_active_low = pdata->le_active_low;
+
+	gc = &glc->gc;
+
+	gc->label = GPIO_LATCH_DRIVER_NAME;
+	gc->base = pdata->base;
+	gc->can_sleep = true;
+	gc->ngpio = pdata->num_gpios;
+	gc->get = gpio_latch_get;
+	gc->set = gpio_latch_set;
+	gc->direction_input = gpio_latch_direction_input,
+	gc->direction_output = gpio_latch_direction_output;
+
+	platform_set_drvdata(pdev, glc);
+
+	ret = gpiochip_add(&glc->gc);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int gpio_latch_remove(struct platform_device *pdev)
+{
+	struct gpio_latch_chip *glc = platform_get_drvdata(pdev);
+
+	gpiochip_remove(&glc->gc);
+	return 0;
+}
+
+
+static struct platform_driver gpio_latch_driver = {
+	.probe = gpio_latch_probe,
+	.remove = gpio_latch_remove,
+	.driver = {
+		.name = GPIO_LATCH_DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init gpio_latch_init(void)
+{
+	return platform_driver_register(&gpio_latch_driver);
+}
+
+postcore_initcall(gpio_latch_init);
+
+MODULE_DESCRIPTION("GPIO latch driver");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" GPIO_LATCH_DRIVER_NAME);
diff -Nur linux-4.1.13.orig/drivers/gpio/gpio-nxp-74hc153.c linux-4.1.13/drivers/gpio/gpio-nxp-74hc153.c
--- linux-4.1.13.orig/drivers/gpio/gpio-nxp-74hc153.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/gpio/gpio-nxp-74hc153.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,251 @@
+/*
+ *  NXP 74HC153 - Dual 4-input multiplexer GPIO driver
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/nxp_74hc153.h>
+
+#define NXP_74HC153_NUM_GPIOS	8
+#define NXP_74HC153_S0_MASK	0x1
+#define NXP_74HC153_S1_MASK	0x2
+#define NXP_74HC153_BANK_MASK	0x4
+
+struct nxp_74hc153_chip {
+	struct device		*parent;
+	struct gpio_chip	gpio_chip;
+	struct mutex		lock;
+};
+
+static struct nxp_74hc153_chip *gpio_to_nxp(struct gpio_chip *gc)
+{
+	return container_of(gc, struct nxp_74hc153_chip, gpio_chip);
+}
+
+static int nxp_74hc153_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	return 0;
+}
+
+static int nxp_74hc153_direction_output(struct gpio_chip *gc,
+					unsigned offset, int val)
+{
+	return -EINVAL;
+}
+
+static int nxp_74hc153_get_value(struct gpio_chip *gc, unsigned offset)
+{
+	struct nxp_74hc153_chip *nxp;
+	struct nxp_74hc153_platform_data *pdata;
+	unsigned s0;
+	unsigned s1;
+	unsigned pin;
+	int ret;
+
+	nxp = gpio_to_nxp(gc);
+	pdata = nxp->parent->platform_data;
+
+	s0 = !!(offset & NXP_74HC153_S0_MASK);
+	s1 = !!(offset & NXP_74HC153_S1_MASK);
+	pin = (offset & NXP_74HC153_BANK_MASK) ? pdata->gpio_pin_2y
+					       : pdata->gpio_pin_1y;
+
+	mutex_lock(&nxp->lock);
+	gpio_set_value(pdata->gpio_pin_s0, s0);
+	gpio_set_value(pdata->gpio_pin_s1, s1);
+	ret = gpio_get_value(pin);
+	mutex_unlock(&nxp->lock);
+
+	return ret;
+}
+
+static void nxp_74hc153_set_value(struct gpio_chip *gc,
+				  unsigned offset, int val)
+{
+	/* not supported */
+}
+
+static int nxp_74hc153_probe(struct platform_device *pdev)
+{
+	struct nxp_74hc153_platform_data *pdata;
+	struct nxp_74hc153_chip *nxp;
+	struct gpio_chip *gc;
+	int err;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) {
+		dev_dbg(&pdev->dev, "no platform data specified\n");
+		return -EINVAL;
+	}
+
+	nxp = kzalloc(sizeof(struct nxp_74hc153_chip), GFP_KERNEL);
+	if (nxp == NULL) {
+		dev_err(&pdev->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	err = gpio_request(pdata->gpio_pin_s0, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_s0, err);
+		goto err_free_nxp;
+	}
+
+	err = gpio_request(pdata->gpio_pin_s1, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_s1, err);
+		goto err_free_s0;
+	}
+
+	err = gpio_request(pdata->gpio_pin_1y, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_1y, err);
+		goto err_free_s1;
+	}
+
+	err = gpio_request(pdata->gpio_pin_2y, dev_name(&pdev->dev));
+	if (err) {
+		dev_err(&pdev->dev, "unable to claim gpio %u, err=%d\n",
+			pdata->gpio_pin_2y, err);
+		goto err_free_1y;
+	}
+
+	err = gpio_direction_output(pdata->gpio_pin_s0, 0);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_s0, err);
+		goto err_free_2y;
+	}
+
+	err = gpio_direction_output(pdata->gpio_pin_s1, 0);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_s1, err);
+		goto err_free_2y;
+	}
+
+	err = gpio_direction_input(pdata->gpio_pin_1y);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_1y, err);
+		goto err_free_2y;
+	}
+
+	err = gpio_direction_input(pdata->gpio_pin_2y);
+	if (err) {
+		dev_err(&pdev->dev,
+			"unable to set direction of gpio %u, err=%d\n",
+			pdata->gpio_pin_2y, err);
+		goto err_free_2y;
+	}
+
+	nxp->parent = &pdev->dev;
+	mutex_init(&nxp->lock);
+
+	gc = &nxp->gpio_chip;
+
+	gc->direction_input  = nxp_74hc153_direction_input;
+	gc->direction_output = nxp_74hc153_direction_output;
+	gc->get = nxp_74hc153_get_value;
+	gc->set = nxp_74hc153_set_value;
+	gc->can_sleep = 1;
+
+	gc->base = pdata->gpio_base;
+	gc->ngpio = NXP_74HC153_NUM_GPIOS;
+	gc->label = dev_name(nxp->parent);
+	gc->dev = nxp->parent;
+	gc->owner = THIS_MODULE;
+
+	err = gpiochip_add(&nxp->gpio_chip);
+	if (err) {
+		dev_err(&pdev->dev, "unable to add gpio chip, err=%d\n", err);
+		goto err_free_2y;
+	}
+
+	platform_set_drvdata(pdev, nxp);
+	return 0;
+
+err_free_2y:
+	gpio_free(pdata->gpio_pin_2y);
+err_free_1y:
+	gpio_free(pdata->gpio_pin_1y);
+err_free_s1:
+	gpio_free(pdata->gpio_pin_s1);
+err_free_s0:
+	gpio_free(pdata->gpio_pin_s0);
+err_free_nxp:
+	kfree(nxp);
+	return err;
+}
+
+static int nxp_74hc153_remove(struct platform_device *pdev)
+{
+	struct nxp_74hc153_chip *nxp = platform_get_drvdata(pdev);
+	struct nxp_74hc153_platform_data *pdata = pdev->dev.platform_data;
+
+	if (nxp) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+		int err;
+
+		err = gpiochip_remove(&nxp->gpio_chip);
+		if (err) {
+			dev_err(&pdev->dev,
+				"unable to remove gpio chip, err=%d\n",
+				err);
+			return err;
+		}
+#else
+		gpiochip_remove(&nxp->gpio_chip);
+#endif
+		gpio_free(pdata->gpio_pin_2y);
+		gpio_free(pdata->gpio_pin_1y);
+		gpio_free(pdata->gpio_pin_s1);
+		gpio_free(pdata->gpio_pin_s0);
+
+		kfree(nxp);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver nxp_74hc153_driver = {
+	.probe		= nxp_74hc153_probe,
+	.remove		= nxp_74hc153_remove,
+	.driver = {
+		.name	= NXP_74HC153_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init nxp_74hc153_init(void)
+{
+	return platform_driver_register(&nxp_74hc153_driver);
+}
+subsys_initcall(nxp_74hc153_init);
+
+static void __exit nxp_74hc153_exit(void)
+{
+	platform_driver_unregister(&nxp_74hc153_driver);
+}
+module_exit(nxp_74hc153_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("GPIO expander driver for NXP 74HC153");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" NXP_74HC153_DRIVER_NAME);
diff -Nur linux-4.1.13.orig/drivers/gpio/Kconfig linux-4.1.13/drivers/gpio/Kconfig
--- linux-4.1.13.orig/drivers/gpio/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/gpio/Kconfig	2015-12-04 19:57:03.934107503 +0100
@@ -941,7 +941,7 @@
 
 config GPIO_74X164
 	tristate "74x164 serial-in/parallel-out 8-bits shift register"
-	depends on SPI_MASTER && OF
+	depends on SPI_MASTER
 	help
 	  Driver for 74x164 compatible serial-in/parallel-out 8-outputs
 	  shift registers. This driver can be used to provide access
@@ -988,4 +988,17 @@
 
 endmenu
 
+comment "Other GPIO expanders"
+
+config GPIO_NXP_74HC153
+	tristate "NXP 74HC153 Dual 4-input multiplexer"
+	help
+	  Platform driver for NXP 74HC153 Dual 4-input Multiplexer. This
+	  provides a GPIO interface supporting input mode only.
+
+config GPIO_LATCH
+	tristate "GPIO latch driver"
+	help
+	  Say yes here to enable a GPIO latch driver.
+
 endif
diff -Nur linux-4.1.13.orig/drivers/gpio/Makefile linux-4.1.13/drivers/gpio/Makefile
--- linux-4.1.13.orig/drivers/gpio/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/gpio/Makefile	2015-12-04 19:57:03.934107503 +0100
@@ -42,6 +42,7 @@
 obj-$(CONFIG_GPIO_KEMPLD)	+= gpio-kempld.o
 obj-$(CONFIG_ARCH_KS8695)	+= gpio-ks8695.o
 obj-$(CONFIG_GPIO_INTEL_MID)	+= gpio-intel-mid.o
+obj-$(CONFIG_GPIO_LATCH)	+= gpio-latch.o
 obj-$(CONFIG_GPIO_LOONGSON)	+= gpio-loongson.o
 obj-$(CONFIG_GPIO_LP3943)	+= gpio-lp3943.o
 obj-$(CONFIG_ARCH_LPC32XX)	+= gpio-lpc32xx.o
@@ -64,6 +65,7 @@
 obj-$(CONFIG_GPIO_MVEBU)        += gpio-mvebu.o
 obj-$(CONFIG_GPIO_MXC)		+= gpio-mxc.o
 obj-$(CONFIG_GPIO_MXS)		+= gpio-mxs.o
+obj-$(CONFIG_GPIO_NXP_74HC153)	+= gpio-nxp-74hc153.o
 obj-$(CONFIG_GPIO_OCTEON)	+= gpio-octeon.o
 obj-$(CONFIG_GPIO_OMAP)		+= gpio-omap.o
 obj-$(CONFIG_GPIO_PCA953X)	+= gpio-pca953x.o
diff -Nur linux-4.1.13.orig/drivers/leds/Kconfig linux-4.1.13/drivers/leds/Kconfig
--- linux-4.1.13.orig/drivers/leds/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/leds/Kconfig	2015-12-04 19:57:03.926108026 +0100
@@ -534,6 +534,17 @@
 	  This option enables support for the 'White' LED block
 	  on Qualcomm PM8941 PMICs.
 
+config LEDS_WNDR3700_USB
+	tristate "NETGEAR WNDR3700 USB LED driver"
+	depends on LEDS_CLASS && ATH79_MACH_WNDR3700
+	help
+	  This option enables support for the USB LED found on the
+	  NETGEAR WNDR3700 board.
+
+config LEDS_RB750
+	tristate "LED driver for the Mikrotik RouterBOARD 750"
+	depends on LEDS_CLASS && ATH79_MACH_RB750
+
 comment "LED Triggers"
 source "drivers/leds/trigger/Kconfig"
 
diff -Nur linux-4.1.13.orig/drivers/leds/leds-rb750.c linux-4.1.13/drivers/leds/leds-rb750.c
--- linux-4.1.13.orig/drivers/leds/leds-rb750.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/leds/leds-rb750.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,144 @@
+/*
+ * LED driver for the RouterBOARD 750
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ath79/mach-rb750.h>
+
+#define DRV_NAME	"leds-rb750"
+
+struct rb750_led_dev {
+	struct led_classdev	cdev;
+	u32			mask;
+	int			active_low;
+	void			(*latch_change)(u32 clear, u32 set);
+};
+
+struct rb750_led_drvdata {
+	struct rb750_led_dev	*led_devs;
+	int			num_leds;
+};
+
+static inline struct rb750_led_dev *to_rbled(struct led_classdev *led_cdev)
+{
+	return (struct rb750_led_dev *)container_of(led_cdev,
+		struct rb750_led_dev, cdev);
+}
+
+static void rb750_led_brightness_set(struct led_classdev *led_cdev,
+				     enum led_brightness value)
+{
+	struct rb750_led_dev *rbled = to_rbled(led_cdev);
+	int level;
+
+	level = (value == LED_OFF) ? 0 : 1;
+	level ^= rbled->active_low;
+
+	if (level)
+		rbled->latch_change(0, rbled->mask);
+	else
+		rbled->latch_change(rbled->mask, 0);
+}
+
+static int rb750_led_probe(struct platform_device *pdev)
+{
+	struct rb750_led_platform_data *pdata;
+	struct rb750_led_drvdata *drvdata;
+	int ret = 0;
+	int i;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata)
+		return -EINVAL;
+
+	drvdata = kzalloc(sizeof(struct rb750_led_drvdata) +
+			  sizeof(struct rb750_led_dev) * pdata->num_leds,
+			  GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+
+	drvdata->num_leds = pdata->num_leds;
+	drvdata->led_devs = (struct rb750_led_dev *) &drvdata[1];
+
+	for (i = 0; i < drvdata->num_leds; i++) {
+		struct rb750_led_dev *rbled = &drvdata->led_devs[i];
+		struct rb750_led_data *led_data = &pdata->leds[i];
+
+		rbled->cdev.name = led_data->name;
+		rbled->cdev.default_trigger = led_data->default_trigger;
+		rbled->cdev.brightness_set = rb750_led_brightness_set;
+		rbled->cdev.brightness = LED_OFF;
+
+		rbled->mask = led_data->mask;
+		rbled->active_low = !!led_data->active_low;
+		rbled->latch_change = pdata->latch_change;
+
+		ret = led_classdev_register(&pdev->dev, &rbled->cdev);
+		if (ret)
+			goto err;
+	}
+
+	platform_set_drvdata(pdev, drvdata);
+	return 0;
+
+err:
+	for (i = i - 1; i >= 0; i--)
+		led_classdev_unregister(&drvdata->led_devs[i].cdev);
+
+	kfree(drvdata);
+	return ret;
+}
+
+static int rb750_led_remove(struct platform_device *pdev)
+{
+	struct rb750_led_drvdata *drvdata;
+	int i;
+
+	drvdata = platform_get_drvdata(pdev);
+	for (i = 0; i < drvdata->num_leds; i++)
+		led_classdev_unregister(&drvdata->led_devs[i].cdev);
+
+	kfree(drvdata);
+	return 0;
+}
+
+static struct platform_driver rb750_led_driver = {
+	.probe		= rb750_led_probe,
+	.remove		= rb750_led_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:leds-rb750");
+
+static int __init rb750_led_init(void)
+{
+	return platform_driver_register(&rb750_led_driver);
+}
+
+static void __exit rb750_led_exit(void)
+{
+	platform_driver_unregister(&rb750_led_driver);
+}
+
+module_init(rb750_led_init);
+module_exit(rb750_led_exit);
+
+MODULE_DESCRIPTION(DRV_NAME);
+MODULE_DESCRIPTION("LED driver for the RouterBOARD 750");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-4.1.13.orig/drivers/leds/leds-wndr3700-usb.c linux-4.1.13/drivers/leds/leds-wndr3700-usb.c
--- linux-4.1.13.orig/drivers/leds/leds-wndr3700-usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/leds/leds-wndr3700-usb.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,76 @@
+/*
+ *  USB LED driver for the NETGEAR WNDR3700
+ *
+ *  Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#define DRIVER_NAME	"wndr3700-led-usb"
+
+static void wndr3700_usb_led_set(struct led_classdev *cdev,
+				 enum led_brightness brightness)
+{
+	if (brightness)
+		ath79_device_reset_clear(AR71XX_RESET_GE1_PHY);
+	else
+		ath79_device_reset_set(AR71XX_RESET_GE1_PHY);
+}
+
+static enum led_brightness wndr3700_usb_led_get(struct led_classdev *cdev)
+{
+	return ath79_device_reset_get(AR71XX_RESET_GE1_PHY) ? LED_OFF : LED_FULL;
+}
+
+static struct led_classdev wndr3700_usb_led = {
+	.name = "netgear:green:usb",
+	.brightness_set = wndr3700_usb_led_set,
+	.brightness_get = wndr3700_usb_led_get,
+};
+
+static int wndr3700_usb_led_probe(struct platform_device *pdev)
+{
+	return led_classdev_register(&pdev->dev, &wndr3700_usb_led);
+}
+
+static int wndr3700_usb_led_remove(struct platform_device *pdev)
+{
+	led_classdev_unregister(&wndr3700_usb_led);
+	return 0;
+}
+
+static struct platform_driver wndr3700_usb_led_driver = {
+	.probe = wndr3700_usb_led_probe,
+	.remove = wndr3700_usb_led_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init wndr3700_usb_led_init(void)
+{
+	return platform_driver_register(&wndr3700_usb_led_driver);
+}
+
+static void __exit wndr3700_usb_led_exit(void)
+{
+	platform_driver_unregister(&wndr3700_usb_led_driver);
+}
+
+module_init(wndr3700_usb_led_init);
+module_exit(wndr3700_usb_led_exit);
+
+MODULE_DESCRIPTION("USB LED driver for the NETGEAR WNDR3700");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Nur linux-4.1.13.orig/drivers/leds/Makefile linux-4.1.13/drivers/leds/Makefile
--- linux-4.1.13.orig/drivers/leds/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/leds/Makefile	2015-12-04 19:57:03.926108026 +0100
@@ -43,12 +43,14 @@
 obj-$(CONFIG_LEDS_WM831X_STATUS)	+= leds-wm831x-status.o
 obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
 obj-$(CONFIG_LEDS_PWM)			+= leds-pwm.o
+obj-${CONFIG_LEDS_WNDR3700_USB}		+= leds-wndr3700-usb.o
 obj-$(CONFIG_LEDS_REGULATOR)		+= leds-regulator.o
 obj-$(CONFIG_LEDS_INTEL_SS4200)		+= leds-ss4200.o
 obj-$(CONFIG_LEDS_LT3593)		+= leds-lt3593.o
 obj-$(CONFIG_LEDS_ADP5520)		+= leds-adp5520.o
 obj-$(CONFIG_LEDS_DELL_NETBOOKS)	+= dell-led.o
 obj-$(CONFIG_LEDS_MC13783)		+= leds-mc13783.o
+obj-$(CONFIG_LEDS_RB750)		+= leds-rb750.o
 obj-$(CONFIG_LEDS_NS2)			+= leds-ns2.o
 obj-$(CONFIG_LEDS_NETXBIG)		+= leds-netxbig.o
 obj-$(CONFIG_LEDS_ASIC3)		+= leds-asic3.o
diff -Nur linux-4.1.13.orig/drivers/Makefile linux-4.1.13/drivers/Makefile
--- linux-4.1.13.orig/drivers/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/Makefile	2015-12-04 19:57:03.890110382 +0100
@@ -71,8 +71,8 @@
 obj-$(CONFIG_SCSI)		+= scsi/
 obj-$(CONFIG_ATA)		+= ata/
 obj-$(CONFIG_TARGET_CORE)	+= target/
-obj-$(CONFIG_MTD)		+= mtd/
 obj-$(CONFIG_SPI)		+= spi/
+obj-$(CONFIG_MTD)		+= mtd/
 obj-$(CONFIG_SPMI)		+= spmi/
 obj-y				+= hsi/
 obj-y				+= net/
diff -Nur linux-4.1.13.orig/drivers/mtd/chips/cfi_cmdset_0002.c linux-4.1.13/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-4.1.13.orig/drivers/mtd/chips/cfi_cmdset_0002.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/mtd/chips/cfi_cmdset_0002.c	2015-12-04 19:57:03.878111167 +0100
@@ -40,7 +40,7 @@
 #include <linux/mtd/xip.h>
 
 #define AMD_BOOTLOC_BUG
-#define FORCE_WORD_WRITE 0
+#define FORCE_WORD_WRITE 1
 
 #define MAX_WORD_RETRIES 3
 
@@ -51,7 +51,9 @@
 
 static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+#if !FORCE_WORD_WRITE
 static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+#endif
 static int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);
 static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
 static void cfi_amdstd_sync (struct mtd_info *);
@@ -202,6 +204,7 @@
 }
 #endif
 
+#if !FORCE_WORD_WRITE
 static void fixup_use_write_buffers(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
@@ -211,6 +214,7 @@
 		mtd->_write = cfi_amdstd_write_buffers;
 	}
 }
+#endif /* !FORCE_WORD_WRITE */
 
 /* Atmel chips don't use the same PRI format as AMD chips */
 static void fixup_convert_atmel_pri(struct mtd_info *mtd)
@@ -1632,8 +1636,8 @@
 			break;
 		}
 
-		if (chip_ready(map, adr))
-			break;
+		if (chip_good(map, adr, datum))
+			goto enable_xip;
 
 		/* Latency issues. Drop the lock, wait a while and retry */
 		UDELAY(map, chip, adr, 1);
@@ -1649,6 +1653,8 @@
 
 		ret = -EIO;
 	}
+
+ enable_xip:
 	xip_enable(map, chip, adr);
  op_done:
 	if (mode == FL_OTP_WRITE)
@@ -1789,6 +1795,7 @@
 /*
  * FIXME: interleaved mode not tested, and probably not supported!
  */
+#if !FORCE_WORD_WRITE
 static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 				    unsigned long adr, const u_char *buf,
 				    int len)
@@ -1916,7 +1923,6 @@
 	return ret;
 }
 
-
 static int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,
 				    size_t *retlen, const u_char *buf)
 {
@@ -1991,6 +1997,7 @@
 
 	return 0;
 }
+#endif /* !FORCE_WORD_WRITE */
 
 /*
  * Wait for the flash chip to become ready to write data
@@ -2226,7 +2233,6 @@
 	return 0;
 }
 
-
 /*
  * Handle devices with one erase region, that only implement
  * the chip erase command.
@@ -2290,8 +2296,8 @@
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr))
-			break;
+		if (chip_good(map, adr, map_word_ff(map)))
+			goto op_done;
 
 		if (time_after(jiffies, timeo)) {
 			printk(KERN_WARNING "MTD %s(): software timeout\n",
@@ -2311,6 +2317,7 @@
 		ret = -EIO;
 	}
 
+ op_done:
 	chip->state = FL_READY;
 	xip_enable(map, chip, adr);
 	DISABLE_VPP(map);
@@ -2379,9 +2386,9 @@
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr)) {
+		if (chip_good(map, adr, map_word_ff(map))) {
 			xip_enable(map, chip, adr);
-			break;
+			goto op_done;
 		}
 
 		if (time_after(jiffies, timeo)) {
@@ -2403,6 +2410,7 @@
 		ret = -EIO;
 	}
 
+ op_done:
 	chip->state = FL_READY;
 	DISABLE_VPP(map);
 	put_chip(map, chip, adr);
diff -Nur linux-4.1.13.orig/drivers/mtd/chips/jedec_probe.c linux-4.1.13/drivers/mtd/chips/jedec_probe.c
--- linux-4.1.13.orig/drivers/mtd/chips/jedec_probe.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/mtd/chips/jedec_probe.c	2015-12-04 19:57:03.834114045 +0100
@@ -148,6 +148,7 @@
 #define SST39LF160	0x2782
 #define SST39VF1601	0x234b
 #define SST39VF3201	0x235b
+#define SST39VF6401B	0x236d
 #define SST39WF1601	0x274b
 #define SST39WF1602	0x274a
 #define SST39LF512	0x00D4
@@ -1569,6 +1570,18 @@
 			ERASEINFO(0x10000,64),
 		}
 	}, {
+		.mfr_id         = CFI_MFR_SST,
+		.dev_id         = SST39VF6401B,
+		.name           = "SST 39VF6401B",
+		.devtypes       = CFI_DEVICETYPE_X16,
+		.uaddr          = MTD_UADDR_0xAAAA_0x5555,
+		.dev_size       = SIZE_8MiB,
+		.cmd_set        = P_ID_AMD_STD,
+		.nr_regions     = 1,
+		.regions        = {
+			ERASEINFO(0x10000,128)
+		}
+	}, {
 		.mfr_id		= CFI_MFR_ST,
 		.dev_id		= M29F800AB,
 		.name		= "ST M29F800AB",
diff -Nur linux-4.1.13.orig/drivers/mtd/cybertan_part.c linux-4.1.13/drivers/mtd/cybertan_part.c
--- linux-4.1.13.orig/drivers/mtd/cybertan_part.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/mtd/cybertan_part.c	2015-09-13 20:04:35.072523889 +0200
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2009 Christian Daniel <cd@maintech.de>
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * TRX flash partition table.
+ * Based on ar7 map by Felix Fietkau <nbd@openwrt.org>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+struct cybertan_header {
+	char	magic[4];
+	u8	res1[4];
+	char	fw_date[3];
+	char	fw_ver[3];
+	char	id[4];
+	char	hw_ver;
+	char	unused;
+	u8	flags[2];
+	u8	res2[10];
+};
+
+#define TRX_PARTS	6
+#define TRX_MAGIC	0x30524448
+#define TRX_MAX_OFFSET	3
+
+struct trx_header {
+	uint32_t magic;           /* "HDR0" */
+	uint32_t len;             /* Length of file including header */
+	uint32_t crc32;           /* 32-bit CRC from flag_version to end of file */
+	uint32_t flag_version;    /* 0:15 flags, 16:31 version */
+	uint32_t offsets[TRX_MAX_OFFSET]; /* Offsets of partitions from start of header */
+};
+
+#define IH_MAGIC	0x27051956	/* Image Magic Number */
+#define IH_NMLEN	32		/* Image Name Length */
+
+struct uimage_header {
+	uint32_t	ih_magic;	/* Image Header Magic Number */
+	uint32_t	ih_hcrc;	/* Image Header CRC Checksum */
+	uint32_t	ih_time;	/* Image Creation Timestamp */
+	uint32_t	ih_size;	/* Image Data Size */
+	uint32_t	ih_load;	/* Data Load  Address */
+	uint32_t	ih_ep;		/* Entry Point Address */
+	uint32_t	ih_dcrc;	/* Image Data CRC Checksum */
+	uint8_t		ih_os;		/* Operating System */
+	uint8_t		ih_arch;	/* CPU architecture */
+	uint8_t		ih_type;	/* Image Type */
+	uint8_t		ih_comp;	/* Compression Type */
+	uint8_t		ih_name[IH_NMLEN];	/* Image Name */
+};
+
+struct firmware_header {
+	struct cybertan_header	cybertan;
+	struct trx_header	trx;
+	struct uimage_header	uimage;
+} __packed;
+
+#define UBOOT_LEN	0x40000
+#define ART_LEN		0x10000
+#define NVRAM_LEN	0x10000
+
+static int cybertan_parse_partitions(struct mtd_info *master,
+				     struct mtd_partition **pparts,
+				     struct mtd_part_parser_data *data)
+{
+	struct firmware_header *header;
+	struct trx_header *theader;
+	struct uimage_header *uheader;
+	struct mtd_partition *trx_parts;
+	size_t retlen;
+	unsigned int kernel_len;
+	unsigned int uboot_len;
+	unsigned int nvram_len;
+	unsigned int art_len;
+	int ret;
+
+	uboot_len = max_t(unsigned int, master->erasesize, UBOOT_LEN);
+	nvram_len = max_t(unsigned int, master->erasesize, NVRAM_LEN);
+	art_len = max_t(unsigned int, master->erasesize, ART_LEN);
+
+	trx_parts = kzalloc(TRX_PARTS * sizeof(struct mtd_partition),
+			    GFP_KERNEL);
+	if (!trx_parts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	header = vmalloc(sizeof(*header));
+	if (!header) {
+		return -ENOMEM;
+		goto free_parts;
+	}
+
+	ret = mtd_read(master, uboot_len, sizeof(*header),
+		       &retlen, (void *) header);
+	if (ret)
+		goto free_hdr;
+
+	if (retlen != sizeof(*header)) {
+		ret = -EIO;
+		goto free_hdr;
+	}
+
+	theader = &header->trx;
+	if (le32_to_cpu(theader->magic) != TRX_MAGIC) {
+		printk(KERN_NOTICE "%s: no TRX header found\n", master->name);
+		goto free_hdr;
+	}
+
+	uheader = &header->uimage;
+	if (uheader->ih_magic != IH_MAGIC) {
+		printk(KERN_NOTICE "%s: no uImage found\n", master->name);
+		goto free_hdr;
+	}
+
+	kernel_len = le32_to_cpu(theader->offsets[1]) +
+		sizeof(struct cybertan_header);
+
+	trx_parts[0].name = "u-boot";
+	trx_parts[0].offset = 0;
+	trx_parts[0].size = uboot_len;
+	trx_parts[0].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[1].name = "kernel";
+	trx_parts[1].offset = trx_parts[0].offset + trx_parts[0].size;
+	trx_parts[1].size = kernel_len;
+	trx_parts[1].mask_flags = 0;
+
+	trx_parts[2].name = "rootfs";
+	trx_parts[2].offset = trx_parts[1].offset + trx_parts[1].size;
+	trx_parts[2].size = master->size - uboot_len - nvram_len - art_len -
+		trx_parts[1].size;
+	trx_parts[2].mask_flags = 0;
+
+	trx_parts[3].name = "nvram";
+	trx_parts[3].offset = master->size - nvram_len - art_len;
+	trx_parts[3].size = nvram_len;
+	trx_parts[3].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[4].name = "art";
+	trx_parts[4].offset = master->size - art_len;
+	trx_parts[4].size = art_len;
+	trx_parts[4].mask_flags = MTD_WRITEABLE;
+
+	trx_parts[5].name = "firmware";
+	trx_parts[5].offset = uboot_len;
+	trx_parts[5].size = master->size - uboot_len - nvram_len - art_len;
+	trx_parts[5].mask_flags = 0;
+
+	vfree(header);
+
+	*pparts = trx_parts;
+	return TRX_PARTS;
+
+free_hdr:
+	vfree(header);
+free_parts:
+	kfree(trx_parts);
+out:
+	return ret;
+}
+
+static struct mtd_part_parser cybertan_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= cybertan_parse_partitions,
+	.name		= "cybertan",
+};
+
+static int __init cybertan_parser_init(void)
+{
+	register_mtd_parser(&cybertan_parser);
+
+	return 0;
+}
+
+module_init(cybertan_parser_init);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Christian Daniel <cd@maintech.de>");
diff -Nur linux-4.1.13.orig/drivers/mtd/devices/m25p80.c linux-4.1.13/drivers/mtd/devices/m25p80.c
--- linux-4.1.13.orig/drivers/mtd/devices/m25p80.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/mtd/devices/m25p80.c	2015-12-04 19:57:03.966105410 +0100
@@ -139,10 +139,15 @@
 	flash->command[0] = nor->read_opcode;
 	m25p_addr2cmd(nor, from, flash->command);
 
+	if (dummy == 1)
+		t[0].dummy = true;
+
+	t[0].type = SPI_TRANSFER_FLASH_READ_CMD;
 	t[0].tx_buf = flash->command;
 	t[0].len = m25p_cmdsz(nor) + dummy;
 	spi_message_add_tail(&t[0], &m);
 
+	t[1].type = SPI_TRANSFER_FLASH_READ_DATA;
 	t[1].rx_buf = buf;
 	t[1].rx_nbits = m25p80_rx_nbits(nor);
 	t[1].len = len;
@@ -232,6 +237,7 @@
 	if (ret)
 		return ret;
 
+	memset(&ppdata, '\0', sizeof(ppdata));
 	ppdata.of_node = spi->dev.of_node;
 
 	return mtd_device_parse_register(&flash->mtd, NULL, &ppdata,
diff -Nur linux-4.1.13.orig/drivers/mtd/Kconfig linux-4.1.13/drivers/mtd/Kconfig
--- linux-4.1.13.orig/drivers/mtd/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/mtd/Kconfig	2015-12-04 19:57:03.850112998 +0100
@@ -155,6 +155,12 @@
 	  This provides partitions parser for devices based on BCM47xx
 	  boards.
 
+config MTD_TPLINK_PARTS
+	tristate "TP-Link AR7XXX/AR9XXX partitioning support"
+	depends on ATH79
+	---help---
+	  TBD.
+
 comment "User Modules And Translation Layers"
 
 #
diff -Nur linux-4.1.13.orig/drivers/mtd/maps/physmap.c linux-4.1.13/drivers/mtd/maps/physmap.c
--- linux-4.1.13.orig/drivers/mtd/maps/physmap.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/mtd/maps/physmap.c	2015-12-04 19:57:03.830114307 +0100
@@ -31,6 +31,66 @@
 	int			vpp_refcnt;
 };
 
+static struct platform_device *physmap_map2pdev(struct map_info *map)
+{
+	return (struct platform_device *) map->map_priv_1;
+}
+
+static void physmap_lock(struct map_info *map)
+{
+	struct platform_device *pdev;
+	struct physmap_flash_data *physmap_data;
+
+	pdev = physmap_map2pdev(map);
+	physmap_data = pdev->dev.platform_data;
+	physmap_data->lock(pdev);
+}
+
+static void physmap_unlock(struct map_info *map)
+{
+	struct platform_device *pdev;
+	struct physmap_flash_data *physmap_data;
+
+	pdev = physmap_map2pdev(map);
+	physmap_data = pdev->dev.platform_data;
+	physmap_data->unlock(pdev);
+}
+
+static map_word physmap_flash_read_lock(struct map_info *map, unsigned long ofs)
+{
+	map_word ret;
+
+	physmap_lock(map);
+	ret = inline_map_read(map, ofs);
+	physmap_unlock(map);
+
+	return ret;
+}
+
+static void physmap_flash_write_lock(struct map_info *map, map_word d,
+				     unsigned long ofs)
+{
+	physmap_lock(map);
+	inline_map_write(map, d, ofs);
+	physmap_unlock(map);
+}
+
+static void physmap_flash_copy_from_lock(struct map_info *map, void *to,
+					 unsigned long from, ssize_t len)
+{
+	physmap_lock(map);
+	inline_map_copy_from(map, to, from, len);
+	physmap_unlock(map);
+}
+
+static void physmap_flash_copy_to_lock(struct map_info *map, unsigned long to,
+				       const void *from, ssize_t len)
+{
+	physmap_lock(map);
+	inline_map_copy_to(map, to, from, len);
+	physmap_unlock(map);
+}
+
 static int physmap_flash_remove(struct platform_device *dev)
 {
 	struct physmap_flash_info *info;
@@ -153,6 +213,13 @@
 
 		simple_map_init(&info->map[i]);
 
+		if (physmap_data->lock && physmap_data->unlock) {
+			info->map[i].read = physmap_flash_read_lock;
+			info->map[i].write = physmap_flash_write_lock;
+			info->map[i].copy_from = physmap_flash_copy_from_lock;
+			info->map[i].copy_to = physmap_flash_copy_to_lock;
+		}
+
 		probe_type = rom_probe_types;
 		if (physmap_data->probe_type == NULL) {
 			for (; info->mtd[i] == NULL && *probe_type != NULL; probe_type++)
diff -Nur linux-4.1.13.orig/drivers/mtd/nand/ar934x_nfc.c linux-4.1.13/drivers/mtd/nand/ar934x_nfc.c
--- linux-4.1.13.orig/drivers/mtd/nand/ar934x_nfc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/mtd/nand/ar934x_nfc.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,1508 @@
+/*
+ * Driver for the built-in NAND controller of the Atheros AR934x SoCs
+ *
+ * Copyright (C) 2011-2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+#include <linux/platform/ar934x_nfc.h>
+
+#define AR934X_NFC_REG_CMD		0x00
+#define AR934X_NFC_REG_CTRL		0x04
+#define AR934X_NFC_REG_STATUS		0x08
+#define AR934X_NFC_REG_INT_MASK		0x0c
+#define AR934X_NFC_REG_INT_STATUS	0x10
+#define AR934X_NFC_REG_ECC_CTRL		0x14
+#define AR934X_NFC_REG_ECC_OFFSET	0x18
+#define AR934X_NFC_REG_ADDR0_0		0x1c
+#define AR934X_NFC_REG_ADDR0_1		0x24
+#define AR934X_NFC_REG_ADDR1_0		0x20
+#define AR934X_NFC_REG_ADDR1_1		0x28
+#define AR934X_NFC_REG_SPARE_SIZE	0x30
+#define AR934X_NFC_REG_PROTECT		0x38
+#define AR934X_NFC_REG_LOOKUP_EN	0x40
+#define AR934X_NFC_REG_LOOKUP(_x)	(0x44 + (_i) * 4)
+#define AR934X_NFC_REG_DMA_ADDR		0x64
+#define AR934X_NFC_REG_DMA_COUNT	0x68
+#define AR934X_NFC_REG_DMA_CTRL		0x6c
+#define AR934X_NFC_REG_MEM_CTRL		0x80
+#define AR934X_NFC_REG_DATA_SIZE	0x84
+#define AR934X_NFC_REG_READ_STATUS	0x88
+#define AR934X_NFC_REG_TIME_SEQ		0x8c
+#define AR934X_NFC_REG_TIMINGS_ASYN	0x90
+#define AR934X_NFC_REG_TIMINGS_SYN	0x94
+#define AR934X_NFC_REG_FIFO_DATA	0x98
+#define AR934X_NFC_REG_TIME_MODE	0x9c
+#define AR934X_NFC_REG_DMA_ADDR_OFFS	0xa0
+#define AR934X_NFC_REG_FIFO_INIT	0xb0
+#define AR934X_NFC_REG_GEN_SEQ_CTRL	0xb4
+
+#define AR934X_NFC_CMD_CMD_SEQ_S		0
+#define AR934X_NFC_CMD_CMD_SEQ_M		0x3f
+#define   AR934X_NFC_CMD_SEQ_1C			0x00
+#define   AR934X_NFC_CMD_SEQ_ERASE		0x0e
+#define   AR934X_NFC_CMD_SEQ_12			0x0c
+#define   AR934X_NFC_CMD_SEQ_1C1AXR		0x21
+#define   AR934X_NFC_CMD_SEQ_S			0x24
+#define   AR934X_NFC_CMD_SEQ_1C3AXR		0x27
+#define   AR934X_NFC_CMD_SEQ_1C5A1CXR		0x2a
+#define   AR934X_NFC_CMD_SEQ_18			0x32
+#define AR934X_NFC_CMD_INPUT_SEL_SIU		0
+#define AR934X_NFC_CMD_INPUT_SEL_DMA		BIT(6)
+#define AR934X_NFC_CMD_ADDR_SEL_0		0
+#define AR934X_NFC_CMD_ADDR_SEL_1		BIT(7)
+#define AR934X_NFC_CMD_CMD0_S			8
+#define AR934X_NFC_CMD_CMD0_M			0xff
+#define AR934X_NFC_CMD_CMD1_S			16
+#define AR934X_NFC_CMD_CMD1_M			0xff
+#define AR934X_NFC_CMD_CMD2_S			24
+#define AR934X_NFC_CMD_CMD2_M			0xff
+
+#define AR934X_NFC_CTRL_ADDR_CYCLE0_M		0x7
+#define AR934X_NFC_CTRL_ADDR_CYCLE0_S		0
+#define AR934X_NFC_CTRL_SPARE_EN		BIT(3)
+#define AR934X_NFC_CTRL_INT_EN			BIT(4)
+#define AR934X_NFC_CTRL_ECC_EN			BIT(5)
+#define AR934X_NFC_CTRL_BLOCK_SIZE_S		6
+#define AR934X_NFC_CTRL_BLOCK_SIZE_M		0x3
+#define   AR934X_NFC_CTRL_BLOCK_SIZE_32		0
+#define   AR934X_NFC_CTRL_BLOCK_SIZE_64		1
+#define   AR934X_NFC_CTRL_BLOCK_SIZE_128	2
+#define   AR934X_NFC_CTRL_BLOCK_SIZE_256	3
+#define AR934X_NFC_CTRL_PAGE_SIZE_S		8
+#define AR934X_NFC_CTRL_PAGE_SIZE_M		0x7
+#define   AR934X_NFC_CTRL_PAGE_SIZE_256		0
+#define   AR934X_NFC_CTRL_PAGE_SIZE_512		1
+#define   AR934X_NFC_CTRL_PAGE_SIZE_1024	2
+#define   AR934X_NFC_CTRL_PAGE_SIZE_2048	3
+#define   AR934X_NFC_CTRL_PAGE_SIZE_4096	4
+#define   AR934X_NFC_CTRL_PAGE_SIZE_8192	5
+#define   AR934X_NFC_CTRL_PAGE_SIZE_16384	6
+#define AR934X_NFC_CTRL_CUSTOM_SIZE_EN		BIT(11)
+#define AR934X_NFC_CTRL_IO_WIDTH_8BITS		0
+#define AR934X_NFC_CTRL_IO_WIDTH_16BITS		BIT(12)
+#define AR934X_NFC_CTRL_LOOKUP_EN		BIT(13)
+#define AR934X_NFC_CTRL_PROT_EN			BIT(14)
+#define AR934X_NFC_CTRL_WORK_MODE_ASYNC		0
+#define AR934X_NFC_CTRL_WORK_MODE_SYNC		BIT(15)
+#define AR934X_NFC_CTRL_ADDR0_AUTO_INC		BIT(16)
+#define AR934X_NFC_CTRL_ADDR1_AUTO_INC		BIT(17)
+#define AR934X_NFC_CTRL_ADDR_CYCLE1_M		0x7
+#define AR934X_NFC_CTRL_ADDR_CYCLE1_S		18
+#define AR934X_NFC_CTRL_SMALL_PAGE		BIT(21)
+
+#define AR934X_NFC_DMA_CTRL_DMA_START		BIT(7)
+#define AR934X_NFC_DMA_CTRL_DMA_DIR_WRITE	0
+#define AR934X_NFC_DMA_CTRL_DMA_DIR_READ	BIT(6)
+#define AR934X_NFC_DMA_CTRL_DMA_MODE_SG		BIT(5)
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_S		2
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_0		0
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_1		1
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_2		2
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_3		3
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_4		4
+#define AR934X_NFC_DMA_CTRL_DMA_BURST_5		5
+#define AR934X_NFC_DMA_CTRL_ERR_FLAG		BIT(1)
+#define AR934X_NFC_DMA_CTRL_DMA_READY		BIT(0)
+
+#define AR934X_NFC_INT_DEV_RDY(_x)		BIT(4 + (_x))
+#define AR934X_NFC_INT_CMD_END			BIT(1)
+
+#define AR934X_NFC_ECC_CTRL_ERR_THRES_S		8
+#define AR934X_NFC_ECC_CTRL_ERR_THRES_M		0x1f
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_S		5
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_M		0x7
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_2		0
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_4		1
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_6		2
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_8		3
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_10		4
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_12		5
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_14		6
+#define AR934X_NFC_ECC_CTRL_ECC_CAP_16		7
+#define AR934X_NFC_ECC_CTRL_ERR_OVER		BIT(2)
+#define AR934X_NFC_ECC_CTRL_ERR_UNCORRECT	BIT(1)
+#define AR934X_NFC_ECC_CTRL_ERR_CORRECT		BIT(0)
+
+#define AR934X_NFC_ECC_OFFS_OFSET_M		0xffff
+
+/* default timing values */
+#define AR934X_NFC_TIME_SEQ_DEFAULT	0x7fff
+#define AR934X_NFC_TIMINGS_ASYN_DEFAULT	0x22
+#define AR934X_NFC_TIMINGS_SYN_DEFAULT	0xf
+
+#define AR934X_NFC_ID_BUF_SIZE		8
+#define AR934X_NFC_DEV_READY_TIMEOUT	25 /* msecs */
+#define AR934X_NFC_DMA_READY_TIMEOUT	25 /* msecs */
+#define AR934X_NFC_DONE_TIMEOUT		1000
+#define AR934X_NFC_DMA_RETRIES		20
+
+#define AR934X_NFC_USE_IRQ		true
+#define AR934X_NFC_IRQ_MASK		AR934X_NFC_INT_DEV_RDY(0)
+
+#define  AR934X_NFC_GENSEQ_SMALL_PAGE_READ	0x30043
+
+#undef AR934X_NFC_DEBUG_DATA
+#undef AR934X_NFC_DEBUG
+
+struct ar934x_nfc;
+
+static inline  __attribute__ ((format (printf, 2, 3)))
+void _nfc_dbg(struct ar934x_nfc *nfc, const char *fmt, ...)
+{
+}
+
+#ifdef AR934X_NFC_DEBUG
+#define nfc_dbg(_nfc, fmt, ...) \
+	dev_info((_nfc)->parent, fmt, ##__VA_ARGS__)
+#else
+#define nfc_dbg(_nfc, fmt, ...) \
+	_nfc_dbg((_nfc), fmt, ##__VA_ARGS__)
+#endif /* AR934X_NFC_DEBUG */
+
+#ifdef AR934X_NFC_DEBUG_DATA
+static void
+nfc_debug_data(const char *label, void *data, int len)
+{
+	print_hex_dump(KERN_WARNING, label, DUMP_PREFIX_OFFSET, 16, 1,
+		       data, len, 0);
+}
+#else
+static inline void
+nfc_debug_data(const char *label, void *data, int len) {}
+#endif /* AR934X_NFC_DEBUG_DATA */
+
+struct ar934x_nfc {
+	struct mtd_info mtd;
+	struct nand_chip nand_chip;
+	struct device *parent;
+	void __iomem *base;
+	void (*select_chip)(int chip_no);
+	bool swap_dma;
+	int irq;
+	wait_queue_head_t irq_waitq;
+
+	bool spurious_irq_expected;
+	u32 irq_status;
+
+	u32 ctrl_reg;
+	u32 ecc_ctrl_reg;
+	u32 ecc_offset_reg;
+	u32 ecc_thres;
+	u32 ecc_oob_pos;
+
+	bool small_page;
+	unsigned int addr_count0;
+	unsigned int addr_count1;
+
+	u8 *buf;
+	dma_addr_t buf_dma;
+	unsigned int buf_size;
+	int buf_index;
+
+	bool read_id;
+
+	int erase1_page_addr;
+
+	int rndout_page_addr;
+	int rndout_read_cmd;
+
+	int seqin_page_addr;
+	int seqin_column;
+	int seqin_read_cmd;
+};
+
+static void ar934x_nfc_restart(struct ar934x_nfc *nfc);
+
+static inline bool
+is_all_ff(u8 *buf, int len)
+{
+	while (len--)
+		if (buf[len] != 0xff)
+			return false;
+
+	return true;
+}
+
+static inline void
+ar934x_nfc_wr(struct ar934x_nfc *nfc, unsigned reg, u32 val)
+{
+	__raw_writel(val, nfc->base + reg);
+}
+
+static inline u32
+ar934x_nfc_rr(struct ar934x_nfc *nfc, unsigned reg)
+{
+	return __raw_readl(nfc->base + reg);
+}
+
+static inline struct ar934x_nfc_platform_data *
+ar934x_nfc_get_platform_data(struct ar934x_nfc *nfc)
+{
+	return nfc->parent->platform_data;
+}
+
+static inline struct
+ar934x_nfc *mtd_to_ar934x_nfc(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct ar934x_nfc, mtd);
+}
+
+static inline bool ar934x_nfc_use_irq(struct ar934x_nfc *nfc)
+{
+	return AR934X_NFC_USE_IRQ;
+}
+
+static inline void ar934x_nfc_write_cmd_reg(struct ar934x_nfc *nfc, u32 cmd_reg)
+{
+	wmb();
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CMD, cmd_reg);
+	/* flush write */
+	ar934x_nfc_rr(nfc, AR934X_NFC_REG_CMD);
+}
+
+static bool
+__ar934x_nfc_dev_ready(struct ar934x_nfc *nfc)
+{
+	u32 status;
+
+	status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_STATUS);
+	return (status & 0xff) == 0xff;
+}
+
+static inline bool
+__ar934x_nfc_is_dma_ready(struct ar934x_nfc *nfc)
+{
+	u32 status;
+
+	status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_DMA_CTRL);
+	return (status & AR934X_NFC_DMA_CTRL_DMA_READY) != 0;
+}
+
+static int
+ar934x_nfc_wait_dev_ready(struct ar934x_nfc *nfc)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(AR934X_NFC_DEV_READY_TIMEOUT);
+	do {
+		if (__ar934x_nfc_dev_ready(nfc))
+			return 0;
+	} while time_before(jiffies, timeout);
+
+	nfc_dbg(nfc, "timeout waiting for device ready, status:%08x int:%08x\n",
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_STATUS),
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS));
+	return -ETIMEDOUT;
+}
+
+static int
+ar934x_nfc_wait_dma_ready(struct ar934x_nfc *nfc)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(AR934X_NFC_DMA_READY_TIMEOUT);
+	do {
+		if (__ar934x_nfc_is_dma_ready(nfc))
+			return 0;
+	} while time_before(jiffies, timeout);
+
+	nfc_dbg(nfc, "timeout waiting for DMA ready, dma_ctrl:%08x\n",
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_DMA_CTRL));
+	return -ETIMEDOUT;
+}
+
+static int
+ar934x_nfc_wait_irq(struct ar934x_nfc *nfc)
+{
+	long timeout;
+	int ret;
+
+	timeout = wait_event_timeout(nfc->irq_waitq,
+				(nfc->irq_status & AR934X_NFC_IRQ_MASK) != 0,
+				msecs_to_jiffies(AR934X_NFC_DEV_READY_TIMEOUT));
+
+	ret = 0;
+	if (!timeout) {
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_MASK, 0);
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+		/* flush write */
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS);
+
+		nfc_dbg(nfc,
+			"timeout waiting for interrupt, status:%08x\n",
+			nfc->irq_status);
+		ret = -ETIMEDOUT;
+	}
+
+	nfc->irq_status = 0;
+	return ret;
+}
+
+static int
+ar934x_nfc_wait_done(struct ar934x_nfc *nfc)
+{
+	int ret;
+
+	if (ar934x_nfc_use_irq(nfc))
+		ret = ar934x_nfc_wait_irq(nfc);
+	else
+		ret = ar934x_nfc_wait_dev_ready(nfc);
+
+	if (ret)
+		return ret;
+
+	return ar934x_nfc_wait_dma_ready(nfc);
+}
+
+static int
+ar934x_nfc_alloc_buf(struct ar934x_nfc *nfc, unsigned size)
+{
+	nfc->buf = dma_alloc_coherent(nfc->parent, size,
+				      &nfc->buf_dma, GFP_KERNEL);
+	if (nfc->buf == NULL) {
+		dev_err(nfc->parent, "no memory for DMA buffer\n");
+		return -ENOMEM;
+	}
+
+	nfc->buf_size = size;
+	nfc_dbg(nfc, "buf:%p size:%u\n", nfc->buf, nfc->buf_size);
+
+	return 0;
+}
+
+static void
+ar934x_nfc_free_buf(struct ar934x_nfc *nfc)
+{
+	dma_free_coherent(nfc->parent, nfc->buf_size, nfc->buf, nfc->buf_dma);
+}
+
+static void
+ar934x_nfc_get_addr(struct ar934x_nfc *nfc, int column, int page_addr,
+		    u32 *addr0, u32 *addr1)
+{
+	u32 a0, a1;
+
+	a0 = 0;
+	a1 = 0;
+
+	if (column == -1) {
+		/* ERASE1 */
+		a0 = (page_addr & 0xffff) << 16;
+		a1 = (page_addr >> 16) & 0xf;
+	} else if (page_addr != -1) {
+		/* SEQIN, READ0, etc.. */
+
+		/* TODO: handle 16bit bus width */
+		if (nfc->small_page) {
+			a0 = column & 0xff;
+			a0 |= (page_addr & 0xff) << 8;
+			a0 |= ((page_addr >> 8) & 0xff) << 16;
+			a0 |= ((page_addr >> 16) & 0xff) << 24;
+		} else {
+			a0 = column & 0x0FFF;
+			a0 |= (page_addr & 0xffff) << 16;
+
+			if (nfc->addr_count0 > 4)
+				a1 = (page_addr >> 16) & 0xf;
+		}
+	}
+
+	*addr0 = a0;
+	*addr1 = a1;
+}
+
+static void
+ar934x_nfc_send_cmd(struct ar934x_nfc *nfc, unsigned command)
+{
+	u32 cmd_reg;
+
+	cmd_reg = AR934X_NFC_CMD_INPUT_SEL_SIU | AR934X_NFC_CMD_ADDR_SEL_0 |
+		  AR934X_NFC_CMD_SEQ_1C;
+	cmd_reg |= (command & AR934X_NFC_CMD_CMD0_M) << AR934X_NFC_CMD_CMD0_S;
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);
+
+	ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
+	ar934x_nfc_wait_dev_ready(nfc);
+}
+
+static int
+ar934x_nfc_do_rw_command(struct ar934x_nfc *nfc, int column, int page_addr,
+			 int len, u32 cmd_reg, u32 ctrl_reg, bool write)
+{
+	u32 addr0, addr1;
+	u32 dma_ctrl;
+	int dir;
+	int err;
+	int retries = 0;
+
+	WARN_ON(len & 3);
+
+	if (WARN_ON(len > nfc->buf_size))
+		dev_err(nfc->parent, "len=%d > buf_size=%d", len, nfc->buf_size);
+
+	if (write) {
+		dma_ctrl = AR934X_NFC_DMA_CTRL_DMA_DIR_WRITE;
+		dir = DMA_TO_DEVICE;
+	} else {
+		dma_ctrl = AR934X_NFC_DMA_CTRL_DMA_DIR_READ;
+		dir = DMA_FROM_DEVICE;
+	}
+
+	ar934x_nfc_get_addr(nfc, column, page_addr, &addr0, &addr1);
+
+	dma_ctrl |= AR934X_NFC_DMA_CTRL_DMA_START |
+		    (AR934X_NFC_DMA_CTRL_DMA_BURST_3 <<
+		     AR934X_NFC_DMA_CTRL_DMA_BURST_S);
+
+	cmd_reg |= AR934X_NFC_CMD_INPUT_SEL_DMA | AR934X_NFC_CMD_ADDR_SEL_0;
+	ctrl_reg |= AR934X_NFC_CTRL_INT_EN;
+
+	nfc_dbg(nfc, "%s a0:%08x a1:%08x len:%x cmd:%08x dma:%08x ctrl:%08x\n",
+		(write) ? "write" : "read",
+		addr0, addr1, len, cmd_reg, dma_ctrl, ctrl_reg);
+
+retry:
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_0, addr0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_1, addr1);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DMA_ADDR, nfc->buf_dma);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DMA_COUNT, len);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DATA_SIZE, len);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, ctrl_reg);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DMA_CTRL, dma_ctrl);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ECC_CTRL, nfc->ecc_ctrl_reg);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ECC_OFFSET, nfc->ecc_offset_reg);
+
+	if (ar934x_nfc_use_irq(nfc)) {
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_MASK, AR934X_NFC_IRQ_MASK);
+		/* flush write */
+		ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_MASK);
+	}
+
+	ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
+	err = ar934x_nfc_wait_done(nfc);
+	if (err) {
+		dev_dbg(nfc->parent, "%s operation stuck at page %d\n",
+			(write) ? "write" : "read", page_addr);
+
+		ar934x_nfc_restart(nfc);
+		if (retries++ < AR934X_NFC_DMA_RETRIES)
+			goto retry;
+
+		dev_err(nfc->parent, "%s operation failed on page %d\n",
+			(write) ? "write" : "read", page_addr);
+	}
+
+	return err;
+}
+
+static int
+ar934x_nfc_send_readid(struct ar934x_nfc *nfc, unsigned command)
+{
+	u32 cmd_reg;
+	int err;
+
+	nfc_dbg(nfc, "readid, cmd:%02x\n", command);
+
+	cmd_reg = AR934X_NFC_CMD_SEQ_1C1AXR;
+	cmd_reg |= (command & AR934X_NFC_CMD_CMD0_M) << AR934X_NFC_CMD_CMD0_S;
+
+	err = ar934x_nfc_do_rw_command(nfc, -1, -1, AR934X_NFC_ID_BUF_SIZE,
+				       cmd_reg, nfc->ctrl_reg, false);
+
+	nfc_debug_data("[id] ", nfc->buf, AR934X_NFC_ID_BUF_SIZE);
+
+	return err;
+}
+
+static int
+ar934x_nfc_send_read(struct ar934x_nfc *nfc, unsigned command, int column,
+		     int page_addr, int len)
+{
+	u32 cmd_reg;
+	int err;
+
+	nfc_dbg(nfc, "read, column=%d page=%d len=%d\n",
+		column, page_addr, len);
+
+	cmd_reg = (command & AR934X_NFC_CMD_CMD0_M) << AR934X_NFC_CMD_CMD0_S;
+
+	if (nfc->small_page) {
+		cmd_reg |= AR934X_NFC_CMD_SEQ_18;
+	} else {
+		cmd_reg |= NAND_CMD_READSTART << AR934X_NFC_CMD_CMD1_S;
+		cmd_reg |= AR934X_NFC_CMD_SEQ_1C5A1CXR;
+	}
+
+	err = ar934x_nfc_do_rw_command(nfc, column, page_addr, len,
+				       cmd_reg, nfc->ctrl_reg, false);
+
+	nfc_debug_data("[data] ", nfc->buf, len);
+
+	return err;
+}
+
+static void
+ar934x_nfc_send_erase(struct ar934x_nfc *nfc, unsigned command, int column,
+		      int page_addr)
+{
+	u32 addr0, addr1;
+	u32 ctrl_reg;
+	u32 cmd_reg;
+
+	ar934x_nfc_get_addr(nfc, column, page_addr, &addr0, &addr1);
+
+	ctrl_reg = nfc->ctrl_reg;
+	if (nfc->small_page) {
+		/* override number of address cycles for the erase command */
+		ctrl_reg &= ~(AR934X_NFC_CTRL_ADDR_CYCLE0_M <<
+			      AR934X_NFC_CTRL_ADDR_CYCLE0_S);
+		ctrl_reg &= ~(AR934X_NFC_CTRL_ADDR_CYCLE1_M <<
+			      AR934X_NFC_CTRL_ADDR_CYCLE1_S);
+		ctrl_reg &= ~(AR934X_NFC_CTRL_SMALL_PAGE);
+		ctrl_reg |= (nfc->addr_count0 + 1) <<
+			    AR934X_NFC_CTRL_ADDR_CYCLE0_S;
+	}
+
+	cmd_reg = NAND_CMD_ERASE1 << AR934X_NFC_CMD_CMD0_S;
+	cmd_reg |= command << AR934X_NFC_CMD_CMD1_S;
+	cmd_reg |= AR934X_NFC_CMD_SEQ_ERASE;
+
+	nfc_dbg(nfc, "erase page %d, a0:%08x a1:%08x cmd:%08x ctrl:%08x\n",
+		page_addr, addr0, addr1, cmd_reg, ctrl_reg);
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, ctrl_reg);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_0, addr0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_ADDR0_1, addr1);
+
+	ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
+	ar934x_nfc_wait_dev_ready(nfc);
+}
+
+static int
+ar934x_nfc_send_write(struct ar934x_nfc *nfc, unsigned command, int column,
+		     int page_addr, int len)
+{
+	u32 cmd_reg;
+
+	nfc_dbg(nfc, "write, column=%d page=%d len=%d\n",
+		column, page_addr, len);
+
+	nfc_debug_data("[data] ", nfc->buf, len);
+
+	cmd_reg = NAND_CMD_SEQIN << AR934X_NFC_CMD_CMD0_S;
+	cmd_reg |= command << AR934X_NFC_CMD_CMD1_S;
+	cmd_reg |= AR934X_NFC_CMD_SEQ_12;
+
+	return ar934x_nfc_do_rw_command(nfc, column, page_addr, len,
+					cmd_reg, nfc->ctrl_reg, true);
+}
+
+static void
+ar934x_nfc_read_status(struct ar934x_nfc *nfc)
+{
+	u32 cmd_reg;
+	u32 status;
+
+	cmd_reg = NAND_CMD_STATUS << AR934X_NFC_CMD_CMD0_S;
+	cmd_reg |= AR934X_NFC_CMD_SEQ_S;
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);
+
+	ar934x_nfc_write_cmd_reg(nfc, cmd_reg);
+	ar934x_nfc_wait_dev_ready(nfc);
+
+	status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_READ_STATUS);
+
+	nfc_dbg(nfc, "read status, cmd:%08x status:%02x\n",
+		cmd_reg, (status & 0xff));
+
+	if (nfc->swap_dma)
+		nfc->buf[0 ^ 3] = status;
+	else
+		nfc->buf[0] = status;
+}
+
+static void
+ar934x_nfc_cmdfunc(struct mtd_info *mtd, unsigned int command, int column,
+		   int page_addr)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	struct nand_chip *nand = mtd->priv;
+
+	nfc->read_id = false;
+	if (command != NAND_CMD_PAGEPROG)
+		nfc->buf_index = 0;
+
+	switch (command) {
+	case NAND_CMD_RESET:
+		ar934x_nfc_send_cmd(nfc, command);
+		break;
+
+	case NAND_CMD_READID:
+		nfc->read_id = true;
+		ar934x_nfc_send_readid(nfc, command);
+		break;
+
+	case NAND_CMD_READ0:
+	case NAND_CMD_READ1:
+		if (nfc->small_page) {
+			ar934x_nfc_send_read(nfc, command, column, page_addr,
+					     mtd->writesize + mtd->oobsize);
+		} else {
+			ar934x_nfc_send_read(nfc, command, 0, page_addr,
+					     mtd->writesize + mtd->oobsize);
+			nfc->buf_index = column;
+			nfc->rndout_page_addr = page_addr;
+			nfc->rndout_read_cmd = command;
+		}
+		break;
+
+	case NAND_CMD_READOOB:
+		if (nfc->small_page)
+			ar934x_nfc_send_read(nfc, NAND_CMD_READOOB,
+					     column, page_addr,
+					     mtd->oobsize);
+		else
+			ar934x_nfc_send_read(nfc, NAND_CMD_READ0,
+					     mtd->writesize, page_addr,
+					     mtd->oobsize);
+		break;
+
+	case NAND_CMD_RNDOUT:
+		if (WARN_ON(nfc->small_page))
+			break;
+
+		/* emulate subpage read */
+		ar934x_nfc_send_read(nfc, nfc->rndout_read_cmd, 0,
+				     nfc->rndout_page_addr,
+				     mtd->writesize + mtd->oobsize);
+		nfc->buf_index = column;
+		break;
+
+	case NAND_CMD_ERASE1:
+		nfc->erase1_page_addr = page_addr;
+		break;
+
+	case NAND_CMD_ERASE2:
+		ar934x_nfc_send_erase(nfc, command, -1, nfc->erase1_page_addr);
+		break;
+
+	case NAND_CMD_STATUS:
+		ar934x_nfc_read_status(nfc);
+		break;
+
+	case NAND_CMD_SEQIN:
+		if (nfc->small_page) {
+			/* output read command */
+			if (column >= mtd->writesize) {
+				column -= mtd->writesize;
+				nfc->seqin_read_cmd = NAND_CMD_READOOB;
+			} else if (column < 256) {
+				nfc->seqin_read_cmd = NAND_CMD_READ0;
+			} else {
+				column -= 256;
+				nfc->seqin_read_cmd = NAND_CMD_READ1;
+			}
+		} else {
+			nfc->seqin_read_cmd = NAND_CMD_READ0;
+		}
+		nfc->seqin_column = column;
+		nfc->seqin_page_addr = page_addr;
+		break;
+
+	case NAND_CMD_PAGEPROG:
+		if (nand->ecc.mode == NAND_ECC_HW) {
+			/* the data is already written */
+			break;
+		}
+
+		if (nfc->small_page)
+			ar934x_nfc_send_cmd(nfc, nfc->seqin_read_cmd);
+
+		ar934x_nfc_send_write(nfc, command, nfc->seqin_column,
+				      nfc->seqin_page_addr,
+				      nfc->buf_index);
+		break;
+
+	default:
+		dev_err(nfc->parent,
+			"unsupported command: %x, column:%d page_addr=%d\n",
+			command, column, page_addr);
+		break;
+	}
+}
+
+static int
+ar934x_nfc_dev_ready(struct mtd_info *mtd)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+
+	return __ar934x_nfc_dev_ready(nfc);
+}
+
+static void
+ar934x_nfc_select_chip(struct mtd_info *mtd, int chip_no)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+
+	if (nfc->select_chip)
+		nfc->select_chip(chip_no);
+}
+
+static u8
+ar934x_nfc_read_byte(struct mtd_info *mtd)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	u8 data;
+
+	WARN_ON(nfc->buf_index >= nfc->buf_size);
+
+	if (nfc->swap_dma || nfc->read_id)
+		data = nfc->buf[nfc->buf_index ^ 3];
+	else
+		data = nfc->buf[nfc->buf_index];
+
+	nfc->buf_index++;
+
+	return data;
+}
+
+static void
+ar934x_nfc_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int i;
+
+	WARN_ON(nfc->buf_index + len > nfc->buf_size);
+
+	if (nfc->swap_dma) {
+		for (i = 0; i < len; i++) {
+			nfc->buf[nfc->buf_index ^ 3] = buf[i];
+			nfc->buf_index++;
+		}
+	} else {
+		for (i = 0; i < len; i++) {
+			nfc->buf[nfc->buf_index] = buf[i];
+			nfc->buf_index++;
+		}
+	}
+}
+
+static void
+ar934x_nfc_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int buf_index;
+	int i;
+
+	WARN_ON(nfc->buf_index + len > nfc->buf_size);
+
+	buf_index = nfc->buf_index;
+
+	if (nfc->swap_dma || nfc->read_id) {
+		for (i = 0; i < len; i++) {
+			buf[i] = nfc->buf[buf_index ^ 3];
+			buf_index++;
+		}
+	} else {
+		for (i = 0; i < len; i++) {
+			buf[i] = nfc->buf[buf_index];
+			buf_index++;
+		}
+	}
+
+	nfc->buf_index = buf_index;
+}
+
+static inline void
+ar934x_nfc_enable_hwecc(struct ar934x_nfc *nfc)
+{
+	nfc->ctrl_reg |= AR934X_NFC_CTRL_ECC_EN;
+	nfc->ctrl_reg &= ~AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
+}
+
+static inline void
+ar934x_nfc_disable_hwecc(struct ar934x_nfc *nfc)
+{
+	nfc->ctrl_reg &= ~AR934X_NFC_CTRL_ECC_EN;
+	nfc->ctrl_reg |= AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
+}
+
+static int
+ar934x_nfc_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+		    int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int err;
+
+	nfc_dbg(nfc, "read_oob: page:%d\n", page);
+
+	err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, mtd->writesize, page,
+				   mtd->oobsize);
+	if (err)
+		return err;
+
+	memcpy(chip->oob_poi, nfc->buf, mtd->oobsize);
+
+	return 0;
+}
+
+static int
+ar934x_nfc_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+		     int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+
+	nfc_dbg(nfc, "write_oob: page:%d\n", page);
+
+	memcpy(nfc->buf, chip->oob_poi, mtd->oobsize);
+
+	return ar934x_nfc_send_write(nfc, NAND_CMD_PAGEPROG, mtd->writesize,
+				     page, mtd->oobsize);
+}
+
+static int
+ar934x_nfc_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+			 u8 *buf, int oob_required, int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int len;
+	int err;
+
+	nfc_dbg(nfc, "read_page_raw: page:%d oob:%d\n", page, oob_required);
+
+	len = mtd->writesize;
+	if (oob_required)
+		len += mtd->oobsize;
+
+	err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, 0, page, len);
+	if (err)
+		return err;
+
+	memcpy(buf, nfc->buf, mtd->writesize);
+
+	if (oob_required)
+		memcpy(chip->oob_poi, &nfc->buf[mtd->writesize], mtd->oobsize);
+
+	return 0;
+}
+
+static int
+ar934x_nfc_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+		     u8 *buf, int oob_required, int page)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	u32 ecc_ctrl;
+	int max_bitflips = 0;
+	bool ecc_failed;
+	bool ecc_corrected;
+	int err;
+
+	nfc_dbg(nfc, "read_page: page:%d oob:%d\n", page, oob_required);
+
+	ar934x_nfc_enable_hwecc(nfc);
+	err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, 0, page,
+				   mtd->writesize);
+	ar934x_nfc_disable_hwecc(nfc);
+
+	if (err)
+		return err;
+
+	/* TODO: optimize to avoid memcpy */
+	memcpy(buf, nfc->buf, mtd->writesize);
+
+	/* read the ECC status */
+	ecc_ctrl = ar934x_nfc_rr(nfc, AR934X_NFC_REG_ECC_CTRL);
+	ecc_failed = ecc_ctrl & AR934X_NFC_ECC_CTRL_ERR_UNCORRECT;
+	ecc_corrected = ecc_ctrl & AR934X_NFC_ECC_CTRL_ERR_CORRECT;
+
+	if (oob_required || ecc_failed) {
+		err = ar934x_nfc_send_read(nfc, NAND_CMD_READ0, mtd->writesize,
+					   page, mtd->oobsize);
+		if (err)
+			return err;
+
+		if (oob_required)
+			memcpy(chip->oob_poi, nfc->buf, mtd->oobsize);
+	}
+
+	if (ecc_failed) {
+		/*
+		 * The hardware ECC engine reports uncorrectable errors
+		 * on empty pages. Check the ECC bytes and the data. If
+		 * both contains 0xff bytes only, dont report a failure.
+		 *
+		 * TODO: prebuild a buffer with 0xff bytes and use memcmp
+		 * for better performance?
+		 */
+		if (!is_all_ff(&nfc->buf[nfc->ecc_oob_pos], chip->ecc.total) ||
+		    !is_all_ff(buf, mtd->writesize))
+				mtd->ecc_stats.failed++;
+	} else if (ecc_corrected) {
+		/*
+		 * The hardware does not report the exact count of the
+		 * corrected bitflips, use assumptions based on the
+		 * threshold.
+		 */
+		if (ecc_ctrl & AR934X_NFC_ECC_CTRL_ERR_OVER) {
+			/*
+			 * The number of corrected bitflips exceeds the
+			 * threshold. Assume the maximum.
+			 */
+			max_bitflips = chip->ecc.strength * chip->ecc.steps;
+		} else {
+			max_bitflips = nfc->ecc_thres * chip->ecc.steps;
+		}
+
+		mtd->ecc_stats.corrected += max_bitflips;
+	}
+
+	return max_bitflips;
+}
+
+static int
+ar934x_nfc_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+			  const u8 *buf, int oob_required)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int page;
+	int len;
+
+	page = nfc->seqin_page_addr;
+
+	nfc_dbg(nfc, "write_page_raw: page:%d oob:%d\n", page, oob_required);
+
+	memcpy(nfc->buf, buf, mtd->writesize);
+	len = mtd->writesize;
+
+	if (oob_required) {
+		memcpy(&nfc->buf[mtd->writesize], chip->oob_poi, mtd->oobsize);
+		len += mtd->oobsize;
+	}
+
+	return ar934x_nfc_send_write(nfc, NAND_CMD_PAGEPROG, 0, page, len);
+}
+
+static int
+ar934x_nfc_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+		      const u8 *buf, int oob_required)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	int page;
+	int err;
+
+	page = nfc->seqin_page_addr;
+
+	nfc_dbg(nfc, "write_page: page:%d oob:%d\n", page, oob_required);
+
+	/* write OOB first */
+	if (oob_required &&
+	    !is_all_ff(chip->oob_poi, mtd->oobsize)) {
+		err = ar934x_nfc_write_oob(mtd, chip, page);
+		if (err)
+			return err;
+	}
+
+	/* TODO: optimize to avoid memcopy */
+	memcpy(nfc->buf, buf, mtd->writesize);
+
+	ar934x_nfc_enable_hwecc(nfc);
+	err = ar934x_nfc_send_write(nfc, NAND_CMD_PAGEPROG, 0, page,
+				    mtd->writesize);
+	ar934x_nfc_disable_hwecc(nfc);
+
+	return err;
+}
+
+static void
+ar934x_nfc_hw_init(struct ar934x_nfc *nfc)
+{
+	struct ar934x_nfc_platform_data *pdata;
+
+	pdata = ar934x_nfc_get_platform_data(nfc);
+	if (pdata->hw_reset) {
+		pdata->hw_reset(true);
+		pdata->hw_reset(false);
+	}
+
+	/*
+	 * setup timings
+	 * TODO: make it configurable via platform data
+	 */
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_TIME_SEQ,
+		      AR934X_NFC_TIME_SEQ_DEFAULT);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_TIMINGS_ASYN,
+		      AR934X_NFC_TIMINGS_ASYN_DEFAULT);
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_TIMINGS_SYN,
+		      AR934X_NFC_TIMINGS_SYN_DEFAULT);
+
+	/* disable WP on all chips, and select chip 0 */
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_MEM_CTRL, 0xff00);
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_DMA_ADDR_OFFS, 0);
+
+	/* initialize Control register */
+	nfc->ctrl_reg = AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);
+
+	if (nfc->small_page) {
+		/*  Setup generic sequence register for small page reads. */
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_GEN_SEQ_CTRL,
+			      AR934X_NFC_GENSEQ_SMALL_PAGE_READ);
+	}
+}
+
+static void
+ar934x_nfc_restart(struct ar934x_nfc *nfc)
+{
+	u32 ctrl_reg;
+
+	if (nfc->select_chip)
+		nfc->select_chip(-1);
+
+	ctrl_reg = nfc->ctrl_reg;
+	ar934x_nfc_hw_init(nfc);
+	nfc->ctrl_reg = ctrl_reg;
+
+	if (nfc->select_chip)
+		nfc->select_chip(0);
+
+	ar934x_nfc_send_cmd(nfc, NAND_CMD_RESET);
+}
+
+static irqreturn_t
+ar934x_nfc_irq_handler(int irq, void *data)
+{
+	struct ar934x_nfc *nfc = data;
+	u32 status;
+
+	status = ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS);
+
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_INT_STATUS, 0);
+	/* flush write */
+	ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_STATUS);
+
+	status &= ar934x_nfc_rr(nfc, AR934X_NFC_REG_INT_MASK);
+	if (status) {
+		nfc_dbg(nfc, "got IRQ, status:%08x\n", status);
+
+		nfc->irq_status = status;
+		nfc->spurious_irq_expected = true;
+		wake_up(&nfc->irq_waitq);
+	} else {
+		if (nfc->spurious_irq_expected) {
+			nfc->spurious_irq_expected = false;
+		} else {
+			dev_warn(nfc->parent, "spurious interrupt\n");
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int
+ar934x_nfc_init_tail(struct mtd_info *mtd)
+{
+	struct ar934x_nfc *nfc = mtd_to_ar934x_nfc(mtd);
+	struct nand_chip *chip = &nfc->nand_chip;
+	u32 ctrl;
+	u32 t;
+	int err;
+
+	switch (mtd->oobsize) {
+	case 16:
+	case 64:
+	case 128:
+		ar934x_nfc_wr(nfc, AR934X_NFC_REG_SPARE_SIZE, mtd->oobsize);
+		break;
+
+	default:
+		dev_err(nfc->parent, "unsupported OOB size: %d bytes\n",
+			mtd->oobsize);
+		return -ENXIO;
+	}
+
+	ctrl = AR934X_NFC_CTRL_CUSTOM_SIZE_EN;
+
+	switch (mtd->erasesize / mtd->writesize) {
+	case 32:
+		t = AR934X_NFC_CTRL_BLOCK_SIZE_32;
+		break;
+
+	case 64:
+		t = AR934X_NFC_CTRL_BLOCK_SIZE_64;
+		break;
+
+	case 128:
+		t = AR934X_NFC_CTRL_BLOCK_SIZE_128;
+		break;
+
+	case 256:
+		t = AR934X_NFC_CTRL_BLOCK_SIZE_256;
+		break;
+
+	default:
+		dev_err(nfc->parent, "unsupported block size: %u\n",
+			mtd->erasesize / mtd->writesize);
+		return -ENXIO;
+	}
+
+	ctrl |= t << AR934X_NFC_CTRL_BLOCK_SIZE_S;
+
+	switch (mtd->writesize) {
+	case 256:
+		nfc->small_page = 1;
+		t = AR934X_NFC_CTRL_PAGE_SIZE_256;
+		break;
+
+	case 512:
+		nfc->small_page = 1;
+		t = AR934X_NFC_CTRL_PAGE_SIZE_512;
+		break;
+
+	case 1024:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_1024;
+		break;
+
+	case 2048:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_2048;
+		break;
+
+	case 4096:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_4096;
+		break;
+
+	case 8192:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_8192;
+		break;
+
+	case 16384:
+		t = AR934X_NFC_CTRL_PAGE_SIZE_16384;
+		break;
+
+	default:
+		dev_err(nfc->parent, "unsupported write size: %d bytes\n",
+			mtd->writesize);
+		return -ENXIO;
+	}
+
+	ctrl |= t << AR934X_NFC_CTRL_PAGE_SIZE_S;
+
+	if (nfc->small_page) {
+		ctrl |= AR934X_NFC_CTRL_SMALL_PAGE;
+
+		if (chip->chipsize > (32 << 20)) {
+			nfc->addr_count0 = 4;
+			nfc->addr_count1 = 3;
+		} else if (chip->chipsize > (2 << 16)) {
+			nfc->addr_count0 = 3;
+			nfc->addr_count1 = 2;
+		} else {
+			nfc->addr_count0 = 2;
+			nfc->addr_count1 = 1;
+		}
+	} else {
+		if (chip->chipsize > (128 << 20)) {
+			nfc->addr_count0 = 5;
+			nfc->addr_count1 = 3;
+		} else if (chip->chipsize > (8 << 16)) {
+			nfc->addr_count0 = 4;
+			nfc->addr_count1 = 2;
+		} else {
+			nfc->addr_count0 = 3;
+			nfc->addr_count1 = 1;
+		}
+	}
+
+	ctrl |= nfc->addr_count0 << AR934X_NFC_CTRL_ADDR_CYCLE0_S;
+	ctrl |= nfc->addr_count1 << AR934X_NFC_CTRL_ADDR_CYCLE1_S;
+
+	nfc->ctrl_reg = ctrl;
+	ar934x_nfc_wr(nfc, AR934X_NFC_REG_CTRL, nfc->ctrl_reg);
+
+	ar934x_nfc_free_buf(nfc);
+	err = ar934x_nfc_alloc_buf(nfc, mtd->writesize + mtd->oobsize);
+
+	return err;
+}
+
+static struct nand_ecclayout ar934x_nfc_oob_64_hwecc = {
+	.eccbytes = 28,
+	.eccpos = {
+		20, 21, 22, 23, 24, 25, 26,
+		27, 28, 29, 30, 31, 32, 33,
+		34, 35, 36, 37, 38, 39, 40,
+		41, 42, 43, 44, 45, 46, 47,
+	},
+	.oobfree = {
+		{
+			.offset = 4,
+			.length = 16,
+		},
+		{
+			.offset = 48,
+			.length = 16,
+		},
+	},
+};
+
+static int
+ar934x_nfc_setup_hwecc(struct ar934x_nfc *nfc)
+{
+	struct nand_chip *nand = &nfc->nand_chip;
+	u32 ecc_cap;
+	u32 ecc_thres;
+
+	if (!config_enabled(CONFIG_MTD_NAND_AR934X_HW_ECC)) {
+		dev_err(nfc->parent, "hardware ECC support is disabled\n");
+		return -EINVAL;
+	}
+
+	switch (nfc->mtd.writesize) {
+	case 2048:
+		/*
+		 * Writing a subpage separately is not supported, because
+		 * the controller only does ECC on full-page accesses.
+		 */
+		nand->options = NAND_NO_SUBPAGE_WRITE;
+
+		nand->ecc.size = 512;
+		nand->ecc.bytes = 7;
+		nand->ecc.strength = 4;
+		nand->ecc.layout = &ar934x_nfc_oob_64_hwecc;
+		break;
+
+	default:
+		dev_err(nfc->parent,
+			"hardware ECC is not available for %d byte pages\n",
+			nfc->mtd.writesize);
+		return -EINVAL;
+	}
+
+	BUG_ON(!nand->ecc.layout);
+
+	switch (nand->ecc.strength) {
+	case 4:
+		ecc_cap = AR934X_NFC_ECC_CTRL_ECC_CAP_4;
+		ecc_thres = 4;
+		break;
+
+	default:
+		dev_err(nfc->parent, "unsupported ECC strength %u\n",
+			nand->ecc.strength);
+		return -EINVAL;
+	}
+
+	nfc->ecc_thres = ecc_thres;
+	nfc->ecc_oob_pos = nand->ecc.layout->eccpos[0];
+
+	nfc->ecc_ctrl_reg = ecc_cap << AR934X_NFC_ECC_CTRL_ECC_CAP_S;
+	nfc->ecc_ctrl_reg |= ecc_thres << AR934X_NFC_ECC_CTRL_ERR_THRES_S;
+
+	nfc->ecc_offset_reg = nfc->mtd.writesize + nfc->ecc_oob_pos;
+
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.read_page = ar934x_nfc_read_page;
+	nand->ecc.read_page_raw = ar934x_nfc_read_page_raw;
+	nand->ecc.write_page = ar934x_nfc_write_page;
+	nand->ecc.write_page_raw = ar934x_nfc_write_page_raw;
+	nand->ecc.read_oob = ar934x_nfc_read_oob;
+	nand->ecc.write_oob = ar934x_nfc_write_oob;
+
+	return 0;
+}
+
+static int
+ar934x_nfc_probe(struct platform_device *pdev)
+{
+	static const char *part_probes[] = { "cmdlinepart", NULL, };
+	struct ar934x_nfc_platform_data *pdata;
+	struct ar934x_nfc *nfc;
+	struct resource *res;
+	struct mtd_info *mtd;
+	struct nand_chip *nand;
+	struct mtd_part_parser_data ppdata;
+	int ret;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) {
+		dev_err(&pdev->dev, "no platform data defined\n");
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to get I/O memory\n");
+		return -EINVAL;
+	}
+
+	nfc = devm_kzalloc(&pdev->dev, sizeof(struct ar934x_nfc), GFP_KERNEL);
+	if (!nfc) {
+		dev_err(&pdev->dev, "failed to allocate driver data\n");
+		return -ENOMEM;
+	}
+
+	nfc->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(nfc->base)) {
+		dev_err(&pdev->dev, "failed to remap I/O memory\n");
+		return PTR_ERR(nfc->base);
+	}
+
+	nfc->irq = platform_get_irq(pdev, 0);
+	if (nfc->irq < 0) {
+		dev_err(&pdev->dev, "no IRQ resource specified\n");
+		return -EINVAL;
+	}
+
+	init_waitqueue_head(&nfc->irq_waitq);
+	ret = request_irq(nfc->irq, ar934x_nfc_irq_handler, 0,
+			  dev_name(&pdev->dev), nfc);
+	if (ret) {
+		dev_err(&pdev->dev, "requast_irq failed, err:%d\n", ret);
+		return ret;
+	}
+
+	nfc->parent = &pdev->dev;
+	nfc->select_chip = pdata->select_chip;
+	nfc->swap_dma = pdata->swap_dma;
+
+	nand = &nfc->nand_chip;
+	mtd = &nfc->mtd;
+
+	mtd->priv = nand;
+	mtd->owner = THIS_MODULE;
+	if (pdata->name)
+		mtd->name = pdata->name;
+	else
+		mtd->name = dev_name(&pdev->dev);
+
+	nand->chip_delay = 25;
+
+	nand->dev_ready = ar934x_nfc_dev_ready;
+	nand->cmdfunc = ar934x_nfc_cmdfunc;
+	nand->read_byte = ar934x_nfc_read_byte;
+	nand->write_buf = ar934x_nfc_write_buf;
+	nand->read_buf = ar934x_nfc_read_buf;
+	nand->select_chip = ar934x_nfc_select_chip;
+
+	ret = ar934x_nfc_alloc_buf(nfc, AR934X_NFC_ID_BUF_SIZE);
+	if (ret)
+		goto err_free_irq;
+
+	platform_set_drvdata(pdev, nfc);
+
+	ar934x_nfc_hw_init(nfc);
+
+	ret = nand_scan_ident(mtd, 1, NULL);
+	if (ret) {
+		dev_err(&pdev->dev, "nand_scan_ident failed, err:%d\n", ret);
+		goto err_free_buf;
+	}
+
+	ret = ar934x_nfc_init_tail(mtd);
+	if (ret) {
+		dev_err(&pdev->dev, "init tail failed, err:%d\n", ret);
+		goto err_free_buf;
+	}
+
+	if (pdata->scan_fixup) {
+		ret = pdata->scan_fixup(mtd);
+		if (ret)
+			goto err_free_buf;
+	}
+
+	switch (pdata->ecc_mode) {
+	case AR934X_NFC_ECC_SOFT:
+		nand->ecc.mode = NAND_ECC_SOFT;
+		break;
+
+	case AR934X_NFC_ECC_SOFT_BCH:
+		nand->ecc.mode = NAND_ECC_SOFT_BCH;
+		break;
+
+	case AR934X_NFC_ECC_HW:
+		ret = ar934x_nfc_setup_hwecc(nfc);
+		if (ret)
+			goto err_free_buf;
+
+		break;
+
+	default:
+		dev_err(nfc->parent, "unknown ECC mode %d\n", pdata->ecc_mode);
+		return -EINVAL;
+	}
+
+	ret = nand_scan_tail(mtd);
+	if (ret) {
+		dev_err(&pdev->dev, "scan tail failed, err:%d\n", ret);
+		goto err_free_buf;
+	}
+
+	memset(&ppdata, '\0', sizeof(ppdata));
+	ret = mtd_device_parse_register(mtd, part_probes, &ppdata,
+					pdata->parts, pdata->nr_parts);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register mtd, err:%d\n", ret);
+		goto err_free_buf;
+	}
+
+	return 0;
+
+err_free_buf:
+	ar934x_nfc_free_buf(nfc);
+err_free_irq:
+	free_irq(nfc->irq, nfc);
+	return ret;
+}
+
+static int
+ar934x_nfc_remove(struct platform_device *pdev)
+{
+	struct ar934x_nfc *nfc;
+
+	nfc = platform_get_drvdata(pdev);
+	if (nfc) {
+		nand_release(&nfc->mtd);
+		ar934x_nfc_free_buf(nfc);
+		free_irq(nfc->irq, nfc);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ar934x_nfc_driver = {
+	.probe		= ar934x_nfc_probe,
+	.remove		= ar934x_nfc_remove,
+	.driver = {
+		.name	= AR934X_NFC_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(ar934x_nfc_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_DESCRIPTION("Atheros AR934x NAND Flash Controller driver");
+MODULE_ALIAS("platform:" AR934X_NFC_DRIVER_NAME);
diff -Nur linux-4.1.13.orig/drivers/mtd/nand/Kconfig linux-4.1.13/drivers/mtd/nand/Kconfig
--- linux-4.1.13.orig/drivers/mtd/nand/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/mtd/nand/Kconfig	2015-12-04 19:57:03.882110905 +0100
@@ -530,4 +530,24 @@
 	help
 	  Enables support for NAND controller on Hisilicon SoC Hip04.
 
+config MTD_NAND_RB4XX
+	tristate "NAND flash driver for RouterBoard 4xx series"
+	depends on MTD_NAND && ATH79_MACH_RB4XX
+
+config MTD_NAND_RB750
+	tristate "NAND flash driver for the RouterBoard 750"
+	depends on MTD_NAND && ATH79_MACH_RB750
+
+config MTD_NAND_RB91X
+	tristate "NAND flash driver for the RouterBOARD 91x series"
+	depends on MTD_NAND && ATH79_MACH_RB91X
+
+config MTD_NAND_AR934X
+	tristate "NAND flash driver for the Qualcomm Atheros AR934x/QCA955x SoCs"
+	depends on (SOC_AR934X || SOC_QCA955X)
+
+config MTD_NAND_AR934X_HW_ECC
+	bool "Hardware ECC support for the AR934X NAND Controller (EXPERIMENTAL)"
+	depends on MTD_NAND_AR934X
+
 endif # MTD_NAND
diff -Nur linux-4.1.13.orig/drivers/mtd/nand/Makefile linux-4.1.13/drivers/mtd/nand/Makefile
--- linux-4.1.13.orig/drivers/mtd/nand/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/mtd/nand/Makefile	2015-12-04 19:57:03.882110905 +0100
@@ -13,6 +13,7 @@
 obj-$(CONFIG_MTD_NAND_DENALI)		+= denali.o
 obj-$(CONFIG_MTD_NAND_DENALI_PCI)	+= denali_pci.o
 obj-$(CONFIG_MTD_NAND_DENALI_DT)	+= denali_dt.o
+obj-$(CONFIG_MTD_NAND_AR934X)		+= ar934x_nfc.o
 obj-$(CONFIG_MTD_NAND_AU1550)		+= au1550nd.o
 obj-$(CONFIG_MTD_NAND_BF5XX)		+= bf5xx_nand.o
 obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
@@ -32,6 +33,9 @@
 obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
 obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
 obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
+obj-$(CONFIG_MTD_NAND_RB4XX)		+= rb4xx_nand.o
+obj-$(CONFIG_MTD_NAND_RB750)		+= rb750_nand.o
+obj-$(CONFIG_MTD_NAND_RB91X)		+= rb91x_nand.o
 obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
 obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_ELBC)		+= fsl_elbc_nand.o
diff -Nur linux-4.1.13.orig/drivers/mtd/nand/rb4xx_nand.c linux-4.1.13/drivers/mtd/nand/rb4xx_nand.c
--- linux-4.1.13.orig/drivers/mtd/nand/rb4xx_nand.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/mtd/nand/rb4xx_nand.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,305 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBoard 4xx series
+ *
+ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This file was based on the driver for Linux 2.6.22 published by
+ *  MikroTik for their RouterBoard 4xx series devices.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/rb4xx_cpld.h>
+
+#define DRV_NAME        "rb4xx-nand"
+#define DRV_VERSION     "0.2.0"
+#define DRV_DESC        "NAND flash driver for RouterBoard 4xx series"
+
+#define RB4XX_NAND_GPIO_READY	5
+#define RB4XX_NAND_GPIO_ALE	37
+#define RB4XX_NAND_GPIO_CLE	38
+#define RB4XX_NAND_GPIO_NCE	39
+
+struct rb4xx_nand_info {
+	struct nand_chip	chip;
+	struct mtd_info		mtd;
+};
+
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb4xx_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static struct mtd_partition rb4xx_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	},
+	{
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static int rb4xx_nand_dev_ready(struct mtd_info *mtd)
+{
+	return gpio_get_value_cansleep(RB4XX_NAND_GPIO_READY);
+}
+
+static void rb4xx_nand_write_cmd(unsigned char cmd)
+{
+	unsigned char data = cmd;
+	int err;
+
+	err = rb4xx_cpld_write(&data, 1);
+	if (err)
+		pr_err("rb4xx_nand: write cmd failed, err=%d\n", err);
+}
+
+static void rb4xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	if (ctrl & NAND_CTRL_CHANGE) {
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_CLE,
+					(ctrl & NAND_CLE) ? 1 : 0);
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_ALE,
+					(ctrl & NAND_ALE) ? 1 : 0);
+		gpio_set_value_cansleep(RB4XX_NAND_GPIO_NCE,
+					(ctrl & NAND_NCE) ? 0 : 1);
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		rb4xx_nand_write_cmd(cmd);
+}
+
+static unsigned char rb4xx_nand_read_byte(struct mtd_info *mtd)
+{
+	unsigned char data = 0;
+	int err;
+
+	err = rb4xx_cpld_read(&data, NULL, 1);
+	if (err) {
+		pr_err("rb4xx_nand: read data failed, err=%d\n", err);
+		data = 0xff;
+	}
+
+	return data;
+}
+
+static void rb4xx_nand_write_buf(struct mtd_info *mtd, const unsigned char *buf,
+				 int len)
+{
+	int err;
+
+	err = rb4xx_cpld_write(buf, len);
+	if (err)
+		pr_err("rb4xx_nand: write buf failed, err=%d\n", err);
+}
+
+static void rb4xx_nand_read_buf(struct mtd_info *mtd, unsigned char *buf,
+				int len)
+{
+	int err;
+
+	err = rb4xx_cpld_read(buf, NULL, len);
+	if (err)
+		pr_err("rb4xx_nand: read buf failed, err=%d\n", err);
+}
+
+static int rb4xx_nand_probe(struct platform_device *pdev)
+{
+	struct rb4xx_nand_info	*info;
+	int ret;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	ret = gpio_request(RB4XX_NAND_GPIO_READY, "NAND RDY");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_READY);
+		goto err;
+	}
+
+	ret = gpio_direction_input(RB4XX_NAND_GPIO_READY);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set input mode on gpio %d\n",
+			RB4XX_NAND_GPIO_READY);
+		goto err_free_gpio_ready;
+	}
+
+	ret = gpio_request(RB4XX_NAND_GPIO_ALE, "NAND ALE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_ready;
+	}
+
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_ALE, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_ale;
+	}
+
+	ret = gpio_request(RB4XX_NAND_GPIO_CLE, "NAND CLE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_CLE);
+		goto err_free_gpio_ale;
+	}
+
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_CLE, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_CLE);
+		goto err_free_gpio_cle;
+	}
+
+	ret = gpio_request(RB4XX_NAND_GPIO_NCE, "NAND NCE");
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request gpio %d\n",
+			RB4XX_NAND_GPIO_NCE);
+		goto err_free_gpio_cle;
+	}
+
+	ret = gpio_direction_output(RB4XX_NAND_GPIO_NCE, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set output mode on gpio %d\n",
+			RB4XX_NAND_GPIO_ALE);
+		goto err_free_gpio_nce;
+	}
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		dev_err(&pdev->dev, "rb4xx-nand: no memory for private data\n");
+		ret = -ENOMEM;
+		goto err_free_gpio_nce;
+	}
+
+	info->chip.priv	= &info;
+	info->mtd.priv	= &info->chip;
+	info->mtd.owner	= THIS_MODULE;
+
+	info->chip.cmd_ctrl	= rb4xx_nand_cmd_ctrl;
+	info->chip.dev_ready	= rb4xx_nand_dev_ready;
+	info->chip.read_byte	= rb4xx_nand_read_byte;
+	info->chip.write_buf	= rb4xx_nand_write_buf;
+	info->chip.read_buf	= rb4xx_nand_read_buf;
+
+	info->chip.chip_delay	= 25;
+	info->chip.ecc.mode	= NAND_ECC_SOFT;
+
+	platform_set_drvdata(pdev, info);
+
+	ret = nand_scan_ident(&info->mtd, 1, NULL);
+	if (ret) {
+		ret = -ENXIO;
+		goto err_free_info;
+	}
+
+	if (info->mtd.writesize == 512)
+		info->chip.ecc.layout = &rb4xx_nand_ecclayout;
+
+	ret = nand_scan_tail(&info->mtd);
+	if (ret) {
+		return -ENXIO;
+		goto err_set_drvdata;
+	}
+
+	mtd_device_register(&info->mtd, rb4xx_nand_partitions,
+				ARRAY_SIZE(rb4xx_nand_partitions));
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+err_release_nand:
+	nand_release(&info->mtd);
+err_set_drvdata:
+	platform_set_drvdata(pdev, NULL);
+err_free_info:
+	kfree(info);
+err_free_gpio_nce:
+	gpio_free(RB4XX_NAND_GPIO_NCE);
+err_free_gpio_cle:
+	gpio_free(RB4XX_NAND_GPIO_CLE);
+err_free_gpio_ale:
+	gpio_free(RB4XX_NAND_GPIO_ALE);
+err_free_gpio_ready:
+	gpio_free(RB4XX_NAND_GPIO_READY);
+err:
+	return ret;
+}
+
+static int rb4xx_nand_remove(struct platform_device *pdev)
+{
+	struct rb4xx_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(&info->mtd);
+	platform_set_drvdata(pdev, NULL);
+	kfree(info);
+	gpio_free(RB4XX_NAND_GPIO_NCE);
+	gpio_free(RB4XX_NAND_GPIO_CLE);
+	gpio_free(RB4XX_NAND_GPIO_ALE);
+	gpio_free(RB4XX_NAND_GPIO_READY);
+
+	return 0;
+}
+
+static struct platform_driver rb4xx_nand_driver = {
+	.probe	= rb4xx_nand_probe,
+	.remove	= rb4xx_nand_remove,
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb4xx_nand_init(void)
+{
+	return platform_driver_register(&rb4xx_nand_driver);
+}
+
+static void __exit rb4xx_nand_exit(void)
+{
+	platform_driver_unregister(&rb4xx_nand_driver);
+}
+
+module_init(rb4xx_nand_init);
+module_exit(rb4xx_nand_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-4.1.13.orig/drivers/mtd/nand/rb750_nand.c linux-4.1.13/drivers/mtd/nand/rb750_nand.c
--- linux-4.1.13.orig/drivers/mtd/nand/rb750_nand.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/mtd/nand/rb750_nand.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,354 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBOARD 750
+ *
+ *  Copyright (C) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/mach-rb750.h>
+
+#define DRV_NAME	"rb750-nand"
+#define DRV_VERSION	"0.1.0"
+#define DRV_DESC	"NAND flash driver for the RouterBOARD 750"
+
+#define RB750_NAND_IO0		BIT(RB750_GPIO_NAND_IO0)
+#define RB750_NAND_ALE		BIT(RB750_GPIO_NAND_ALE)
+#define RB750_NAND_CLE		BIT(RB750_GPIO_NAND_CLE)
+#define RB750_NAND_NRE		BIT(RB750_GPIO_NAND_NRE)
+#define RB750_NAND_NWE		BIT(RB750_GPIO_NAND_NWE)
+#define RB750_NAND_RDY		BIT(RB750_GPIO_NAND_RDY)
+
+#define RB750_NAND_DATA_SHIFT	1
+#define RB750_NAND_DATA_BITS	(0xff << RB750_NAND_DATA_SHIFT)
+#define RB750_NAND_INPUT_BITS	(RB750_NAND_DATA_BITS | RB750_NAND_RDY)
+#define RB750_NAND_OUTPUT_BITS	(RB750_NAND_ALE | RB750_NAND_CLE | \
+				 RB750_NAND_NRE | RB750_NAND_NWE)
+
+struct rb750_nand_info {
+	struct nand_chip	chip;
+	struct mtd_info		mtd;
+	struct rb7xx_nand_platform_data *pdata;
+};
+
+static inline struct rb750_nand_info *mtd_to_rbinfo(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct rb750_nand_info, mtd);
+}
+
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb750_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static struct mtd_partition rb750_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	}, {
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static void rb750_nand_write(const u8 *buf, unsigned len)
+{
+	void __iomem *base = ath79_gpio_base;
+	u32 out;
+	u32 t;
+	unsigned i;
+
+	/* set data lines to output mode */
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t | RB750_NAND_DATA_BITS, base + AR71XX_GPIO_REG_OE);
+
+	out = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+	out &= ~(RB750_NAND_DATA_BITS | RB750_NAND_NWE);
+	for (i = 0; i != len; i++) {
+		u32 data;
+
+		data = buf[i];
+		data <<= RB750_NAND_DATA_SHIFT;
+		data |= out;
+		__raw_writel(data, base + AR71XX_GPIO_REG_OUT);
+
+		__raw_writel(data | RB750_NAND_NWE, base + AR71XX_GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_OUT);
+	}
+
+	/* set data lines to input mode */
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t & ~RB750_NAND_DATA_BITS, base + AR71XX_GPIO_REG_OE);
+	/* flush write */
+	__raw_readl(base + AR71XX_GPIO_REG_OE);
+}
+
+static void rb750_nand_read(u8 *read_buf, unsigned len)
+{
+	void __iomem *base = ath79_gpio_base;
+	unsigned i;
+
+	for (i = 0; i < len; i++) {
+		u8 data;
+
+		/* activate RE line */
+		__raw_writel(RB750_NAND_NRE, base + AR71XX_GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_CLEAR);
+
+		/* read input lines */
+		data = __raw_readl(base + AR71XX_GPIO_REG_IN) >>
+		       RB750_NAND_DATA_SHIFT;
+
+		/* deactivate RE line */
+		__raw_writel(RB750_NAND_NRE, base + AR71XX_GPIO_REG_SET);
+
+		read_buf[i] = data;
+	}
+}
+
+static void rb750_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	struct rb750_nand_info *rbinfo = mtd_to_rbinfo(mtd);
+	void __iomem *base = ath79_gpio_base;
+	u32 t;
+
+	if (chip >= 0) {
+		rbinfo->pdata->enable_pins();
+
+		/* set input mode for data lines */
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(t & ~RB750_NAND_INPUT_BITS,
+			     base + AR71XX_GPIO_REG_OE);
+
+		/* deactivate RE and WE lines */
+		__raw_writel(RB750_NAND_NRE | RB750_NAND_NWE,
+			     base + AR71XX_GPIO_REG_SET);
+		/* flush write */
+		(void) __raw_readl(base + AR71XX_GPIO_REG_SET);
+
+		/* activate CE line */
+		__raw_writel(rbinfo->pdata->nce_line,
+			     base + AR71XX_GPIO_REG_CLEAR);
+	} else {
+		/* deactivate CE line */
+		__raw_writel(rbinfo->pdata->nce_line,
+			     base + AR71XX_GPIO_REG_SET);
+		/* flush write */
+		(void) __raw_readl(base + AR71XX_GPIO_REG_SET);
+
+		t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+		__raw_writel(t | RB750_NAND_IO0 | RB750_NAND_RDY,
+			     base + AR71XX_GPIO_REG_OE);
+
+		rbinfo->pdata->disable_pins();
+	}
+}
+
+static int rb750_nand_dev_ready(struct mtd_info *mtd)
+{
+	void __iomem *base = ath79_gpio_base;
+
+	return !!(__raw_readl(base + AR71XX_GPIO_REG_IN) & RB750_NAND_RDY);
+}
+
+static void rb750_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	if (ctrl & NAND_CTRL_CHANGE) {
+		void __iomem *base = ath79_gpio_base;
+		u32 t;
+
+		t = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+		t &= ~(RB750_NAND_CLE | RB750_NAND_ALE);
+		t |= (ctrl & NAND_CLE) ? RB750_NAND_CLE : 0;
+		t |= (ctrl & NAND_ALE) ? RB750_NAND_ALE : 0;
+
+		__raw_writel(t, base + AR71XX_GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_OUT);
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		u8 t = cmd;
+		rb750_nand_write(&t, 1);
+	}
+}
+
+static u8 rb750_nand_read_byte(struct mtd_info *mtd)
+{
+	u8 data = 0;
+	rb750_nand_read(&data, 1);
+	return data;
+}
+
+static void rb750_nand_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	rb750_nand_read(buf, len);
+}
+
+static void rb750_nand_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	rb750_nand_write(buf, len);
+}
+
+static void __init rb750_nand_gpio_init(struct rb750_nand_info *info)
+{
+	void __iomem *base = ath79_gpio_base;
+	u32 out;
+	u32 t;
+
+	out = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* setup output levels */
+	__raw_writel(RB750_NAND_NCE | RB750_NAND_NRE | RB750_NAND_NWE,
+		     base + AR71XX_GPIO_REG_SET);
+
+	__raw_writel(RB750_NAND_ALE | RB750_NAND_CLE,
+		     base + AR71XX_GPIO_REG_CLEAR);
+
+	/* setup input lines */
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	__raw_writel(t & ~(RB750_NAND_INPUT_BITS), base + AR71XX_GPIO_REG_OE);
+
+	/* setup output lines */
+	t = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	t |= RB750_NAND_OUTPUT_BITS;
+	t |= info->pdata->nce_line;
+	__raw_writel(t, base + AR71XX_GPIO_REG_OE);
+
+	info->pdata->latch_change(~out & RB750_NAND_IO0, out & RB750_NAND_IO0);
+}
+
+static int rb750_nand_probe(struct platform_device *pdev)
+{
+	struct rb750_nand_info	*info;
+	struct rb7xx_nand_platform_data *pdata;
+	int ret;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION "\n");
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata)
+		return -EINVAL;
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->chip.priv	= &info;
+	info->mtd.priv	= &info->chip;
+	info->mtd.owner	= THIS_MODULE;
+
+	info->chip.select_chip	= rb750_nand_select_chip;
+	info->chip.cmd_ctrl	= rb750_nand_cmd_ctrl;
+	info->chip.dev_ready	= rb750_nand_dev_ready;
+	info->chip.read_byte	= rb750_nand_read_byte;
+	info->chip.write_buf	= rb750_nand_write_buf;
+	info->chip.read_buf	= rb750_nand_read_buf;
+
+	info->chip.chip_delay	= 25;
+	info->chip.ecc.mode	= NAND_ECC_SOFT;
+
+	info->pdata = pdata;
+
+	platform_set_drvdata(pdev, info);
+
+	rb750_nand_gpio_init(info);
+
+	ret = nand_scan_ident(&info->mtd, 1, NULL);
+	if (ret) {
+		ret = -ENXIO;
+		goto err_free_info;
+	}
+
+	if (info->mtd.writesize == 512)
+		info->chip.ecc.layout = &rb750_nand_ecclayout;
+
+	ret = nand_scan_tail(&info->mtd);
+	if (ret) {
+		return -ENXIO;
+		goto err_set_drvdata;
+	}
+
+	ret = mtd_device_register(&info->mtd, rb750_nand_partitions,
+				 ARRAY_SIZE(rb750_nand_partitions));
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+err_release_nand:
+	nand_release(&info->mtd);
+err_set_drvdata:
+	platform_set_drvdata(pdev, NULL);
+err_free_info:
+	kfree(info);
+	return ret;
+}
+
+static int rb750_nand_remove(struct platform_device *pdev)
+{
+	struct rb750_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(&info->mtd);
+	platform_set_drvdata(pdev, NULL);
+	kfree(info);
+
+	return 0;
+}
+
+static struct platform_driver rb750_nand_driver = {
+	.probe	= rb750_nand_probe,
+	.remove	= rb750_nand_remove,
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb750_nand_init(void)
+{
+	return platform_driver_register(&rb750_nand_driver);
+}
+
+static void __exit rb750_nand_exit(void)
+{
+	platform_driver_unregister(&rb750_nand_driver);
+}
+
+module_init(rb750_nand_init);
+module_exit(rb750_nand_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-4.1.13.orig/drivers/mtd/nand/rb91x_nand.c linux-4.1.13/drivers/mtd/nand/rb91x_nand.c
--- linux-4.1.13.orig/drivers/mtd/nand/rb91x_nand.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/mtd/nand/rb91x_nand.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,377 @@
+/*
+ *  NAND flash driver for the MikroTik RouterBOARD 91x series
+ *
+ *  Copyright (C) 2013-2014 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/rb91x_nand.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#define DRV_DESC	"NAND flash driver for the RouterBOARD 91x series"
+
+#define RB91X_NAND_NRWE		BIT(12)
+
+#define RB91X_NAND_DATA_BITS	(BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4) |\
+				 BIT(13) | BIT(14) | BIT(15))
+
+#define RB91X_NAND_INPUT_BITS	(RB91X_NAND_DATA_BITS | RB91X_NAND_RDY)
+#define RB91X_NAND_OUTPUT_BITS	(RB91X_NAND_DATA_BITS | RB91X_NAND_NRWE)
+
+#define RB91X_NAND_LOW_DATA_MASK	0x1f
+#define RB91X_NAND_HIGH_DATA_MASK	0xe0
+#define RB91X_NAND_HIGH_DATA_SHIFT	8
+
+struct rb91x_nand_info {
+	struct nand_chip chip;
+	struct mtd_info mtd;
+	struct device *dev;
+
+	int gpio_nce;
+	int gpio_ale;
+	int gpio_cle;
+	int gpio_rdy;
+	int gpio_read;
+	int gpio_nrw;
+	int gpio_nle;
+};
+
+static inline struct rb91x_nand_info *mtd_to_rbinfo(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct rb91x_nand_info, mtd);
+}
+
+/*
+ * We need to use the OLD Yaffs-1 OOB layout, otherwise the RB bootloader
+ * will not be able to find the kernel that we load.
+ */
+static struct nand_ecclayout rb91x_nand_ecclayout = {
+	.eccbytes	= 6,
+	.eccpos		= { 8, 9, 10, 13, 14, 15 },
+	.oobavail	= 9,
+	.oobfree	= { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+
+static struct mtd_partition rb91x_nand_partitions[] = {
+	{
+		.name	= "booter",
+		.offset	= 0,
+		.size	= (256 * 1024),
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name	= "kernel",
+		.offset	= (256 * 1024),
+		.size	= (4 * 1024 * 1024) - (256 * 1024),
+	}, {
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static void rb91x_nand_write(struct rb91x_nand_info *rbni,
+			     const u8 *buf,
+			     unsigned len)
+{
+	void __iomem *base = ath79_gpio_base;
+	u32 oe_reg;
+	u32 out_reg;
+	u32 out;
+	unsigned i;
+
+	/* enable the latch */
+	gpio_set_value_cansleep(rbni->gpio_nle, 0);
+
+	oe_reg = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	out_reg = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* set data lines to output mode */
+	__raw_writel(oe_reg & ~(RB91X_NAND_DATA_BITS | RB91X_NAND_NRWE),
+		     base + AR71XX_GPIO_REG_OE);
+
+	out = out_reg & ~(RB91X_NAND_DATA_BITS | RB91X_NAND_NRWE);
+	for (i = 0; i != len; i++) {
+		u32 data;
+
+		data = (buf[i] & RB91X_NAND_HIGH_DATA_MASK) <<
+			RB91X_NAND_HIGH_DATA_SHIFT;
+		data |= buf[i] & RB91X_NAND_LOW_DATA_MASK;
+		data |= out;
+		__raw_writel(data, base + AR71XX_GPIO_REG_OUT);
+
+		/* deactivate WE line */
+		data |= RB91X_NAND_NRWE;
+		__raw_writel(data, base + AR71XX_GPIO_REG_OUT);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_OUT);
+	}
+
+	/* restore  registers */
+	__raw_writel(out_reg, base + AR71XX_GPIO_REG_OUT);
+	__raw_writel(oe_reg, base + AR71XX_GPIO_REG_OE);
+	/* flush write */
+	__raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* disable the latch */
+	gpio_set_value_cansleep(rbni->gpio_nle, 1);
+}
+
+static void rb91x_nand_read(struct rb91x_nand_info *rbni,
+			    u8 *read_buf,
+			    unsigned len)
+{
+	void __iomem *base = ath79_gpio_base;
+	u32 oe_reg;
+	u32 out_reg;
+	unsigned i;
+
+	/* enable read mode */
+	gpio_set_value_cansleep(rbni->gpio_read, 1);
+
+	/* enable latch */
+	gpio_set_value_cansleep(rbni->gpio_nle, 0);
+
+	/* save registers */
+	oe_reg = __raw_readl(base + AR71XX_GPIO_REG_OE);
+	out_reg = __raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* set data lines to input mode */
+	__raw_writel(oe_reg | RB91X_NAND_DATA_BITS,
+		     base + AR71XX_GPIO_REG_OE);
+
+	for (i = 0; i < len; i++) {
+		u32 in;
+		u8 data;
+
+		/* activate RE line */
+		__raw_writel(RB91X_NAND_NRWE, base + AR71XX_GPIO_REG_CLEAR);
+		/* flush write */
+		__raw_readl(base + AR71XX_GPIO_REG_CLEAR);
+
+		/* read input lines */
+		in = __raw_readl(base + AR71XX_GPIO_REG_IN);
+
+		/* deactivate RE line */
+		__raw_writel(RB91X_NAND_NRWE, base + AR71XX_GPIO_REG_SET);
+
+		data = (in & RB91X_NAND_LOW_DATA_MASK);
+		data |= (in >> RB91X_NAND_HIGH_DATA_SHIFT) &
+			RB91X_NAND_HIGH_DATA_MASK;
+
+		read_buf[i] = data;
+	}
+
+	/* restore  registers */
+	__raw_writel(out_reg, base + AR71XX_GPIO_REG_OUT);
+	__raw_writel(oe_reg, base + AR71XX_GPIO_REG_OE);
+	/* flush write */
+	__raw_readl(base + AR71XX_GPIO_REG_OUT);
+
+	/* disable latch */
+	gpio_set_value_cansleep(rbni->gpio_nle, 1);
+
+	/* disable read mode */
+	gpio_set_value_cansleep(rbni->gpio_read, 0);
+}
+
+static int rb91x_nand_dev_ready(struct mtd_info *mtd)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+
+	return gpio_get_value_cansleep(rbni->gpio_rdy);
+}
+
+static void rb91x_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+				unsigned int ctrl)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		gpio_set_value_cansleep(rbni->gpio_cle,
+					(ctrl & NAND_CLE) ? 1 : 0);
+		gpio_set_value_cansleep(rbni->gpio_ale,
+					(ctrl & NAND_ALE) ? 1 : 0);
+		gpio_set_value_cansleep(rbni->gpio_nce,
+					(ctrl & NAND_NCE) ? 0 : 1);
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		u8 t = cmd;
+
+		rb91x_nand_write(rbni, &t, 1);
+	}
+}
+
+static u8 rb91x_nand_read_byte(struct mtd_info *mtd)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+	u8 data = 0xff;
+
+	rb91x_nand_read(rbni, &data, 1);
+
+	return data;
+}
+
+static void rb91x_nand_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+
+	rb91x_nand_read(rbni, buf, len);
+}
+
+static void rb91x_nand_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	struct rb91x_nand_info *rbni = mtd_to_rbinfo(mtd);
+
+	rb91x_nand_write(rbni, buf, len);
+}
+
+static int rb91x_nand_gpio_init(struct rb91x_nand_info *info)
+{
+	int ret;
+
+	/*
+	 * Ensure that the LATCH is disabled before initializing
+	 * control lines.
+	 */
+	ret = devm_gpio_request_one(info->dev, info->gpio_nle,
+				    GPIOF_OUT_INIT_HIGH, "LATCH enable");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_nce,
+				    GPIOF_OUT_INIT_HIGH, "NAND nCE");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_nrw,
+				    GPIOF_OUT_INIT_HIGH, "NAND nRW");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_cle,
+				    GPIOF_OUT_INIT_LOW, "NAND CLE");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_ale,
+				    GPIOF_OUT_INIT_LOW, "NAND ALE");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_read,
+				    GPIOF_OUT_INIT_LOW, "NAND READ");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request_one(info->dev, info->gpio_rdy,
+				    GPIOF_IN, "NAND RDY");
+	return ret;
+}
+
+static int rb91x_nand_probe(struct platform_device *pdev)
+{
+	struct rb91x_nand_info	*rbni;
+	struct rb91x_nand_platform_data *pdata;
+	int ret;
+
+	pr_info(DRV_DESC "\n");
+
+	pdata = dev_get_platdata(&pdev->dev);
+	if (!pdata)
+		return -EINVAL;
+
+	rbni = devm_kzalloc(&pdev->dev, sizeof(*rbni), GFP_KERNEL);
+	if (!rbni)
+		return -ENOMEM;
+
+	rbni->dev = &pdev->dev;
+	rbni->gpio_nce = pdata->gpio_nce;
+	rbni->gpio_ale = pdata->gpio_ale;
+	rbni->gpio_cle = pdata->gpio_cle;
+	rbni->gpio_read = pdata->gpio_read;
+	rbni->gpio_nrw = pdata->gpio_nrw;
+	rbni->gpio_rdy = pdata->gpio_rdy;
+	rbni->gpio_nle = pdata->gpio_nle;
+
+	rbni->chip.priv	= &rbni;
+	rbni->mtd.priv	= &rbni->chip;
+	rbni->mtd.owner	= THIS_MODULE;
+
+	rbni->chip.cmd_ctrl	= rb91x_nand_cmd_ctrl;
+	rbni->chip.dev_ready	= rb91x_nand_dev_ready;
+	rbni->chip.read_byte	= rb91x_nand_read_byte;
+	rbni->chip.write_buf	= rb91x_nand_write_buf;
+	rbni->chip.read_buf	= rb91x_nand_read_buf;
+
+	rbni->chip.chip_delay	= 25;
+	rbni->chip.ecc.mode	= NAND_ECC_SOFT;
+
+	platform_set_drvdata(pdev, rbni);
+
+	ret = rb91x_nand_gpio_init(rbni);
+	if (ret)
+		return ret;
+
+	ret = nand_scan_ident(&rbni->mtd, 1, NULL);
+	if (ret)
+		return ret;
+
+	if (rbni->mtd.writesize == 512)
+		rbni->chip.ecc.layout = &rb91x_nand_ecclayout;
+
+	ret = nand_scan_tail(&rbni->mtd);
+	if (ret)
+		return ret;
+
+	ret = mtd_device_register(&rbni->mtd, rb91x_nand_partitions,
+				 ARRAY_SIZE(rb91x_nand_partitions));
+	if (ret)
+		goto err_release_nand;
+
+	return 0;
+
+err_release_nand:
+	nand_release(&rbni->mtd);
+	return ret;
+}
+
+static int rb91x_nand_remove(struct platform_device *pdev)
+{
+	struct rb91x_nand_info *info = platform_get_drvdata(pdev);
+
+	nand_release(&info->mtd);
+
+	return 0;
+}
+
+static struct platform_driver rb91x_nand_driver = {
+	.probe	= rb91x_nand_probe,
+	.remove	= rb91x_nand_remove,
+	.driver	= {
+		.name	= RB91X_NAND_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(rb91x_nand_driver);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-4.1.13.orig/drivers/mtd/redboot.c linux-4.1.13/drivers/mtd/redboot.c
--- linux-4.1.13.orig/drivers/mtd/redboot.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/mtd/redboot.c	2015-12-04 19:57:03.870111690 +0100
@@ -76,12 +76,18 @@
 	static char nullstring[] = "unallocated";
 #endif
 
+	buf = vmalloc(master->erasesize);
+	if (!buf)
+		return -ENOMEM;
+
+ restart:
 	if ( directory < 0 ) {
 		offset = master->size + directory * master->erasesize;
 		while (mtd_block_isbad(master, offset)) {
 			if (!offset) {
 			nogood:
 				printk(KERN_NOTICE "Failed to find a non-bad block to check for RedBoot partition table\n");
+				vfree(buf);
 				return -EIO;
 			}
 			offset -= master->erasesize;
@@ -94,10 +100,6 @@
 				goto nogood;
 		}
 	}
-	buf = vmalloc(master->erasesize);
-
-	if (!buf)
-		return -ENOMEM;
 
 	printk(KERN_NOTICE "Searching for RedBoot partition table in %s at offset 0x%lx\n",
 	       master->name, offset);
@@ -170,6 +172,11 @@
 	}
 	if (i == numslots) {
 		/* Didn't find it */
+		if (offset + master->erasesize < master->size) {
+			/* not at the end of the flash yet, maybe next block :) */
+			directory++;
+			goto restart;
+		}
 		printk(KERN_NOTICE "No RedBoot partition table detected in %s\n",
 		       master->name);
 		ret = 0;
diff -Nur linux-4.1.13.orig/drivers/mtd/tplinkpart.c linux-4.1.13/drivers/mtd/tplinkpart.c
--- linux-4.1.13.orig/drivers/mtd/tplinkpart.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/mtd/tplinkpart.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/magic.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#define TPLINK_NUM_PARTS	5
+#define TPLINK_HEADER_V1	0x01000000
+#define TPLINK_HEADER_V2	0x02000000
+#define MD5SUM_LEN		16
+
+#define TPLINK_ART_LEN		0x10000
+#define TPLINK_KERNEL_OFFS	0x20000
+#define TPLINK_64K_KERNEL_OFFS	0x10000
+
+struct tplink_fw_header {
+	uint32_t	version;	/* header version */
+	char		vendor_name[24];
+	char		fw_version[36];
+	uint32_t	hw_id;		/* hardware id */
+	uint32_t	hw_rev;		/* hardware revision */
+	uint32_t	unk1;
+	uint8_t		md5sum1[MD5SUM_LEN];
+	uint32_t	unk2;
+	uint8_t		md5sum2[MD5SUM_LEN];
+	uint32_t	unk3;
+	uint32_t	kernel_la;	/* kernel load address */
+	uint32_t	kernel_ep;	/* kernel entry point */
+	uint32_t	fw_length;	/* total length of the firmware */
+	uint32_t	kernel_ofs;	/* kernel data offset */
+	uint32_t	kernel_len;	/* kernel data length */
+	uint32_t	rootfs_ofs;	/* rootfs data offset */
+	uint32_t	rootfs_len;	/* rootfs data length */
+	uint32_t	boot_ofs;	/* bootloader data offset */
+	uint32_t	boot_len;	/* bootloader data length */
+	uint8_t		pad[360];
+} __attribute__ ((packed));
+
+static struct tplink_fw_header *
+tplink_read_header(struct mtd_info *mtd, size_t offset)
+{
+	struct tplink_fw_header *header;
+	size_t header_len;
+	size_t retlen;
+	int ret;
+	u32 t;
+
+	header = vmalloc(sizeof(*header));
+	if (!header)
+		goto err;
+
+	header_len = sizeof(struct tplink_fw_header);
+	ret = mtd_read(mtd, offset, header_len, &retlen,
+		       (unsigned char *) header);
+	if (ret)
+		goto err_free_header;
+
+	if (retlen != header_len)
+		goto err_free_header;
+
+	/* sanity checks */
+	t = be32_to_cpu(header->version);
+	if ((t != TPLINK_HEADER_V1) && (t != TPLINK_HEADER_V2))
+		goto err_free_header;
+
+	t = be32_to_cpu(header->kernel_ofs);
+	if (t != header_len)
+		goto err_free_header;
+
+	return header;
+
+err_free_header:
+	vfree(header);
+err:
+	return NULL;
+}
+
+static int tplink_check_rootfs_magic(struct mtd_info *mtd, size_t offset)
+{
+	u32 magic;
+	size_t retlen;
+	int ret;
+
+	ret = mtd_read(mtd, offset, sizeof(magic), &retlen,
+		       (unsigned char *) &magic);
+	if (ret)
+		return ret;
+
+	if (retlen != sizeof(magic))
+		return -EIO;
+
+	if (le32_to_cpu(magic) != SQUASHFS_MAGIC &&
+	    magic != 0x19852003)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int tplink_parse_partitions_offset(struct mtd_info *master,
+				   struct mtd_partition **pparts,
+				   struct mtd_part_parser_data *data,
+				   size_t offset)
+{
+	struct mtd_partition *parts;
+	struct tplink_fw_header *header;
+	int nr_parts;
+	size_t art_offset;
+	size_t rootfs_offset;
+	size_t squashfs_offset;
+	int ret;
+
+	nr_parts = TPLINK_NUM_PARTS;
+	parts = kzalloc(nr_parts * sizeof(struct mtd_partition), GFP_KERNEL);
+	if (!parts) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	header = tplink_read_header(master, offset);
+	if (!header) {
+		pr_notice("%s: no TP-Link header found\n", master->name);
+		ret = -ENODEV;
+		goto err_free_parts;
+	}
+
+	squashfs_offset = offset + sizeof(struct tplink_fw_header) +
+			  be32_to_cpu(header->kernel_len);
+
+	ret = tplink_check_rootfs_magic(master, squashfs_offset);
+	if (ret == 0)
+		rootfs_offset = squashfs_offset;
+	else
+		rootfs_offset = offset + be32_to_cpu(header->rootfs_ofs);
+
+	art_offset = master->size - TPLINK_ART_LEN;
+
+	parts[0].name = "u-boot";
+	parts[0].offset = 0;
+	parts[0].size = offset;
+	parts[0].mask_flags = MTD_WRITEABLE;
+
+	parts[1].name = "kernel";
+	parts[1].offset = offset;
+	parts[1].size = rootfs_offset - offset;
+
+	parts[2].name = "rootfs";
+	parts[2].offset = rootfs_offset;
+	parts[2].size = art_offset - rootfs_offset;
+
+	parts[3].name = "art";
+	parts[3].offset = art_offset;
+	parts[3].size = TPLINK_ART_LEN;
+	parts[3].mask_flags = MTD_WRITEABLE;
+
+	parts[4].name = "firmware";
+	parts[4].offset = offset;
+	parts[4].size = art_offset - offset;
+
+	vfree(header);
+
+	*pparts = parts;
+	return nr_parts;
+
+err_free_parts:
+	kfree(parts);
+err:
+	*pparts = NULL;
+	return ret;
+}
+
+static int tplink_parse_partitions(struct mtd_info *master,
+				   struct mtd_partition **pparts,
+				   struct mtd_part_parser_data *data)
+{
+	return tplink_parse_partitions_offset(master, pparts, data,
+		                              TPLINK_KERNEL_OFFS);
+}
+
+static int tplink_parse_64k_partitions(struct mtd_info *master,
+				   struct mtd_partition **pparts,
+				   struct mtd_part_parser_data *data)
+{
+	return tplink_parse_partitions_offset(master, pparts, data,
+		                              TPLINK_64K_KERNEL_OFFS);
+}
+
+static struct mtd_part_parser tplink_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= tplink_parse_partitions,
+	.name		= "tp-link",
+};
+
+static struct mtd_part_parser tplink_64k_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= tplink_parse_64k_partitions,
+	.name		= "tp-link-64k",
+};
+
+static int __init tplink_parser_init(void)
+{
+	register_mtd_parser(&tplink_parser);
+	register_mtd_parser(&tplink_64k_parser);
+
+	return 0;
+}
+
+module_init(tplink_parser_init);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
diff -Nur linux-4.1.13.orig/drivers/net/dsa/Kconfig linux-4.1.13/drivers/net/dsa/Kconfig
--- linux-4.1.13.orig/drivers/net/dsa/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/net/dsa/Kconfig	2015-12-04 19:57:03.886110643 +0100
@@ -13,6 +13,13 @@
 	  This enables support for the Marvell 88E6060 ethernet switch
 	  chip.
 
+config NET_DSA_MV88E6063
+	bool "Marvell 88E6063 ethernet switch chip support"
+	select NET_DSA_TAG_TRAILER
+	---help---
+	  This enables support for the Marvell 88E6063 ethernet switch
+	  chip
+
 config NET_DSA_MV88E6XXX_NEED_PPU
 	bool
 	default n
diff -Nur linux-4.1.13.orig/drivers/net/dsa/Makefile linux-4.1.13/drivers/net/dsa/Makefile
--- linux-4.1.13.orig/drivers/net/dsa/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/net/dsa/Makefile	2015-12-04 19:57:03.886110643 +0100
@@ -1,4 +1,5 @@
 obj-$(CONFIG_NET_DSA_MV88E6060) += mv88e6060.o
+obj-$(CONFIG_NET_DSA_MV88E6063) += mv88e6063.o
 obj-$(CONFIG_NET_DSA_MV88E6XXX) += mv88e6xxx_drv.o
 mv88e6xxx_drv-y += mv88e6xxx.o
 ifdef CONFIG_NET_DSA_MV88E6123_61_65
diff -Nur linux-4.1.13.orig/drivers/net/dsa/mv88e6063.c linux-4.1.13/drivers/net/dsa/mv88e6063.c
--- linux-4.1.13.orig/drivers/net/dsa/mv88e6063.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/dsa/mv88e6063.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,311 @@
+/*
+ * net/dsa/mv88e6063.c - Driver for Marvell 88e6063 switch chips
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This driver was base on: net/dsa/mv88e6060.c
+ *   net/dsa/mv88e6063.c - Driver for Marvell 88e6060 switch chips
+ *   Copyright (c) 2008-2009 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <net/dsa.h>
+
+#define REG_BASE		0x10
+#define REG_PHY(p)		(REG_BASE + (p))
+#define REG_PORT(p)		(REG_BASE + 8 + (p))
+#define REG_GLOBAL		(REG_BASE + 0x0f)
+#define NUM_PORTS		7
+
+static int reg_read(struct dsa_switch *ds, int addr, int reg)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	return mdiobus_read(ds->master_mii_bus, addr, reg);
+#else
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->master_dev);
+	return mdiobus_read(bus, addr, reg);
+#endif
+}
+
+#define REG_READ(addr, reg)					\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_read(ds, addr, reg);		\
+		if (__ret < 0)					\
+			return __ret;				\
+		__ret;						\
+	})
+
+
+static int reg_write(struct dsa_switch *ds, int addr, int reg, u16 val)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	return mdiobus_write(ds->master_mii_bus, addr, reg, val);
+#else
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(ds->master_dev);
+	return mdiobus_write(bus, addr, reg, val);
+#endif
+}
+
+#define REG_WRITE(addr, reg, val)				\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_write(ds, addr, reg, val);		\
+		if (__ret < 0)					\
+			return __ret;				\
+	})
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+static char *mv88e6063_probe(struct mii_bus *bus, int sw_addr)
+{
+#else
+static char *mv88e6063_probe(struct device *host_dev, int sw_addr)
+{
+	struct mii_bus *bus = dsa_host_dev_to_mii_bus(host_dev);
+#endif
+	int ret;
+
+	ret = mdiobus_read(bus, REG_PORT(0), 0x03);
+	if (ret >= 0) {
+		ret &= 0xfff0;
+		if (ret == 0x1530)
+			return "Marvell 88E6063";
+	}
+
+	return NULL;
+}
+
+static int mv88e6063_switch_reset(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	/*
+	 * Set all ports to the disabled state.
+	 */
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = REG_READ(REG_PORT(i), 0x04);
+		REG_WRITE(REG_PORT(i), 0x04, ret & 0xfffc);
+	}
+
+	/*
+	 * Wait for transmit queues to drain.
+	 */
+	msleep(2);
+
+	/*
+	 * Reset the switch.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0xa130);
+
+	/*
+	 * Wait up to one second for reset to complete.
+	 */
+	for (i = 0; i < 1000; i++) {
+		ret = REG_READ(REG_GLOBAL, 0x00);
+		if ((ret & 0x8000) == 0x0000)
+			break;
+
+		msleep(1);
+	}
+	if (i == 1000)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int mv88e6063_setup_global(struct dsa_switch *ds)
+{
+	/*
+	 * Disable discarding of frames with excessive collisions,
+	 * set the maximum frame size to 1536 bytes, and mask all
+	 * interrupt sources.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x04, 0x0800);
+
+	/*
+	 * Enable automatic address learning, set the address
+	 * database size to 1024 entries, and set the default aging
+	 * time to 5 minutes.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0x2130);
+
+	return 0;
+}
+
+static int mv88e6063_setup_port(struct dsa_switch *ds, int p)
+{
+	int addr = REG_PORT(p);
+
+	/*
+	 * Do not force flow control, disable Ingress and Egress
+	 * Header tagging, disable VLAN tunneling, and set the port
+	 * state to Forwarding.  Additionally, if this is the CPU
+	 * port, enable Ingress and Egress Trailer tagging mode.
+	 */
+	REG_WRITE(addr, 0x04, dsa_is_cpu_port(ds, p) ?  0x4103 : 0x0003);
+
+	/*
+	 * Port based VLAN map: give each port its own address
+	 * database, allow the CPU port to talk to each of the 'real'
+	 * ports, and allow each of the 'real' ports to only talk to
+	 * the CPU port.
+	 */
+	REG_WRITE(addr, 0x06,
+			((p & 0xf) << 12) |
+			 (dsa_is_cpu_port(ds, p) ?
+				ds->phys_port_mask :
+				(1 << ds->dst->cpu_port)));
+
+	/*
+	 * Port Association Vector: when learning source addresses
+	 * of packets, add the address to the address database using
+	 * a port bitmap that has only the bit for this port set and
+	 * the other bits clear.
+	 */
+	REG_WRITE(addr, 0x0b, 1 << p);
+
+	return 0;
+}
+
+static int mv88e6063_setup(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	ret = mv88e6063_switch_reset(ds);
+	if (ret < 0)
+		return ret;
+
+	/* @@@ initialise atu */
+
+	ret = mv88e6063_setup_global(ds);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = mv88e6063_setup_port(ds, i);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mv88e6063_set_addr(struct dsa_switch *ds, u8 *addr)
+{
+	REG_WRITE(REG_GLOBAL, 0x01, (addr[0] << 8) | addr[1]);
+	REG_WRITE(REG_GLOBAL, 0x02, (addr[2] << 8) | addr[3]);
+	REG_WRITE(REG_GLOBAL, 0x03, (addr[4] << 8) | addr[5]);
+
+	return 0;
+}
+
+static int mv88e6063_port_to_phy_addr(int port)
+{
+	if (port >= 0 && port <= NUM_PORTS)
+		return REG_PHY(port);
+	return -1;
+}
+
+static int mv88e6063_phy_read(struct dsa_switch *ds, int port, int regnum)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_read(ds, addr, regnum);
+}
+
+static int
+mv88e6063_phy_write(struct dsa_switch *ds, int port, int regnum, u16 val)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_write(ds, addr, regnum, val);
+}
+
+static void mv88e6063_poll_link(struct dsa_switch *ds)
+{
+	int i;
+
+	for (i = 0; i < DSA_MAX_PORTS; i++) {
+		struct net_device *dev;
+		int uninitialized_var(port_status);
+		int link;
+		int speed;
+		int duplex;
+		int fc;
+
+		dev = ds->ports[i];
+		if (dev == NULL)
+			continue;
+
+		link = 0;
+		if (dev->flags & IFF_UP) {
+			port_status = reg_read(ds, REG_PORT(i), 0x00);
+			if (port_status < 0)
+				continue;
+
+			link = !!(port_status & 0x1000);
+		}
+
+		if (!link) {
+			if (netif_carrier_ok(dev)) {
+				printk(KERN_INFO "%s: link down\n", dev->name);
+				netif_carrier_off(dev);
+			}
+			continue;
+		}
+
+		speed = (port_status & 0x0100) ? 100 : 10;
+		duplex = (port_status & 0x0200) ? 1 : 0;
+		fc = ((port_status & 0xc000) == 0xc000) ? 1 : 0;
+
+		if (!netif_carrier_ok(dev)) {
+			printk(KERN_INFO "%s: link up, %d Mb/s, %s duplex, "
+					 "flow control %sabled\n", dev->name,
+					 speed, duplex ? "full" : "half",
+					 fc ? "en" : "dis");
+			netif_carrier_on(dev);
+		}
+	}
+}
+
+static struct dsa_switch_driver mv88e6063_switch_driver = {
+	.tag_protocol	= htons(ETH_P_TRAILER),
+	.probe		= mv88e6063_probe,
+	.setup		= mv88e6063_setup,
+	.set_addr	= mv88e6063_set_addr,
+	.phy_read	= mv88e6063_phy_read,
+	.phy_write	= mv88e6063_phy_write,
+	.poll_link	= mv88e6063_poll_link,
+};
+
+static int __init mv88e6063_init(void)
+{
+	register_switch_driver(&mv88e6063_switch_driver);
+	return 0;
+}
+module_init(mv88e6063_init);
+
+static void __exit mv88e6063_cleanup(void)
+{
+	unregister_switch_driver(&mv88e6063_switch_driver);
+}
+module_exit(mv88e6063_cleanup);
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar7240.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,1229 @@
+/*
+ *  Driver for the built-in ethernet switch of the Atheros AR7240 SoC
+ *  Copyright (c) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (c) 2010 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <linux/mii.h>
+#include <linux/bitops.h>
+#include <linux/switch.h>
+#include "ag71xx.h"
+
+#define BITM(_count)	(BIT(_count) - 1)
+#define BITS(_shift, _count)	(BITM(_count) << _shift)
+
+#define AR7240_REG_MASK_CTRL		0x00
+#define AR7240_MASK_CTRL_REVISION_M	BITM(8)
+#define AR7240_MASK_CTRL_VERSION_M	BITM(8)
+#define AR7240_MASK_CTRL_VERSION_S	8
+#define   AR7240_MASK_CTRL_VERSION_AR7240 0x01
+#define   AR7240_MASK_CTRL_VERSION_AR934X 0x02
+#define AR7240_MASK_CTRL_SOFT_RESET	BIT(31)
+
+#define AR7240_REG_MAC_ADDR0		0x20
+#define AR7240_REG_MAC_ADDR1		0x24
+
+#define AR7240_REG_FLOOD_MASK		0x2c
+#define AR7240_FLOOD_MASK_BROAD_TO_CPU	BIT(26)
+
+#define AR7240_REG_GLOBAL_CTRL		0x30
+#define AR7240_GLOBAL_CTRL_MTU_M	BITM(11)
+#define AR9340_GLOBAL_CTRL_MTU_M	BITM(14)
+
+#define AR7240_REG_VTU			0x0040
+#define   AR7240_VTU_OP			BITM(3)
+#define   AR7240_VTU_OP_NOOP		0x0
+#define   AR7240_VTU_OP_FLUSH		0x1
+#define   AR7240_VTU_OP_LOAD		0x2
+#define   AR7240_VTU_OP_PURGE		0x3
+#define   AR7240_VTU_OP_REMOVE_PORT	0x4
+#define   AR7240_VTU_ACTIVE		BIT(3)
+#define   AR7240_VTU_FULL		BIT(4)
+#define   AR7240_VTU_PORT		BITS(8, 4)
+#define   AR7240_VTU_PORT_S		8
+#define   AR7240_VTU_VID		BITS(16, 12)
+#define   AR7240_VTU_VID_S		16
+#define   AR7240_VTU_PRIO		BITS(28, 3)
+#define   AR7240_VTU_PRIO_S		28
+#define   AR7240_VTU_PRIO_EN		BIT(31)
+
+#define AR7240_REG_VTU_DATA		0x0044
+#define   AR7240_VTUDATA_MEMBER		BITS(0, 10)
+#define   AR7240_VTUDATA_VALID		BIT(11)
+
+#define AR7240_REG_ATU			0x50
+#define AR7240_ATU_FLUSH_ALL		0x1
+
+#define AR7240_REG_AT_CTRL		0x5c
+#define AR7240_AT_CTRL_AGE_TIME		BITS(0, 15)
+#define AR7240_AT_CTRL_AGE_EN		BIT(17)
+#define AR7240_AT_CTRL_LEARN_CHANGE	BIT(18)
+#define AR7240_AT_CTRL_RESERVED		BIT(19)
+#define AR7240_AT_CTRL_ARP_EN		BIT(20)
+
+#define AR7240_REG_TAG_PRIORITY		0x70
+
+#define AR7240_REG_SERVICE_TAG		0x74
+#define AR7240_SERVICE_TAG_M		BITM(16)
+
+#define AR7240_REG_CPU_PORT		0x78
+#define AR7240_MIRROR_PORT_S		4
+#define AR7240_CPU_PORT_EN		BIT(8)
+
+#define AR7240_REG_MIB_FUNCTION0	0x80
+#define AR7240_MIB_TIMER_M		BITM(16)
+#define AR7240_MIB_AT_HALF_EN		BIT(16)
+#define AR7240_MIB_BUSY			BIT(17)
+#define AR7240_MIB_FUNC_S		24
+#define AR7240_MIB_FUNC_M		BITM(3)
+#define AR7240_MIB_FUNC_NO_OP		0x0
+#define AR7240_MIB_FUNC_FLUSH		0x1
+#define AR7240_MIB_FUNC_CAPTURE		0x3
+
+#define AR7240_REG_MDIO_CTRL		0x98
+#define AR7240_MDIO_CTRL_DATA_M		BITM(16)
+#define AR7240_MDIO_CTRL_REG_ADDR_S	16
+#define AR7240_MDIO_CTRL_PHY_ADDR_S	21
+#define AR7240_MDIO_CTRL_CMD_WRITE	0
+#define AR7240_MDIO_CTRL_CMD_READ	BIT(27)
+#define AR7240_MDIO_CTRL_MASTER_EN	BIT(30)
+#define AR7240_MDIO_CTRL_BUSY		BIT(31)
+
+#define AR7240_REG_PORT_BASE(_port)	(0x100 + (_port) * 0x100)
+
+#define AR7240_REG_PORT_STATUS(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x00)
+#define AR7240_PORT_STATUS_SPEED_S	0
+#define AR7240_PORT_STATUS_SPEED_M	BITM(2)
+#define AR7240_PORT_STATUS_SPEED_10	0
+#define AR7240_PORT_STATUS_SPEED_100	1
+#define AR7240_PORT_STATUS_SPEED_1000	2
+#define AR7240_PORT_STATUS_TXMAC	BIT(2)
+#define AR7240_PORT_STATUS_RXMAC	BIT(3)
+#define AR7240_PORT_STATUS_TXFLOW	BIT(4)
+#define AR7240_PORT_STATUS_RXFLOW	BIT(5)
+#define AR7240_PORT_STATUS_DUPLEX	BIT(6)
+#define AR7240_PORT_STATUS_LINK_UP	BIT(8)
+#define AR7240_PORT_STATUS_LINK_AUTO	BIT(9)
+#define AR7240_PORT_STATUS_LINK_PAUSE	BIT(10)
+
+#define AR7240_REG_PORT_CTRL(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x04)
+#define AR7240_PORT_CTRL_STATE_M	BITM(3)
+#define	AR7240_PORT_CTRL_STATE_DISABLED	0
+#define AR7240_PORT_CTRL_STATE_BLOCK	1
+#define AR7240_PORT_CTRL_STATE_LISTEN	2
+#define AR7240_PORT_CTRL_STATE_LEARN	3
+#define AR7240_PORT_CTRL_STATE_FORWARD	4
+#define AR7240_PORT_CTRL_LEARN_LOCK	BIT(7)
+#define AR7240_PORT_CTRL_VLAN_MODE_S	8
+#define AR7240_PORT_CTRL_VLAN_MODE_KEEP	0
+#define AR7240_PORT_CTRL_VLAN_MODE_STRIP 1
+#define AR7240_PORT_CTRL_VLAN_MODE_ADD	2
+#define AR7240_PORT_CTRL_VLAN_MODE_DOUBLE_TAG 3
+#define AR7240_PORT_CTRL_IGMP_SNOOP	BIT(10)
+#define AR7240_PORT_CTRL_HEADER		BIT(11)
+#define AR7240_PORT_CTRL_MAC_LOOP	BIT(12)
+#define AR7240_PORT_CTRL_SINGLE_VLAN	BIT(13)
+#define AR7240_PORT_CTRL_LEARN		BIT(14)
+#define AR7240_PORT_CTRL_DOUBLE_TAG	BIT(15)
+#define AR7240_PORT_CTRL_MIRROR_TX	BIT(16)
+#define AR7240_PORT_CTRL_MIRROR_RX	BIT(17)
+
+#define AR7240_REG_PORT_VLAN(_port)	(AR7240_REG_PORT_BASE((_port)) + 0x08)
+
+#define AR7240_PORT_VLAN_DEFAULT_ID_S	0
+#define AR7240_PORT_VLAN_DEST_PORTS_S	16
+#define AR7240_PORT_VLAN_MODE_S		30
+#define AR7240_PORT_VLAN_MODE_PORT_ONLY	0
+#define AR7240_PORT_VLAN_MODE_PORT_FALLBACK	1
+#define AR7240_PORT_VLAN_MODE_VLAN_ONLY	2
+#define AR7240_PORT_VLAN_MODE_SECURE	3
+
+
+#define AR7240_REG_STATS_BASE(_port)	(0x20000 + (_port) * 0x100)
+
+#define AR7240_STATS_RXBROAD		0x00
+#define AR7240_STATS_RXPAUSE		0x04
+#define AR7240_STATS_RXMULTI		0x08
+#define AR7240_STATS_RXFCSERR		0x0c
+#define AR7240_STATS_RXALIGNERR		0x10
+#define AR7240_STATS_RXRUNT		0x14
+#define AR7240_STATS_RXFRAGMENT		0x18
+#define AR7240_STATS_RX64BYTE		0x1c
+#define AR7240_STATS_RX128BYTE		0x20
+#define AR7240_STATS_RX256BYTE		0x24
+#define AR7240_STATS_RX512BYTE		0x28
+#define AR7240_STATS_RX1024BYTE		0x2c
+#define AR7240_STATS_RX1518BYTE		0x30
+#define AR7240_STATS_RXMAXBYTE		0x34
+#define AR7240_STATS_RXTOOLONG		0x38
+#define AR7240_STATS_RXGOODBYTE		0x3c
+#define AR7240_STATS_RXBADBYTE		0x44
+#define AR7240_STATS_RXOVERFLOW		0x4c
+#define AR7240_STATS_FILTERED		0x50
+#define AR7240_STATS_TXBROAD		0x54
+#define AR7240_STATS_TXPAUSE		0x58
+#define AR7240_STATS_TXMULTI		0x5c
+#define AR7240_STATS_TXUNDERRUN		0x60
+#define AR7240_STATS_TX64BYTE		0x64
+#define AR7240_STATS_TX128BYTE		0x68
+#define AR7240_STATS_TX256BYTE		0x6c
+#define AR7240_STATS_TX512BYTE		0x70
+#define AR7240_STATS_TX1024BYTE		0x74
+#define AR7240_STATS_TX1518BYTE		0x78
+#define AR7240_STATS_TXMAXBYTE		0x7c
+#define AR7240_STATS_TXOVERSIZE		0x80
+#define AR7240_STATS_TXBYTE		0x84
+#define AR7240_STATS_TXCOLLISION	0x8c
+#define AR7240_STATS_TXABORTCOL		0x90
+#define AR7240_STATS_TXMULTICOL		0x94
+#define AR7240_STATS_TXSINGLECOL	0x98
+#define AR7240_STATS_TXEXCDEFER		0x9c
+#define AR7240_STATS_TXDEFER		0xa0
+#define AR7240_STATS_TXLATECOL		0xa4
+
+#define AR7240_PORT_CPU		0
+#define AR7240_NUM_PORTS	6
+#define AR7240_NUM_PHYS		5
+
+#define AR7240_PHY_ID1		0x004d
+#define AR7240_PHY_ID2		0xd041
+
+#define AR934X_PHY_ID1		0x004d
+#define AR934X_PHY_ID2		0xd042
+
+#define AR7240_MAX_VLANS	16
+
+#define AR934X_REG_OPER_MODE0		0x04
+#define   AR934X_OPER_MODE0_MAC_GMII_EN	BIT(6)
+#define   AR934X_OPER_MODE0_PHY_MII_EN	BIT(10)
+
+#define AR934X_REG_OPER_MODE1		0x08
+#define   AR934X_REG_OPER_MODE1_PHY4_MII_EN	BIT(28)
+
+#define AR934X_REG_FLOOD_MASK		0x2c
+#define   AR934X_FLOOD_MASK_MC_DP(_p)	BIT(16 + (_p))
+#define   AR934X_FLOOD_MASK_BC_DP(_p)	BIT(25 + (_p))
+
+#define AR934X_REG_QM_CTRL		0x3c
+#define   AR934X_QM_CTRL_ARP_EN		BIT(15)
+
+#define AR934X_REG_AT_CTRL		0x5c
+#define   AR934X_AT_CTRL_AGE_TIME	BITS(0, 15)
+#define   AR934X_AT_CTRL_AGE_EN		BIT(17)
+#define   AR934X_AT_CTRL_LEARN_CHANGE	BIT(18)
+
+#define AR934X_MIB_ENABLE		BIT(30)
+
+#define AR934X_REG_PORT_BASE(_port)	(0x100 + (_port) * 0x100)
+
+#define AR934X_REG_PORT_VLAN1(_port)	(AR934X_REG_PORT_BASE((_port)) + 0x08)
+#define   AR934X_PORT_VLAN1_DEFAULT_SVID_S		0
+#define   AR934X_PORT_VLAN1_FORCE_DEFAULT_VID_EN 	BIT(12)
+#define   AR934X_PORT_VLAN1_PORT_TLS_MODE		BIT(13)
+#define   AR934X_PORT_VLAN1_PORT_VLAN_PROP_EN		BIT(14)
+#define   AR934X_PORT_VLAN1_PORT_CLONE_EN		BIT(15)
+#define   AR934X_PORT_VLAN1_DEFAULT_CVID_S		16
+#define   AR934X_PORT_VLAN1_FORCE_PORT_VLAN_EN		BIT(28)
+#define   AR934X_PORT_VLAN1_ING_PORT_PRI_S		29
+
+#define AR934X_REG_PORT_VLAN2(_port)	(AR934X_REG_PORT_BASE((_port)) + 0x0c)
+#define   AR934X_PORT_VLAN2_PORT_VID_MEM_S		16
+#define   AR934X_PORT_VLAN2_8021Q_MODE_S		30
+#define   AR934X_PORT_VLAN2_8021Q_MODE_PORT_ONLY	0
+#define   AR934X_PORT_VLAN2_8021Q_MODE_PORT_FALLBACK	1
+#define   AR934X_PORT_VLAN2_8021Q_MODE_VLAN_ONLY	2
+#define   AR934X_PORT_VLAN2_8021Q_MODE_SECURE		3
+
+#define sw_to_ar7240(_dev) container_of(_dev, struct ar7240sw, swdev)
+
+struct ar7240sw_port_stat {
+	unsigned long rx_broadcast;
+	unsigned long rx_pause;
+	unsigned long rx_multicast;
+	unsigned long rx_fcs_error;
+	unsigned long rx_align_error;
+	unsigned long rx_runt;
+	unsigned long rx_fragments;
+	unsigned long rx_64byte;
+	unsigned long rx_128byte;
+	unsigned long rx_256byte;
+	unsigned long rx_512byte;
+	unsigned long rx_1024byte;
+	unsigned long rx_1518byte;
+	unsigned long rx_maxbyte;
+	unsigned long rx_toolong;
+	unsigned long rx_good_byte;
+	unsigned long rx_bad_byte;
+	unsigned long rx_overflow;
+	unsigned long filtered;
+
+	unsigned long tx_broadcast;
+	unsigned long tx_pause;
+	unsigned long tx_multicast;
+	unsigned long tx_underrun;
+	unsigned long tx_64byte;
+	unsigned long tx_128byte;
+	unsigned long tx_256byte;
+	unsigned long tx_512byte;
+	unsigned long tx_1024byte;
+	unsigned long tx_1518byte;
+	unsigned long tx_maxbyte;
+	unsigned long tx_oversize;
+	unsigned long tx_byte;
+	unsigned long tx_collision;
+	unsigned long tx_abortcol;
+	unsigned long tx_multicol;
+	unsigned long tx_singlecol;
+	unsigned long tx_excdefer;
+	unsigned long tx_defer;
+	unsigned long tx_xlatecol;
+};
+
+struct ar7240sw {
+	struct mii_bus	*mii_bus;
+	struct ag71xx_switch_platform_data *swdata;
+	struct switch_dev swdev;
+	int num_ports;
+	u8 ver;
+	bool vlan;
+	u16 vlan_id[AR7240_MAX_VLANS];
+	u8 vlan_table[AR7240_MAX_VLANS];
+	u8 vlan_tagged;
+	u16 pvid[AR7240_NUM_PORTS];
+	char buf[80];
+
+	rwlock_t stats_lock;
+	struct ar7240sw_port_stat port_stats[AR7240_NUM_PORTS];
+};
+
+struct ar7240sw_hw_stat {
+	char string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int reg;
+};
+
+static DEFINE_MUTEX(reg_mutex);
+
+static inline int sw_is_ar7240(struct ar7240sw *as)
+{
+	return as->ver == AR7240_MASK_CTRL_VERSION_AR7240;
+}
+
+static inline int sw_is_ar934x(struct ar7240sw *as)
+{
+	return as->ver == AR7240_MASK_CTRL_VERSION_AR934X;
+}
+
+static inline u32 ar7240sw_port_mask(struct ar7240sw *as, int port)
+{
+	return BIT(port);
+}
+
+static inline u32 ar7240sw_port_mask_all(struct ar7240sw *as)
+{
+	return BIT(as->swdev.ports) - 1;
+}
+
+static inline u32 ar7240sw_port_mask_but(struct ar7240sw *as, int port)
+{
+	return ar7240sw_port_mask_all(as) & ~BIT(port);
+}
+
+static inline u16 mk_phy_addr(u32 reg)
+{
+	return 0x17 & ((reg >> 4) | 0x10);
+}
+
+static inline u16 mk_phy_reg(u32 reg)
+{
+	return (reg << 1) & 0x1e;
+}
+
+static inline u16 mk_high_addr(u32 reg)
+{
+	return (reg >> 7) & 0x1ff;
+}
+
+static u32 __ar7240sw_reg_read(struct mii_bus *mii, u32 reg)
+{
+	unsigned long flags;
+	u16 phy_addr;
+	u16 phy_reg;
+	u32 hi, lo;
+
+	reg = (reg & 0xfffffffc) >> 2;
+	phy_addr = mk_phy_addr(reg);
+	phy_reg = mk_phy_reg(reg);
+
+	local_irq_save(flags);
+	ag71xx_mdio_mii_write(mii->priv, 0x1f, 0x10, mk_high_addr(reg));
+	lo = (u32) ag71xx_mdio_mii_read(mii->priv, phy_addr, phy_reg);
+	hi = (u32) ag71xx_mdio_mii_read(mii->priv, phy_addr, phy_reg + 1);
+	local_irq_restore(flags);
+
+	return (hi << 16) | lo;
+}
+
+static void __ar7240sw_reg_write(struct mii_bus *mii, u32 reg, u32 val)
+{
+	unsigned long flags;
+	u16 phy_addr;
+	u16 phy_reg;
+
+	reg = (reg & 0xfffffffc) >> 2;
+	phy_addr = mk_phy_addr(reg);
+	phy_reg = mk_phy_reg(reg);
+
+	local_irq_save(flags);
+	ag71xx_mdio_mii_write(mii->priv, 0x1f, 0x10, mk_high_addr(reg));
+	ag71xx_mdio_mii_write(mii->priv, phy_addr, phy_reg + 1, (val >> 16));
+	ag71xx_mdio_mii_write(mii->priv, phy_addr, phy_reg, (val & 0xffff));
+	local_irq_restore(flags);
+}
+
+static u32 ar7240sw_reg_read(struct mii_bus *mii, u32 reg_addr)
+{
+	u32 ret;
+
+	mutex_lock(&reg_mutex);
+	ret = __ar7240sw_reg_read(mii, reg_addr);
+	mutex_unlock(&reg_mutex);
+
+	return ret;
+}
+
+static void ar7240sw_reg_write(struct mii_bus *mii, u32 reg_addr, u32 reg_val)
+{
+	mutex_lock(&reg_mutex);
+	__ar7240sw_reg_write(mii, reg_addr, reg_val);
+	mutex_unlock(&reg_mutex);
+}
+
+static u32 ar7240sw_reg_rmw(struct mii_bus *mii, u32 reg, u32 mask, u32 val)
+{
+	u32 t;
+
+	mutex_lock(&reg_mutex);
+	t = __ar7240sw_reg_read(mii, reg);
+	t &= ~mask;
+	t |= val;
+	__ar7240sw_reg_write(mii, reg, t);
+	mutex_unlock(&reg_mutex);
+
+	return t;
+}
+
+static void ar7240sw_reg_set(struct mii_bus *mii, u32 reg, u32 val)
+{
+	u32 t;
+
+	mutex_lock(&reg_mutex);
+	t = __ar7240sw_reg_read(mii, reg);
+	t |= val;
+	__ar7240sw_reg_write(mii, reg, t);
+	mutex_unlock(&reg_mutex);
+}
+
+static int __ar7240sw_reg_wait(struct mii_bus *mii, u32 reg, u32 mask, u32 val,
+			       unsigned timeout)
+{
+	int i;
+
+	for (i = 0; i < timeout; i++) {
+		u32 t;
+
+		t = __ar7240sw_reg_read(mii, reg);
+		if ((t & mask) == val)
+			return 0;
+
+		usleep_range(1000, 2000);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int ar7240sw_reg_wait(struct mii_bus *mii, u32 reg, u32 mask, u32 val,
+			     unsigned timeout)
+{
+	int ret;
+
+	mutex_lock(&reg_mutex);
+	ret = __ar7240sw_reg_wait(mii, reg, mask, val, timeout);
+	mutex_unlock(&reg_mutex);
+	return ret;
+}
+
+u16 ar7240sw_phy_read(struct mii_bus *mii, unsigned phy_addr,
+		      unsigned reg_addr)
+{
+	u32 t, val = 0xffff;
+	int err;
+
+	if (phy_addr >= AR7240_NUM_PHYS)
+		return 0xffff;
+
+	mutex_lock(&reg_mutex);
+	t = (reg_addr << AR7240_MDIO_CTRL_REG_ADDR_S) |
+	    (phy_addr << AR7240_MDIO_CTRL_PHY_ADDR_S) |
+	    AR7240_MDIO_CTRL_MASTER_EN |
+	    AR7240_MDIO_CTRL_BUSY |
+	    AR7240_MDIO_CTRL_CMD_READ;
+
+	__ar7240sw_reg_write(mii, AR7240_REG_MDIO_CTRL, t);
+	err = __ar7240sw_reg_wait(mii, AR7240_REG_MDIO_CTRL,
+				  AR7240_MDIO_CTRL_BUSY, 0, 5);
+	if (!err)
+		val = __ar7240sw_reg_read(mii, AR7240_REG_MDIO_CTRL);
+	mutex_unlock(&reg_mutex);
+
+	return val & AR7240_MDIO_CTRL_DATA_M;
+}
+
+int ar7240sw_phy_write(struct mii_bus *mii, unsigned phy_addr,
+		       unsigned reg_addr, u16 reg_val)
+{
+	u32 t;
+	int ret;
+
+	if (phy_addr >= AR7240_NUM_PHYS)
+		return -EINVAL;
+
+	mutex_lock(&reg_mutex);
+	t = (phy_addr << AR7240_MDIO_CTRL_PHY_ADDR_S) |
+	    (reg_addr << AR7240_MDIO_CTRL_REG_ADDR_S) |
+	    AR7240_MDIO_CTRL_MASTER_EN |
+	    AR7240_MDIO_CTRL_BUSY |
+	    AR7240_MDIO_CTRL_CMD_WRITE |
+	    reg_val;
+
+	__ar7240sw_reg_write(mii, AR7240_REG_MDIO_CTRL, t);
+	ret = __ar7240sw_reg_wait(mii, AR7240_REG_MDIO_CTRL,
+				  AR7240_MDIO_CTRL_BUSY, 0, 5);
+	mutex_unlock(&reg_mutex);
+
+	return ret;
+}
+
+static int ar7240sw_capture_stats(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+	int port;
+	int ret;
+
+	write_lock(&as->stats_lock);
+
+	/* Capture the hardware statistics for all ports */
+	ar7240sw_reg_rmw(mii, AR7240_REG_MIB_FUNCTION0,
+			 (AR7240_MIB_FUNC_M << AR7240_MIB_FUNC_S),
+			 (AR7240_MIB_FUNC_CAPTURE << AR7240_MIB_FUNC_S));
+
+	/* Wait for the capturing to complete. */
+	ret = ar7240sw_reg_wait(mii, AR7240_REG_MIB_FUNCTION0,
+				AR7240_MIB_BUSY, 0, 10);
+
+	if (ret)
+		goto unlock;
+
+	for (port = 0; port < AR7240_NUM_PORTS; port++) {
+		unsigned int base;
+		struct ar7240sw_port_stat *stats;
+
+		base = AR7240_REG_STATS_BASE(port);
+		stats = &as->port_stats[port];
+
+#define READ_STAT(_r) ar7240sw_reg_read(mii, base + AR7240_STATS_ ## _r)
+
+		stats->rx_good_byte += READ_STAT(RXGOODBYTE);
+		stats->tx_byte += READ_STAT(TXBYTE);
+
+#undef READ_STAT
+	}
+
+	ret = 0;
+
+unlock:
+	write_unlock(&as->stats_lock);
+	return ret;
+}
+
+static void ar7240sw_disable_port(struct ar7240sw *as, unsigned port)
+{
+	ar7240sw_reg_write(as->mii_bus, AR7240_REG_PORT_CTRL(port),
+			   AR7240_PORT_CTRL_STATE_DISABLED);
+}
+
+static void ar7240sw_setup(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+
+	/* Enable CPU port, and disable mirror port */
+	ar7240sw_reg_write(mii, AR7240_REG_CPU_PORT,
+			   AR7240_CPU_PORT_EN |
+			   (15 << AR7240_MIRROR_PORT_S));
+
+	/* Setup TAG priority mapping */
+	ar7240sw_reg_write(mii, AR7240_REG_TAG_PRIORITY, 0xfa50);
+
+	if (sw_is_ar934x(as)) {
+		/* Enable aging, MAC replacing */
+		ar7240sw_reg_write(mii, AR934X_REG_AT_CTRL,
+			0x2b /* 5 min age time */ |
+			AR934X_AT_CTRL_AGE_EN |
+			AR934X_AT_CTRL_LEARN_CHANGE);
+		/* Enable ARP frame acknowledge */
+		ar7240sw_reg_set(mii, AR934X_REG_QM_CTRL,
+				 AR934X_QM_CTRL_ARP_EN);
+		/* Enable Broadcast/Multicast frames transmitted to the CPU */
+		ar7240sw_reg_set(mii, AR934X_REG_FLOOD_MASK,
+				 AR934X_FLOOD_MASK_BC_DP(0) |
+				 AR934X_FLOOD_MASK_MC_DP(0));
+
+		/* setup MTU */
+		ar7240sw_reg_rmw(mii, AR7240_REG_GLOBAL_CTRL,
+				 AR9340_GLOBAL_CTRL_MTU_M,
+				 AR9340_GLOBAL_CTRL_MTU_M);
+
+		/* Enable MIB counters */
+		ar7240sw_reg_set(mii, AR7240_REG_MIB_FUNCTION0,
+				 AR934X_MIB_ENABLE);
+
+	} else {
+		/* Enable ARP frame acknowledge, aging, MAC replacing */
+		ar7240sw_reg_write(mii, AR7240_REG_AT_CTRL,
+			AR7240_AT_CTRL_RESERVED |
+			0x2b /* 5 min age time */ |
+			AR7240_AT_CTRL_AGE_EN |
+			AR7240_AT_CTRL_ARP_EN |
+			AR7240_AT_CTRL_LEARN_CHANGE);
+		/* Enable Broadcast frames transmitted to the CPU */
+		ar7240sw_reg_set(mii, AR7240_REG_FLOOD_MASK,
+				 AR7240_FLOOD_MASK_BROAD_TO_CPU);
+
+		/* setup MTU */
+		ar7240sw_reg_rmw(mii, AR7240_REG_GLOBAL_CTRL,
+				 AR7240_GLOBAL_CTRL_MTU_M,
+				 AR7240_GLOBAL_CTRL_MTU_M);
+	}
+
+	/* setup Service TAG */
+	ar7240sw_reg_rmw(mii, AR7240_REG_SERVICE_TAG, AR7240_SERVICE_TAG_M, 0);
+}
+
+/* inspired by phy_poll_reset in drivers/net/phy/phy_device.c */
+static int
+ar7240sw_phy_poll_reset(struct mii_bus *bus)
+{
+	const unsigned int sleep_msecs = 20;
+	int ret, elapsed, i;
+
+	for (elapsed = sleep_msecs; elapsed <= 600;
+	     elapsed += sleep_msecs) {
+		msleep(sleep_msecs);
+		for (i = 0; i < AR7240_NUM_PHYS; i++) {
+			ret = ar7240sw_phy_read(bus, i, MII_BMCR);
+			if (ret < 0)
+				return ret;
+			if (ret & BMCR_RESET)
+				break;
+			if (i == AR7240_NUM_PHYS - 1) {
+				usleep_range(1000, 2000);
+				return 0;
+			}
+		}
+	}
+	return -ETIMEDOUT;
+}
+
+static int ar7240sw_reset(struct ar7240sw *as)
+{
+	struct mii_bus *mii = as->mii_bus;
+	int ret;
+	int i;
+
+	/* Set all ports to disabled state. */
+	for (i = 0; i < AR7240_NUM_PORTS; i++)
+		ar7240sw_disable_port(as, i);
+
+	/* Wait for transmit queues to drain. */
+	usleep_range(2000, 3000);
+
+	/* Reset the switch. */
+	ar7240sw_reg_write(mii, AR7240_REG_MASK_CTRL,
+			   AR7240_MASK_CTRL_SOFT_RESET);
+
+	ret = ar7240sw_reg_wait(mii, AR7240_REG_MASK_CTRL,
+				AR7240_MASK_CTRL_SOFT_RESET, 0, 1000);
+
+	/* setup PHYs */
+	for (i = 0; i < AR7240_NUM_PHYS; i++) {
+		ar7240sw_phy_write(mii, i, MII_ADVERTISE,
+				   ADVERTISE_ALL | ADVERTISE_PAUSE_CAP |
+				   ADVERTISE_PAUSE_ASYM);
+		ar7240sw_phy_write(mii, i, MII_BMCR,
+				   BMCR_RESET | BMCR_ANENABLE);
+	}
+	ret = ar7240sw_phy_poll_reset(mii);
+	if (ret)
+		return ret;
+
+	ar7240sw_setup(as);
+	return ret;
+}
+
+static void ar7240sw_setup_port(struct ar7240sw *as, unsigned port, u8 portmask)
+{
+	struct mii_bus *mii = as->mii_bus;
+	u32 ctrl;
+	u32 vid, mode;
+
+	ctrl = AR7240_PORT_CTRL_STATE_FORWARD | AR7240_PORT_CTRL_LEARN |
+		AR7240_PORT_CTRL_SINGLE_VLAN;
+
+	if (port == AR7240_PORT_CPU) {
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_STATUS(port),
+				   AR7240_PORT_STATUS_SPEED_1000 |
+				   AR7240_PORT_STATUS_TXFLOW |
+				   AR7240_PORT_STATUS_RXFLOW |
+				   AR7240_PORT_STATUS_TXMAC |
+				   AR7240_PORT_STATUS_RXMAC |
+				   AR7240_PORT_STATUS_DUPLEX);
+	} else {
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_STATUS(port),
+				   AR7240_PORT_STATUS_LINK_AUTO);
+	}
+
+	/* Set the default VID for this port */
+	if (as->vlan) {
+		vid = as->vlan_id[as->pvid[port]];
+		mode = AR7240_PORT_VLAN_MODE_SECURE;
+	} else {
+		vid = port;
+		mode = AR7240_PORT_VLAN_MODE_PORT_ONLY;
+	}
+
+	if (as->vlan) {
+		if (as->vlan_tagged & BIT(port))
+			ctrl |= AR7240_PORT_CTRL_VLAN_MODE_ADD <<
+				AR7240_PORT_CTRL_VLAN_MODE_S;
+		else
+			ctrl |= AR7240_PORT_CTRL_VLAN_MODE_STRIP <<
+				AR7240_PORT_CTRL_VLAN_MODE_S;
+	} else {
+		ctrl |= AR7240_PORT_CTRL_VLAN_MODE_KEEP <<
+			AR7240_PORT_CTRL_VLAN_MODE_S;
+	}
+
+	if (!portmask) {
+		if (port == AR7240_PORT_CPU)
+			portmask = ar7240sw_port_mask_but(as, AR7240_PORT_CPU);
+		else
+			portmask = ar7240sw_port_mask(as, AR7240_PORT_CPU);
+	}
+
+	/* allow the port to talk to all other ports, but exclude its
+	 * own ID to prevent frames from being reflected back to the
+	 * port that they came from */
+	portmask &= ar7240sw_port_mask_but(as, port);
+
+	ar7240sw_reg_write(mii, AR7240_REG_PORT_CTRL(port), ctrl);
+	if (sw_is_ar934x(as)) {
+		u32 vlan1, vlan2;
+
+		vlan1 = (vid << AR934X_PORT_VLAN1_DEFAULT_CVID_S);
+		vlan2 = (portmask << AR934X_PORT_VLAN2_PORT_VID_MEM_S) |
+			(mode << AR934X_PORT_VLAN2_8021Q_MODE_S);
+		ar7240sw_reg_write(mii, AR934X_REG_PORT_VLAN1(port), vlan1);
+		ar7240sw_reg_write(mii, AR934X_REG_PORT_VLAN2(port), vlan2);
+	} else {
+		u32 vlan;
+
+		vlan = vid | (mode << AR7240_PORT_VLAN_MODE_S) |
+		       (portmask << AR7240_PORT_VLAN_DEST_PORTS_S);
+
+		ar7240sw_reg_write(mii, AR7240_REG_PORT_VLAN(port), vlan);
+	}
+}
+
+static int ar7240_set_addr(struct ar7240sw *as, u8 *addr)
+{
+	struct mii_bus *mii = as->mii_bus;
+	u32 t;
+
+	t = (addr[4] << 8) | addr[5];
+	ar7240sw_reg_write(mii, AR7240_REG_MAC_ADDR0, t);
+
+	t = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];
+	ar7240sw_reg_write(mii, AR7240_REG_MAC_ADDR1, t);
+
+	return 0;
+}
+
+static int
+ar7240_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	as->vlan_id[val->port_vlan] = val->value.i;
+	return 0;
+}
+
+static int
+ar7240_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	val->value.i = as->vlan_id[val->port_vlan];
+	return 0;
+}
+
+static int
+ar7240_set_pvid(struct switch_dev *dev, int port, int vlan)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+
+	/* make sure no invalid PVIDs get set */
+
+	if (vlan >= dev->vlans)
+		return -EINVAL;
+
+	as->pvid[port] = vlan;
+	return 0;
+}
+
+static int
+ar7240_get_pvid(struct switch_dev *dev, int port, int *vlan)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	*vlan = as->pvid[port];
+	return 0;
+}
+
+static int
+ar7240_get_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 ports = as->vlan_table[val->port_vlan];
+	int i;
+
+	val->len = 0;
+	for (i = 0; i < as->swdev.ports; i++) {
+		struct switch_port *p;
+
+		if (!(ports & (1 << i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+		if (as->vlan_tagged & (1 << i))
+			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
+		else
+			p->flags = 0;
+	}
+	return 0;
+}
+
+static int
+ar7240_set_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 *vt = &as->vlan_table[val->port_vlan];
+	int i, j;
+
+	*vt = 0;
+	for (i = 0; i < val->len; i++) {
+		struct switch_port *p = &val->value.ports[i];
+
+		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED))
+			as->vlan_tagged |= (1 << p->id);
+		else {
+			as->vlan_tagged &= ~(1 << p->id);
+			as->pvid[p->id] = val->port_vlan;
+
+			/* make sure that an untagged port does not
+			 * appear in other vlans */
+			for (j = 0; j < AR7240_MAX_VLANS; j++) {
+				if (j == val->port_vlan)
+					continue;
+				as->vlan_table[j] &= ~(1 << p->id);
+			}
+		}
+
+		*vt |= 1 << p->id;
+	}
+	return 0;
+}
+
+static int
+ar7240_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	as->vlan = !!val->value.i;
+	return 0;
+}
+
+static int
+ar7240_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	val->value.i = as->vlan;
+	return 0;
+}
+
+static void
+ar7240_vtu_op(struct ar7240sw *as, u32 op, u32 val)
+{
+	struct mii_bus *mii = as->mii_bus;
+
+	if (ar7240sw_reg_wait(mii, AR7240_REG_VTU, AR7240_VTU_ACTIVE, 0, 5))
+		return;
+
+	if ((op & AR7240_VTU_OP) == AR7240_VTU_OP_LOAD) {
+		val &= AR7240_VTUDATA_MEMBER;
+		val |= AR7240_VTUDATA_VALID;
+		ar7240sw_reg_write(mii, AR7240_REG_VTU_DATA, val);
+	}
+	op |= AR7240_VTU_ACTIVE;
+	ar7240sw_reg_write(mii, AR7240_REG_VTU, op);
+}
+
+static int
+ar7240_hw_apply(struct switch_dev *dev)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	u8 portmask[AR7240_NUM_PORTS];
+	int i, j;
+
+	/* flush all vlan translation unit entries */
+	ar7240_vtu_op(as, AR7240_VTU_OP_FLUSH, 0);
+
+	memset(portmask, 0, sizeof(portmask));
+	if (as->vlan) {
+		/* calculate the port destination masks and load vlans
+		 * into the vlan translation unit */
+		for (j = 0; j < AR7240_MAX_VLANS; j++) {
+			u8 vp = as->vlan_table[j];
+
+			if (!vp)
+				continue;
+
+			for (i = 0; i < as->swdev.ports; i++) {
+				u8 mask = (1 << i);
+				if (vp & mask)
+					portmask[i] |= vp & ~mask;
+			}
+
+			ar7240_vtu_op(as,
+				AR7240_VTU_OP_LOAD |
+				(as->vlan_id[j] << AR7240_VTU_VID_S),
+				as->vlan_table[j]);
+		}
+	} else {
+		/* vlan disabled:
+		 * isolate all ports, but connect them to the cpu port */
+		for (i = 0; i < as->swdev.ports; i++) {
+			if (i == AR7240_PORT_CPU)
+				continue;
+
+			portmask[i] = 1 << AR7240_PORT_CPU;
+			portmask[AR7240_PORT_CPU] |= (1 << i);
+		}
+	}
+
+	/* update the port destination mask registers and tag settings */
+	for (i = 0; i < as->swdev.ports; i++)
+		ar7240sw_setup_port(as, i, portmask[i]);
+
+	return 0;
+}
+
+static int
+ar7240_reset_switch(struct switch_dev *dev)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	ar7240sw_reset(as);
+	return 0;
+}
+
+static int
+ar7240_get_port_link(struct switch_dev *dev, int port,
+		     struct switch_port_link *link)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+	struct mii_bus *mii = as->mii_bus;
+	u32 status;
+
+	if (port > AR7240_NUM_PORTS)
+		return -EINVAL;
+
+	status = ar7240sw_reg_read(mii, AR7240_REG_PORT_STATUS(port));
+	link->aneg = !!(status & AR7240_PORT_STATUS_LINK_AUTO);
+	if (link->aneg) {
+		link->link = !!(status & AR7240_PORT_STATUS_LINK_UP);
+		if (!link->link)
+			return 0;
+	} else {
+		link->link = true;
+	}
+
+	link->duplex = !!(status & AR7240_PORT_STATUS_DUPLEX);
+	link->tx_flow = !!(status & AR7240_PORT_STATUS_TXFLOW);
+	link->rx_flow = !!(status & AR7240_PORT_STATUS_RXFLOW);
+	switch (status & AR7240_PORT_STATUS_SPEED_M) {
+	case AR7240_PORT_STATUS_SPEED_10:
+		link->speed = SWITCH_PORT_SPEED_10;
+		break;
+	case AR7240_PORT_STATUS_SPEED_100:
+		link->speed = SWITCH_PORT_SPEED_100;
+		break;
+	case AR7240_PORT_STATUS_SPEED_1000:
+		link->speed = SWITCH_PORT_SPEED_1000;
+		break;
+	}
+
+	return 0;
+}
+
+static int
+ar7240_get_port_stats(struct switch_dev *dev, int port,
+		      struct switch_port_stats *stats)
+{
+	struct ar7240sw *as = sw_to_ar7240(dev);
+
+	if (port > AR7240_NUM_PORTS)
+		return -EINVAL;
+
+	ar7240sw_capture_stats(as);
+
+	read_lock(&as->stats_lock);
+	stats->rx_bytes = as->port_stats[port].rx_good_byte;
+	stats->tx_bytes = as->port_stats[port].tx_byte;
+	read_unlock(&as->stats_lock);
+
+	return 0;
+}
+
+static struct switch_attr ar7240_globals[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = ar7240_set_vlan,
+		.get = ar7240_get_vlan,
+		.max = 1
+	},
+};
+
+static struct switch_attr ar7240_port[] = {
+};
+
+static struct switch_attr ar7240_vlan[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "vid",
+		.description = "VLAN ID",
+		.set = ar7240_set_vid,
+		.get = ar7240_get_vid,
+		.max = 4094,
+	},
+};
+
+static const struct switch_dev_ops ar7240_ops = {
+	.attr_global = {
+		.attr = ar7240_globals,
+		.n_attr = ARRAY_SIZE(ar7240_globals),
+	},
+	.attr_port = {
+		.attr = ar7240_port,
+		.n_attr = ARRAY_SIZE(ar7240_port),
+	},
+	.attr_vlan = {
+		.attr = ar7240_vlan,
+		.n_attr = ARRAY_SIZE(ar7240_vlan),
+	},
+	.get_port_pvid = ar7240_get_pvid,
+	.set_port_pvid = ar7240_set_pvid,
+	.get_vlan_ports = ar7240_get_ports,
+	.set_vlan_ports = ar7240_set_ports,
+	.apply_config = ar7240_hw_apply,
+	.reset_switch = ar7240_reset_switch,
+	.get_port_link = ar7240_get_port_link,
+	.get_port_stats = ar7240_get_port_stats,
+};
+
+static struct ar7240sw *ar7240_probe(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct mii_bus *mii = ag->mii_bus;
+	struct ar7240sw *as;
+	struct switch_dev *swdev;
+	u32 ctrl;
+	u16 phy_id1;
+	u16 phy_id2;
+	int i;
+
+	phy_id1 = ar7240sw_phy_read(mii, 0, MII_PHYSID1);
+	phy_id2 = ar7240sw_phy_read(mii, 0, MII_PHYSID2);
+	if ((phy_id1 != AR7240_PHY_ID1 || phy_id2 != AR7240_PHY_ID2) &&
+	    (phy_id1 != AR934X_PHY_ID1 || phy_id2 != AR934X_PHY_ID2)) {
+		pr_err("%s: unknown phy id '%04x:%04x'\n",
+		       dev_name(&mii->dev), phy_id1, phy_id2);
+		return NULL;
+	}
+
+	as = kzalloc(sizeof(*as), GFP_KERNEL);
+	if (!as)
+		return NULL;
+
+	as->mii_bus = mii;
+	as->swdata = pdata->switch_data;
+
+	swdev = &as->swdev;
+
+	ctrl = ar7240sw_reg_read(mii, AR7240_REG_MASK_CTRL);
+	as->ver = (ctrl >> AR7240_MASK_CTRL_VERSION_S) &
+		  AR7240_MASK_CTRL_VERSION_M;
+
+	if (sw_is_ar7240(as)) {
+		swdev->name = "AR7240/AR9330 built-in switch";
+		swdev->ports = AR7240_NUM_PORTS - 1;
+	} else if (sw_is_ar934x(as)) {
+		swdev->name = "AR934X built-in switch";
+
+		if (pdata->phy_if_mode == PHY_INTERFACE_MODE_GMII) {
+			ar7240sw_reg_set(mii, AR934X_REG_OPER_MODE0,
+					 AR934X_OPER_MODE0_MAC_GMII_EN);
+		} else if (pdata->phy_if_mode == PHY_INTERFACE_MODE_MII) {
+			ar7240sw_reg_set(mii, AR934X_REG_OPER_MODE0,
+					 AR934X_OPER_MODE0_PHY_MII_EN);
+		} else {
+			pr_err("%s: invalid PHY interface mode\n",
+			       dev_name(&mii->dev));
+			goto err_free;
+		}
+
+		if (as->swdata->phy4_mii_en) {
+			ar7240sw_reg_set(mii, AR934X_REG_OPER_MODE1,
+					 AR934X_REG_OPER_MODE1_PHY4_MII_EN);
+			swdev->ports = AR7240_NUM_PORTS - 1;
+		} else {
+			swdev->ports = AR7240_NUM_PORTS;
+		}
+	} else {
+		pr_err("%s: unsupported chip, ctrl=%08x\n",
+			dev_name(&mii->dev), ctrl);
+		goto err_free;
+	}
+
+	swdev->cpu_port = AR7240_PORT_CPU;
+	swdev->vlans = AR7240_MAX_VLANS;
+	swdev->ops = &ar7240_ops;
+
+	if (register_switch(&as->swdev, ag->dev) < 0)
+		goto err_free;
+
+	pr_info("%s: Found an %s\n", dev_name(&mii->dev), swdev->name);
+
+	/* initialize defaults */
+	for (i = 0; i < AR7240_MAX_VLANS; i++)
+		as->vlan_id[i] = i;
+
+	as->vlan_table[0] = ar7240sw_port_mask_all(as);
+
+	return as;
+
+err_free:
+	kfree(as);
+	return NULL;
+}
+
+static void link_function(struct work_struct *work) {
+	struct ag71xx *ag = container_of(work, struct ag71xx, link_work.work);
+	struct ar7240sw *as = ag->phy_priv;
+	unsigned long flags;
+	u8 mask;
+	int i;
+	int status = 0;
+
+	mask = ~as->swdata->phy_poll_mask;
+	for (i = 0; i < AR7240_NUM_PHYS; i++) {
+		int link;
+
+		if (!(mask & BIT(i)))
+			continue;
+
+		link = ar7240sw_phy_read(ag->mii_bus, i, MII_BMSR);
+		if (link & BMSR_LSTATUS) {
+			status = 1;
+			break;
+		}
+	}
+
+	spin_lock_irqsave(&ag->lock, flags);
+	if (status != ag->link) {
+		ag->link = status;
+		ag71xx_link_adjust(ag);
+	}
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	schedule_delayed_work(&ag->link_work, HZ / 2);
+}
+
+void ag71xx_ar7240_start(struct ag71xx *ag)
+{
+	struct ar7240sw *as = ag->phy_priv;
+
+	ar7240sw_reset(as);
+
+	ag->speed = SPEED_1000;
+	ag->duplex = 1;
+
+	ar7240_set_addr(as, ag->dev->dev_addr);
+	ar7240_hw_apply(&as->swdev);
+
+	schedule_delayed_work(&ag->link_work, HZ / 10);
+}
+
+void ag71xx_ar7240_stop(struct ag71xx *ag)
+{
+	cancel_delayed_work_sync(&ag->link_work);
+}
+
+int ag71xx_ar7240_init(struct ag71xx *ag)
+{
+	struct ar7240sw *as;
+
+	as = ar7240_probe(ag);
+	if (!as)
+		return -ENODEV;
+
+	ag->phy_priv = as;
+	ar7240sw_reset(as);
+
+	rwlock_init(&as->stats_lock);
+	INIT_DELAYED_WORK(&ag->link_work, link_function);
+
+	return 0;
+}
+
+void ag71xx_ar7240_cleanup(struct ag71xx *ag)
+{
+	struct ar7240sw *as = ag->phy_priv;
+
+	if (!as)
+		return;
+
+	unregister_switch(&as->swdev);
+	kfree(as);
+	ag->phy_priv = NULL;
+}
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_ar8216.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,44 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *  Special support for the Atheros ar8216 switch chip
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+#define AR8216_PACKET_TYPE_MASK		0xf
+#define AR8216_PACKET_TYPE_NORMAL	0
+
+#define AR8216_HEADER_LEN	2
+
+void ag71xx_add_ar8216_header(struct ag71xx *ag, struct sk_buff *skb)
+{
+	skb_push(skb, AR8216_HEADER_LEN);
+	skb->data[0] = 0x10;
+	skb->data[1] = 0x80;
+}
+
+int ag71xx_remove_ar8216_header(struct ag71xx *ag, struct sk_buff *skb,
+				int pktlen)
+{
+	u8 type;
+
+	type = skb->data[1] & AR8216_PACKET_TYPE_MASK;
+	switch (type) {
+	case AR8216_PACKET_TYPE_NORMAL:
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	skb_pull(skb, AR8216_HEADER_LEN);
+	return 0;
+}
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_debugfs.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,285 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/debugfs.h>
+
+#include "ag71xx.h"
+
+static struct dentry *ag71xx_debugfs_root;
+
+static int ag71xx_debugfs_generic_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+void ag71xx_debugfs_update_int_stats(struct ag71xx *ag, u32 status)
+{
+	if (status)
+		ag->debug.int_stats.total++;
+	if (status & AG71XX_INT_TX_PS)
+		ag->debug.int_stats.tx_ps++;
+	if (status & AG71XX_INT_TX_UR)
+		ag->debug.int_stats.tx_ur++;
+	if (status & AG71XX_INT_TX_BE)
+		ag->debug.int_stats.tx_be++;
+	if (status & AG71XX_INT_RX_PR)
+		ag->debug.int_stats.rx_pr++;
+	if (status & AG71XX_INT_RX_OF)
+		ag->debug.int_stats.rx_of++;
+	if (status & AG71XX_INT_RX_BE)
+		ag->debug.int_stats.rx_be++;
+}
+
+static ssize_t read_file_int_stats(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+#define PR_INT_STAT(_label, _field)					\
+	len += snprintf(buf + len, sizeof(buf) - len,			\
+		"%20s: %10lu\n", _label, ag->debug.int_stats._field);
+
+	struct ag71xx *ag = file->private_data;
+	char buf[256];
+	unsigned int len = 0;
+
+	PR_INT_STAT("TX Packet Sent", tx_ps);
+	PR_INT_STAT("TX Underrun", tx_ur);
+	PR_INT_STAT("TX Bus Error", tx_be);
+	PR_INT_STAT("RX Packet Received", rx_pr);
+	PR_INT_STAT("RX Overflow", rx_of);
+	PR_INT_STAT("RX Bus Error", rx_be);
+	len += snprintf(buf + len, sizeof(buf) - len, "\n");
+	PR_INT_STAT("Total", total);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+#undef PR_INT_STAT
+}
+
+static const struct file_operations ag71xx_fops_int_stats = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_int_stats,
+	.owner	= THIS_MODULE
+};
+
+void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag, int rx, int tx)
+{
+	struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;
+
+	if (rx) {
+		stats->rx_count++;
+		stats->rx_packets += rx;
+		if (rx <= AG71XX_NAPI_WEIGHT)
+			stats->rx[rx]++;
+		if (rx > stats->rx_packets_max)
+			stats->rx_packets_max = rx;
+	}
+
+	if (tx) {
+		stats->tx_count++;
+		stats->tx_packets += tx;
+		if (tx <= AG71XX_NAPI_WEIGHT)
+			stats->tx[tx]++;
+		if (tx > stats->tx_packets_max)
+			stats->tx_packets_max = tx;
+	}
+}
+
+static ssize_t read_file_napi_stats(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+	struct ag71xx_napi_stats *stats = &ag->debug.napi_stats;
+	char *buf;
+	unsigned int buflen;
+	unsigned int len = 0;
+	unsigned long rx_avg = 0;
+	unsigned long tx_avg = 0;
+	int ret;
+	int i;
+
+	buflen = 2048;
+	buf = kmalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (stats->rx_count)
+		rx_avg = stats->rx_packets / stats->rx_count;
+
+	if (stats->tx_count)
+		tx_avg = stats->tx_packets / stats->tx_count;
+
+	len += snprintf(buf + len, buflen - len, "%3s  %10s %10s\n",
+			"len", "rx", "tx");
+
+	for (i = 1; i <= AG71XX_NAPI_WEIGHT; i++)
+		len += snprintf(buf + len, buflen - len,
+				"%3d: %10lu %10lu\n",
+				i, stats->rx[i], stats->tx[i]);
+
+	len += snprintf(buf + len, buflen - len, "\n");
+
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"sum", stats->rx_count, stats->tx_count);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"avg", rx_avg, tx_avg);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"max", stats->rx_packets_max, stats->tx_packets_max);
+	len += snprintf(buf + len, buflen - len, "%3s: %10lu %10lu\n",
+			"pkt", stats->rx_packets, stats->tx_packets);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations ag71xx_fops_napi_stats = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_napi_stats,
+	.owner	= THIS_MODULE
+};
+
+#define DESC_PRINT_LEN	64
+
+static ssize_t read_file_ring(struct file *file, char __user *user_buf,
+			      size_t count, loff_t *ppos,
+			      struct ag71xx *ag,
+			      struct ag71xx_ring *ring,
+			      unsigned desc_reg)
+{
+	char *buf;
+	unsigned int buflen;
+	unsigned int len = 0;
+	unsigned long flags;
+	ssize_t ret;
+	int curr;
+	int dirty;
+	u32 desc_hw;
+	int i;
+
+	buflen = (ring->size * DESC_PRINT_LEN);
+	buf = kmalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	len += snprintf(buf + len, buflen - len,
+			"Idx ... %-8s %-8s %-8s %-8s . %-10s\n",
+			"desc", "next", "data", "ctrl", "timestamp");
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	curr = (ring->curr % ring->size);
+	dirty = (ring->dirty % ring->size);
+	desc_hw = ag71xx_rr(ag, desc_reg);
+	for (i = 0; i < ring->size; i++) {
+		struct ag71xx_buf *ab = &ring->buf[i];
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+		u32 desc_dma = ((u32) ring->descs_dma) + i * ring->desc_size;
+
+		len += snprintf(buf + len, buflen - len,
+			"%3d %c%c%c %08x %08x %08x %08x %c %10lu\n",
+			i,
+			(i == curr) ? 'C' : ' ',
+			(i == dirty) ? 'D' : ' ',
+			(desc_hw == desc_dma) ? 'H' : ' ',
+			desc_dma,
+			desc->next,
+			desc->data,
+			desc->ctrl,
+			(desc->ctrl & DESC_EMPTY) ? 'E' : '*',
+			ab->timestamp);
+	}
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t read_file_tx_ring(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+
+	return read_file_ring(file, user_buf, count, ppos, ag, &ag->tx_ring,
+			      AG71XX_REG_TX_DESC);
+}
+
+static const struct file_operations ag71xx_fops_tx_ring = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_tx_ring,
+	.owner	= THIS_MODULE
+};
+
+static ssize_t read_file_rx_ring(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ag71xx *ag = file->private_data;
+
+	return read_file_ring(file, user_buf, count, ppos, ag, &ag->rx_ring,
+			      AG71XX_REG_RX_DESC);
+}
+
+static const struct file_operations ag71xx_fops_rx_ring = {
+	.open	= ag71xx_debugfs_generic_open,
+	.read	= read_file_rx_ring,
+	.owner	= THIS_MODULE
+};
+
+void ag71xx_debugfs_exit(struct ag71xx *ag)
+{
+	debugfs_remove_recursive(ag->debug.debugfs_dir);
+}
+
+int ag71xx_debugfs_init(struct ag71xx *ag)
+{
+	struct device *dev = &ag->pdev->dev;
+
+	ag->debug.debugfs_dir = debugfs_create_dir(dev_name(dev),
+						   ag71xx_debugfs_root);
+	if (!ag->debug.debugfs_dir) {
+		dev_err(dev, "unable to create debugfs directory\n");
+		return -ENOENT;
+	}
+
+	debugfs_create_file("int_stats", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_int_stats);
+	debugfs_create_file("napi_stats", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_napi_stats);
+	debugfs_create_file("tx_ring", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_tx_ring);
+	debugfs_create_file("rx_ring", S_IRUGO, ag->debug.debugfs_dir,
+			    ag, &ag71xx_fops_rx_ring);
+
+	return 0;
+}
+
+int ag71xx_debugfs_root_init(void)
+{
+	if (ag71xx_debugfs_root)
+		return -EBUSY;
+
+	ag71xx_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (!ag71xx_debugfs_root)
+		return -ENOENT;
+
+	return 0;
+}
+
+void ag71xx_debugfs_root_exit(void)
+{
+	debugfs_remove(ag71xx_debugfs_root);
+	ag71xx_debugfs_root = NULL;
+}
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_ethtool.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,130 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+static int ag71xx_ethtool_get_settings(struct net_device *dev,
+				       struct ethtool_cmd *cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int ag71xx_ethtool_set_settings(struct net_device *dev,
+				       struct ethtool_cmd *cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static void ag71xx_ethtool_get_drvinfo(struct net_device *dev,
+				       struct ethtool_drvinfo *info)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	strcpy(info->driver, ag->pdev->dev.driver->name);
+	strcpy(info->version, AG71XX_DRV_VERSION);
+	strcpy(info->bus_info, dev_name(&ag->pdev->dev));
+}
+
+static u32 ag71xx_ethtool_get_msglevel(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	return ag->msg_enable;
+}
+
+static void ag71xx_ethtool_set_msglevel(struct net_device *dev, u32 msg_level)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	ag->msg_enable = msg_level;
+}
+
+static void ag71xx_ethtool_get_ringparam(struct net_device *dev,
+					 struct ethtool_ringparam *er)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	er->tx_max_pending = AG71XX_TX_RING_SIZE_MAX;
+	er->rx_max_pending = AG71XX_RX_RING_SIZE_MAX;
+	er->rx_mini_max_pending = 0;
+	er->rx_jumbo_max_pending = 0;
+
+	er->tx_pending = ag->tx_ring.size;
+	er->rx_pending = ag->rx_ring.size;
+	er->rx_mini_pending = 0;
+	er->rx_jumbo_pending = 0;
+
+	if (ag->tx_ring.desc_split)
+		er->tx_pending /= AG71XX_TX_RING_DS_PER_PKT;
+}
+
+static int ag71xx_ethtool_set_ringparam(struct net_device *dev,
+					struct ethtool_ringparam *er)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned tx_size;
+	unsigned rx_size;
+	int err;
+
+	if (er->rx_mini_pending != 0||
+	    er->rx_jumbo_pending != 0 ||
+	    er->rx_pending == 0 ||
+	    er->tx_pending == 0)
+		return -EINVAL;
+
+	tx_size = er->tx_pending < AG71XX_TX_RING_SIZE_MAX ?
+		  er->tx_pending : AG71XX_TX_RING_SIZE_MAX;
+
+	rx_size = er->rx_pending < AG71XX_RX_RING_SIZE_MAX ?
+		  er->rx_pending : AG71XX_RX_RING_SIZE_MAX;
+
+	if (netif_running(dev)) {
+		err = dev->netdev_ops->ndo_stop(dev);
+		if (err)
+			return err;
+	}
+
+	if (ag->tx_ring.desc_split)
+		tx_size *= AG71XX_TX_RING_DS_PER_PKT;
+
+	ag->tx_ring.size = tx_size;
+	ag->rx_ring.size = rx_size;
+
+	if (netif_running(dev))
+		err = dev->netdev_ops->ndo_open(dev);
+
+	return err;
+}
+
+struct ethtool_ops ag71xx_ethtool_ops = {
+	.set_settings	= ag71xx_ethtool_set_settings,
+	.get_settings	= ag71xx_ethtool_get_settings,
+	.get_drvinfo	= ag71xx_ethtool_get_drvinfo,
+	.get_msglevel	= ag71xx_ethtool_get_msglevel,
+	.set_msglevel	= ag71xx_ethtool_set_msglevel,
+	.get_ringparam	= ag71xx_ethtool_get_ringparam,
+	.set_ringparam	= ag71xx_ethtool_set_ringparam,
+	.get_link	= ethtool_op_get_link,
+};
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx.h linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx.h
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx.h	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,485 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef __AG71XX_H
+#define __AG71XX_H
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/random.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <linux/if_vlan.h>
+#include <linux/phy.h>
+#include <linux/skbuff.h>
+#include <linux/dma-mapping.h>
+#include <linux/workqueue.h>
+
+#include <linux/bitops.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ag71xx_platform.h>
+
+#define AG71XX_DRV_NAME		"ag71xx"
+#define AG71XX_DRV_VERSION	"0.5.35"
+
+#define AG71XX_NAPI_WEIGHT	64
+#define AG71XX_OOM_REFILL	(1 + HZ/10)
+
+#define AG71XX_INT_ERR	(AG71XX_INT_RX_BE | AG71XX_INT_TX_BE)
+#define AG71XX_INT_TX	(AG71XX_INT_TX_PS)
+#define AG71XX_INT_RX	(AG71XX_INT_RX_PR | AG71XX_INT_RX_OF)
+
+#define AG71XX_INT_POLL	(AG71XX_INT_RX | AG71XX_INT_TX)
+#define AG71XX_INT_INIT	(AG71XX_INT_ERR | AG71XX_INT_POLL)
+
+#define AG71XX_TX_MTU_LEN	1540
+
+#define AG71XX_TX_RING_SPLIT		512
+#define AG71XX_TX_RING_DS_PER_PKT	DIV_ROUND_UP(AG71XX_TX_MTU_LEN, \
+						     AG71XX_TX_RING_SPLIT)
+#define AG71XX_TX_RING_SIZE_DEFAULT	48
+#define AG71XX_RX_RING_SIZE_DEFAULT	128
+
+#define AG71XX_TX_RING_SIZE_MAX		48
+#define AG71XX_RX_RING_SIZE_MAX		128
+
+#ifdef CONFIG_AG71XX_DEBUG
+#define DBG(fmt, args...)	pr_debug(fmt, ## args)
+#else
+#define DBG(fmt, args...)	do {} while (0)
+#endif
+
+#define ag71xx_assert(_cond)						\
+do {									\
+	if (_cond)							\
+		break;							\
+	printk("%s,%d: assertion failed\n", __FILE__, __LINE__);	\
+	BUG();								\
+} while (0)
+
+struct ag71xx_desc {
+	u32	data;
+	u32	ctrl;
+#define DESC_EMPTY	BIT(31)
+#define DESC_MORE	BIT(24)
+#define DESC_PKTLEN_M	0xfff
+	u32	next;
+	u32	pad;
+} __attribute__((aligned(4)));
+
+struct ag71xx_buf {
+	union {
+		struct sk_buff	*skb;
+		void		*rx_buf;
+	};
+	union {
+		dma_addr_t	dma_addr;
+		unsigned long	timestamp;
+	};
+	unsigned int		len;
+};
+
+struct ag71xx_ring {
+	struct ag71xx_buf	*buf;
+	u8			*descs_cpu;
+	dma_addr_t		descs_dma;
+	u16			desc_split;
+	u16			desc_size;
+	unsigned int		curr;
+	unsigned int		dirty;
+	unsigned int		size;
+};
+
+struct ag71xx_mdio {
+	struct mii_bus		*mii_bus;
+	int			mii_irq[PHY_MAX_ADDR];
+	void __iomem		*mdio_base;
+	struct ag71xx_mdio_platform_data *pdata;
+};
+
+struct ag71xx_int_stats {
+	unsigned long		rx_pr;
+	unsigned long		rx_be;
+	unsigned long		rx_of;
+	unsigned long		tx_ps;
+	unsigned long		tx_be;
+	unsigned long		tx_ur;
+	unsigned long		total;
+};
+
+struct ag71xx_napi_stats {
+	unsigned long		napi_calls;
+	unsigned long		rx_count;
+	unsigned long		rx_packets;
+	unsigned long		rx_packets_max;
+	unsigned long		tx_count;
+	unsigned long		tx_packets;
+	unsigned long		tx_packets_max;
+
+	unsigned long		rx[AG71XX_NAPI_WEIGHT + 1];
+	unsigned long		tx[AG71XX_NAPI_WEIGHT + 1];
+};
+
+struct ag71xx_debug {
+	struct dentry		*debugfs_dir;
+
+	struct ag71xx_int_stats int_stats;
+	struct ag71xx_napi_stats napi_stats;
+};
+
+struct ag71xx {
+	void __iomem		*mac_base;
+
+	spinlock_t		lock;
+	struct platform_device	*pdev;
+	struct net_device	*dev;
+	struct napi_struct	napi;
+	u32			msg_enable;
+
+	struct ag71xx_desc	*stop_desc;
+	dma_addr_t		stop_desc_dma;
+
+	struct ag71xx_ring	rx_ring;
+	struct ag71xx_ring	tx_ring;
+
+	struct mii_bus		*mii_bus;
+	struct phy_device	*phy_dev;
+	void			*phy_priv;
+
+	unsigned int		link;
+	unsigned int		speed;
+	int			duplex;
+
+	unsigned int		max_frame_len;
+	unsigned int		desc_pktlen_mask;
+	unsigned int		rx_buf_size;
+
+	struct work_struct	restart_work;
+	struct delayed_work	link_work;
+	struct timer_list	oom_timer;
+
+#ifdef CONFIG_AG71XX_DEBUG_FS
+	struct ag71xx_debug	debug;
+#endif
+};
+
+extern struct ethtool_ops ag71xx_ethtool_ops;
+void ag71xx_link_adjust(struct ag71xx *ag);
+
+int ag71xx_mdio_driver_init(void) __init;
+void ag71xx_mdio_driver_exit(void);
+
+int ag71xx_phy_connect(struct ag71xx *ag);
+void ag71xx_phy_disconnect(struct ag71xx *ag);
+void ag71xx_phy_start(struct ag71xx *ag);
+void ag71xx_phy_stop(struct ag71xx *ag);
+
+static inline struct ag71xx_platform_data *ag71xx_get_pdata(struct ag71xx *ag)
+{
+	return ag->pdev->dev.platform_data;
+}
+
+static inline int ag71xx_desc_empty(struct ag71xx_desc *desc)
+{
+	return (desc->ctrl & DESC_EMPTY) != 0;
+}
+
+static inline struct ag71xx_desc *
+ag71xx_ring_desc(struct ag71xx_ring *ring, int idx)
+{
+	return (struct ag71xx_desc *) &ring->descs_cpu[idx * ring->desc_size];
+}
+
+/* Register offsets */
+#define AG71XX_REG_MAC_CFG1	0x0000
+#define AG71XX_REG_MAC_CFG2	0x0004
+#define AG71XX_REG_MAC_IPG	0x0008
+#define AG71XX_REG_MAC_HDX	0x000c
+#define AG71XX_REG_MAC_MFL	0x0010
+#define AG71XX_REG_MII_CFG	0x0020
+#define AG71XX_REG_MII_CMD	0x0024
+#define AG71XX_REG_MII_ADDR	0x0028
+#define AG71XX_REG_MII_CTRL	0x002c
+#define AG71XX_REG_MII_STATUS	0x0030
+#define AG71XX_REG_MII_IND	0x0034
+#define AG71XX_REG_MAC_IFCTL	0x0038
+#define AG71XX_REG_MAC_ADDR1	0x0040
+#define AG71XX_REG_MAC_ADDR2	0x0044
+#define AG71XX_REG_FIFO_CFG0	0x0048
+#define AG71XX_REG_FIFO_CFG1	0x004c
+#define AG71XX_REG_FIFO_CFG2	0x0050
+#define AG71XX_REG_FIFO_CFG3	0x0054
+#define AG71XX_REG_FIFO_CFG4	0x0058
+#define AG71XX_REG_FIFO_CFG5	0x005c
+#define AG71XX_REG_FIFO_RAM0	0x0060
+#define AG71XX_REG_FIFO_RAM1	0x0064
+#define AG71XX_REG_FIFO_RAM2	0x0068
+#define AG71XX_REG_FIFO_RAM3	0x006c
+#define AG71XX_REG_FIFO_RAM4	0x0070
+#define AG71XX_REG_FIFO_RAM5	0x0074
+#define AG71XX_REG_FIFO_RAM6	0x0078
+#define AG71XX_REG_FIFO_RAM7	0x007c
+
+#define AG71XX_REG_TX_CTRL	0x0180
+#define AG71XX_REG_TX_DESC	0x0184
+#define AG71XX_REG_TX_STATUS	0x0188
+#define AG71XX_REG_RX_CTRL	0x018c
+#define AG71XX_REG_RX_DESC	0x0190
+#define AG71XX_REG_RX_STATUS	0x0194
+#define AG71XX_REG_INT_ENABLE	0x0198
+#define AG71XX_REG_INT_STATUS	0x019c
+
+#define AG71XX_REG_FIFO_DEPTH	0x01a8
+#define AG71XX_REG_RX_SM	0x01b0
+#define AG71XX_REG_TX_SM	0x01b4
+
+#define MAC_CFG1_TXE		BIT(0)	/* Tx Enable */
+#define MAC_CFG1_STX		BIT(1)	/* Synchronize Tx Enable */
+#define MAC_CFG1_RXE		BIT(2)	/* Rx Enable */
+#define MAC_CFG1_SRX		BIT(3)	/* Synchronize Rx Enable */
+#define MAC_CFG1_TFC		BIT(4)	/* Tx Flow Control Enable */
+#define MAC_CFG1_RFC		BIT(5)	/* Rx Flow Control Enable */
+#define MAC_CFG1_LB		BIT(8)	/* Loopback mode */
+#define MAC_CFG1_SR		BIT(31)	/* Soft Reset */
+
+#define MAC_CFG2_FDX		BIT(0)
+#define MAC_CFG2_CRC_EN		BIT(1)
+#define MAC_CFG2_PAD_CRC_EN	BIT(2)
+#define MAC_CFG2_LEN_CHECK	BIT(4)
+#define MAC_CFG2_HUGE_FRAME_EN	BIT(5)
+#define MAC_CFG2_IF_1000	BIT(9)
+#define MAC_CFG2_IF_10_100	BIT(8)
+
+#define FIFO_CFG0_WTM		BIT(0)	/* Watermark Module */
+#define FIFO_CFG0_RXS		BIT(1)	/* Rx System Module */
+#define FIFO_CFG0_RXF		BIT(2)	/* Rx Fabric Module */
+#define FIFO_CFG0_TXS		BIT(3)	/* Tx System Module */
+#define FIFO_CFG0_TXF		BIT(4)	/* Tx Fabric Module */
+#define FIFO_CFG0_ALL	(FIFO_CFG0_WTM | FIFO_CFG0_RXS | FIFO_CFG0_RXF \
+			| FIFO_CFG0_TXS | FIFO_CFG0_TXF)
+
+#define FIFO_CFG0_ENABLE_SHIFT	8
+
+#define FIFO_CFG4_DE		BIT(0)	/* Drop Event */
+#define FIFO_CFG4_DV		BIT(1)	/* RX_DV Event */
+#define FIFO_CFG4_FC		BIT(2)	/* False Carrier */
+#define FIFO_CFG4_CE		BIT(3)	/* Code Error */
+#define FIFO_CFG4_CR		BIT(4)	/* CRC error */
+#define FIFO_CFG4_LM		BIT(5)	/* Length Mismatch */
+#define FIFO_CFG4_LO		BIT(6)	/* Length out of range */
+#define FIFO_CFG4_OK		BIT(7)	/* Packet is OK */
+#define FIFO_CFG4_MC		BIT(8)	/* Multicast Packet */
+#define FIFO_CFG4_BC		BIT(9)	/* Broadcast Packet */
+#define FIFO_CFG4_DR		BIT(10)	/* Dribble */
+#define FIFO_CFG4_LE		BIT(11)	/* Long Event */
+#define FIFO_CFG4_CF		BIT(12)	/* Control Frame */
+#define FIFO_CFG4_PF		BIT(13)	/* Pause Frame */
+#define FIFO_CFG4_UO		BIT(14)	/* Unsupported Opcode */
+#define FIFO_CFG4_VT		BIT(15)	/* VLAN tag detected */
+#define FIFO_CFG4_FT		BIT(16)	/* Frame Truncated */
+#define FIFO_CFG4_UC		BIT(17)	/* Unicast Packet */
+
+#define FIFO_CFG5_DE		BIT(0)	/* Drop Event */
+#define FIFO_CFG5_DV		BIT(1)	/* RX_DV Event */
+#define FIFO_CFG5_FC		BIT(2)	/* False Carrier */
+#define FIFO_CFG5_CE		BIT(3)	/* Code Error */
+#define FIFO_CFG5_LM		BIT(4)	/* Length Mismatch */
+#define FIFO_CFG5_LO		BIT(5)	/* Length Out of Range */
+#define FIFO_CFG5_OK		BIT(6)	/* Packet is OK */
+#define FIFO_CFG5_MC		BIT(7)	/* Multicast Packet */
+#define FIFO_CFG5_BC		BIT(8)	/* Broadcast Packet */
+#define FIFO_CFG5_DR		BIT(9)	/* Dribble */
+#define FIFO_CFG5_CF		BIT(10)	/* Control Frame */
+#define FIFO_CFG5_PF		BIT(11)	/* Pause Frame */
+#define FIFO_CFG5_UO		BIT(12)	/* Unsupported Opcode */
+#define FIFO_CFG5_VT		BIT(13)	/* VLAN tag detected */
+#define FIFO_CFG5_LE		BIT(14)	/* Long Event */
+#define FIFO_CFG5_FT		BIT(15)	/* Frame Truncated */
+#define FIFO_CFG5_16		BIT(16)	/* unknown */
+#define FIFO_CFG5_17		BIT(17)	/* unknown */
+#define FIFO_CFG5_SF		BIT(18)	/* Short Frame */
+#define FIFO_CFG5_BM		BIT(19)	/* Byte Mode */
+
+#define AG71XX_INT_TX_PS	BIT(0)
+#define AG71XX_INT_TX_UR	BIT(1)
+#define AG71XX_INT_TX_BE	BIT(3)
+#define AG71XX_INT_RX_PR	BIT(4)
+#define AG71XX_INT_RX_OF	BIT(6)
+#define AG71XX_INT_RX_BE	BIT(7)
+
+#define MAC_IFCTL_SPEED		BIT(16)
+
+#define MII_CFG_CLK_DIV_4	0
+#define MII_CFG_CLK_DIV_6	2
+#define MII_CFG_CLK_DIV_8	3
+#define MII_CFG_CLK_DIV_10	4
+#define MII_CFG_CLK_DIV_14	5
+#define MII_CFG_CLK_DIV_20	6
+#define MII_CFG_CLK_DIV_28	7
+#define MII_CFG_CLK_DIV_34	8
+#define MII_CFG_CLK_DIV_42	9
+#define MII_CFG_CLK_DIV_50	10
+#define MII_CFG_CLK_DIV_58	11
+#define MII_CFG_CLK_DIV_66	12
+#define MII_CFG_CLK_DIV_74	13
+#define MII_CFG_CLK_DIV_82	14
+#define MII_CFG_CLK_DIV_98	15
+#define MII_CFG_RESET		BIT(31)
+
+#define MII_CMD_WRITE		0x0
+#define MII_CMD_READ		0x1
+#define MII_ADDR_SHIFT		8
+#define MII_IND_BUSY		BIT(0)
+#define MII_IND_INVALID		BIT(2)
+
+#define TX_CTRL_TXE		BIT(0)	/* Tx Enable */
+
+#define TX_STATUS_PS		BIT(0)	/* Packet Sent */
+#define TX_STATUS_UR		BIT(1)	/* Tx Underrun */
+#define TX_STATUS_BE		BIT(3)	/* Bus Error */
+
+#define RX_CTRL_RXE		BIT(0)	/* Rx Enable */
+
+#define RX_STATUS_PR		BIT(0)	/* Packet Received */
+#define RX_STATUS_OF		BIT(2)	/* Rx Overflow */
+#define RX_STATUS_BE		BIT(3)	/* Bus Error */
+
+static inline void ag71xx_check_reg_offset(struct ag71xx *ag, unsigned reg)
+{
+	switch (reg) {
+	case AG71XX_REG_MAC_CFG1 ... AG71XX_REG_MAC_MFL:
+	case AG71XX_REG_MAC_IFCTL ... AG71XX_REG_TX_SM:
+	case AG71XX_REG_MII_CFG:
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+static inline void ag71xx_wr(struct ag71xx *ag, unsigned reg, u32 value)
+{
+	ag71xx_check_reg_offset(ag, reg);
+
+	__raw_writel(value, ag->mac_base + reg);
+	/* flush write */
+	(void) __raw_readl(ag->mac_base + reg);
+}
+
+static inline u32 ag71xx_rr(struct ag71xx *ag, unsigned reg)
+{
+	ag71xx_check_reg_offset(ag, reg);
+
+	return __raw_readl(ag->mac_base + reg);
+}
+
+static inline void ag71xx_sb(struct ag71xx *ag, unsigned reg, u32 mask)
+{
+	void __iomem *r;
+
+	ag71xx_check_reg_offset(ag, reg);
+
+	r = ag->mac_base + reg;
+	__raw_writel(__raw_readl(r) | mask, r);
+	/* flush write */
+	(void)__raw_readl(r);
+}
+
+static inline void ag71xx_cb(struct ag71xx *ag, unsigned reg, u32 mask)
+{
+	void __iomem *r;
+
+	ag71xx_check_reg_offset(ag, reg);
+
+	r = ag->mac_base + reg;
+	__raw_writel(__raw_readl(r) & ~mask, r);
+	/* flush write */
+	(void) __raw_readl(r);
+}
+
+static inline void ag71xx_int_enable(struct ag71xx *ag, u32 ints)
+{
+	ag71xx_sb(ag, AG71XX_REG_INT_ENABLE, ints);
+}
+
+static inline void ag71xx_int_disable(struct ag71xx *ag, u32 ints)
+{
+	ag71xx_cb(ag, AG71XX_REG_INT_ENABLE, ints);
+}
+
+#ifdef CONFIG_AG71XX_AR8216_SUPPORT
+void ag71xx_add_ar8216_header(struct ag71xx *ag, struct sk_buff *skb);
+int ag71xx_remove_ar8216_header(struct ag71xx *ag, struct sk_buff *skb,
+				int pktlen);
+static inline int ag71xx_has_ar8216(struct ag71xx *ag)
+{
+	return ag71xx_get_pdata(ag)->has_ar8216;
+}
+#else
+static inline void ag71xx_add_ar8216_header(struct ag71xx *ag,
+					   struct sk_buff *skb)
+{
+}
+
+static inline int ag71xx_remove_ar8216_header(struct ag71xx *ag,
+					      struct sk_buff *skb,
+					      int pktlen)
+{
+	return 0;
+}
+static inline int ag71xx_has_ar8216(struct ag71xx *ag)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_AG71XX_DEBUG_FS
+int ag71xx_debugfs_root_init(void);
+void ag71xx_debugfs_root_exit(void);
+int ag71xx_debugfs_init(struct ag71xx *ag);
+void ag71xx_debugfs_exit(struct ag71xx *ag);
+void ag71xx_debugfs_update_int_stats(struct ag71xx *ag, u32 status);
+void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag, int rx, int tx);
+#else
+static inline int ag71xx_debugfs_root_init(void) { return 0; }
+static inline void ag71xx_debugfs_root_exit(void) {}
+static inline int ag71xx_debugfs_init(struct ag71xx *ag) { return 0; }
+static inline void ag71xx_debugfs_exit(struct ag71xx *ag) {}
+static inline void ag71xx_debugfs_update_int_stats(struct ag71xx *ag,
+						   u32 status) {}
+static inline void ag71xx_debugfs_update_napi_stats(struct ag71xx *ag,
+						    int rx, int tx) {}
+#endif /* CONFIG_AG71XX_DEBUG_FS */
+
+void ag71xx_ar7240_start(struct ag71xx *ag);
+void ag71xx_ar7240_stop(struct ag71xx *ag);
+int ag71xx_ar7240_init(struct ag71xx *ag);
+void ag71xx_ar7240_cleanup(struct ag71xx *ag);
+
+int ag71xx_mdio_mii_read(struct ag71xx_mdio *am, int addr, int reg);
+void ag71xx_mdio_mii_write(struct ag71xx_mdio *am, int addr, int reg, u16 val);
+
+u16 ar7240sw_phy_read(struct mii_bus *mii, unsigned phy_addr,
+		      unsigned reg_addr);
+int ar7240sw_phy_write(struct mii_bus *mii, unsigned phy_addr,
+		       unsigned reg_addr, u16 reg_val);
+
+#endif /* _AG71XX_H */
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,1406 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+#define AG71XX_DEFAULT_MSG_ENABLE	\
+	(NETIF_MSG_DRV			\
+	| NETIF_MSG_PROBE		\
+	| NETIF_MSG_LINK		\
+	| NETIF_MSG_TIMER		\
+	| NETIF_MSG_IFDOWN		\
+	| NETIF_MSG_IFUP		\
+	| NETIF_MSG_RX_ERR		\
+	| NETIF_MSG_TX_ERR)
+
+static int ag71xx_msg_level = -1;
+
+module_param_named(msg_level, ag71xx_msg_level, int, 0);
+MODULE_PARM_DESC(msg_level, "Message level (-1=defaults,0=none,...,16=all)");
+
+#define ETH_SWITCH_HEADER_LEN	2
+
+static inline unsigned int ag71xx_max_frame_len(unsigned int mtu)
+{
+	return ETH_SWITCH_HEADER_LEN + ETH_HLEN + VLAN_HLEN + mtu + ETH_FCS_LEN;
+}
+
+static void ag71xx_dump_dma_regs(struct ag71xx *ag)
+{
+	DBG("%s: dma_tx_ctrl=%08x, dma_tx_desc=%08x, dma_tx_status=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_TX_CTRL),
+		ag71xx_rr(ag, AG71XX_REG_TX_DESC),
+		ag71xx_rr(ag, AG71XX_REG_TX_STATUS));
+
+	DBG("%s: dma_rx_ctrl=%08x, dma_rx_desc=%08x, dma_rx_status=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_RX_CTRL),
+		ag71xx_rr(ag, AG71XX_REG_RX_DESC),
+		ag71xx_rr(ag, AG71XX_REG_RX_STATUS));
+}
+
+static void ag71xx_dump_regs(struct ag71xx *ag)
+{
+	DBG("%s: mac_cfg1=%08x, mac_cfg2=%08x, ipg=%08x, hdx=%08x, mfl=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG2),
+		ag71xx_rr(ag, AG71XX_REG_MAC_IPG),
+		ag71xx_rr(ag, AG71XX_REG_MAC_HDX),
+		ag71xx_rr(ag, AG71XX_REG_MAC_MFL));
+	DBG("%s: mac_ifctl=%08x, mac_addr1=%08x, mac_addr2=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL),
+		ag71xx_rr(ag, AG71XX_REG_MAC_ADDR1),
+		ag71xx_rr(ag, AG71XX_REG_MAC_ADDR2));
+	DBG("%s: fifo_cfg0=%08x, fifo_cfg1=%08x, fifo_cfg2=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG0),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG2));
+	DBG("%s: fifo_cfg3=%08x, fifo_cfg4=%08x, fifo_cfg5=%08x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG3),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG4),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5));
+}
+
+static inline void ag71xx_dump_intr(struct ag71xx *ag, char *label, u32 intr)
+{
+	DBG("%s: %s intr=%08x %s%s%s%s%s%s\n",
+		ag->dev->name, label, intr,
+		(intr & AG71XX_INT_TX_PS) ? "TXPS " : "",
+		(intr & AG71XX_INT_TX_UR) ? "TXUR " : "",
+		(intr & AG71XX_INT_TX_BE) ? "TXBE " : "",
+		(intr & AG71XX_INT_RX_PR) ? "RXPR " : "",
+		(intr & AG71XX_INT_RX_OF) ? "RXOF " : "",
+		(intr & AG71XX_INT_RX_BE) ? "RXBE " : "");
+}
+
+static void ag71xx_ring_free(struct ag71xx_ring *ring)
+{
+	kfree(ring->buf);
+
+	if (ring->descs_cpu)
+		dma_free_coherent(NULL, ring->size * ring->desc_size,
+				  ring->descs_cpu, ring->descs_dma);
+}
+
+static int ag71xx_ring_alloc(struct ag71xx_ring *ring)
+{
+	int err;
+
+	ring->desc_size = sizeof(struct ag71xx_desc);
+	if (ring->desc_size % cache_line_size()) {
+		DBG("ag71xx: ring %p, desc size %u rounded to %u\n",
+			ring, ring->desc_size,
+			roundup(ring->desc_size, cache_line_size()));
+		ring->desc_size = roundup(ring->desc_size, cache_line_size());
+	}
+
+	ring->descs_cpu = dma_alloc_coherent(NULL, ring->size * ring->desc_size,
+					     &ring->descs_dma, GFP_ATOMIC);
+	if (!ring->descs_cpu) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+
+	ring->buf = kzalloc(ring->size * sizeof(*ring->buf), GFP_KERNEL);
+	if (!ring->buf) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+	return 0;
+
+err:
+	return err;
+}
+
+static void ag71xx_ring_tx_clean(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct net_device *dev = ag->dev;
+	u32 bytes_compl = 0, pkts_compl = 0;
+
+	while (ring->curr != ring->dirty) {
+		struct ag71xx_desc *desc;
+		u32 i = ring->dirty % ring->size;
+
+		desc = ag71xx_ring_desc(ring, i);
+		if (!ag71xx_desc_empty(desc)) {
+			desc->ctrl = 0;
+			dev->stats.tx_errors++;
+		}
+
+		if (ring->buf[i].skb) {
+			bytes_compl += ring->buf[i].len;
+			pkts_compl++;
+			dev_kfree_skb_any(ring->buf[i].skb);
+		}
+		ring->buf[i].skb = NULL;
+		ring->dirty++;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	netdev_completed_queue(dev, pkts_compl, bytes_compl);
+}
+
+static void ag71xx_ring_tx_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	int i;
+
+	for (i = 0; i < ring->size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+
+		desc->next = (u32) (ring->descs_dma +
+			ring->desc_size * ((i + 1) % ring->size));
+
+		desc->ctrl = DESC_EMPTY;
+		ring->buf[i].skb = NULL;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	ring->curr = 0;
+	ring->dirty = 0;
+	netdev_reset_queue(ag->dev);
+}
+
+static void ag71xx_ring_rx_clean(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int i;
+
+	if (!ring->buf)
+		return;
+
+	for (i = 0; i < ring->size; i++)
+		if (ring->buf[i].rx_buf) {
+			dma_unmap_single(&ag->dev->dev, ring->buf[i].dma_addr,
+					 ag->rx_buf_size, DMA_FROM_DEVICE);
+			kfree(ring->buf[i].rx_buf);
+		}
+}
+
+static int ag71xx_buffer_offset(struct ag71xx *ag)
+{
+	int offset = NET_SKB_PAD;
+
+	/*
+	 * On AR71xx/AR91xx packets must be 4-byte aligned.
+	 *
+	 * When using builtin AR8216 support, hardware adds a 2-byte header,
+	 * so we don't need any extra alignment in that case.
+	 */
+	if (!ag71xx_get_pdata(ag)->is_ar724x || ag71xx_has_ar8216(ag))
+		return offset;
+
+	return offset + NET_IP_ALIGN;
+}
+
+static bool ag71xx_fill_rx_buf(struct ag71xx *ag, struct ag71xx_buf *buf,
+			       int offset)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	struct ag71xx_desc *desc = ag71xx_ring_desc(ring, buf - &ring->buf[0]);
+	void *data;
+
+	data = kmalloc(ag->rx_buf_size +
+		       SKB_DATA_ALIGN(sizeof(struct skb_shared_info)),
+		       GFP_ATOMIC);
+	if (!data)
+		return false;
+
+	buf->rx_buf = data;
+	buf->dma_addr = dma_map_single(&ag->dev->dev, data, ag->rx_buf_size,
+				       DMA_FROM_DEVICE);
+	desc->data = (u32) buf->dma_addr + offset;
+	return true;
+}
+
+static int ag71xx_ring_rx_init(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	unsigned int i;
+	int ret;
+	int offset = ag71xx_buffer_offset(ag);
+
+	ret = 0;
+	for (i = 0; i < ring->size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+
+		desc->next = (u32) (ring->descs_dma +
+			ring->desc_size * ((i + 1) % ring->size));
+
+		DBG("ag71xx: RX desc at %p, next is %08x\n",
+			desc, desc->next);
+	}
+
+	for (i = 0; i < ring->size; i++) {
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+
+		if (!ag71xx_fill_rx_buf(ag, &ring->buf[i], offset)) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		desc->ctrl = DESC_EMPTY;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	ring->curr = 0;
+	ring->dirty = 0;
+
+	return ret;
+}
+
+static int ag71xx_ring_rx_refill(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	unsigned int count;
+	int offset = ag71xx_buffer_offset(ag);
+
+	count = 0;
+	for (; ring->curr - ring->dirty > 0; ring->dirty++) {
+		struct ag71xx_desc *desc;
+		unsigned int i;
+
+		i = ring->dirty % ring->size;
+		desc = ag71xx_ring_desc(ring, i);
+
+		if (!ring->buf[i].rx_buf &&
+		    !ag71xx_fill_rx_buf(ag, &ring->buf[i], offset))
+			break;
+
+		desc->ctrl = DESC_EMPTY;
+		count++;
+	}
+
+	/* flush descriptors */
+	wmb();
+
+	DBG("%s: %u rx descriptors refilled\n", ag->dev->name, count);
+
+	return count;
+}
+
+static int ag71xx_rings_init(struct ag71xx *ag)
+{
+	int ret;
+
+	ret = ag71xx_ring_alloc(&ag->tx_ring);
+	if (ret)
+		return ret;
+
+	ag71xx_ring_tx_init(ag);
+
+	ret = ag71xx_ring_alloc(&ag->rx_ring);
+	if (ret)
+		return ret;
+
+	ret = ag71xx_ring_rx_init(ag);
+	return ret;
+}
+
+static void ag71xx_rings_cleanup(struct ag71xx *ag)
+{
+	ag71xx_ring_rx_clean(ag);
+	ag71xx_ring_free(&ag->rx_ring);
+
+	ag71xx_ring_tx_clean(ag);
+	netdev_reset_queue(ag->dev);
+	ag71xx_ring_free(&ag->tx_ring);
+}
+
+static unsigned char *ag71xx_speed_str(struct ag71xx *ag)
+{
+	switch (ag->speed) {
+	case SPEED_1000:
+		return "1000";
+	case SPEED_100:
+		return "100";
+	case SPEED_10:
+		return "10";
+	}
+
+	return "?";
+}
+
+static void ag71xx_hw_set_macaddr(struct ag71xx *ag, unsigned char *mac)
+{
+	u32 t;
+
+	t = (((u32) mac[5]) << 24) | (((u32) mac[4]) << 16)
+	  | (((u32) mac[3]) << 8) | ((u32) mac[2]);
+
+	ag71xx_wr(ag, AG71XX_REG_MAC_ADDR1, t);
+
+	t = (((u32) mac[1]) << 24) | (((u32) mac[0]) << 16);
+	ag71xx_wr(ag, AG71XX_REG_MAC_ADDR2, t);
+}
+
+static void ag71xx_dma_reset(struct ag71xx *ag)
+{
+	u32 val;
+	int i;
+
+	ag71xx_dump_dma_regs(ag);
+
+	/* stop RX and TX */
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);
+
+	/*
+	 * give the hardware some time to really stop all rx/tx activity
+	 * clearing the descriptors too early causes random memory corruption
+	 */
+	mdelay(1);
+
+	/* clear descriptor addresses */
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->stop_desc_dma);
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->stop_desc_dma);
+
+	/* clear pending RX/TX interrupts */
+	for (i = 0; i < 256; i++) {
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);
+		ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
+	}
+
+	/* clear pending errors */
+	ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE | RX_STATUS_OF);
+	ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE | TX_STATUS_UR);
+
+	val = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
+	if (val)
+		pr_alert("%s: unable to clear DMA Rx status: %08x\n",
+			 ag->dev->name, val);
+
+	val = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);
+
+	/* mask out reserved bits */
+	val &= ~0xff000000;
+
+	if (val)
+		pr_alert("%s: unable to clear DMA Tx status: %08x\n",
+			 ag->dev->name, val);
+
+	ag71xx_dump_dma_regs(ag);
+}
+
+#define MAC_CFG1_INIT	(MAC_CFG1_RXE | MAC_CFG1_TXE | \
+			 MAC_CFG1_SRX | MAC_CFG1_STX)
+
+#define FIFO_CFG0_INIT	(FIFO_CFG0_ALL << FIFO_CFG0_ENABLE_SHIFT)
+
+#define FIFO_CFG4_INIT	(FIFO_CFG4_DE | FIFO_CFG4_DV | FIFO_CFG4_FC | \
+			 FIFO_CFG4_CE | FIFO_CFG4_CR | FIFO_CFG4_LM | \
+			 FIFO_CFG4_LO | FIFO_CFG4_OK | FIFO_CFG4_MC | \
+			 FIFO_CFG4_BC | FIFO_CFG4_DR | FIFO_CFG4_LE | \
+			 FIFO_CFG4_CF | FIFO_CFG4_PF | FIFO_CFG4_UO | \
+			 FIFO_CFG4_VT)
+
+#define FIFO_CFG5_INIT	(FIFO_CFG5_DE | FIFO_CFG5_DV | FIFO_CFG5_FC | \
+			 FIFO_CFG5_CE | FIFO_CFG5_LO | FIFO_CFG5_OK | \
+			 FIFO_CFG5_MC | FIFO_CFG5_BC | FIFO_CFG5_DR | \
+			 FIFO_CFG5_CF | FIFO_CFG5_PF | FIFO_CFG5_VT | \
+			 FIFO_CFG5_LE | FIFO_CFG5_FT | FIFO_CFG5_16 | \
+			 FIFO_CFG5_17 | FIFO_CFG5_SF)
+
+static void ag71xx_hw_stop(struct ag71xx *ag)
+{
+	/* disable all interrupts and stop the rx/tx engine */
+	ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, 0);
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);
+}
+
+static void ag71xx_hw_setup(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	/* setup MAC configuration registers */
+	ag71xx_wr(ag, AG71XX_REG_MAC_CFG1, MAC_CFG1_INIT);
+
+	ag71xx_sb(ag, AG71XX_REG_MAC_CFG2,
+		  MAC_CFG2_PAD_CRC_EN | MAC_CFG2_LEN_CHECK);
+
+	/* setup max frame length to zero */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL, 0);
+
+	/* setup FIFO configuration registers */
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG0, FIFO_CFG0_INIT);
+	if (pdata->is_ar724x) {
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG1, pdata->fifo_cfg1);
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG2, pdata->fifo_cfg2);
+	} else {
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG1, 0x0fff0000);
+		ag71xx_wr(ag, AG71XX_REG_FIFO_CFG2, 0x00001fff);
+	}
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG4, FIFO_CFG4_INIT);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, FIFO_CFG5_INIT);
+}
+
+static void ag71xx_hw_init(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	u32 reset_mask = pdata->reset_bit;
+
+	ag71xx_hw_stop(ag);
+
+	if (pdata->is_ar724x) {
+		u32 reset_phy = reset_mask;
+
+		reset_phy &= AR71XX_RESET_GE0_PHY | AR71XX_RESET_GE1_PHY;
+		reset_mask &= ~(AR71XX_RESET_GE0_PHY | AR71XX_RESET_GE1_PHY);
+
+		ath79_device_reset_set(reset_phy);
+		msleep(50);
+		ath79_device_reset_clear(reset_phy);
+		msleep(200);
+	}
+
+	ag71xx_sb(ag, AG71XX_REG_MAC_CFG1, MAC_CFG1_SR);
+	udelay(20);
+
+	ath79_device_reset_set(reset_mask);
+	msleep(100);
+	ath79_device_reset_clear(reset_mask);
+	msleep(200);
+
+	ag71xx_hw_setup(ag);
+
+	ag71xx_dma_reset(ag);
+}
+
+static void ag71xx_fast_reset(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct net_device *dev = ag->dev;
+	u32 reset_mask = pdata->reset_bit;
+	u32 rx_ds, tx_ds;
+	u32 mii_reg;
+
+	reset_mask &= AR71XX_RESET_GE0_MAC | AR71XX_RESET_GE1_MAC;
+
+	mii_reg = ag71xx_rr(ag, AG71XX_REG_MII_CFG);
+	rx_ds = ag71xx_rr(ag, AG71XX_REG_RX_DESC);
+	tx_ds = ag71xx_rr(ag, AG71XX_REG_TX_DESC);
+
+	ath79_device_reset_set(reset_mask);
+	udelay(10);
+	ath79_device_reset_clear(reset_mask);
+	udelay(10);
+
+	ag71xx_dma_reset(ag);
+	ag71xx_hw_setup(ag);
+
+	/* setup max frame length */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL,
+		  ag71xx_max_frame_len(ag->dev->mtu));
+
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, rx_ds);
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, tx_ds);
+	ag71xx_wr(ag, AG71XX_REG_MII_CFG, mii_reg);
+
+	ag71xx_hw_set_macaddr(ag, dev->dev_addr);
+}
+
+static void ag71xx_hw_start(struct ag71xx *ag)
+{
+	/* start RX engine */
+	ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);
+
+	/* enable interrupts */
+	ag71xx_wr(ag, AG71XX_REG_INT_ENABLE, AG71XX_INT_INIT);
+}
+
+void ag71xx_link_adjust(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	u32 cfg2;
+	u32 ifctl;
+	u32 fifo5;
+	u32 fifo3;
+
+	if (!ag->link) {
+		ag71xx_hw_stop(ag);
+		netif_carrier_off(ag->dev);
+		if (netif_msg_link(ag))
+			pr_info("%s: link down\n", ag->dev->name);
+		return;
+	}
+
+	if (pdata->is_ar724x)
+		ag71xx_fast_reset(ag);
+
+	cfg2 = ag71xx_rr(ag, AG71XX_REG_MAC_CFG2);
+	cfg2 &= ~(MAC_CFG2_IF_1000 | MAC_CFG2_IF_10_100 | MAC_CFG2_FDX);
+	cfg2 |= (ag->duplex) ? MAC_CFG2_FDX : 0;
+
+	ifctl = ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL);
+	ifctl &= ~(MAC_IFCTL_SPEED);
+
+	fifo5 = ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5);
+	fifo5 &= ~FIFO_CFG5_BM;
+
+	switch (ag->speed) {
+	case SPEED_1000:
+		cfg2 |= MAC_CFG2_IF_1000;
+		fifo5 |= FIFO_CFG5_BM;
+		break;
+	case SPEED_100:
+		cfg2 |= MAC_CFG2_IF_10_100;
+		ifctl |= MAC_IFCTL_SPEED;
+		break;
+	case SPEED_10:
+		cfg2 |= MAC_CFG2_IF_10_100;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	if (pdata->is_ar91xx)
+		fifo3 = 0x00780fff;
+	else if (pdata->is_ar724x)
+		fifo3 = pdata->fifo_cfg3;
+	else
+		fifo3 = 0x008001ff;
+
+	if (ag->tx_ring.desc_split) {
+		fifo3 &= 0xffff;
+		fifo3 |= ((2048 - ag->tx_ring.desc_split) / 4) << 16;
+	}
+
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG3, fifo3);
+
+	if (pdata->set_speed)
+		pdata->set_speed(ag->speed);
+
+	ag71xx_wr(ag, AG71XX_REG_MAC_CFG2, cfg2);
+	ag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, fifo5);
+	ag71xx_wr(ag, AG71XX_REG_MAC_IFCTL, ifctl);
+	ag71xx_hw_start(ag);
+
+	netif_carrier_on(ag->dev);
+	if (netif_msg_link(ag))
+		pr_info("%s: link up (%sMbps/%s duplex)\n",
+			ag->dev->name,
+			ag71xx_speed_str(ag),
+			(DUPLEX_FULL == ag->duplex) ? "Full" : "Half");
+
+	DBG("%s: fifo_cfg0=%#x, fifo_cfg1=%#x, fifo_cfg2=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG0),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG1),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG2));
+
+	DBG("%s: fifo_cfg3=%#x, fifo_cfg4=%#x, fifo_cfg5=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG3),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG4),
+		ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5));
+
+	DBG("%s: mac_cfg2=%#x, mac_ifctl=%#x\n",
+		ag->dev->name,
+		ag71xx_rr(ag, AG71XX_REG_MAC_CFG2),
+		ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL));
+}
+
+static int ag71xx_open(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned int max_frame_len;
+	int ret;
+
+	max_frame_len = ag71xx_max_frame_len(dev->mtu);
+	ag->rx_buf_size = max_frame_len + NET_SKB_PAD + NET_IP_ALIGN;
+
+	/* setup max frame length */
+	ag71xx_wr(ag, AG71XX_REG_MAC_MFL, max_frame_len);
+
+	ret = ag71xx_rings_init(ag);
+	if (ret)
+		goto err;
+
+	napi_enable(&ag->napi);
+
+	netif_carrier_off(dev);
+	ag71xx_phy_start(ag);
+
+	ag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);
+	ag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->rx_ring.descs_dma);
+
+	ag71xx_hw_set_macaddr(ag, dev->dev_addr);
+
+	netif_start_queue(dev);
+
+	return 0;
+
+err:
+	ag71xx_rings_cleanup(ag);
+	return ret;
+}
+
+static int ag71xx_stop(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned long flags;
+
+	netif_carrier_off(dev);
+	ag71xx_phy_stop(ag);
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	netif_stop_queue(dev);
+
+	ag71xx_hw_stop(ag);
+	ag71xx_dma_reset(ag);
+
+	napi_disable(&ag->napi);
+	del_timer_sync(&ag->oom_timer);
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+
+	ag71xx_rings_cleanup(ag);
+
+	return 0;
+}
+
+static int ag71xx_fill_dma_desc(struct ag71xx_ring *ring, u32 addr, int len)
+{
+	int i;
+	struct ag71xx_desc *desc;
+	int ndesc = 0;
+	int split = ring->desc_split;
+
+	if (!split)
+		split = len;
+
+	while (len > 0) {
+		unsigned int cur_len = len;
+
+		i = (ring->curr + ndesc) % ring->size;
+		desc = ag71xx_ring_desc(ring, i);
+
+		if (!ag71xx_desc_empty(desc))
+			return -1;
+
+		if (cur_len > split) {
+			cur_len = split;
+
+			/*
+			 * TX will hang if DMA transfers <= 4 bytes,
+			 * make sure next segment is more than 4 bytes long.
+			 */
+			if (len <= split + 4)
+				cur_len -= 4;
+		}
+
+		desc->data = addr;
+		addr += cur_len;
+		len -= cur_len;
+
+		if (len > 0)
+			cur_len |= DESC_MORE;
+
+		/* prevent early tx attempt of this descriptor */
+		if (!ndesc)
+			cur_len |= DESC_EMPTY;
+
+		desc->ctrl = cur_len;
+		ndesc++;
+	}
+
+	return ndesc;
+}
+
+static netdev_tx_t ag71xx_hard_start_xmit(struct sk_buff *skb,
+					  struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct ag71xx_desc *desc;
+	dma_addr_t dma_addr;
+	int i, n, ring_min;
+
+	if (ag71xx_has_ar8216(ag))
+		ag71xx_add_ar8216_header(ag, skb);
+
+	if (skb->len <= 4) {
+		DBG("%s: packet len is too small\n", ag->dev->name);
+		goto err_drop;
+	}
+
+	dma_addr = dma_map_single(&dev->dev, skb->data, skb->len,
+				  DMA_TO_DEVICE);
+
+	i = ring->curr % ring->size;
+	desc = ag71xx_ring_desc(ring, i);
+
+	/* setup descriptor fields */
+	n = ag71xx_fill_dma_desc(ring, (u32) dma_addr, skb->len & ag->desc_pktlen_mask);
+	if (n < 0)
+		goto err_drop_unmap;
+
+	i = (ring->curr + n - 1) % ring->size;
+	ring->buf[i].len = skb->len;
+	ring->buf[i].skb = skb;
+	ring->buf[i].timestamp = jiffies;
+
+	netdev_sent_queue(dev, skb->len);
+
+	desc->ctrl &= ~DESC_EMPTY;
+	ring->curr += n;
+
+	/* flush descriptor */
+	wmb();
+
+	ring_min = 2;
+	if (ring->desc_split)
+	    ring_min *= AG71XX_TX_RING_DS_PER_PKT;
+
+	if (ring->curr - ring->dirty >= ring->size - ring_min) {
+		DBG("%s: tx queue full\n", dev->name);
+		netif_stop_queue(dev);
+	}
+
+	DBG("%s: packet injected into TX queue\n", ag->dev->name);
+
+	/* enable TX engine */
+	ag71xx_wr(ag, AG71XX_REG_TX_CTRL, TX_CTRL_TXE);
+
+	return NETDEV_TX_OK;
+
+err_drop_unmap:
+	dma_unmap_single(&dev->dev, dma_addr, skb->len, DMA_TO_DEVICE);
+
+err_drop:
+	dev->stats.tx_dropped++;
+
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+static int ag71xx_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	int ret;
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		if (ag->phy_dev == NULL)
+			break;
+
+		spin_lock_irq(&ag->lock);
+		ret = phy_ethtool_ioctl(ag->phy_dev, (void *) ifr->ifr_data);
+		spin_unlock_irq(&ag->lock);
+		return ret;
+
+	case SIOCSIFHWADDR:
+		if (copy_from_user
+			(dev->dev_addr, ifr->ifr_data, sizeof(dev->dev_addr)))
+			return -EFAULT;
+		return 0;
+
+	case SIOCGIFHWADDR:
+		if (copy_to_user
+			(ifr->ifr_data, dev->dev_addr, sizeof(dev->dev_addr)))
+			return -EFAULT;
+		return 0;
+
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		if (ag->phy_dev == NULL)
+			break;
+
+		return phy_mii_ioctl(ag->phy_dev, ifr, cmd);
+
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static void ag71xx_oom_timer_handler(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct ag71xx *ag = netdev_priv(dev);
+
+	napi_schedule(&ag->napi);
+}
+
+static void ag71xx_tx_timeout(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+
+	if (netif_msg_tx_err(ag))
+		pr_info("%s: tx timeout\n", ag->dev->name);
+
+	schedule_work(&ag->restart_work);
+}
+
+static void ag71xx_restart_work_func(struct work_struct *work)
+{
+	struct ag71xx *ag = container_of(work, struct ag71xx, restart_work);
+
+	if (ag71xx_get_pdata(ag)->is_ar724x) {
+		ag->link = 0;
+		ag71xx_link_adjust(ag);
+		return;
+	}
+
+	ag71xx_stop(ag->dev);
+	ag71xx_open(ag->dev);
+}
+
+static bool ag71xx_check_dma_stuck(struct ag71xx *ag, unsigned long timestamp)
+{
+	u32 rx_sm, tx_sm, rx_fd;
+
+	if (likely(time_before(jiffies, timestamp + HZ/10)))
+		return false;
+
+	if (!netif_carrier_ok(ag->dev))
+		return false;
+
+	rx_sm = ag71xx_rr(ag, AG71XX_REG_RX_SM);
+	if ((rx_sm & 0x7) == 0x3 && ((rx_sm >> 4) & 0x7) == 0x6)
+		return true;
+
+	tx_sm = ag71xx_rr(ag, AG71XX_REG_TX_SM);
+	rx_fd = ag71xx_rr(ag, AG71XX_REG_FIFO_DEPTH);
+	if (((tx_sm >> 4) & 0x7) == 0 && ((rx_sm & 0x7) == 0) &&
+	    ((rx_sm >> 4) & 0x7) == 0 && rx_fd == 0)
+		return true;
+
+	return false;
+}
+
+static int ag71xx_tx_packets(struct ag71xx *ag)
+{
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	int sent = 0;
+	int bytes_compl = 0;
+	int n = 0;
+
+	DBG("%s: processing TX ring\n", ag->dev->name);
+
+	while (ring->dirty + n != ring->curr) {
+		unsigned int i = (ring->dirty + n) % ring->size;
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+		struct sk_buff *skb = ring->buf[i].skb;
+
+		if (!ag71xx_desc_empty(desc)) {
+			if (pdata->is_ar7240 &&
+			    ag71xx_check_dma_stuck(ag, ring->buf[i].timestamp))
+				schedule_work(&ag->restart_work);
+			break;
+		}
+
+		n++;
+		if (!skb)
+			continue;
+
+		dev_kfree_skb_any(skb);
+		ring->buf[i].skb = NULL;
+
+		bytes_compl += ring->buf[i].len;
+
+		sent++;
+		ring->dirty += n;
+
+		while (n > 0) {
+			ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
+			n--;
+		}
+	}
+
+	DBG("%s: %d packets sent out\n", ag->dev->name, sent);
+
+	ag->dev->stats.tx_bytes += bytes_compl;
+	ag->dev->stats.tx_packets += sent;
+
+	if (!sent)
+		return 0;
+
+	netdev_completed_queue(ag->dev, sent, bytes_compl);
+	if ((ring->curr - ring->dirty) < (ring->size * 3) / 4)
+		netif_wake_queue(ag->dev);
+
+	return sent;
+}
+
+static int ag71xx_rx_packets(struct ag71xx *ag, int limit)
+{
+	struct net_device *dev = ag->dev;
+	struct ag71xx_ring *ring = &ag->rx_ring;
+	int offset = ag71xx_buffer_offset(ag);
+	unsigned int pktlen_mask = ag->desc_pktlen_mask;
+	int done = 0;
+
+	DBG("%s: rx packets, limit=%d, curr=%u, dirty=%u\n",
+			dev->name, limit, ring->curr, ring->dirty);
+
+	while (done < limit) {
+		unsigned int i = ring->curr % ring->size;
+		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
+		struct sk_buff *skb;
+		int pktlen;
+		int err = 0;
+
+		if (ag71xx_desc_empty(desc))
+			break;
+
+		if ((ring->dirty + ring->size) == ring->curr) {
+			ag71xx_assert(0);
+			break;
+		}
+
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);
+
+		pktlen = desc->ctrl & pktlen_mask;
+		pktlen -= ETH_FCS_LEN;
+
+		dma_unmap_single(&dev->dev, ring->buf[i].dma_addr,
+				 ag->rx_buf_size, DMA_FROM_DEVICE);
+
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += pktlen;
+
+		skb = build_skb(ring->buf[i].rx_buf, 0);
+		if (!skb) {
+			kfree(ring->buf[i].rx_buf);
+			goto next;
+		}
+
+		skb_reserve(skb, offset);
+		skb_put(skb, pktlen);
+
+		if (ag71xx_has_ar8216(ag))
+			err = ag71xx_remove_ar8216_header(ag, skb, pktlen);
+
+		if (err) {
+			dev->stats.rx_dropped++;
+			kfree_skb(skb);
+		} else {
+			skb->dev = dev;
+			skb->ip_summed = CHECKSUM_NONE;
+			skb->protocol = eth_type_trans(skb, dev);
+			netif_receive_skb(skb);
+		}
+
+next:
+		ring->buf[i].rx_buf = NULL;
+		done++;
+
+		ring->curr++;
+	}
+
+	ag71xx_ring_rx_refill(ag);
+
+	DBG("%s: rx finish, curr=%u, dirty=%u, done=%d\n",
+		dev->name, ring->curr, ring->dirty, done);
+
+	return done;
+}
+
+static int ag71xx_poll(struct napi_struct *napi, int limit)
+{
+	struct ag71xx *ag = container_of(napi, struct ag71xx, napi);
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct net_device *dev = ag->dev;
+	struct ag71xx_ring *rx_ring;
+	unsigned long flags;
+	u32 status;
+	int tx_done;
+	int rx_done;
+
+	pdata->ddr_flush();
+	tx_done = ag71xx_tx_packets(ag);
+
+	DBG("%s: processing RX ring\n", dev->name);
+	rx_done = ag71xx_rx_packets(ag, limit);
+
+	ag71xx_debugfs_update_napi_stats(ag, rx_done, tx_done);
+
+	rx_ring = &ag->rx_ring;
+	if (rx_ring->buf[rx_ring->dirty % rx_ring->size].rx_buf == NULL)
+		goto oom;
+
+	status = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
+	if (unlikely(status & RX_STATUS_OF)) {
+		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_OF);
+		dev->stats.rx_fifo_errors++;
+
+		/* restart RX */
+		ag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);
+	}
+
+	if (rx_done < limit) {
+		if (status & RX_STATUS_PR)
+			goto more;
+
+		status = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);
+		if (status & TX_STATUS_PS)
+			goto more;
+
+		DBG("%s: disable polling mode, rx=%d, tx=%d,limit=%d\n",
+			dev->name, rx_done, tx_done, limit);
+
+		napi_complete(napi);
+
+		/* enable interrupts */
+		spin_lock_irqsave(&ag->lock, flags);
+		ag71xx_int_enable(ag, AG71XX_INT_POLL);
+		spin_unlock_irqrestore(&ag->lock, flags);
+		return rx_done;
+	}
+
+more:
+	DBG("%s: stay in polling mode, rx=%d, tx=%d, limit=%d\n",
+			dev->name, rx_done, tx_done, limit);
+	return limit;
+
+oom:
+	if (netif_msg_rx_err(ag))
+		pr_info("%s: out of memory\n", dev->name);
+
+	mod_timer(&ag->oom_timer, jiffies + AG71XX_OOM_REFILL);
+	napi_complete(napi);
+	return 0;
+}
+
+static irqreturn_t ag71xx_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct ag71xx *ag = netdev_priv(dev);
+	u32 status;
+
+	status = ag71xx_rr(ag, AG71XX_REG_INT_STATUS);
+	ag71xx_dump_intr(ag, "raw", status);
+
+	if (unlikely(!status))
+		return IRQ_NONE;
+
+	if (unlikely(status & AG71XX_INT_ERR)) {
+		if (status & AG71XX_INT_TX_BE) {
+			ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE);
+			dev_err(&dev->dev, "TX BUS error\n");
+		}
+		if (status & AG71XX_INT_RX_BE) {
+			ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE);
+			dev_err(&dev->dev, "RX BUS error\n");
+		}
+	}
+
+	if (likely(status & AG71XX_INT_POLL)) {
+		ag71xx_int_disable(ag, AG71XX_INT_POLL);
+		DBG("%s: enable polling mode\n", dev->name);
+		napi_schedule(&ag->napi);
+	}
+
+	ag71xx_debugfs_update_int_stats(ag, status);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void ag71xx_netpoll(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	ag71xx_interrupt(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+#endif
+
+static int ag71xx_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	unsigned int max_frame_len;
+
+	max_frame_len = ag71xx_max_frame_len(new_mtu);
+	if (new_mtu < 68 || max_frame_len > ag->max_frame_len)
+		return -EINVAL;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+static const struct net_device_ops ag71xx_netdev_ops = {
+	.ndo_open		= ag71xx_open,
+	.ndo_stop		= ag71xx_stop,
+	.ndo_start_xmit		= ag71xx_hard_start_xmit,
+	.ndo_do_ioctl		= ag71xx_do_ioctl,
+	.ndo_tx_timeout		= ag71xx_tx_timeout,
+	.ndo_change_mtu		= ag71xx_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= ag71xx_netpoll,
+#endif
+};
+
+static const char *ag71xx_get_phy_if_mode_name(phy_interface_t mode)
+{
+	switch (mode) {
+	case PHY_INTERFACE_MODE_MII:
+		return "MII";
+	case PHY_INTERFACE_MODE_GMII:
+		return "GMII";
+	case PHY_INTERFACE_MODE_RMII:
+		return "RMII";
+	case PHY_INTERFACE_MODE_RGMII:
+		return "RGMII";
+	case PHY_INTERFACE_MODE_SGMII:
+		return "SGMII";
+	default:
+		break;
+	}
+
+	return "unknown";
+}
+
+
+static int ag71xx_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct resource *res;
+	struct ag71xx *ag;
+	struct ag71xx_platform_data *pdata;
+	int err;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data specified\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	if (pdata->mii_bus_dev == NULL && pdata->phy_mask) {
+		dev_err(&pdev->dev, "no MII bus device specified\n");
+		err = -EINVAL;
+		goto err_out;
+	}
+
+	dev = alloc_etherdev(sizeof(*ag));
+	if (!dev) {
+		dev_err(&pdev->dev, "alloc_etherdev failed\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	if (!pdata->max_frame_len || !pdata->desc_pktlen_mask)
+		return -EINVAL;
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	ag = netdev_priv(dev);
+	ag->pdev = pdev;
+	ag->dev = dev;
+	ag->msg_enable = netif_msg_init(ag71xx_msg_level,
+					AG71XX_DEFAULT_MSG_ENABLE);
+	spin_lock_init(&ag->lock);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mac_base");
+	if (!res) {
+		dev_err(&pdev->dev, "no mac_base resource found\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	ag->mac_base = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!ag->mac_base) {
+		dev_err(&pdev->dev, "unable to ioremap mac_base\n");
+		err = -ENOMEM;
+		goto err_free_dev;
+	}
+
+	dev->irq = platform_get_irq(pdev, 0);
+	err = request_irq(dev->irq, ag71xx_interrupt,
+			  0x0,
+			  dev->name, dev);
+	if (err) {
+		dev_err(&pdev->dev, "unable to request IRQ %d\n", dev->irq);
+		goto err_unmap_base;
+	}
+
+	dev->base_addr = (unsigned long)ag->mac_base;
+	dev->netdev_ops = &ag71xx_netdev_ops;
+	dev->ethtool_ops = &ag71xx_ethtool_ops;
+
+	INIT_WORK(&ag->restart_work, ag71xx_restart_work_func);
+
+	init_timer(&ag->oom_timer);
+	ag->oom_timer.data = (unsigned long) dev;
+	ag->oom_timer.function = ag71xx_oom_timer_handler;
+
+	ag->tx_ring.size = AG71XX_TX_RING_SIZE_DEFAULT;
+	ag->rx_ring.size = AG71XX_RX_RING_SIZE_DEFAULT;
+
+	ag->max_frame_len = pdata->max_frame_len;
+	ag->desc_pktlen_mask = pdata->desc_pktlen_mask;
+
+	if (!pdata->is_ar724x && !pdata->is_ar91xx) {
+		ag->tx_ring.desc_split = AG71XX_TX_RING_SPLIT;
+		ag->tx_ring.size *= AG71XX_TX_RING_DS_PER_PKT;
+	}
+
+	ag->stop_desc = dma_alloc_coherent(NULL,
+		sizeof(struct ag71xx_desc), &ag->stop_desc_dma, GFP_KERNEL);
+
+	if (!ag->stop_desc)
+		goto err_free_irq;
+
+	ag->stop_desc->data = 0;
+	ag->stop_desc->ctrl = 0;
+	ag->stop_desc->next = (u32) ag->stop_desc_dma;
+
+	memcpy(dev->dev_addr, pdata->mac_addr, ETH_ALEN);
+
+	netif_napi_add(dev, &ag->napi, ag71xx_poll, AG71XX_NAPI_WEIGHT);
+
+	ag71xx_dump_regs(ag);
+
+	ag71xx_hw_init(ag);
+
+	ag71xx_dump_regs(ag);
+
+	err = ag71xx_phy_connect(ag);
+	if (err)
+		goto err_free_desc;
+
+	err = ag71xx_debugfs_init(ag);
+	if (err)
+		goto err_phy_disconnect;
+
+	platform_set_drvdata(pdev, dev);
+
+	err = register_netdev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "unable to register net device\n");
+		goto err_debugfs_exit;
+	}
+
+	pr_info("%s: Atheros AG71xx at 0x%08lx, irq %d, mode:%s\n",
+		dev->name, dev->base_addr, dev->irq,
+		ag71xx_get_phy_if_mode_name(pdata->phy_if_mode));
+
+	return 0;
+
+err_debugfs_exit:
+	ag71xx_debugfs_exit(ag);
+err_phy_disconnect:
+	ag71xx_phy_disconnect(ag);
+err_free_desc:
+	dma_free_coherent(NULL, sizeof(struct ag71xx_desc), ag->stop_desc,
+			  ag->stop_desc_dma);
+err_free_irq:
+	free_irq(dev->irq, dev);
+err_unmap_base:
+	iounmap(ag->mac_base);
+err_free_dev:
+	kfree(dev);
+err_out:
+	platform_set_drvdata(pdev, NULL);
+	return err;
+}
+
+static int ag71xx_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+
+	if (dev) {
+		struct ag71xx *ag = netdev_priv(dev);
+
+		ag71xx_debugfs_exit(ag);
+		ag71xx_phy_disconnect(ag);
+		unregister_netdev(dev);
+		free_irq(dev->irq, dev);
+		iounmap(ag->mac_base);
+		kfree(dev);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ag71xx_driver = {
+	.probe		= ag71xx_probe,
+	.remove		= ag71xx_remove,
+	.driver = {
+		.name	= AG71XX_DRV_NAME,
+	}
+};
+
+static int __init ag71xx_module_init(void)
+{
+	int ret;
+
+	ret = ag71xx_debugfs_root_init();
+	if (ret)
+		goto err_out;
+
+	ret = ag71xx_mdio_driver_init();
+	if (ret)
+		goto err_debugfs_exit;
+
+	ret = platform_driver_register(&ag71xx_driver);
+	if (ret)
+		goto err_mdio_exit;
+
+	return 0;
+
+err_mdio_exit:
+	ag71xx_mdio_driver_exit();
+err_debugfs_exit:
+	ag71xx_debugfs_root_exit();
+err_out:
+	return ret;
+}
+
+static void __exit ag71xx_module_exit(void)
+{
+	platform_driver_unregister(&ag71xx_driver);
+	ag71xx_mdio_driver_exit();
+	ag71xx_debugfs_root_exit();
+}
+
+module_init(ag71xx_module_init);
+module_exit(ag71xx_module_exit);
+
+MODULE_VERSION(AG71XX_DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" AG71XX_DRV_NAME);
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,318 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+#define AG71XX_MDIO_RETRY	1000
+#define AG71XX_MDIO_DELAY	5
+
+static inline void ag71xx_mdio_wr(struct ag71xx_mdio *am, unsigned reg,
+				  u32 value)
+{
+	void __iomem *r;
+
+	r = am->mdio_base + reg;
+	__raw_writel(value, r);
+
+	/* flush write */
+	(void) __raw_readl(r);
+}
+
+static inline u32 ag71xx_mdio_rr(struct ag71xx_mdio *am, unsigned reg)
+{
+	return __raw_readl(am->mdio_base + reg);
+}
+
+static void ag71xx_mdio_dump_regs(struct ag71xx_mdio *am)
+{
+	DBG("%s: mii_cfg=%08x, mii_cmd=%08x, mii_addr=%08x\n",
+		am->mii_bus->name,
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_CFG),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_CMD),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_ADDR));
+	DBG("%s: mii_ctrl=%08x, mii_status=%08x, mii_ind=%08x\n",
+		am->mii_bus->name,
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_CTRL),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_STATUS),
+		ag71xx_mdio_rr(am, AG71XX_REG_MII_IND));
+}
+
+static int ag71xx_mdio_wait_busy(struct ag71xx_mdio *am)
+{
+	int i;
+
+	for (i = 0; i < AG71XX_MDIO_RETRY; i++) {
+		u32 busy;
+
+		udelay(AG71XX_MDIO_DELAY);
+
+		busy = ag71xx_mdio_rr(am, AG71XX_REG_MII_IND);
+		if (!busy)
+			return 0;
+
+		udelay(AG71XX_MDIO_DELAY);
+	}
+
+	pr_err("%s: MDIO operation timed out\n", am->mii_bus->name);
+
+	return -ETIMEDOUT;
+}
+
+int ag71xx_mdio_mii_read(struct ag71xx_mdio *am, int addr, int reg)
+{
+	int err;
+	int ret;
+
+	err = ag71xx_mdio_wait_busy(am);
+	if (err)
+		return 0xffff;
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CMD, MII_CMD_WRITE);
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_ADDR,
+			((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CMD, MII_CMD_READ);
+
+	err = ag71xx_mdio_wait_busy(am);
+	if (err)
+		return 0xffff;
+
+	ret = ag71xx_mdio_rr(am, AG71XX_REG_MII_STATUS) & 0xffff;
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CMD, MII_CMD_WRITE);
+
+	DBG("mii_read: addr=%04x, reg=%04x, value=%04x\n", addr, reg, ret);
+
+	return ret;
+}
+
+void ag71xx_mdio_mii_write(struct ag71xx_mdio *am, int addr, int reg, u16 val)
+{
+	DBG("mii_write: addr=%04x, reg=%04x, value=%04x\n", addr, reg, val);
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_ADDR,
+			((addr & 0xff) << MII_ADDR_SHIFT) | (reg & 0xff));
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CTRL, val);
+
+	ag71xx_mdio_wait_busy(am);
+}
+
+static const u32 ar71xx_mdio_div_table[] = {
+	4, 4, 6, 8, 10, 14, 20, 28,
+};
+
+static const u32 ar7240_mdio_div_table[] = {
+	2, 2, 4, 6, 8, 12, 18, 26, 32, 40, 48, 56, 62, 70, 78, 96,
+};
+
+static const u32 ar933x_mdio_div_table[] = {
+	4, 4, 6, 8, 10, 14, 20, 28, 34, 42, 50, 58, 66, 74, 82, 98,
+};
+
+static int ag71xx_mdio_get_divider(struct ag71xx_mdio *am, u32 *div)
+{
+	unsigned long ref_clock, mdio_clock;
+	const u32 *table;
+	int ndivs;
+	int i;
+
+	ref_clock = am->pdata->ref_clock;
+	mdio_clock = am->pdata->mdio_clock;
+
+	if (!ref_clock || !mdio_clock)
+		return -EINVAL;
+
+	if (am->pdata->is_ar9330 || am->pdata->is_ar934x) {
+		table = ar933x_mdio_div_table;
+		ndivs = ARRAY_SIZE(ar933x_mdio_div_table);
+	} else if (am->pdata->is_ar7240) {
+		table = ar7240_mdio_div_table;
+		ndivs = ARRAY_SIZE(ar7240_mdio_div_table);
+	} else {
+		table = ar71xx_mdio_div_table;
+		ndivs = ARRAY_SIZE(ar71xx_mdio_div_table);
+	}
+
+	for (i = 0; i < ndivs; i++) {
+		unsigned long t;
+
+		t = ref_clock / table[i];
+		if (t <= mdio_clock) {
+			*div = i;
+			return 0;
+		}
+	}
+
+	dev_err(&am->mii_bus->dev, "no divider found for %lu/%lu\n",
+		ref_clock, mdio_clock);
+	return -ENOENT;
+}
+
+static int ag71xx_mdio_reset(struct mii_bus *bus)
+{
+	struct ag71xx_mdio *am = bus->priv;
+	u32 t;
+	int err;
+
+	err = ag71xx_mdio_get_divider(am, &t);
+	if (err) {
+		/* fallback */
+		if (am->pdata->is_ar7240)
+			t = MII_CFG_CLK_DIV_6;
+		else if (am->pdata->builtin_switch && !am->pdata->is_ar934x)
+			t = MII_CFG_CLK_DIV_10;
+		else if (!am->pdata->builtin_switch && am->pdata->is_ar934x)
+			t = MII_CFG_CLK_DIV_58;
+		else
+			t = MII_CFG_CLK_DIV_28;
+	}
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CFG, t | MII_CFG_RESET);
+	udelay(100);
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MII_CFG, t);
+	udelay(100);
+
+	if (am->pdata->reset)
+		am->pdata->reset(bus);
+
+	return 0;
+}
+
+static int ag71xx_mdio_read(struct mii_bus *bus, int addr, int reg)
+{
+	struct ag71xx_mdio *am = bus->priv;
+
+	if (am->pdata->builtin_switch)
+		return ar7240sw_phy_read(bus, addr, reg);
+	else
+		return ag71xx_mdio_mii_read(am, addr, reg);
+}
+
+static int ag71xx_mdio_write(struct mii_bus *bus, int addr, int reg, u16 val)
+{
+	struct ag71xx_mdio *am = bus->priv;
+
+	if (am->pdata->builtin_switch)
+		ar7240sw_phy_write(bus, addr, reg, val);
+	else
+		ag71xx_mdio_mii_write(am, addr, reg, val);
+	return 0;
+}
+
+static int ag71xx_mdio_probe(struct platform_device *pdev)
+{
+	struct ag71xx_mdio_platform_data *pdata;
+	struct ag71xx_mdio *am;
+	struct resource *res;
+	int i;
+	int err;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data specified\n");
+		return -EINVAL;
+	}
+
+	am = kzalloc(sizeof(*am), GFP_KERNEL);
+	if (!am) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	am->pdata = pdata;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no iomem resource found\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	am->mdio_base = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!am->mdio_base) {
+		dev_err(&pdev->dev, "unable to ioremap registers\n");
+		err = -ENOMEM;
+		goto err_free_mdio;
+	}
+
+	am->mii_bus = mdiobus_alloc();
+	if (am->mii_bus == NULL) {
+		err = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	am->mii_bus->name = "ag71xx_mdio";
+	am->mii_bus->read = ag71xx_mdio_read;
+	am->mii_bus->write = ag71xx_mdio_write;
+	am->mii_bus->reset = ag71xx_mdio_reset;
+	am->mii_bus->irq = am->mii_irq;
+	am->mii_bus->priv = am;
+	am->mii_bus->parent = &pdev->dev;
+	snprintf(am->mii_bus->id, MII_BUS_ID_SIZE, "%s", dev_name(&pdev->dev));
+	am->mii_bus->phy_mask = pdata->phy_mask;
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		am->mii_irq[i] = PHY_POLL;
+
+	ag71xx_mdio_wr(am, AG71XX_REG_MAC_CFG1, 0);
+
+	err = mdiobus_register(am->mii_bus);
+	if (err)
+		goto err_free_bus;
+
+	ag71xx_mdio_dump_regs(am);
+
+	platform_set_drvdata(pdev, am);
+	return 0;
+
+err_free_bus:
+	mdiobus_free(am->mii_bus);
+err_iounmap:
+	iounmap(am->mdio_base);
+err_free_mdio:
+	kfree(am);
+err_out:
+	return err;
+}
+
+static int ag71xx_mdio_remove(struct platform_device *pdev)
+{
+	struct ag71xx_mdio *am = platform_get_drvdata(pdev);
+
+	if (am) {
+		mdiobus_unregister(am->mii_bus);
+		mdiobus_free(am->mii_bus);
+		iounmap(am->mdio_base);
+		kfree(am);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ag71xx_mdio_driver = {
+	.probe		= ag71xx_mdio_probe,
+	.remove		= ag71xx_mdio_remove,
+	.driver = {
+		.name	= "ag71xx-mdio",
+	}
+};
+
+int __init ag71xx_mdio_driver_init(void)
+{
+	return platform_driver_register(&ag71xx_mdio_driver);
+}
+
+void ag71xx_mdio_driver_exit(void)
+{
+	platform_driver_unregister(&ag71xx_mdio_driver);
+}
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/ag71xx_phy.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,235 @@
+/*
+ *  Atheros AR71xx built-in ethernet mac driver
+ *
+ *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Based on Atheros' AG7100 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "ag71xx.h"
+
+static void ag71xx_phy_link_adjust(struct net_device *dev)
+{
+	struct ag71xx *ag = netdev_priv(dev);
+	struct phy_device *phydev = ag->phy_dev;
+	unsigned long flags;
+	int status_change = 0;
+
+	spin_lock_irqsave(&ag->lock, flags);
+
+	if (phydev->link) {
+		if (ag->duplex != phydev->duplex
+		    || ag->speed != phydev->speed) {
+			status_change = 1;
+		}
+	}
+
+	if (phydev->link != ag->link)
+		status_change = 1;
+
+	ag->link = phydev->link;
+	ag->duplex = phydev->duplex;
+	ag->speed = phydev->speed;
+
+	if (status_change)
+		ag71xx_link_adjust(ag);
+
+	spin_unlock_irqrestore(&ag->lock, flags);
+}
+
+void ag71xx_phy_start(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (ag->phy_dev) {
+		phy_start(ag->phy_dev);
+	} else if (pdata->mii_bus_dev && pdata->switch_data) {
+		ag71xx_ar7240_start(ag);
+	} else {
+		ag->link = 1;
+		ag71xx_link_adjust(ag);
+	}
+}
+
+void ag71xx_phy_stop(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	unsigned long flags;
+
+	if (ag->phy_dev)
+		phy_stop(ag->phy_dev);
+	else if (pdata->mii_bus_dev && pdata->switch_data)
+		ag71xx_ar7240_stop(ag);
+
+	spin_lock_irqsave(&ag->lock, flags);
+	if (ag->link) {
+		ag->link = 0;
+		ag71xx_link_adjust(ag);
+	}
+	spin_unlock_irqrestore(&ag->lock, flags);
+}
+
+static int ag71xx_phy_connect_fixed(struct ag71xx *ag)
+{
+	struct device *dev = &ag->pdev->dev;
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	int ret = 0;
+
+	/* use fixed settings */
+	switch (pdata->speed) {
+	case SPEED_10:
+	case SPEED_100:
+	case SPEED_1000:
+		break;
+	default:
+		dev_err(dev, "invalid speed specified\n");
+		ret = -EINVAL;
+		break;
+	}
+
+	dev_dbg(dev, "using fixed link parameters\n");
+
+	ag->duplex = pdata->duplex;
+	ag->speed = pdata->speed;
+
+	return ret;
+}
+
+static int ag71xx_phy_connect_multi(struct ag71xx *ag)
+{
+	struct device *dev = &ag->pdev->dev;
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+	struct phy_device *phydev = NULL;
+	int phy_addr;
+	int ret = 0;
+
+	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
+		if (!(pdata->phy_mask & (1 << phy_addr)))
+			continue;
+
+		if (ag->mii_bus->phy_map[phy_addr] == NULL)
+			continue;
+
+		DBG("%s: PHY found at %s, uid=%08x\n",
+			dev_name(dev),
+			dev_name(&ag->mii_bus->phy_map[phy_addr]->dev),
+			ag->mii_bus->phy_map[phy_addr]->phy_id);
+
+		if (phydev == NULL)
+			phydev = ag->mii_bus->phy_map[phy_addr];
+	}
+
+	if (!phydev) {
+		dev_err(dev, "no PHY found with phy_mask=%08x\n",
+			   pdata->phy_mask);
+		return -ENODEV;
+	}
+
+	ag->phy_dev = phy_connect(ag->dev, dev_name(&phydev->dev),
+				  &ag71xx_phy_link_adjust,
+				  pdata->phy_if_mode);
+
+	if (IS_ERR(ag->phy_dev)) {
+		dev_err(dev, "could not connect to PHY at %s\n",
+			   dev_name(&phydev->dev));
+		return PTR_ERR(ag->phy_dev);
+	}
+
+	/* mask with MAC supported features */
+	if (pdata->has_gbit)
+		phydev->supported &= PHY_GBIT_FEATURES;
+	else
+		phydev->supported &= PHY_BASIC_FEATURES;
+
+	phydev->advertising = phydev->supported;
+
+	dev_info(dev, "connected to PHY at %s [uid=%08x, driver=%s]\n",
+		    dev_name(&phydev->dev), phydev->phy_id, phydev->drv->name);
+
+	ag->link = 0;
+	ag->speed = 0;
+	ag->duplex = -1;
+
+	return ret;
+}
+
+static int dev_is_class(struct device *dev, void *class)
+{
+	if (dev->class != NULL && !strcmp(dev->class->name, class))
+		return 1;
+
+	return 0;
+}
+
+static struct device *dev_find_class(struct device *parent, char *class)
+{
+	if (dev_is_class(parent, class)) {
+		get_device(parent);
+		return parent;
+	}
+
+	return device_find_child(parent, class, dev_is_class);
+}
+
+static struct mii_bus *dev_to_mii_bus(struct device *dev)
+{
+	struct device *d;
+
+	d = dev_find_class(dev, "mdio_bus");
+	if (d != NULL) {
+		struct mii_bus *bus;
+
+		bus = to_mii_bus(d);
+		put_device(d);
+
+		return bus;
+	}
+
+	return NULL;
+}
+
+int ag71xx_phy_connect(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (pdata->mii_bus_dev == NULL ||
+	    pdata->mii_bus_dev->bus == NULL )
+		return ag71xx_phy_connect_fixed(ag);
+
+	ag->mii_bus = dev_to_mii_bus(pdata->mii_bus_dev);
+	if (ag->mii_bus == NULL) {
+		dev_err(&ag->pdev->dev, "unable to find MII bus on device '%s'\n",
+			   dev_name(pdata->mii_bus_dev));
+		return -ENODEV;
+	}
+
+	/* Reset the mdio bus explicitly */
+	if (ag->mii_bus->reset) {
+		mutex_lock(&ag->mii_bus->mdio_lock);
+		ag->mii_bus->reset(ag->mii_bus);
+		mutex_unlock(&ag->mii_bus->mdio_lock);
+	}
+
+	if (pdata->switch_data)
+		return ag71xx_ar7240_init(ag);
+
+	if (pdata->phy_mask)
+		return ag71xx_phy_connect_multi(ag);
+
+	return ag71xx_phy_connect_fixed(ag);
+}
+
+void ag71xx_phy_disconnect(struct ag71xx *ag)
+{
+	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
+
+	if (pdata->switch_data)
+		ag71xx_ar7240_cleanup(ag);
+	else if (ag->phy_dev)
+		phy_disconnect(ag->phy_dev);
+}
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/Kconfig linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/Kconfig
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/Kconfig	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,33 @@
+config AG71XX
+	tristate "Atheros AR7XXX/AR9XXX built-in ethernet mac support"
+	depends on ATH79
+	select PHYLIB
+	help
+	  If you wish to compile a kernel for AR7XXX/91XXX and enable
+	  ethernet support, then you should always answer Y to this.
+
+if AG71XX
+
+config AG71XX_DEBUG
+	bool "Atheros AR71xx built-in ethernet driver debugging"
+	default n
+	help
+	  Atheros AR71xx built-in ethernet driver debugging messages.
+
+config AG71XX_DEBUG_FS
+	bool "Atheros AR71xx built-in ethernet driver debugfs support"
+	depends on DEBUG_FS
+	default n
+	help
+	  Say Y, if you need access to various statistics provided by
+	  the ag71xx driver.
+
+config AG71XX_AR8216_SUPPORT
+	bool "special support for the Atheros AR8216 switch"
+	default n
+	default y if ATH79_MACH_WNR2000 || ATH79_MACH_MZK_W04NU
+	help
+	  Say 'y' here if you want to enable special support for the
+	  Atheros AR8216 switch found on some boards.
+
+endif
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/Makefile linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/Makefile
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/ag71xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/ag71xx/Makefile	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,15 @@
+#
+# Makefile for the Atheros AR71xx built-in ethernet macs
+#
+
+ag71xx-y	+= ag71xx_main.o
+ag71xx-y	+= ag71xx_ethtool.o
+ag71xx-y	+= ag71xx_phy.o
+ag71xx-y	+= ag71xx_mdio.o
+ag71xx-y	+= ag71xx_ar7240.o
+
+ag71xx-$(CONFIG_AG71XX_DEBUG_FS)	+= ag71xx_debugfs.o
+ag71xx-$(CONFIG_AG71XX_AR8216_SUPPORT)	+= ag71xx_ar8216.o
+
+obj-$(CONFIG_AG71XX)	+= ag71xx.o
+
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/Kconfig linux-4.1.13/drivers/net/ethernet/atheros/Kconfig
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/Kconfig	2015-12-04 19:57:03.882110905 +0100
@@ -5,7 +5,7 @@
 config NET_VENDOR_ATHEROS
 	bool "Atheros devices"
 	default y
-	depends on PCI
+	depends on (PCI || ATH79)
 	---help---
 	  If you have a network (Ethernet) card belonging to this class, say Y
 	  and read the Ethernet-HOWTO, available from
@@ -80,4 +80,6 @@
 	  To compile this driver as a module, choose M here.  The module
 	  will be called alx.
 
+source drivers/net/ethernet/atheros/ag71xx/Kconfig
+
 endif # NET_VENDOR_ATHEROS
diff -Nur linux-4.1.13.orig/drivers/net/ethernet/atheros/Makefile linux-4.1.13/drivers/net/ethernet/atheros/Makefile
--- linux-4.1.13.orig/drivers/net/ethernet/atheros/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/net/ethernet/atheros/Makefile	2015-12-04 19:57:03.882110905 +0100
@@ -2,6 +2,7 @@
 # Makefile for the Atheros network device drivers.
 #
 
+obj-$(CONFIG_AG71XX) += ag71xx/
 obj-$(CONFIG_ATL1) += atlx/
 obj-$(CONFIG_ATL2) += atlx/
 obj-$(CONFIG_ATL1E) += atl1e/
diff -Nur linux-4.1.13.orig/drivers/net/phy/at803x.c linux-4.1.13/drivers/net/phy/at803x.c
--- linux-4.1.13.orig/drivers/net/phy/at803x.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/net/phy/at803x.c	2015-12-04 19:57:03.890110382 +0100
@@ -12,12 +12,14 @@
  */
 
 #include <linux/phy.h>
+#include <linux/mdio.h>
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/of_gpio.h>
 #include <linux/gpio/consumer.h>
+#include <linux/platform_data/phy-at803x.h>
 
 #define AT803X_INTR_ENABLE			0x12
 #define AT803X_INTR_STATUS			0x13
@@ -34,8 +36,16 @@
 #define AT803X_INER				0x0012
 #define AT803X_INER_INIT			0xec00
 #define AT803X_INSR				0x0013
+
+#define AT803X_PCS_SMART_EEE_CTRL3			0x805D
+#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_MASK	0x3
+#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT	12
+#define AT803X_SMART_EEE_CTRL3_LPI_EN			BIT(8)
+
 #define AT803X_DEBUG_ADDR			0x1D
 #define AT803X_DEBUG_DATA			0x1E
+#define AT803X_DBG0_REG				0x00
+#define AT803X_DEBUG_RGMII_RX_CLK_DLY		BIT(8)
 #define AT803X_DEBUG_SYSTEM_MODE_CTRL		0x05
 #define AT803X_DEBUG_RGMII_TX_CLK_DLY		BIT(8)
 
@@ -50,6 +60,7 @@
 struct at803x_priv {
 	bool phy_reset:1;
 	struct gpio_desc *gpiod_reset;
+	int prev_speed;
 };
 
 struct at803x_context {
@@ -61,6 +72,43 @@
 	u16 led_control;
 };
 
+static u16
+at803x_dbg_reg_rmw(struct phy_device *phydev, u16 reg, u16 clear, u16 set)
+{
+	struct mii_bus *bus = phydev->bus;
+	int val;
+
+	mutex_lock(&bus->mdio_lock);
+
+	bus->write(bus, phydev->addr, AT803X_DEBUG_ADDR, reg);
+	val = bus->read(bus, phydev->addr, AT803X_DEBUG_DATA);
+	if (val < 0) {
+		val = 0xffff;
+		goto out;
+	}
+
+	val &= ~clear;
+	val |= set;
+	bus->write(bus, phydev->addr, AT803X_DEBUG_DATA, val);
+
+out:
+	mutex_unlock(&bus->mdio_lock);
+	return val;
+}
+
+static inline void
+at803x_dbg_reg_set(struct phy_device *phydev, u16 reg, u16 set)
+{
+	at803x_dbg_reg_rmw(phydev, reg, 0, set);
+}
+
+static inline void
+at803x_dbg_reg_clr(struct phy_device *phydev, u16 reg, u16 clear)
+{
+	at803x_dbg_reg_rmw(phydev, reg, clear, 0);
+}
+
+
 /* save relevant PHY registers to private copy */
 static void at803x_context_save(struct phy_device *phydev,
 				struct at803x_context *context)
@@ -209,8 +257,16 @@
 	return 0;
 }
 
+static void at803x_disable_smarteee(struct phy_device *phydev)
+{
+	phy_write_mmd(phydev, MDIO_MMD_PCS, AT803X_PCS_SMART_EEE_CTRL3,
+		1 << AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT);
+	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0);
+}
+
 static int at803x_config_init(struct phy_device *phydev)
 {
+	struct at803x_platform_data *pdata;
 	int ret;
 
 	ret = genphy_config_init(phydev);
@@ -228,6 +284,26 @@
 			return ret;
 	}
 
+	pdata = dev_get_platdata(&phydev->dev);
+	if (pdata) {
+		if (pdata->disable_smarteee)
+			at803x_disable_smarteee(phydev);
+
+		if (pdata->enable_rgmii_rx_delay)
+			at803x_dbg_reg_set(phydev, AT803X_DBG0_REG,
+				AT803X_DEBUG_RGMII_RX_CLK_DLY);
+		else
+			at803x_dbg_reg_clr(phydev, AT803X_DBG0_REG,
+				AT803X_DEBUG_RGMII_RX_CLK_DLY);
+
+		if (pdata->enable_rgmii_tx_delay)
+			at803x_dbg_reg_set(phydev, AT803X_DEBUG_SYSTEM_MODE_CTRL,
+				AT803X_DEBUG_RGMII_TX_CLK_DLY);
+		else
+			at803x_dbg_reg_clr(phydev, AT803X_DEBUG_SYSTEM_MODE_CTRL,
+				AT803X_DEBUG_RGMII_TX_CLK_DLY);
+	}
+
 	return 0;
 }
 
@@ -259,6 +335,8 @@
 static void at803x_link_change_notify(struct phy_device *phydev)
 {
 	struct at803x_priv *priv = phydev->priv;
+	struct at803x_platform_data *pdata;
+	pdata = dev_get_platdata(&phydev->dev);
 
 	/*
 	 * Conduct a hardware reset for AT8030 every time a link loss is
@@ -289,6 +367,26 @@
 			priv->phy_reset = false;
 		}
 	}
+	if (pdata && pdata->fixup_rgmii_tx_delay &&
+	    phydev->speed != priv->prev_speed) {
+		switch (phydev->speed) {
+		case SPEED_10:
+		case SPEED_100:
+			at803x_dbg_reg_set(phydev,
+				AT803X_DEBUG_SYSTEM_MODE_CTRL,
+				AT803X_DEBUG_RGMII_TX_CLK_DLY);
+			break;
+		case SPEED_1000:
+			at803x_dbg_reg_clr(phydev,
+				AT803X_DEBUG_SYSTEM_MODE_CTRL,
+				AT803X_DEBUG_RGMII_TX_CLK_DLY);
+			break;
+		default:
+			break;
+		}
+
+		priv->prev_speed = phydev->speed;
+	}
 }
 
 static struct phy_driver at803x_driver[] = {
diff -Nur linux-4.1.13.orig/drivers/net/phy/Kconfig linux-4.1.13/drivers/net/phy/Kconfig
--- linux-4.1.13.orig/drivers/net/phy/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/net/phy/Kconfig	2015-12-04 21:33:39.755626859 +0100
@@ -12,6 +12,16 @@
 
 if PHYLIB
 
+config SWCONFIG
+	tristate "Switch configuration API"
+	---help---
+	  Switch configuration API using netlink. This allows
+	  you to configure the VLAN features of certain switches.
+
+config SWCONFIG_LEDS
+	bool "Switch LED trigger support"
+	depends on (SWCONFIG && LEDS_TRIGGERS)
+
 comment "MII PHY device drivers"
 
 config AT803X_PHY
diff -Nur linux-4.1.13.orig/drivers/net/phy/Makefile linux-4.1.13/drivers/net/phy/Makefile
--- linux-4.1.13.orig/drivers/net/phy/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/net/phy/Makefile	2015-12-04 21:33:39.775625531 +0100
@@ -3,6 +3,7 @@
 libphy-objs			:= phy.o phy_device.o mdio_bus.o
 
 obj-$(CONFIG_PHYLIB)		+= libphy.o
+obj-$(CONFIG_SWCONFIG)		+= swconfig.o
 obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
 obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
 obj-$(CONFIG_CICADA_PHY)	+= cicada.o
diff -Nur linux-4.1.13.orig/drivers/net/phy/mdio-bitbang.c linux-4.1.13/drivers/net/phy/mdio-bitbang.c
--- linux-4.1.13.orig/drivers/net/phy/mdio-bitbang.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/net/phy/mdio-bitbang.c	2015-12-04 19:57:05.909978229 +0100
@@ -17,6 +17,7 @@
  * kind, whether express or implied.
  */
 
+#include <linux/irqflags.h>
 #include <linux/module.h>
 #include <linux/mdio-bitbang.h>
 #include <linux/types.h>
@@ -156,7 +157,9 @@
 {
 	struct mdiobb_ctrl *ctrl = bus->priv;
 	int ret, i;
+	long flags;
 
+	local_irq_save(flags);
 	if (reg & MII_ADDR_C45) {
 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
 		mdiobb_cmd(ctrl, MDIO_C45_READ, phy, reg);
@@ -165,26 +168,21 @@
 
 	ctrl->ops->set_mdio_dir(ctrl, 0);
 
-	/* check the turnaround bit: the PHY should be driving it to zero */
-	if (mdiobb_get_bit(ctrl) != 0) {
-		/* PHY didn't drive TA low -- flush any bits it
-		 * may be trying to send.
-		 */
-		for (i = 0; i < 32; i++)
-			mdiobb_get_bit(ctrl);
-
-		return 0xffff;
-	}
+	mdiobb_get_bit(ctrl);
 
 	ret = mdiobb_get_num(ctrl, 16);
 	mdiobb_get_bit(ctrl);
+	local_irq_restore(flags);
+
 	return ret;
 }
 
 static int mdiobb_write(struct mii_bus *bus, int phy, int reg, u16 val)
 {
 	struct mdiobb_ctrl *ctrl = bus->priv;
+	long flags;
 
+	local_irq_save(flags);
 	if (reg & MII_ADDR_C45) {
 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
 		mdiobb_cmd(ctrl, MDIO_C45_WRITE, phy, reg);
@@ -199,6 +197,8 @@
 
 	ctrl->ops->set_mdio_dir(ctrl, 0);
 	mdiobb_get_bit(ctrl);
+	local_irq_restore(flags);
+
 	return 0;
 }
 
diff -Nur linux-4.1.13.orig/drivers/net/phy/phy.c linux-4.1.13/drivers/net/phy/phy.c
--- linux-4.1.13.orig/drivers/net/phy/phy.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/net/phy/phy.c	2015-12-04 20:31:10.856994541 +0100
@@ -357,6 +357,50 @@
 }
 EXPORT_SYMBOL(phy_ethtool_gset);
 
+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr)
+{
+	u32 cmd;
+	int tmp;
+	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
+	struct ethtool_value edata = { ETHTOOL_GLINK };
+
+	if (get_user(cmd, (u32 *) useraddr))
+		return -EFAULT;
+
+	switch (cmd) {
+	case ETHTOOL_GSET:
+		phy_ethtool_gset(phydev, &ecmd);
+		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
+			return -EFAULT;
+		return 0;
+
+	case ETHTOOL_SSET:
+		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
+			return -EFAULT;
+		return phy_ethtool_sset(phydev, &ecmd);
+
+	case ETHTOOL_NWAY_RST:
+		/* if autoneg is off, it's an error */
+		tmp = phy_read(phydev, MII_BMCR);
+		if (tmp & BMCR_ANENABLE) {
+			tmp |= (BMCR_ANRESTART);
+			phy_write(phydev, MII_BMCR, tmp);
+			return 0;
+		}
+		return -EINVAL;
+
+	case ETHTOOL_GLINK:
+		edata.data = (phy_read(phydev,
+				MII_BMSR) & BMSR_LSTATUS) ? 1 : 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+
+	return -EOPNOTSUPP;
+}
+EXPORT_SYMBOL(phy_ethtool_ioctl);
+
 /**
  * phy_mii_ioctl - generic PHY MII ioctl interface
  * @phydev: the phy_device struct
diff -Nur linux-4.1.13.orig/drivers/net/phy/swconfig.c linux-4.1.13/drivers/net/phy/swconfig.c
--- linux-4.1.13.orig/drivers/net/phy/swconfig.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/phy/swconfig.c	2015-12-04 21:18:34.855186030 +0100
@@ -0,0 +1,1153 @@
+/*
+ * swconfig.c: Switch configuration API
+ *
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/if.h>
+#include <linux/if_ether.h>
+#include <linux/capability.h>
+#include <linux/skbuff.h>
+#include <linux/switch.h>
+#include <linux/of.h>
+#include <linux/version.h>
+
+#define SWCONFIG_DEVNAME	"switch%d"
+
+#include "swconfig_leds.c"
+
+MODULE_AUTHOR("Felix Fietkau <nbd@openwrt.org>");
+MODULE_LICENSE("GPL");
+
+static int swdev_id;
+static struct list_head swdevs;
+static DEFINE_SPINLOCK(swdevs_lock);
+struct swconfig_callback;
+
+struct swconfig_callback {
+	struct sk_buff *msg;
+	struct genlmsghdr *hdr;
+	struct genl_info *info;
+	int cmd;
+
+	/* callback for filling in the message data */
+	int (*fill)(struct swconfig_callback *cb, void *arg);
+
+	/* callback for closing the message before sending it */
+	int (*close)(struct swconfig_callback *cb, void *arg);
+
+	struct nlattr *nest[4];
+	int args[4];
+};
+
+/* defaults */
+
+static int
+swconfig_get_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr,
+			struct switch_val *val)
+{
+	int ret;
+	if (val->port_vlan >= dev->vlans)
+		return -EINVAL;
+
+	if (!dev->ops->get_vlan_ports)
+		return -EOPNOTSUPP;
+
+	ret = dev->ops->get_vlan_ports(dev, val);
+	return ret;
+}
+
+static int
+swconfig_set_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr,
+			struct switch_val *val)
+{
+	struct switch_port *ports = val->value.ports;
+	const struct switch_dev_ops *ops = dev->ops;
+	int i;
+
+	if (val->port_vlan >= dev->vlans)
+		return -EINVAL;
+
+	/* validate ports */
+	if (val->len > dev->ports)
+		return -EINVAL;
+
+	if (!ops->set_vlan_ports)
+		return -EOPNOTSUPP;
+
+	for (i = 0; i < val->len; i++) {
+		if (ports[i].id >= dev->ports)
+			return -EINVAL;
+
+		if (ops->set_port_pvid &&
+		    !(ports[i].flags & (1 << SWITCH_PORT_FLAG_TAGGED)))
+			ops->set_port_pvid(dev, ports[i].id, val->port_vlan);
+	}
+
+	return ops->set_vlan_ports(dev, val);
+}
+
+static int
+swconfig_set_pvid(struct switch_dev *dev, const struct switch_attr *attr,
+			struct switch_val *val)
+{
+	if (val->port_vlan >= dev->ports)
+		return -EINVAL;
+
+	if (!dev->ops->set_port_pvid)
+		return -EOPNOTSUPP;
+
+	return dev->ops->set_port_pvid(dev, val->port_vlan, val->value.i);
+}
+
+static int
+swconfig_get_pvid(struct switch_dev *dev, const struct switch_attr *attr,
+			struct switch_val *val)
+{
+	if (val->port_vlan >= dev->ports)
+		return -EINVAL;
+
+	if (!dev->ops->get_port_pvid)
+		return -EOPNOTSUPP;
+
+	return dev->ops->get_port_pvid(dev, val->port_vlan, &val->value.i);
+}
+
+static const char *
+swconfig_speed_str(enum switch_port_speed speed)
+{
+	switch (speed) {
+	case SWITCH_PORT_SPEED_10:
+		return "10baseT";
+	case SWITCH_PORT_SPEED_100:
+		return "100baseT";
+	case SWITCH_PORT_SPEED_1000:
+		return "1000baseT";
+	default:
+		break;
+	}
+
+	return "unknown";
+}
+
+static int
+swconfig_get_link(struct switch_dev *dev, const struct switch_attr *attr,
+			struct switch_val *val)
+{
+	struct switch_port_link link;
+	int len;
+	int ret;
+
+	if (val->port_vlan >= dev->ports)
+		return -EINVAL;
+
+	if (!dev->ops->get_port_link)
+		return -EOPNOTSUPP;
+
+	memset(&link, 0, sizeof(link));
+	ret = dev->ops->get_port_link(dev, val->port_vlan, &link);
+	if (ret)
+		return ret;
+
+	memset(dev->buf, 0, sizeof(dev->buf));
+
+	if (link.link)
+		len = snprintf(dev->buf, sizeof(dev->buf),
+			       "port:%d link:up speed:%s %s-duplex %s%s%s%s%s",
+			       val->port_vlan,
+			       swconfig_speed_str(link.speed),
+			       link.duplex ? "full" : "half",
+			       link.tx_flow ? "txflow " : "",
+			       link.rx_flow ?	"rxflow " : "",
+			       link.eee & ADVERTISED_100baseT_Full ? "eee100 " : "",
+			       link.eee & ADVERTISED_1000baseT_Full ? "eee1000 " : "",
+			       link.aneg ? "auto" : "");
+	else
+		len = snprintf(dev->buf, sizeof(dev->buf), "port:%d link:down",
+			       val->port_vlan);
+
+	val->value.s = dev->buf;
+	val->len = len;
+
+	return 0;
+}
+
+static int
+swconfig_apply_config(struct switch_dev *dev, const struct switch_attr *attr,
+			struct switch_val *val)
+{
+	/* don't complain if not supported by the switch driver */
+	if (!dev->ops->apply_config)
+		return 0;
+
+	return dev->ops->apply_config(dev);
+}
+
+static int
+swconfig_reset_switch(struct switch_dev *dev, const struct switch_attr *attr,
+			struct switch_val *val)
+{
+	/* don't complain if not supported by the switch driver */
+	if (!dev->ops->reset_switch)
+		return 0;
+
+	return dev->ops->reset_switch(dev);
+}
+
+enum global_defaults {
+	GLOBAL_APPLY,
+	GLOBAL_RESET,
+};
+
+enum vlan_defaults {
+	VLAN_PORTS,
+};
+
+enum port_defaults {
+	PORT_PVID,
+	PORT_LINK,
+};
+
+static struct switch_attr default_global[] = {
+	[GLOBAL_APPLY] = {
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "apply",
+		.description = "Activate changes in the hardware",
+		.set = swconfig_apply_config,
+	},
+	[GLOBAL_RESET] = {
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset",
+		.description = "Reset the switch",
+		.set = swconfig_reset_switch,
+	}
+};
+
+static struct switch_attr default_port[] = {
+	[PORT_PVID] = {
+		.type = SWITCH_TYPE_INT,
+		.name = "pvid",
+		.description = "Primary VLAN ID",
+		.set = swconfig_set_pvid,
+		.get = swconfig_get_pvid,
+	},
+	[PORT_LINK] = {
+		.type = SWITCH_TYPE_STRING,
+		.name = "link",
+		.description = "Get port link information",
+		.set = NULL,
+		.get = swconfig_get_link,
+	}
+};
+
+static struct switch_attr default_vlan[] = {
+	[VLAN_PORTS] = {
+		.type = SWITCH_TYPE_PORTS,
+		.name = "ports",
+		.description = "VLAN port mapping",
+		.set = swconfig_set_vlan_ports,
+		.get = swconfig_get_vlan_ports,
+	},
+};
+
+static const struct switch_attr *
+swconfig_find_attr_by_name(const struct switch_attrlist *alist,
+				const char *name)
+{
+	int i;
+
+	for (i = 0; i < alist->n_attr; i++)
+		if (strcmp(name, alist->attr[i].name) == 0)
+			return &alist->attr[i];
+
+	return NULL;
+}
+
+static void swconfig_defaults_init(struct switch_dev *dev)
+{
+	const struct switch_dev_ops *ops = dev->ops;
+
+	dev->def_global = 0;
+	dev->def_vlan = 0;
+	dev->def_port = 0;
+
+	if (ops->get_vlan_ports || ops->set_vlan_ports)
+		set_bit(VLAN_PORTS, &dev->def_vlan);
+
+	if (ops->get_port_pvid || ops->set_port_pvid)
+		set_bit(PORT_PVID, &dev->def_port);
+
+	if (ops->get_port_link &&
+	    !swconfig_find_attr_by_name(&ops->attr_port, "link"))
+		set_bit(PORT_LINK, &dev->def_port);
+
+	/* always present, can be no-op */
+	set_bit(GLOBAL_APPLY, &dev->def_global);
+	set_bit(GLOBAL_RESET, &dev->def_global);
+}
+
+
+static struct genl_family switch_fam = {
+	.id = GENL_ID_GENERATE,
+	.name = "switch",
+	.hdrsize = 0,
+	.version = 1,
+	.maxattr = SWITCH_ATTR_MAX,
+};
+
+static const struct nla_policy switch_policy[SWITCH_ATTR_MAX+1] = {
+	[SWITCH_ATTR_ID] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_ID] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_PORT] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_VLAN] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_VALUE_INT] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_VALUE_STR] = { .type = NLA_NUL_STRING },
+	[SWITCH_ATTR_OP_VALUE_PORTS] = { .type = NLA_NESTED },
+	[SWITCH_ATTR_TYPE] = { .type = NLA_U32 },
+};
+
+static const struct nla_policy port_policy[SWITCH_PORT_ATTR_MAX+1] = {
+	[SWITCH_PORT_ID] = { .type = NLA_U32 },
+	[SWITCH_PORT_FLAG_TAGGED] = { .type = NLA_FLAG },
+};
+
+static inline void
+swconfig_lock(void)
+{
+	spin_lock(&swdevs_lock);
+}
+
+static inline void
+swconfig_unlock(void)
+{
+	spin_unlock(&swdevs_lock);
+}
+
+static struct switch_dev *
+swconfig_get_dev(struct genl_info *info)
+{
+	struct switch_dev *dev = NULL;
+	struct switch_dev *p;
+	int id;
+
+	if (!info->attrs[SWITCH_ATTR_ID])
+		goto done;
+
+	id = nla_get_u32(info->attrs[SWITCH_ATTR_ID]);
+	swconfig_lock();
+	list_for_each_entry(p, &swdevs, dev_list) {
+		if (id != p->id)
+			continue;
+
+		dev = p;
+		break;
+	}
+	if (dev)
+		mutex_lock(&dev->sw_mutex);
+	else
+		pr_debug("device %d not found\n", id);
+	swconfig_unlock();
+done:
+	return dev;
+}
+
+static inline void
+swconfig_put_dev(struct switch_dev *dev)
+{
+	mutex_unlock(&dev->sw_mutex);
+}
+
+static int
+swconfig_dump_attr(struct swconfig_callback *cb, void *arg)
+{
+	struct switch_attr *op = arg;
+	struct genl_info *info = cb->info;
+	struct sk_buff *msg = cb->msg;
+	int id = cb->args[0];
+	void *hdr;
+
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &switch_fam,
+			NLM_F_MULTI, SWITCH_CMD_NEW_ATTR);
+	if (IS_ERR(hdr))
+		return -1;
+
+	if (nla_put_u32(msg, SWITCH_ATTR_OP_ID, id))
+		goto nla_put_failure;
+	if (nla_put_u32(msg, SWITCH_ATTR_OP_TYPE, op->type))
+		goto nla_put_failure;
+	if (nla_put_string(msg, SWITCH_ATTR_OP_NAME, op->name))
+		goto nla_put_failure;
+	if (op->description)
+		if (nla_put_string(msg, SWITCH_ATTR_OP_DESCRIPTION,
+			op->description))
+			goto nla_put_failure;
+
+	genlmsg_end(msg, hdr);
+	return msg->len;
+nla_put_failure:
+	genlmsg_cancel(msg, hdr);
+	return -EMSGSIZE;
+}
+
+/* spread multipart messages across multiple message buffers */
+static int
+swconfig_send_multipart(struct swconfig_callback *cb, void *arg)
+{
+	struct genl_info *info = cb->info;
+	int restart = 0;
+	int err;
+
+	do {
+		if (!cb->msg) {
+			cb->msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+			if (cb->msg == NULL)
+				goto error;
+		}
+
+		if (!(cb->fill(cb, arg) < 0))
+			break;
+
+		/* fill failed, check if this was already the second attempt */
+		if (restart)
+			goto error;
+
+		/* try again in a new message, send the current one */
+		restart = 1;
+		if (cb->close) {
+			if (cb->close(cb, arg) < 0)
+				goto error;
+		}
+		err = genlmsg_reply(cb->msg, info);
+		cb->msg = NULL;
+		if (err < 0)
+			goto error;
+
+	} while (restart);
+
+	return 0;
+
+error:
+	if (cb->msg)
+		nlmsg_free(cb->msg);
+	return -1;
+}
+
+static int
+swconfig_list_attrs(struct sk_buff *skb, struct genl_info *info)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct switch_attrlist *alist;
+	struct switch_dev *dev;
+	struct swconfig_callback cb;
+	int err = -EINVAL;
+	int i;
+
+	/* defaults */
+	struct switch_attr *def_list;
+	unsigned long *def_active;
+	int n_def;
+
+	dev = swconfig_get_dev(info);
+	if (!dev)
+		return -EINVAL;
+
+	switch (hdr->cmd) {
+	case SWITCH_CMD_LIST_GLOBAL:
+		alist = &dev->ops->attr_global;
+		def_list = default_global;
+		def_active = &dev->def_global;
+		n_def = ARRAY_SIZE(default_global);
+		break;
+	case SWITCH_CMD_LIST_VLAN:
+		alist = &dev->ops->attr_vlan;
+		def_list = default_vlan;
+		def_active = &dev->def_vlan;
+		n_def = ARRAY_SIZE(default_vlan);
+		break;
+	case SWITCH_CMD_LIST_PORT:
+		alist = &dev->ops->attr_port;
+		def_list = default_port;
+		def_active = &dev->def_port;
+		n_def = ARRAY_SIZE(default_port);
+		break;
+	default:
+		WARN_ON(1);
+		goto out;
+	}
+
+	memset(&cb, 0, sizeof(cb));
+	cb.info = info;
+	cb.fill = swconfig_dump_attr;
+	for (i = 0; i < alist->n_attr; i++) {
+		if (alist->attr[i].disabled)
+			continue;
+		cb.args[0] = i;
+		err = swconfig_send_multipart(&cb, (void *) &alist->attr[i]);
+		if (err < 0)
+			goto error;
+	}
+
+	/* defaults */
+	for (i = 0; i < n_def; i++) {
+		if (!test_bit(i, def_active))
+			continue;
+		cb.args[0] = SWITCH_ATTR_DEFAULTS_OFFSET + i;
+		err = swconfig_send_multipart(&cb, (void *) &def_list[i]);
+		if (err < 0)
+			goto error;
+	}
+	swconfig_put_dev(dev);
+
+	if (!cb.msg)
+		return 0;
+
+	return genlmsg_reply(cb.msg, info);
+
+error:
+	if (cb.msg)
+		nlmsg_free(cb.msg);
+out:
+	swconfig_put_dev(dev);
+	return err;
+}
+
+static const struct switch_attr *
+swconfig_lookup_attr(struct switch_dev *dev, struct genl_info *info,
+		struct switch_val *val)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct switch_attrlist *alist;
+	const struct switch_attr *attr = NULL;
+	int attr_id;
+
+	/* defaults */
+	struct switch_attr *def_list;
+	unsigned long *def_active;
+	int n_def;
+
+	if (!info->attrs[SWITCH_ATTR_OP_ID])
+		goto done;
+
+	switch (hdr->cmd) {
+	case SWITCH_CMD_SET_GLOBAL:
+	case SWITCH_CMD_GET_GLOBAL:
+		alist = &dev->ops->attr_global;
+		def_list = default_global;
+		def_active = &dev->def_global;
+		n_def = ARRAY_SIZE(default_global);
+		break;
+	case SWITCH_CMD_SET_VLAN:
+	case SWITCH_CMD_GET_VLAN:
+		alist = &dev->ops->attr_vlan;
+		def_list = default_vlan;
+		def_active = &dev->def_vlan;
+		n_def = ARRAY_SIZE(default_vlan);
+		if (!info->attrs[SWITCH_ATTR_OP_VLAN])
+			goto done;
+		val->port_vlan = nla_get_u32(info->attrs[SWITCH_ATTR_OP_VLAN]);
+		if (val->port_vlan >= dev->vlans)
+			goto done;
+		break;
+	case SWITCH_CMD_SET_PORT:
+	case SWITCH_CMD_GET_PORT:
+		alist = &dev->ops->attr_port;
+		def_list = default_port;
+		def_active = &dev->def_port;
+		n_def = ARRAY_SIZE(default_port);
+		if (!info->attrs[SWITCH_ATTR_OP_PORT])
+			goto done;
+		val->port_vlan = nla_get_u32(info->attrs[SWITCH_ATTR_OP_PORT]);
+		if (val->port_vlan >= dev->ports)
+			goto done;
+		break;
+	default:
+		WARN_ON(1);
+		goto done;
+	}
+
+	if (!alist)
+		goto done;
+
+	attr_id = nla_get_u32(info->attrs[SWITCH_ATTR_OP_ID]);
+	if (attr_id >= SWITCH_ATTR_DEFAULTS_OFFSET) {
+		attr_id -= SWITCH_ATTR_DEFAULTS_OFFSET;
+		if (attr_id >= n_def)
+			goto done;
+		if (!test_bit(attr_id, def_active))
+			goto done;
+		attr = &def_list[attr_id];
+	} else {
+		if (attr_id >= alist->n_attr)
+			goto done;
+		attr = &alist->attr[attr_id];
+	}
+
+	if (attr->disabled)
+		attr = NULL;
+
+done:
+	if (!attr)
+		pr_debug("attribute lookup failed\n");
+	val->attr = attr;
+	return attr;
+}
+
+static int
+swconfig_parse_ports(struct sk_buff *msg, struct nlattr *head,
+		struct switch_val *val, int max)
+{
+	struct nlattr *nla;
+	int rem;
+
+	val->len = 0;
+	nla_for_each_nested(nla, head, rem) {
+		struct nlattr *tb[SWITCH_PORT_ATTR_MAX+1];
+		struct switch_port *port = &val->value.ports[val->len];
+
+		if (val->len >= max)
+			return -EINVAL;
+
+		if (nla_parse_nested(tb, SWITCH_PORT_ATTR_MAX, nla,
+				port_policy))
+			return -EINVAL;
+
+		if (!tb[SWITCH_PORT_ID])
+			return -EINVAL;
+
+		port->id = nla_get_u32(tb[SWITCH_PORT_ID]);
+		if (tb[SWITCH_PORT_FLAG_TAGGED])
+			port->flags |= (1 << SWITCH_PORT_FLAG_TAGGED);
+		val->len++;
+	}
+
+	return 0;
+}
+
+static int
+swconfig_set_attr(struct sk_buff *skb, struct genl_info *info)
+{
+	const struct switch_attr *attr;
+	struct switch_dev *dev;
+	struct switch_val val;
+	int err = -EINVAL;
+
+	dev = swconfig_get_dev(info);
+	if (!dev)
+		return -EINVAL;
+
+	memset(&val, 0, sizeof(val));
+	attr = swconfig_lookup_attr(dev, info, &val);
+	if (!attr || !attr->set)
+		goto error;
+
+	val.attr = attr;
+	switch (attr->type) {
+	case SWITCH_TYPE_NOVAL:
+		break;
+	case SWITCH_TYPE_INT:
+		if (!info->attrs[SWITCH_ATTR_OP_VALUE_INT])
+			goto error;
+		val.value.i =
+			nla_get_u32(info->attrs[SWITCH_ATTR_OP_VALUE_INT]);
+		break;
+	case SWITCH_TYPE_STRING:
+		if (!info->attrs[SWITCH_ATTR_OP_VALUE_STR])
+			goto error;
+		val.value.s =
+			nla_data(info->attrs[SWITCH_ATTR_OP_VALUE_STR]);
+		break;
+	case SWITCH_TYPE_PORTS:
+		val.value.ports = dev->portbuf;
+		memset(dev->portbuf, 0,
+			sizeof(struct switch_port) * dev->ports);
+
+		/* TODO: implement multipart? */
+		if (info->attrs[SWITCH_ATTR_OP_VALUE_PORTS]) {
+			err = swconfig_parse_ports(skb,
+				info->attrs[SWITCH_ATTR_OP_VALUE_PORTS],
+				&val, dev->ports);
+			if (err < 0)
+				goto error;
+		} else {
+			val.len = 0;
+			err = 0;
+		}
+		break;
+	default:
+		goto error;
+	}
+
+	err = attr->set(dev, attr, &val);
+error:
+	swconfig_put_dev(dev);
+	return err;
+}
+
+static int
+swconfig_close_portlist(struct swconfig_callback *cb, void *arg)
+{
+	if (cb->nest[0])
+		nla_nest_end(cb->msg, cb->nest[0]);
+	return 0;
+}
+
+static int
+swconfig_send_port(struct swconfig_callback *cb, void *arg)
+{
+	const struct switch_port *port = arg;
+	struct nlattr *p = NULL;
+
+	if (!cb->nest[0]) {
+		cb->nest[0] = nla_nest_start(cb->msg, cb->cmd);
+		if (!cb->nest[0])
+			return -1;
+	}
+
+	p = nla_nest_start(cb->msg, SWITCH_ATTR_PORT);
+	if (!p)
+		goto error;
+
+	if (nla_put_u32(cb->msg, SWITCH_PORT_ID, port->id))
+		goto nla_put_failure;
+	if (port->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
+		if (nla_put_flag(cb->msg, SWITCH_PORT_FLAG_TAGGED))
+			goto nla_put_failure;
+	}
+
+	nla_nest_end(cb->msg, p);
+	return 0;
+
+nla_put_failure:
+		nla_nest_cancel(cb->msg, p);
+error:
+	nla_nest_cancel(cb->msg, cb->nest[0]);
+	return -1;
+}
+
+static int
+swconfig_send_ports(struct sk_buff **msg, struct genl_info *info, int attr,
+		const struct switch_val *val)
+{
+	struct swconfig_callback cb;
+	int err = 0;
+	int i;
+
+	if (!val->value.ports)
+		return -EINVAL;
+
+	memset(&cb, 0, sizeof(cb));
+	cb.cmd = attr;
+	cb.msg = *msg;
+	cb.info = info;
+	cb.fill = swconfig_send_port;
+	cb.close = swconfig_close_portlist;
+
+	cb.nest[0] = nla_nest_start(cb.msg, cb.cmd);
+	for (i = 0; i < val->len; i++) {
+		err = swconfig_send_multipart(&cb, &val->value.ports[i]);
+		if (err)
+			goto done;
+	}
+	err = val->len;
+	swconfig_close_portlist(&cb, NULL);
+	*msg = cb.msg;
+
+done:
+	return err;
+}
+
+static int
+swconfig_get_attr(struct sk_buff *skb, struct genl_info *info)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct switch_attr *attr;
+	struct switch_dev *dev;
+	struct sk_buff *msg = NULL;
+	struct switch_val val;
+	int err = -EINVAL;
+	int cmd = hdr->cmd;
+
+	dev = swconfig_get_dev(info);
+	if (!dev)
+		return -EINVAL;
+
+	memset(&val, 0, sizeof(val));
+	attr = swconfig_lookup_attr(dev, info, &val);
+	if (!attr || !attr->get)
+		goto error;
+
+	if (attr->type == SWITCH_TYPE_PORTS) {
+		val.value.ports = dev->portbuf;
+		memset(dev->portbuf, 0,
+			sizeof(struct switch_port) * dev->ports);
+	}
+
+	err = attr->get(dev, attr, &val);
+	if (err)
+		goto error;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		goto error;
+
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &switch_fam,
+			0, cmd);
+	if (IS_ERR(hdr))
+		goto nla_put_failure;
+
+	switch (attr->type) {
+	case SWITCH_TYPE_INT:
+		if (nla_put_u32(msg, SWITCH_ATTR_OP_VALUE_INT, val.value.i))
+			goto nla_put_failure;
+		break;
+	case SWITCH_TYPE_STRING:
+		if (nla_put_string(msg, SWITCH_ATTR_OP_VALUE_STR, val.value.s))
+			goto nla_put_failure;
+		break;
+	case SWITCH_TYPE_PORTS:
+		err = swconfig_send_ports(&msg, info,
+				SWITCH_ATTR_OP_VALUE_PORTS, &val);
+		if (err < 0)
+			goto nla_put_failure;
+		break;
+	default:
+		pr_debug("invalid type in attribute\n");
+		err = -EINVAL;
+		goto error;
+	}
+	genlmsg_end(msg, hdr);
+	err = msg->len;
+	if (err < 0)
+		goto nla_put_failure;
+
+	swconfig_put_dev(dev);
+	return genlmsg_reply(msg, info);
+
+nla_put_failure:
+	if (msg)
+		nlmsg_free(msg);
+error:
+	swconfig_put_dev(dev);
+	if (!err)
+		err = -ENOMEM;
+	return err;
+}
+
+static int
+swconfig_send_switch(struct sk_buff *msg, u32 pid, u32 seq, int flags,
+		const struct switch_dev *dev)
+{
+	struct nlattr *p = NULL, *m = NULL;
+	void *hdr;
+	int i;
+
+	hdr = genlmsg_put(msg, pid, seq, &switch_fam, flags,
+			SWITCH_CMD_NEW_ATTR);
+	if (IS_ERR(hdr))
+		return -1;
+
+	if (nla_put_u32(msg, SWITCH_ATTR_ID, dev->id))
+		goto nla_put_failure;
+	if (nla_put_string(msg, SWITCH_ATTR_DEV_NAME, dev->devname))
+		goto nla_put_failure;
+	if (nla_put_string(msg, SWITCH_ATTR_ALIAS, dev->alias))
+		goto nla_put_failure;
+	if (nla_put_string(msg, SWITCH_ATTR_NAME, dev->name))
+		goto nla_put_failure;
+	if (nla_put_u32(msg, SWITCH_ATTR_VLANS, dev->vlans))
+		goto nla_put_failure;
+	if (nla_put_u32(msg, SWITCH_ATTR_PORTS, dev->ports))
+		goto nla_put_failure;
+	if (nla_put_u32(msg, SWITCH_ATTR_CPU_PORT, dev->cpu_port))
+		goto nla_put_failure;
+
+	m = nla_nest_start(msg, SWITCH_ATTR_PORTMAP);
+	if (!m)
+		goto nla_put_failure;
+	for (i = 0; i < dev->ports; i++) {
+		p = nla_nest_start(msg, SWITCH_ATTR_PORTS);
+		if (!p)
+			continue;
+		if (dev->portmap[i].s) {
+			if (nla_put_string(msg, SWITCH_PORTMAP_SEGMENT,
+						dev->portmap[i].s))
+				goto nla_put_failure;
+			if (nla_put_u32(msg, SWITCH_PORTMAP_VIRT,
+						dev->portmap[i].virt))
+				goto nla_put_failure;
+		}
+		nla_nest_end(msg, p);
+	}
+	nla_nest_end(msg, m);
+	genlmsg_end(msg, hdr);
+	return msg->len;
+nla_put_failure:
+	genlmsg_cancel(msg, hdr);
+	return -EMSGSIZE;
+}
+
+static int swconfig_dump_switches(struct sk_buff *skb,
+		struct netlink_callback *cb)
+{
+	struct switch_dev *dev;
+	int start = cb->args[0];
+	int idx = 0;
+
+	swconfig_lock();
+	list_for_each_entry(dev, &swdevs, dev_list) {
+		if (++idx <= start)
+			continue;
+		if (swconfig_send_switch(skb, NETLINK_CB(cb->skb).portid,
+				cb->nlh->nlmsg_seq, NLM_F_MULTI,
+				dev) < 0)
+			break;
+	}
+	swconfig_unlock();
+	cb->args[0] = idx;
+
+	return skb->len;
+}
+
+static int
+swconfig_done(struct netlink_callback *cb)
+{
+	return 0;
+}
+
+static struct genl_ops swconfig_ops[] = {
+	{
+		.cmd = SWITCH_CMD_LIST_GLOBAL,
+		.doit = swconfig_list_attrs,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_LIST_VLAN,
+		.doit = swconfig_list_attrs,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_LIST_PORT,
+		.doit = swconfig_list_attrs,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_GLOBAL,
+		.doit = swconfig_get_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_VLAN,
+		.doit = swconfig_get_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_PORT,
+		.doit = swconfig_get_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_SET_GLOBAL,
+		.doit = swconfig_set_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_SET_VLAN,
+		.doit = swconfig_set_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_SET_PORT,
+		.doit = swconfig_set_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_SWITCH,
+		.dumpit = swconfig_dump_switches,
+		.policy = switch_policy,
+		.done = swconfig_done,
+	}
+};
+
+#ifdef CONFIG_OF
+void
+of_switch_load_portmap(struct switch_dev *dev)
+{
+	struct device_node *port;
+
+	if (!dev->of_node)
+		return;
+
+	for_each_child_of_node(dev->of_node, port) {
+		const __be32 *prop;
+		const char *segment;
+		int size, phys;
+
+		if (!of_device_is_compatible(port, "swconfig,port"))
+			continue;
+
+		if (of_property_read_string(port, "swconfig,segment", &segment))
+			continue;
+
+		prop = of_get_property(port, "swconfig,portmap", &size);
+		if (!prop)
+			continue;
+
+		if (size != (2 * sizeof(*prop))) {
+			pr_err("%s: failed to parse port mapping\n",
+					port->name);
+			continue;
+		}
+
+		phys = be32_to_cpup(prop++);
+		if ((phys < 0) | (phys >= dev->ports)) {
+			pr_err("%s: physical port index out of range\n",
+					port->name);
+			continue;
+		}
+
+		dev->portmap[phys].s = kstrdup(segment, GFP_KERNEL);
+		dev->portmap[phys].virt = be32_to_cpup(prop);
+		pr_debug("Found port: %s, physical: %d, virtual: %d\n",
+			segment, phys, dev->portmap[phys].virt);
+	}
+}
+#endif
+
+int
+register_switch(struct switch_dev *dev, struct net_device *netdev)
+{
+	struct switch_dev *sdev;
+	const int max_switches = 8 * sizeof(unsigned long);
+	unsigned long in_use = 0;
+	int err;
+	int i;
+
+	INIT_LIST_HEAD(&dev->dev_list);
+	if (netdev) {
+		dev->netdev = netdev;
+		if (!dev->alias)
+			dev->alias = netdev->name;
+	}
+	BUG_ON(!dev->alias);
+
+	if (dev->ports > 0) {
+		dev->portbuf = kzalloc(sizeof(struct switch_port) *
+				dev->ports, GFP_KERNEL);
+		if (!dev->portbuf)
+			return -ENOMEM;
+		dev->portmap = kzalloc(sizeof(struct switch_portmap) *
+				dev->ports, GFP_KERNEL);
+		if (!dev->portmap) {
+			kfree(dev->portbuf);
+			return -ENOMEM;
+		}
+	}
+	swconfig_defaults_init(dev);
+	mutex_init(&dev->sw_mutex);
+	swconfig_lock();
+	dev->id = ++swdev_id;
+
+	list_for_each_entry(sdev, &swdevs, dev_list) {
+		if (!sscanf(sdev->devname, SWCONFIG_DEVNAME, &i))
+			continue;
+		if (i < 0 || i > max_switches)
+			continue;
+
+		set_bit(i, &in_use);
+	}
+	i = find_first_zero_bit(&in_use, max_switches);
+
+	if (i == max_switches) {
+		swconfig_unlock();
+		return -ENFILE;
+	}
+
+#ifdef CONFIG_OF
+	if (dev->ports)
+		of_switch_load_portmap(dev);
+#endif
+
+	/* fill device name */
+	snprintf(dev->devname, IFNAMSIZ, SWCONFIG_DEVNAME, i);
+
+	list_add_tail(&dev->dev_list, &swdevs);
+	swconfig_unlock();
+
+	err = swconfig_create_led_trigger(dev);
+	if (err)
+		return err;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(register_switch);
+
+void
+unregister_switch(struct switch_dev *dev)
+{
+	swconfig_destroy_led_trigger(dev);
+	kfree(dev->portbuf);
+	mutex_lock(&dev->sw_mutex);
+	swconfig_lock();
+	list_del(&dev->dev_list);
+	swconfig_unlock();
+	mutex_unlock(&dev->sw_mutex);
+}
+EXPORT_SYMBOL_GPL(unregister_switch);
+
+
+static int __init
+swconfig_init(void)
+{
+	int err;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0))
+	int i;
+#endif
+
+	INIT_LIST_HEAD(&swdevs);
+	
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0))
+	err = genl_register_family(&switch_fam);
+	if (err)
+		return err;
+
+	for (i = 0; i < ARRAY_SIZE(swconfig_ops); i++) {
+		err = genl_register_ops(&switch_fam, &swconfig_ops[i]);
+		if (err)
+			goto unregister;
+	}
+	return 0;
+
+unregister:
+	genl_unregister_family(&switch_fam);
+	return err;
+#else
+	err = genl_register_family_with_ops(&switch_fam, swconfig_ops);
+	if (err)
+		return err;
+	return 0;
+#endif
+}
+
+static void __exit
+swconfig_exit(void)
+{
+	genl_unregister_family(&switch_fam);
+}
+
+module_init(swconfig_init);
+module_exit(swconfig_exit);
+
diff -Nur linux-4.1.13.orig/drivers/net/phy/swconfig_leds.c linux-4.1.13/drivers/net/phy/swconfig_leds.c
--- linux-4.1.13.orig/drivers/net/phy/swconfig_leds.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/net/phy/swconfig_leds.c	2015-12-04 21:45:30.824406773 +0100
@@ -0,0 +1,354 @@
+/*
+ * swconfig_led.c: LED trigger support for the switch configuration API
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ */
+
+#ifdef CONFIG_SWCONFIG_LEDS
+
+#include <linux/leds.h>
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+
+#define SWCONFIG_LED_TIMER_INTERVAL	(HZ / 10)
+#define SWCONFIG_LED_NUM_PORTS		32
+
+struct switch_led_trigger {
+	struct led_trigger trig;
+	struct switch_dev *swdev;
+
+	struct delayed_work sw_led_work;
+	u32 port_mask;
+	u32 port_link;
+	unsigned long port_traffic[SWCONFIG_LED_NUM_PORTS];
+};
+
+struct swconfig_trig_data {
+	struct led_classdev *led_cdev;
+	struct switch_dev *swdev;
+
+	rwlock_t lock;
+	u32 port_mask;
+
+	bool prev_link;
+	unsigned long prev_traffic;
+	enum led_brightness prev_brightness;
+};
+
+static void
+swconfig_trig_set_brightness(struct swconfig_trig_data *trig_data,
+			     enum led_brightness brightness)
+{
+	led_set_brightness(trig_data->led_cdev, brightness);
+	trig_data->prev_brightness = brightness;
+}
+
+static void
+swconfig_trig_update_port_mask(struct led_trigger *trigger)
+{
+	struct list_head *entry;
+	struct switch_led_trigger *sw_trig;
+	u32 port_mask;
+
+	if (!trigger)
+		return;
+
+	sw_trig = (void *) trigger;
+
+	port_mask = 0;
+	read_lock(&trigger->leddev_list_lock);
+	list_for_each(entry, &trigger->led_cdevs) {
+		struct led_classdev *led_cdev;
+		struct swconfig_trig_data *trig_data;
+
+		led_cdev = list_entry(entry, struct led_classdev, trig_list);
+		trig_data = led_cdev->trigger_data;
+		if (trig_data) {
+			read_lock(&trig_data->lock);
+			port_mask |= trig_data->port_mask;
+			read_unlock(&trig_data->lock);
+		}
+	}
+	read_unlock(&trigger->leddev_list_lock);
+
+	sw_trig->port_mask = port_mask;
+
+	if (port_mask)
+		schedule_delayed_work(&sw_trig->sw_led_work,
+				      SWCONFIG_LED_TIMER_INTERVAL);
+	else
+		cancel_delayed_work_sync(&sw_trig->sw_led_work);
+}
+
+static ssize_t
+swconfig_trig_port_mask_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
+	unsigned long port_mask;
+	ssize_t ret = -EINVAL;
+	char *after;
+	size_t count;
+
+	port_mask = simple_strtoul(buf, &after, 16);
+	count =	after - buf;
+
+	if (*after && isspace(*after))
+		count++;
+
+	if (count == size) {
+		bool changed;
+
+		write_lock(&trig_data->lock);
+
+		changed = (trig_data->port_mask != port_mask);
+		if (changed) {
+			trig_data->port_mask = port_mask;
+			if (port_mask == 0)
+				swconfig_trig_set_brightness(trig_data, LED_OFF);
+		}
+
+		write_unlock(&trig_data->lock);
+
+		if (changed)
+			swconfig_trig_update_port_mask(led_cdev->trigger);
+
+		ret = count;
+	}
+
+	return ret;
+}
+
+static ssize_t
+swconfig_trig_port_mask_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
+
+	read_lock(&trig_data->lock);
+	sprintf(buf, "%#x\n", trig_data->port_mask);
+	read_unlock(&trig_data->lock);
+
+	return strlen(buf) + 1;
+}
+
+static DEVICE_ATTR(port_mask, 0644, swconfig_trig_port_mask_show,
+		   swconfig_trig_port_mask_store);
+
+static void
+swconfig_trig_activate(struct led_classdev *led_cdev)
+{
+	struct switch_led_trigger *sw_trig;
+	struct swconfig_trig_data *trig_data;
+	int err;
+
+	if (led_cdev->trigger->activate != swconfig_trig_activate)
+		return;
+
+	trig_data = kzalloc(sizeof(struct swconfig_trig_data), GFP_KERNEL);
+	if (!trig_data)
+		return;
+
+	sw_trig = (void *) led_cdev->trigger;
+
+	rwlock_init(&trig_data->lock);
+	trig_data->led_cdev = led_cdev;
+	trig_data->swdev = sw_trig->swdev;
+	led_cdev->trigger_data = trig_data;
+
+	err = device_create_file(led_cdev->dev, &dev_attr_port_mask);
+	if (err)
+		goto err_free;
+
+	return;
+
+err_free:
+	led_cdev->trigger_data = NULL;
+	kfree(trig_data);
+}
+
+static void
+swconfig_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct swconfig_trig_data *trig_data;
+
+	swconfig_trig_update_port_mask(led_cdev->trigger);
+
+	trig_data = (void *) led_cdev->trigger_data;
+	if (trig_data) {
+		device_remove_file(led_cdev->dev, &dev_attr_port_mask);
+		kfree(trig_data);
+	}
+}
+
+static void
+swconfig_trig_led_event(struct switch_led_trigger *sw_trig,
+			struct led_classdev *led_cdev)
+{
+	struct swconfig_trig_data *trig_data;
+	u32 port_mask;
+	bool link;
+
+	trig_data = led_cdev->trigger_data;
+	if (!trig_data)
+		return;
+
+	read_lock(&trig_data->lock);
+	port_mask = trig_data->port_mask;
+	read_unlock(&trig_data->lock);
+
+	link = !!(sw_trig->port_link & port_mask);
+	if (!link) {
+		if (link != trig_data->prev_link)
+			swconfig_trig_set_brightness(trig_data, LED_OFF);
+	} else {
+		unsigned long traffic;
+		int i;
+
+		traffic = 0;
+		for (i = 0; i < SWCONFIG_LED_NUM_PORTS; i++) {
+			if (port_mask & (1 << i))
+				traffic += sw_trig->port_traffic[i];
+		}
+
+		if (trig_data->prev_brightness != LED_FULL)
+			swconfig_trig_set_brightness(trig_data, LED_FULL);
+		else if (traffic != trig_data->prev_traffic)
+			swconfig_trig_set_brightness(trig_data, LED_OFF);
+
+		trig_data->prev_traffic = traffic;
+	}
+
+	trig_data->prev_link = link;
+}
+
+static void
+swconfig_trig_update_leds(struct switch_led_trigger *sw_trig)
+{
+	struct list_head *entry;
+	struct led_trigger *trigger;
+
+	trigger = &sw_trig->trig;
+	read_lock(&trigger->leddev_list_lock);
+	list_for_each(entry, &trigger->led_cdevs) {
+		struct led_classdev *led_cdev;
+
+		led_cdev = list_entry(entry, struct led_classdev, trig_list);
+		swconfig_trig_led_event(sw_trig, led_cdev);
+	}
+	read_unlock(&trigger->leddev_list_lock);
+}
+
+static void
+swconfig_led_work_func(struct work_struct *work)
+{
+	struct switch_led_trigger *sw_trig;
+	struct switch_dev *swdev;
+	u32 port_mask;
+	u32 link;
+	int i;
+
+	sw_trig = container_of(work, struct switch_led_trigger,
+			       sw_led_work.work);
+
+	port_mask = sw_trig->port_mask;
+	swdev = sw_trig->swdev;
+
+	link = 0;
+	for (i = 0; i < SWCONFIG_LED_NUM_PORTS; i++) {
+		u32 port_bit;
+
+		port_bit = BIT(i);
+		if ((port_mask & port_bit) == 0)
+			continue;
+
+		if (swdev->ops->get_port_link) {
+			struct switch_port_link port_link;
+
+			memset(&port_link, '\0', sizeof(port_link));
+			swdev->ops->get_port_link(swdev, i, &port_link);
+
+			if (port_link.link)
+				link |= port_bit;
+		}
+
+		if (swdev->ops->get_port_stats) {
+			struct switch_port_stats port_stats;
+
+			memset(&port_stats, '\0', sizeof(port_stats));
+			swdev->ops->get_port_stats(swdev, i, &port_stats);
+			sw_trig->port_traffic[i] = port_stats.tx_bytes +
+						   port_stats.rx_bytes;
+		}
+	}
+
+	sw_trig->port_link = link;
+
+	swconfig_trig_update_leds(sw_trig);
+
+	schedule_delayed_work(&sw_trig->sw_led_work,
+			      SWCONFIG_LED_TIMER_INTERVAL);
+}
+
+static int
+swconfig_create_led_trigger(struct switch_dev *swdev)
+{
+	struct switch_led_trigger *sw_trig;
+	int err;
+
+	if (!swdev->ops->get_port_link)
+		return 0;
+
+	sw_trig = kzalloc(sizeof(struct switch_led_trigger), GFP_KERNEL);
+	if (!sw_trig)
+		return -ENOMEM;
+
+	sw_trig->swdev = swdev;
+	sw_trig->trig.name = swdev->devname;
+	sw_trig->trig.activate = swconfig_trig_activate;
+	sw_trig->trig.deactivate = swconfig_trig_deactivate;
+
+	INIT_DELAYED_WORK(&sw_trig->sw_led_work, swconfig_led_work_func);
+
+	err = led_trigger_register(&sw_trig->trig);
+	if (err)
+		goto err_free;
+
+	swdev->led_trigger = sw_trig;
+
+	return 0;
+
+err_free:
+	kfree(sw_trig);
+	return err;
+}
+
+static void
+swconfig_destroy_led_trigger(struct switch_dev *swdev)
+{
+	struct switch_led_trigger *sw_trig;
+
+	sw_trig = swdev->led_trigger;
+	if (sw_trig) {
+		cancel_delayed_work_sync(&sw_trig->sw_led_work);
+		led_trigger_unregister(&sw_trig->trig);
+		kfree(sw_trig);
+	}
+}
+
+#else /* SWCONFIG_LEDS */
+static inline int
+swconfig_create_led_trigger(struct switch_dev *swdev) { return 0; }
+
+static inline void
+swconfig_destroy_led_trigger(struct switch_dev *swdev) { }
+#endif /* CONFIG_SWCONFIG_LEDS */
diff -Nur linux-4.1.13.orig/drivers/spi/Kconfig linux-4.1.13/drivers/spi/Kconfig
--- linux-4.1.13.orig/drivers/spi/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/spi/Kconfig	2015-12-04 19:57:03.922108288 +0100
@@ -59,6 +59,14 @@
 	help
 	  This is the driver for the Altera SPI Controller.
 
+config SPI_AP83
+	tristate "Atheros AP83 specific SPI Controller"
+	depends on SPI_MASTER && ATH79_MACH_AP83
+	select SPI_BITBANG
+	help
+	  This is a specific SPI controller driver for the Atheros AP83
+	  reference board.
+
 config SPI_ATH79
 	tristate "Atheros AR71XX/AR724X/AR913X SPI controller driver"
 	depends on ATH79 && GPIOLIB
@@ -448,6 +456,12 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called spi_qup.
 
+config SPI_RB4XX
+	tristate "Mikrotik RB4XX SPI master"
+	depends on SPI_MASTER && ATH79_MACH_RB4XX
+	help
+	  SPI controller driver for the Mikrotik RB4xx series boards.
+
 config SPI_S3C24XX
 	tristate "Samsung S3C24XX series SPI"
 	depends on ARCH_S3C24XX
@@ -661,6 +675,18 @@
 	  sysfs interface, with each line presented as a kind of GPIO
 	  exposing both switch control and diagnostic feedback.
 
+config SPI_RB4XX_CPLD
+	tristate "MikroTik RB4XX CPLD driver"
+	depends on ATH79_MACH_RB4XX
+	help
+	  SPI driver for the Xilinx CPLD chip present on the
+	  MikroTik RB4xx boards.
+
+config SPI_VSC7385
+	tristate "Vitesse VSC7385 ethernet switch driver"
+	help
+	  SPI driver for the Vitesse VSC7385 ethernet switch.
+
 #
 # Add new SPI protocol masters in alphabetical order above this line
 #
diff -Nur linux-4.1.13.orig/drivers/spi/Makefile linux-4.1.13/drivers/spi/Makefile
--- linux-4.1.13.orig/drivers/spi/Makefile	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/spi/Makefile	2015-12-04 19:57:03.922108288 +0100
@@ -12,6 +12,7 @@
 # SPI master controller drivers (bus)
 obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
 obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
+obj-$(CONFIG_SPI_AP83)			+= spi-ap83.o
 obj-$(CONFIG_SPI_ATH79)			+= spi-ath79.o
 obj-$(CONFIG_SPI_AU1550)		+= spi-au1550.o
 obj-$(CONFIG_SPI_BCM2835)		+= spi-bcm2835.o
@@ -64,6 +65,8 @@
 spi-pxa2xx-platform-$(CONFIG_SPI_PXA2XX_DMA)	+= spi-pxa2xx-dma.o
 obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
 obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
+obj-$(CONFIG_SPI_RB4XX)			+= spi-rb4xx.o
+obj-$(CONFIG_SPI_RB4XX_CPLD)		+= spi-rb4xx-cpld.o
 obj-$(CONFIG_SPI_QUP)			+= spi-qup.o
 obj-$(CONFIG_SPI_ROCKCHIP)		+= spi-rockchip.o
 obj-$(CONFIG_SPI_RSPI)			+= spi-rspi.o
@@ -86,6 +89,7 @@
 obj-$(CONFIG_SPI_TLE62X0)		+= spi-tle62x0.o
 obj-$(CONFIG_SPI_TOPCLIFF_PCH)		+= spi-topcliff-pch.o
 obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
+obj-$(CONFIG_SPI_VSC7385)		+= spi-vsc7385.o
 obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
 obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
diff -Nur linux-4.1.13.orig/drivers/spi/spi-ap83.c linux-4.1.13/drivers/spi/spi-ap83.c
--- linux-4.1.13.orig/drivers/spi/spi-ap83.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/spi/spi-ap83.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,283 @@
+/*
+ * Atheros AP83 board specific SPI Controller driver
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+
+#define DRV_DESC	"Atheros AP83 board SPI Controller driver"
+#define DRV_VERSION	"0.1.0"
+#define DRV_NAME	"ap83-spi"
+
+#define AP83_SPI_CLK_HIGH	(1 << 23)
+#define AP83_SPI_CLK_LOW	0
+#define AP83_SPI_MOSI_HIGH	(1 << 22)
+#define AP83_SPI_MOSI_LOW	0
+
+#define AP83_SPI_GPIO_CS	1
+#define AP83_SPI_GPIO_MISO	3
+
+struct ap83_spi {
+	struct	spi_bitbang	bitbang;
+	void __iomem		*base;
+	u32			addr;
+
+	struct platform_device	*pdev;
+};
+
+static inline u32 ap83_spi_rr(struct ap83_spi *sp, u32 reg)
+{
+	return __raw_readl(sp->base + reg);
+}
+
+static inline struct ap83_spi *spidev_to_sp(struct spi_device *spi)
+{
+	return spi_master_get_devdata(spi->master);
+}
+
+static inline void setsck(struct spi_device *spi, int val)
+{
+	struct ap83_spi *sp = spidev_to_sp(spi);
+
+	if (val)
+		sp->addr |= AP83_SPI_CLK_HIGH;
+	else
+		sp->addr &= ~AP83_SPI_CLK_HIGH;
+
+	dev_dbg(&spi->dev, "addr=%08x,  SCK set to %s\n",
+		sp->addr, (val) ? "HIGH" : "LOW");
+
+	ap83_spi_rr(sp, sp->addr);
+}
+
+static inline void setmosi(struct spi_device *spi, int val)
+{
+	struct ap83_spi *sp = spidev_to_sp(spi);
+
+	if (val)
+		sp->addr |= AP83_SPI_MOSI_HIGH;
+	else
+		sp->addr &= ~AP83_SPI_MOSI_HIGH;
+
+	dev_dbg(&spi->dev, "addr=%08x, MOSI set to %s\n",
+		sp->addr, (val) ? "HIGH" : "LOW");
+
+	ap83_spi_rr(sp, sp->addr);
+}
+
+static inline u32 getmiso(struct spi_device *spi)
+{
+	u32 ret;
+
+	ret = gpio_get_value(AP83_SPI_GPIO_MISO) ? 1 : 0;
+	dev_dbg(&spi->dev, "get MISO: %d\n", ret);
+
+	return ret;
+}
+
+static inline void do_spidelay(struct spi_device *spi, unsigned nsecs)
+{
+	ndelay(nsecs);
+}
+
+static void ap83_spi_chipselect(struct spi_device *spi, int on)
+{
+	struct ap83_spi *sp = spidev_to_sp(spi);
+
+	dev_dbg(&spi->dev, "set CS to %d\n", (on) ? 0 : 1);
+
+	if (on) {
+		ath79_flash_acquire();
+
+		sp->addr = 0;
+		ap83_spi_rr(sp, sp->addr);
+
+		gpio_set_value(AP83_SPI_GPIO_CS, 0);
+	} else {
+		gpio_set_value(AP83_SPI_GPIO_CS, 1);
+		ath79_flash_release();
+	}
+}
+
+#define spidelay(nsecs)							\
+	do {								\
+		/* Steal the spi_device pointer from our caller.	\
+		 * The bitbang-API should probably get fixed here... */	\
+		do_spidelay(spi, nsecs);				\
+	} while (0)
+
+#define EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+#include "spi-bitbang-txrx.h"
+
+static u32 ap83_spi_txrx_mode0(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX0 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);
+}
+
+static u32 ap83_spi_txrx_mode1(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX1 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, 0, word, bits);
+}
+
+static u32 ap83_spi_txrx_mode2(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX2 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, 0, word, bits);
+}
+
+static u32 ap83_spi_txrx_mode3(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	dev_dbg(&spi->dev, "TXRX3 word=%08x, bits=%u\n", word, bits);
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, 0, word, bits);
+}
+
+static int ap83_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct ap83_spi *sp;
+	struct ap83_spi_platform_data *pdata;
+	struct resource	*r;
+	int ret;
+
+	ret = gpio_request(AP83_SPI_GPIO_MISO, "spi-miso");
+	if (ret) {
+		dev_err(&pdev->dev, "gpio request failed for MISO\n");
+		return ret;
+	}
+
+	ret = gpio_request(AP83_SPI_GPIO_CS, "spi-cs");
+	if (ret) {
+		dev_err(&pdev->dev, "gpio request failed for CS\n");
+		goto err_free_miso;
+	}
+
+	ret = gpio_direction_input(AP83_SPI_GPIO_MISO);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set direction of MISO\n");
+		goto err_free_cs;
+	}
+
+	ret = gpio_direction_output(AP83_SPI_GPIO_CS, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to set direction of CS\n");
+		goto err_free_cs;
+	}
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi master\n");
+		return -ENOMEM;
+	}
+
+	sp = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, sp);
+
+	pdata = pdev->dev.platform_data;
+
+	sp->bitbang.master = spi_master_get(master);
+	sp->bitbang.chipselect = ap83_spi_chipselect;
+	sp->bitbang.txrx_word[SPI_MODE_0] = ap83_spi_txrx_mode0;
+	sp->bitbang.txrx_word[SPI_MODE_1] = ap83_spi_txrx_mode1;
+	sp->bitbang.txrx_word[SPI_MODE_2] = ap83_spi_txrx_mode2;
+	sp->bitbang.txrx_word[SPI_MODE_3] = ap83_spi_txrx_mode3;
+
+	sp->bitbang.master->bus_num = pdev->id;
+	sp->bitbang.master->num_chipselect = 1;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENOENT;
+		goto err_spi_put;
+	}
+
+	sp->base = ioremap_nocache(r->start, r->end - r->start + 1);
+	if (!sp->base) {
+		ret = -ENXIO;
+		goto err_spi_put;
+	}
+
+	ret = spi_bitbang_start(&sp->bitbang);
+	if (!ret)
+		goto err_unmap;
+
+	dev_info(&pdev->dev, "AP83 SPI adapter at %08x\n", r->start);
+
+	return 0;
+
+err_unmap:
+	iounmap(sp->base);
+err_spi_put:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+err_free_cs:
+	gpio_free(AP83_SPI_GPIO_CS);
+err_free_miso:
+	gpio_free(AP83_SPI_GPIO_MISO);
+	return ret;
+}
+
+static int ap83_spi_remove(struct platform_device *pdev)
+{
+	struct ap83_spi *sp = platform_get_drvdata(pdev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	iounmap(sp->base);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver ap83_spi_drv = {
+	.probe		= ap83_spi_probe,
+	.remove		= ap83_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ap83_spi_init(void)
+{
+	return platform_driver_register(&ap83_spi_drv);
+}
+module_init(ap83_spi_init);
+
+static void __exit ap83_spi_exit(void)
+{
+	platform_driver_unregister(&ap83_spi_drv);
+}
+module_exit(ap83_spi_exit);
+
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-4.1.13.orig/drivers/spi/spi-ath79.c linux-4.1.13/drivers/spi/spi-ath79.c
--- linux-4.1.13.orig/drivers/spi/spi-ath79.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/spi/spi-ath79.c	2015-12-04 19:57:03.966105410 +0100
@@ -33,6 +33,13 @@
 #define ATH79_SPI_RRW_DELAY_FACTOR	12000
 #define MHZ				(1000 * 1000)
 
+#define ATH79_SPI_CS_LINE_MAX		2
+
+enum ath79_spi_state {
+	ATH79_SPI_STATE_WAIT_CMD = 0,
+	ATH79_SPI_STATE_WAIT_READ,
+};
+
 struct ath79_spi {
 	struct spi_bitbang	bitbang;
 	u32			ioc_base;
@@ -40,6 +47,11 @@
 	void __iomem		*base;
 	struct clk		*clk;
 	unsigned		rrw_delay;
+
+	enum ath79_spi_state	state;
+	u32			clk_div;
+	unsigned long 		read_addr;
+	unsigned long		ahb_rate;
 };
 
 static inline u32 ath79_spi_rr(struct ath79_spi *sp, unsigned reg)
@@ -67,6 +79,7 @@
 {
 	struct ath79_spi *sp = ath79_spidev_to_sp(spi);
 	int cs_high = (spi->mode & SPI_CS_HIGH) ? is_active : !is_active;
+	struct ath79_spi_controller_data *cdata = spi->controller_data;
 
 	if (is_active) {
 		/* set initial clock polarity */
@@ -78,20 +91,24 @@
 		ath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);
 	}
 
-	if (spi->chip_select) {
-		struct ath79_spi_controller_data *cdata = spi->controller_data;
-
-		/* SPI is normally active-low */
-		gpio_set_value(cdata->gpio, cs_high);
-	} else {
+	switch (cdata->cs_type) {
+	case ATH79_SPI_CS_TYPE_INTERNAL:
 		if (cs_high)
-			sp->ioc_base |= AR71XX_SPI_IOC_CS0;
+			sp->ioc_base |= AR71XX_SPI_IOC_CS(cdata->cs_line);
 		else
-			sp->ioc_base &= ~AR71XX_SPI_IOC_CS0;
+			sp->ioc_base &= ~AR71XX_SPI_IOC_CS(cdata->cs_line);
 
 		ath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);
-	}
+		break;
 
+	case ATH79_SPI_CS_TYPE_GPIO:
+		/* SPI is normally active-low */
+		if (gpio_cansleep(cdata->cs_line))
+			gpio_set_value_cansleep(cdata->cs_line, cs_high);
+		else
+			gpio_set_value(cdata->cs_line, cs_high);
+		break;
+	}
 }
 
 static void ath79_spi_enable(struct ath79_spi *sp)
@@ -102,9 +119,6 @@
 	/* save CTRL register */
 	sp->reg_ctrl = ath79_spi_rr(sp, AR71XX_SPI_REG_CTRL);
 	sp->ioc_base = ath79_spi_rr(sp, AR71XX_SPI_REG_IOC);
-
-	/* TODO: setup speed? */
-	ath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, 0x43);
 }
 
 static void ath79_spi_disable(struct ath79_spi *sp)
@@ -118,24 +132,30 @@
 static int ath79_spi_setup_cs(struct spi_device *spi)
 {
 	struct ath79_spi_controller_data *cdata;
+	unsigned long flags;
 	int status;
 
 	cdata = spi->controller_data;
-	if (spi->chip_select && !cdata)
+	if (!cdata)
 		return -EINVAL;
 
 	status = 0;
-	if (spi->chip_select) {
-		unsigned long flags;
+	switch (cdata->cs_type) {
+	case ATH79_SPI_CS_TYPE_INTERNAL:
+		if (cdata->cs_line > ATH79_SPI_CS_LINE_MAX)
+			status = -EINVAL;
+		break;
 
+	case ATH79_SPI_CS_TYPE_GPIO:
 		flags = GPIOF_DIR_OUT;
 		if (spi->mode & SPI_CS_HIGH)
 			flags |= GPIOF_INIT_LOW;
 		else
 			flags |= GPIOF_INIT_HIGH;
 
-		status = gpio_request_one(cdata->gpio, flags,
+		status = gpio_request_one(cdata->cs_line, flags,
 					  dev_name(&spi->dev));
+		break;
 	}
 
 	return status;
@@ -143,9 +163,19 @@
 
 static void ath79_spi_cleanup_cs(struct spi_device *spi)
 {
-	if (spi->chip_select) {
-		struct ath79_spi_controller_data *cdata = spi->controller_data;
-		gpio_free(cdata->gpio);
+	struct ath79_spi_controller_data *cdata;
+
+	cdata = spi->controller_data;
+	if (!cdata)
+		return;
+
+	switch (cdata->cs_type) {
+	case ATH79_SPI_CS_TYPE_INTERNAL:
+		/* nothing to do */
+		break;
+	case ATH79_SPI_CS_TYPE_GPIO:
+		gpio_free(cdata->cs_line);
+		break;
 	}
 }
 
@@ -201,6 +231,114 @@
 	return ath79_spi_rr(sp, AR71XX_SPI_REG_RDS);
 }
 
+static int ath79_spi_do_read_flash_data(struct spi_device *spi,
+					struct spi_transfer *t)
+{
+	struct ath79_spi *sp = ath79_spidev_to_sp(spi);
+
+	/* disable GPIO mode */
+	ath79_spi_wr(sp, AR71XX_SPI_REG_FS, 0);
+
+	memcpy_fromio(t->rx_buf, sp->base + sp->read_addr, t->len);
+
+	/* enable GPIO mode */
+	ath79_spi_wr(sp, AR71XX_SPI_REG_FS, AR71XX_SPI_FS_GPIO);
+
+	/* restore IOC register */
+	ath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);
+
+	return t->len;
+}
+
+static int ath79_spi_do_read_flash_cmd(struct spi_device *spi,
+				       struct spi_transfer *t)
+{
+	struct ath79_spi *sp = ath79_spidev_to_sp(spi);
+	int len;
+	const u8 *p;
+
+	sp->read_addr = 0;
+
+	len = t->len - 1;
+
+	if (t->dummy)
+		len -= 1;
+
+	p = t->tx_buf;
+
+	while (len--) {
+		p++;
+		sp->read_addr <<= 8;
+		sp->read_addr |= *p;
+	}
+
+	return t->len;
+}
+
+static bool ath79_spi_is_read_cmd(struct spi_device *spi,
+				 struct spi_transfer *t)
+{
+	return t->type == SPI_TRANSFER_FLASH_READ_CMD;
+}
+
+static bool ath79_spi_is_data_read(struct spi_device *spi,
+				  struct spi_transfer *t)
+{
+	return t->type == SPI_TRANSFER_FLASH_READ_DATA;
+}
+
+static int ath79_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct ath79_spi *sp = ath79_spidev_to_sp(spi);
+	int ret;
+
+	switch (sp->state) {
+	case ATH79_SPI_STATE_WAIT_CMD:
+		if (ath79_spi_is_read_cmd(spi, t)) {
+			ret = ath79_spi_do_read_flash_cmd(spi, t);
+			sp->state = ATH79_SPI_STATE_WAIT_READ;
+		} else {
+			ret = spi_bitbang_bufs(spi, t);
+		}
+		break;
+
+	case ATH79_SPI_STATE_WAIT_READ:
+		if (ath79_spi_is_data_read(spi, t)) {
+			ret = ath79_spi_do_read_flash_data(spi, t);
+		} else {
+			dev_warn(&spi->dev, "flash data read expected\n");
+			ret = -EIO;
+		}
+		sp->state = ATH79_SPI_STATE_WAIT_CMD;
+		break;
+
+	default:
+		BUG();
+	}
+
+	return ret;
+}
+
+static int ath79_spi_setup_transfer(struct spi_device *spi,
+				    struct spi_transfer *t)
+{
+	struct ath79_spi *sp = ath79_spidev_to_sp(spi);
+	struct ath79_spi_controller_data *cdata;
+	int ret;
+
+	ret = spi_bitbang_setup_transfer(spi, t);
+	if (ret)
+		return ret;
+
+	cdata = spi->controller_data;
+	if (cdata->is_flash)
+		sp->bitbang.txrx_bufs = ath79_spi_txrx_bufs;
+	else
+		sp->bitbang.txrx_bufs = spi_bitbang_bufs;
+
+	return ret;
+}
+
 static int ath79_spi_probe(struct platform_device *pdev)
 {
 	struct spi_master *master;
@@ -210,6 +348,10 @@
 	unsigned long rate;
 	int ret;
 
+	pdata = pdev->dev.platform_data;
+	if (!pdata)
+		return -EINVAL;
+
 	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
 	if (master == NULL) {
 		dev_err(&pdev->dev, "failed to allocate spi master\n");
@@ -219,20 +361,18 @@
 	sp = spi_master_get_devdata(master);
 	platform_set_drvdata(pdev, sp);
 
-	pdata = dev_get_platdata(&pdev->dev);
+	sp->state = ATH79_SPI_STATE_WAIT_CMD;
 
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);
 	master->setup = ath79_spi_setup;
 	master->cleanup = ath79_spi_cleanup;
-	if (pdata) {
-		master->bus_num = pdata->bus_num;
-		master->num_chipselect = pdata->num_chipselect;
-	}
+	master->bus_num = pdata->bus_num;
+	master->num_chipselect = pdata->num_chipselect;
 
 	sp->bitbang.master = master;
 	sp->bitbang.chipselect = ath79_spi_chipselect;
 	sp->bitbang.txrx_word[SPI_MODE_0] = ath79_spi_txrx_mode0;
-	sp->bitbang.setup_transfer = spi_bitbang_setup_transfer;
+	sp->bitbang.setup_transfer = ath79_spi_setup_transfer;
 	sp->bitbang.flags = SPI_CS_HIGH;
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -257,7 +397,8 @@
 	if (ret)
 		goto err_put_master;
 
-	rate = DIV_ROUND_UP(clk_get_rate(sp->clk), MHZ);
+	sp->ahb_rate = clk_get_rate(sp->clk);
+	rate = DIV_ROUND_UP(sp->ahb_rate, MHZ);
 	if (!rate) {
 		ret = -EINVAL;
 		goto err_clk_disable;
diff -Nur linux-4.1.13.orig/drivers/spi/spi-bitbang.c linux-4.1.13/drivers/spi/spi-bitbang.c
--- linux-4.1.13.orig/drivers/spi/spi-bitbang.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/spi/spi-bitbang.c	2015-12-04 19:57:03.934107503 +0100
@@ -230,13 +230,14 @@
 }
 EXPORT_SYMBOL_GPL(spi_bitbang_cleanup);
 
-static int spi_bitbang_bufs(struct spi_device *spi, struct spi_transfer *t)
+int spi_bitbang_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
 	struct spi_bitbang_cs	*cs = spi->controller_state;
 	unsigned		nsecs = cs->nsecs;
 
 	return cs->txrx_bufs(spi, cs->txrx_word, nsecs, t);
 }
+EXPORT_SYMBOL_GPL(spi_bitbang_bufs);
 
 /*----------------------------------------------------------------------*/
 
diff -Nur linux-4.1.13.orig/drivers/spi/spi-rb4xx.c linux-4.1.13/drivers/spi/spi-rb4xx.c
--- linux-4.1.13.orig/drivers/spi/spi-rb4xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/spi/spi-rb4xx.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,507 @@
+/*
+ * SPI controller driver for the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+#define DRV_NAME	"rb4xx-spi"
+#define DRV_DESC	"Mikrotik RB4xx SPI controller driver"
+#define DRV_VERSION	"0.1.0"
+
+#define SPI_CTRL_FASTEST	0x40
+#define SPI_FLASH_HZ		33333334
+#define SPI_CPLD_HZ		33333334
+
+#define CPLD_CMD_READ_FAST	0x0b
+
+#undef RB4XX_SPI_DEBUG
+
+struct rb4xx_spi {
+	void __iomem		*base;
+	struct spi_master	*master;
+
+	unsigned		spi_ctrl_flash;
+	unsigned		spi_ctrl_fread;
+
+	struct clk		*ahb_clk;
+	unsigned long		ahb_freq;
+
+	spinlock_t		lock;
+	struct list_head	queue;
+	int			busy:1;
+	int			cs_wait;
+};
+
+static unsigned spi_clk_low = AR71XX_SPI_IOC_CS1;
+
+#ifdef RB4XX_SPI_DEBUG
+static inline void do_spi_delay(void)
+{
+	ndelay(20000);
+}
+#else
+static inline void do_spi_delay(void) { }
+#endif
+
+static inline void do_spi_init(struct spi_device *spi)
+{
+	unsigned cs = AR71XX_SPI_IOC_CS0 | AR71XX_SPI_IOC_CS1;
+
+	if (!(spi->mode & SPI_CS_HIGH))
+		cs ^= (spi->chip_select == 2) ? AR71XX_SPI_IOC_CS1 :
+						AR71XX_SPI_IOC_CS0;
+
+	spi_clk_low = cs;
+}
+
+static inline void do_spi_finish(void __iomem *base)
+{
+	do_spi_delay();
+	__raw_writel(AR71XX_SPI_IOC_CS0 | AR71XX_SPI_IOC_CS1,
+		     base + AR71XX_SPI_REG_IOC);
+}
+
+static inline void do_spi_clk(void __iomem *base, int bit)
+{
+	unsigned bval = spi_clk_low | ((bit & 1) ? AR71XX_SPI_IOC_DO : 0);
+
+	do_spi_delay();
+	__raw_writel(bval, base + AR71XX_SPI_REG_IOC);
+	do_spi_delay();
+	__raw_writel(bval | AR71XX_SPI_IOC_CLK, base + AR71XX_SPI_REG_IOC);
+}
+
+static void do_spi_byte(void __iomem *base, unsigned char byte)
+{
+	do_spi_clk(base, byte >> 7);
+	do_spi_clk(base, byte >> 6);
+	do_spi_clk(base, byte >> 5);
+	do_spi_clk(base, byte >> 4);
+	do_spi_clk(base, byte >> 3);
+	do_spi_clk(base, byte >> 2);
+	do_spi_clk(base, byte >> 1);
+	do_spi_clk(base, byte);
+
+	pr_debug("spi_byte sent 0x%02x got 0x%02x\n",
+	       (unsigned)byte,
+	       (unsigned char)__raw_readl(base + AR71XX_SPI_REG_RDS));
+}
+
+static inline void do_spi_clk_fast(void __iomem *base, unsigned bit1,
+				   unsigned bit2)
+{
+	unsigned bval = (spi_clk_low |
+			 ((bit1 & 1) ? AR71XX_SPI_IOC_DO : 0) |
+			 ((bit2 & 1) ? AR71XX_SPI_IOC_CS2 : 0));
+	do_spi_delay();
+	__raw_writel(bval, base + AR71XX_SPI_REG_IOC);
+	do_spi_delay();
+	__raw_writel(bval | AR71XX_SPI_IOC_CLK, base + AR71XX_SPI_REG_IOC);
+}
+
+static void do_spi_byte_fast(void __iomem *base, unsigned char byte)
+{
+	do_spi_clk_fast(base, byte >> 7, byte >> 6);
+	do_spi_clk_fast(base, byte >> 5, byte >> 4);
+	do_spi_clk_fast(base, byte >> 3, byte >> 2);
+	do_spi_clk_fast(base, byte >> 1, byte >> 0);
+
+	pr_debug("spi_byte_fast sent 0x%02x got 0x%02x\n",
+	       (unsigned)byte,
+	       (unsigned char) __raw_readl(base + AR71XX_SPI_REG_RDS));
+}
+
+static int rb4xx_spi_txrx(void __iomem *base, struct spi_transfer *t)
+{
+	const unsigned char *rxv_ptr = NULL;
+	const unsigned char *tx_ptr = t->tx_buf;
+	unsigned char *rx_ptr = t->rx_buf;
+	unsigned i;
+
+	pr_debug("spi_txrx len %u tx %u rx %u\n",
+	       t->len,
+	       (t->tx_buf ? 1 : 0),
+	       (t->rx_buf ? 1 : 0));
+
+	if (t->verify) {
+		rxv_ptr = tx_ptr;
+		tx_ptr = NULL;
+	}
+
+	for (i = 0; i < t->len; ++i) {
+		unsigned char sdata = tx_ptr ? tx_ptr[i] : 0;
+
+		if (t->fast_write)
+			do_spi_byte_fast(base, sdata);
+		else
+			do_spi_byte(base, sdata);
+
+		if (rx_ptr) {
+			rx_ptr[i] = __raw_readl(base + AR71XX_SPI_REG_RDS) & 0xff;
+		} else if (rxv_ptr) {
+			unsigned char c = __raw_readl(base + AR71XX_SPI_REG_RDS);
+			if (rxv_ptr[i] != c)
+				return i;
+		}
+	}
+
+	return i;
+}
+
+static int rb4xx_spi_read_fast(struct rb4xx_spi *rbspi,
+			       struct spi_message *m)
+{
+	struct spi_transfer *t;
+	const unsigned char *tx_ptr;
+	unsigned addr;
+	void __iomem *base = rbspi->base;
+
+	/* check for exactly two transfers */
+	if (list_empty(&m->transfers) ||
+	    list_is_last(m->transfers.next, &m->transfers) ||
+	    !list_is_last(m->transfers.next->next, &m->transfers)) {
+		return -1;
+	}
+
+	/* first transfer contains command and address  */
+	t = list_entry(m->transfers.next,
+		       struct spi_transfer, transfer_list);
+
+	if (t->len != 5 || t->tx_buf == NULL)
+		return -1;
+
+	tx_ptr = t->tx_buf;
+	if (tx_ptr[0] != CPLD_CMD_READ_FAST)
+		return -1;
+
+	addr = tx_ptr[1];
+	addr = tx_ptr[2] | (addr << 8);
+	addr = tx_ptr[3] | (addr << 8);
+	addr += (unsigned) base;
+
+	m->actual_length += t->len;
+
+	/* second transfer contains data itself */
+	t = list_entry(m->transfers.next->next,
+		       struct spi_transfer, transfer_list);
+
+	if (t->tx_buf && !t->verify)
+		return -1;
+
+	__raw_writel(AR71XX_SPI_FS_GPIO, base + AR71XX_SPI_REG_FS);
+	__raw_writel(rbspi->spi_ctrl_fread, base + AR71XX_SPI_REG_CTRL);
+	__raw_writel(0, base + AR71XX_SPI_REG_FS);
+
+	if (t->rx_buf) {
+		memcpy(t->rx_buf, (const void *)addr, t->len);
+	} else if (t->tx_buf) {
+		unsigned char buf[t->len];
+		memcpy(buf, (const void *)addr, t->len);
+		if (memcmp(t->tx_buf, buf, t->len) != 0)
+			m->status = -EMSGSIZE;
+	}
+	m->actual_length += t->len;
+
+	if (rbspi->spi_ctrl_flash != rbspi->spi_ctrl_fread) {
+		__raw_writel(AR71XX_SPI_FS_GPIO, base + AR71XX_SPI_REG_FS);
+		__raw_writel(rbspi->spi_ctrl_flash, base + AR71XX_SPI_REG_CTRL);
+		__raw_writel(0, base + AR71XX_SPI_REG_FS);
+	}
+
+	return 0;
+}
+
+static int rb4xx_spi_msg(struct rb4xx_spi *rbspi, struct spi_message *m)
+{
+	struct spi_transfer *t = NULL;
+	void __iomem *base = rbspi->base;
+
+	m->status = 0;
+	if (list_empty(&m->transfers))
+		return -1;
+
+	if (m->fast_read)
+		if (rb4xx_spi_read_fast(rbspi, m) == 0)
+			return -1;
+
+	__raw_writel(AR71XX_SPI_FS_GPIO, base + AR71XX_SPI_REG_FS);
+	__raw_writel(SPI_CTRL_FASTEST, base + AR71XX_SPI_REG_CTRL);
+	do_spi_init(m->spi);
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		int len;
+
+		len = rb4xx_spi_txrx(base, t);
+		if (len != t->len) {
+			m->status = -EMSGSIZE;
+			break;
+		}
+		m->actual_length += len;
+
+		if (t->cs_change) {
+			if (list_is_last(&t->transfer_list, &m->transfers)) {
+				/* wait for continuation */
+				return m->spi->chip_select;
+			}
+			do_spi_finish(base);
+			ndelay(100);
+		}
+	}
+
+	do_spi_finish(base);
+	__raw_writel(rbspi->spi_ctrl_flash, base + AR71XX_SPI_REG_CTRL);
+	__raw_writel(0, base + AR71XX_SPI_REG_FS);
+	return -1;
+}
+
+static void rb4xx_spi_process_queue_locked(struct rb4xx_spi *rbspi,
+					   unsigned long *flags)
+{
+	int cs = rbspi->cs_wait;
+
+	rbspi->busy = 1;
+	while (!list_empty(&rbspi->queue)) {
+		struct spi_message *m;
+
+		list_for_each_entry(m, &rbspi->queue, queue)
+			if (cs < 0 || cs == m->spi->chip_select)
+				break;
+
+		if (&m->queue == &rbspi->queue)
+			break;
+
+		list_del_init(&m->queue);
+		spin_unlock_irqrestore(&rbspi->lock, *flags);
+
+		cs = rb4xx_spi_msg(rbspi, m);
+		m->complete(m->context);
+
+		spin_lock_irqsave(&rbspi->lock, *flags);
+	}
+
+	rbspi->cs_wait = cs;
+	rbspi->busy = 0;
+
+	if (cs >= 0) {
+		/* TODO: add timer to unlock cs after 1s inactivity */
+	}
+}
+
+static int rb4xx_spi_transfer(struct spi_device *spi,
+			      struct spi_message *m)
+{
+	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	m->actual_length = 0;
+	m->status = -EINPROGRESS;
+
+	spin_lock_irqsave(&rbspi->lock, flags);
+	list_add_tail(&m->queue, &rbspi->queue);
+	if (rbspi->busy ||
+	    (rbspi->cs_wait >= 0 && rbspi->cs_wait != m->spi->chip_select)) {
+		/* job will be done later */
+		spin_unlock_irqrestore(&rbspi->lock, flags);
+		return 0;
+	}
+
+	/* process job in current context */
+	rb4xx_spi_process_queue_locked(rbspi, &flags);
+	spin_unlock_irqrestore(&rbspi->lock, flags);
+
+	return 0;
+}
+
+static int rb4xx_spi_setup(struct spi_device *spi)
+{
+	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	if (spi->mode & ~(SPI_CS_HIGH)) {
+		dev_err(&spi->dev, "mode %x not supported\n",
+			(unsigned) spi->mode);
+		return -EINVAL;
+	}
+
+	if (spi->bits_per_word != 8 && spi->bits_per_word != 0) {
+		dev_err(&spi->dev, "bits_per_word %u not supported\n",
+			(unsigned) spi->bits_per_word);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&rbspi->lock, flags);
+	if (rbspi->cs_wait == spi->chip_select && !rbspi->busy) {
+		rbspi->cs_wait = -1;
+		rb4xx_spi_process_queue_locked(rbspi, &flags);
+	}
+	spin_unlock_irqrestore(&rbspi->lock, flags);
+
+	return 0;
+}
+
+static unsigned get_spi_ctrl(struct rb4xx_spi *rbspi, unsigned hz_max,
+			     const char *name)
+{
+	unsigned div;
+
+	div = (rbspi->ahb_freq - 1) / (2 * hz_max);
+
+	/*
+	 * CPU has a bug at (div == 0) - first bit read is random
+	 */
+	if (div == 0)
+		++div;
+
+	if (name) {
+		unsigned ahb_khz = (rbspi->ahb_freq + 500) / 1000;
+		unsigned div_real = 2 * (div + 1);
+		pr_debug("rb4xx: %s SPI clock %u kHz (AHB %u kHz / %u)\n",
+		       name,
+		       ahb_khz / div_real,
+		       ahb_khz, div_real);
+	}
+
+	return SPI_CTRL_FASTEST + div;
+}
+
+static int rb4xx_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct rb4xx_spi *rbspi;
+	struct resource *r;
+	int err = 0;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*rbspi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "no memory for spi_master\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	master->bus_num = 0;
+	master->num_chipselect = 3;
+	master->setup = rb4xx_spi_setup;
+	master->transfer = rb4xx_spi_transfer;
+
+	rbspi = spi_master_get_devdata(master);
+
+	rbspi->ahb_clk = clk_get(&pdev->dev, "ahb");
+	if (IS_ERR(rbspi->ahb_clk)) {
+		err = PTR_ERR(rbspi->ahb_clk);
+		goto err_put_master;
+	}
+
+	err = clk_enable(rbspi->ahb_clk);
+	if (err)
+		goto err_clk_put;
+
+	rbspi->ahb_freq = clk_get_rate(rbspi->ahb_clk);
+	if (!rbspi->ahb_freq) {
+		err = -EINVAL;
+		goto err_clk_disable;
+	}
+
+	platform_set_drvdata(pdev, rbspi);
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		err = -ENOENT;
+		goto err_clk_disable;
+	}
+
+	rbspi->base = ioremap(r->start, r->end - r->start + 1);
+	if (!rbspi->base) {
+		err = -ENXIO;
+		goto err_clk_disable;
+	}
+
+	rbspi->master = master;
+	rbspi->spi_ctrl_flash = get_spi_ctrl(rbspi, SPI_FLASH_HZ, "FLASH");
+	rbspi->spi_ctrl_fread = get_spi_ctrl(rbspi, SPI_CPLD_HZ, "CPLD");
+	rbspi->cs_wait = -1;
+
+	spin_lock_init(&rbspi->lock);
+	INIT_LIST_HEAD(&rbspi->queue);
+
+	err = spi_register_master(master);
+	if (err) {
+		dev_err(&pdev->dev, "failed to register SPI master\n");
+		goto err_iounmap;
+	}
+
+	return 0;
+
+err_iounmap:
+	iounmap(rbspi->base);
+err_clk_disable:
+	clk_disable(rbspi->ahb_clk);
+err_clk_put:
+	clk_put(rbspi->ahb_clk);
+err_put_master:
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(master);
+err_out:
+	return err;
+}
+
+static int rb4xx_spi_remove(struct platform_device *pdev)
+{
+	struct rb4xx_spi *rbspi = platform_get_drvdata(pdev);
+
+	iounmap(rbspi->base);
+	clk_disable(rbspi->ahb_clk);
+	clk_put(rbspi->ahb_clk);
+	platform_set_drvdata(pdev, NULL);
+	spi_master_put(rbspi->master);
+
+	return 0;
+}
+
+static struct platform_driver rb4xx_spi_drv = {
+	.probe		= rb4xx_spi_probe,
+	.remove		= rb4xx_spi_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init rb4xx_spi_init(void)
+{
+	return platform_driver_register(&rb4xx_spi_drv);
+}
+subsys_initcall(rb4xx_spi_init);
+
+static void __exit rb4xx_spi_exit(void)
+{
+	platform_driver_unregister(&rb4xx_spi_drv);
+}
+
+module_exit(rb4xx_spi_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-4.1.13.orig/drivers/spi/spi-rb4xx-cpld.c linux-4.1.13/drivers/spi/spi-rb4xx-cpld.c
--- linux-4.1.13.orig/drivers/spi/spi-rb4xx-cpld.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/spi/spi-rb4xx-cpld.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,441 @@
+/*
+ * SPI driver for the CPLD chip on the Mikrotik RB4xx boards
+ *
+ * Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This file was based on the patches for Linux 2.6.27.39 published by
+ * MikroTik for their RouterBoard 4xx series devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <asm/mach-ath79/rb4xx_cpld.h>
+
+#define DRV_NAME	"spi-rb4xx-cpld"
+#define DRV_DESC	"RB4xx CPLD driver"
+#define DRV_VERSION	"0.1.0"
+
+#define CPLD_CMD_WRITE_NAND	0x08 /* send cmd, n x send data, send indle */
+#define CPLD_CMD_WRITE_CFG	0x09 /* send cmd, n x send cfg */
+#define CPLD_CMD_READ_NAND	0x0a /* send cmd, send idle, n x read data */
+#define CPLD_CMD_READ_FAST	0x0b /* send cmd, 4 x idle, n x read data */
+#define CPLD_CMD_LED5_ON	0x0c /* send cmd */
+#define CPLD_CMD_LED5_OFF	0x0d /* send cmd */
+
+struct rb4xx_cpld {
+	struct spi_device	*spi;
+	struct mutex		lock;
+	struct gpio_chip	chip;
+	unsigned int		config;
+};
+
+static struct rb4xx_cpld *rb4xx_cpld;
+
+static inline struct rb4xx_cpld *gpio_to_cpld(struct gpio_chip *chip)
+{
+	return container_of(chip, struct rb4xx_cpld, chip);
+}
+
+static int rb4xx_cpld_write_cmd(struct rb4xx_cpld *cpld, unsigned char cmd)
+{
+	struct spi_transfer t[1];
+	struct spi_message m;
+	unsigned char tx_buf[1];
+	int err;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = tx_buf;
+	t[0].len = sizeof(tx_buf);
+	spi_message_add_tail(&t[0], &m);
+
+	tx_buf[0] = cmd;
+
+	err = spi_sync(cpld->spi, &m);
+	return err;
+}
+
+static int rb4xx_cpld_write_cfg(struct rb4xx_cpld *cpld, unsigned char config)
+{
+	struct spi_transfer t[1];
+	struct spi_message m;
+	unsigned char cmd[2];
+	int err;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_WRITE_CFG;
+	cmd[1] = config;
+
+	err = spi_sync(cpld->spi, &m);
+	return err;
+}
+
+static int __rb4xx_cpld_change_cfg(struct rb4xx_cpld *cpld, unsigned mask,
+				   unsigned value)
+{
+	unsigned int config;
+	int err;
+
+	config = cpld->config & ~mask;
+	config |= value;
+
+	if ((cpld->config ^ config) & 0xff) {
+		err = rb4xx_cpld_write_cfg(cpld, config);
+		if (err)
+			return err;
+	}
+
+	if ((cpld->config ^ config) & CPLD_CFG_nLED5) {
+		err = rb4xx_cpld_write_cmd(cpld, (value) ? CPLD_CMD_LED5_ON :
+							   CPLD_CMD_LED5_OFF);
+		if (err)
+			return err;
+	}
+
+	cpld->config = config;
+	return 0;
+}
+
+int rb4xx_cpld_change_cfg(unsigned mask, unsigned value)
+{
+	int ret;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	mutex_lock(&rb4xx_cpld->lock);
+	ret = __rb4xx_cpld_change_cfg(rb4xx_cpld, mask, value);
+	mutex_unlock(&rb4xx_cpld->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_change_cfg);
+
+int rb4xx_cpld_read_from(unsigned addr, unsigned char *rx_buf,
+			 const unsigned char *verify_buf, unsigned count)
+{
+	const unsigned char cmd[5] = {
+		CPLD_CMD_READ_FAST,
+		(addr >> 16) & 0xff,
+		(addr >> 8) & 0xff,
+		 addr & 0xff,
+		 0
+	};
+	struct spi_transfer t[2] = {
+		{
+			.tx_buf = &cmd,
+			.len = 5,
+		},
+		{
+			.tx_buf = verify_buf,
+			.rx_buf = rx_buf,
+			.len = count,
+			.verify = (verify_buf != NULL),
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	m.fast_read = 1;
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_read_from);
+
+#if 0
+int rb4xx_cpld_read(unsigned char *buf, unsigned char *verify_buf,
+		    unsigned count)
+{
+	struct spi_transfer t[2];
+	struct spi_message m;
+	unsigned char cmd[2];
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	/* send command */
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_READ_NAND;
+	cmd[1] = 0;
+
+	/* read data */
+	t[1].rx_buf = buf;
+	t[1].len = count;
+	spi_message_add_tail(&t[1], &m);
+
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+#else
+int rb4xx_cpld_read(unsigned char *rx_buf, const unsigned char *verify_buf,
+		    unsigned count)
+{
+	static const unsigned char cmd[2] = { CPLD_CMD_READ_NAND, 0 };
+	struct spi_transfer t[2] = {
+		{
+			.tx_buf = &cmd,
+			.len = 2,
+		}, {
+			.tx_buf = verify_buf,
+			.rx_buf = rx_buf,
+			.len = count,
+			.verify = (verify_buf != NULL),
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+}
+#endif
+EXPORT_SYMBOL_GPL(rb4xx_cpld_read);
+
+int rb4xx_cpld_write(const unsigned char *buf, unsigned count)
+{
+#if 0
+	struct spi_transfer t[3];
+	struct spi_message m;
+	unsigned char cmd[1];
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	memset(&t, 0, sizeof(t));
+	spi_message_init(&m);
+
+	/* send command */
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	cmd[0] = CPLD_CMD_WRITE_NAND;
+
+	/* write data */
+	t[1].tx_buf = buf;
+	t[1].len = count;
+	spi_message_add_tail(&t[1], &m);
+
+	/* send idle */
+	t[2].len = 1;
+	spi_message_add_tail(&t[2], &m);
+
+	return spi_sync(rb4xx_cpld->spi, &m);
+#else
+	static const unsigned char cmd = CPLD_CMD_WRITE_NAND;
+	struct spi_transfer t[3] = {
+		{
+			.tx_buf = &cmd,
+			.len = 1,
+		}, {
+			.tx_buf = buf,
+			.len = count,
+			.fast_write = 1,
+		}, {
+			.len = 1,
+			.fast_write = 1,
+		},
+	};
+	struct spi_message m;
+
+	if (rb4xx_cpld == NULL)
+		return -ENODEV;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+	spi_message_add_tail(&t[2], &m);
+	return spi_sync(rb4xx_cpld->spi, &m);
+#endif
+}
+EXPORT_SYMBOL_GPL(rb4xx_cpld_write);
+
+static int rb4xx_cpld_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+	int ret;
+
+	mutex_lock(&cpld->lock);
+	ret = (cpld->config >> offset) & 1;
+	mutex_unlock(&cpld->lock);
+
+	return ret;
+}
+
+static void rb4xx_cpld_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int value)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+
+	mutex_lock(&cpld->lock);
+	__rb4xx_cpld_change_cfg(cpld, (1 << offset), !!value << offset);
+	mutex_unlock(&cpld->lock);
+}
+
+static int rb4xx_cpld_gpio_direction_input(struct gpio_chip *chip,
+					   unsigned offset)
+{
+	return -EOPNOTSUPP;
+}
+
+static int rb4xx_cpld_gpio_direction_output(struct gpio_chip *chip,
+					    unsigned offset,
+					    int value)
+{
+	struct rb4xx_cpld *cpld = gpio_to_cpld(chip);
+	int ret;
+
+	mutex_lock(&cpld->lock);
+	ret = __rb4xx_cpld_change_cfg(cpld, (1 << offset), !!value << offset);
+	mutex_unlock(&cpld->lock);
+
+	return ret;
+}
+
+static int rb4xx_cpld_gpio_init(struct rb4xx_cpld *cpld, unsigned int base)
+{
+	int err;
+
+	/* init config */
+	cpld->config = CPLD_CFG_nLED1 | CPLD_CFG_nLED2 | CPLD_CFG_nLED3 |
+		       CPLD_CFG_nLED4 | CPLD_CFG_nCE;
+	rb4xx_cpld_write_cfg(cpld, cpld->config);
+
+	/* setup GPIO chip */
+	cpld->chip.label = DRV_NAME;
+
+	cpld->chip.get = rb4xx_cpld_gpio_get;
+	cpld->chip.set = rb4xx_cpld_gpio_set;
+	cpld->chip.direction_input = rb4xx_cpld_gpio_direction_input;
+	cpld->chip.direction_output = rb4xx_cpld_gpio_direction_output;
+
+	cpld->chip.base = base;
+	cpld->chip.ngpio = CPLD_NUM_GPIOS;
+	cpld->chip.can_sleep = 1;
+	cpld->chip.dev = &cpld->spi->dev;
+	cpld->chip.owner = THIS_MODULE;
+
+	err = gpiochip_add(&cpld->chip);
+	if (err)
+		dev_err(&cpld->spi->dev, "adding GPIO chip failed, err=%d\n",
+			err);
+
+	return err;
+}
+
+static int rb4xx_cpld_probe(struct spi_device *spi)
+{
+	struct rb4xx_cpld *cpld;
+	struct rb4xx_cpld_platform_data *pdata;
+	int err;
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data\n");
+		return -EINVAL;
+	}
+
+	cpld = kzalloc(sizeof(*cpld), GFP_KERNEL);
+	if (!cpld) {
+		dev_err(&spi->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&cpld->lock);
+	cpld->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, cpld);
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi_setup failed, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = rb4xx_cpld_gpio_init(cpld, pdata->gpio_base);
+	if (err)
+		goto err_drvdata;
+
+	rb4xx_cpld = cpld;
+
+	return 0;
+
+err_drvdata:
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(cpld);
+
+	return err;
+}
+
+static int rb4xx_cpld_remove(struct spi_device *spi)
+{
+	struct rb4xx_cpld *cpld;
+
+	rb4xx_cpld = NULL;
+	cpld = dev_get_drvdata(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(cpld);
+
+	return 0;
+}
+
+static struct spi_driver rb4xx_cpld_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= rb4xx_cpld_probe,
+	.remove		= rb4xx_cpld_remove,
+};
+
+static int __init rb4xx_cpld_init(void)
+{
+	return spi_register_driver(&rb4xx_cpld_driver);
+}
+module_init(rb4xx_cpld_init);
+
+static void __exit rb4xx_cpld_exit(void)
+{
+	spi_unregister_driver(&rb4xx_cpld_driver);
+}
+module_exit(rb4xx_cpld_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-4.1.13.orig/drivers/spi/spi-vsc7385.c linux-4.1.13/drivers/spi/spi-vsc7385.c
--- linux-4.1.13.orig/drivers/spi/spi-vsc7385.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/drivers/spi/spi-vsc7385.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,621 @@
+/*
+ * SPI driver for the Vitesse VSC7385 ethernet switch
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Parts of this file are based on Atheros' 2.6.15 BSP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+#include <linux/firmware.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/vsc7385.h>
+
+#define DRV_NAME	"spi-vsc7385"
+#define DRV_DESC	"Vitesse VSC7385 Gbit ethernet switch driver"
+#define DRV_VERSION	"0.1.0"
+
+#define VSC73XX_BLOCK_MAC	0x1
+#define VSC73XX_BLOCK_2		0x2
+#define VSC73XX_BLOCK_MII	0x3
+#define VSC73XX_BLOCK_4		0x4
+#define VSC73XX_BLOCK_5		0x5
+#define VSC73XX_BLOCK_SYSTEM	0x7
+
+#define VSC73XX_SUBBLOCK_PORT_0		0
+#define VSC73XX_SUBBLOCK_PORT_1		1
+#define VSC73XX_SUBBLOCK_PORT_2		2
+#define VSC73XX_SUBBLOCK_PORT_3		3
+#define VSC73XX_SUBBLOCK_PORT_4		4
+#define VSC73XX_SUBBLOCK_PORT_MAC	6
+
+/* MAC Block registers */
+#define VSC73XX_MAC_CFG		0x0
+#define VSC73XX_ADVPORTM	0x19
+#define VSC73XX_RXOCT		0x50
+#define VSC73XX_TXOCT		0x51
+#define VSC73XX_C_RX0		0x52
+#define VSC73XX_C_RX1		0x53
+#define VSC73XX_C_RX2		0x54
+#define VSC73XX_C_TX0		0x55
+#define VSC73XX_C_TX1		0x56
+#define VSC73XX_C_TX2		0x57
+#define VSC73XX_C_CFG		0x58
+
+/* MAC_CFG register bits */
+#define VSC73XX_MAC_CFG_WEXC_DIS	(1 << 31)
+#define VSC73XX_MAC_CFG_PORT_RST	(1 << 29)
+#define VSC73XX_MAC_CFG_TX_EN		(1 << 28)
+#define VSC73XX_MAC_CFG_SEED_LOAD	(1 << 27)
+#define VSC73XX_MAC_CFG_FDX		(1 << 18)
+#define VSC73XX_MAC_CFG_GIGE		(1 << 17)
+#define VSC73XX_MAC_CFG_RX_EN		(1 << 16)
+#define VSC73XX_MAC_CFG_VLAN_DBLAWR	(1 << 15)
+#define VSC73XX_MAC_CFG_VLAN_AWR	(1 << 14)
+#define VSC73XX_MAC_CFG_100_BASE_T	(1 << 13)
+#define VSC73XX_MAC_CFG_TX_IPG(x)	(((x) & 0x1f) << 6)
+#define VSC73XX_MAC_CFG_MAC_RX_RST	(1 << 5)
+#define VSC73XX_MAC_CFG_MAC_TX_RST	(1 << 4)
+#define VSC73XX_MAC_CFG_BIT2		(1 << 2)
+#define VSC73XX_MAC_CFG_CLK_SEL(x)	((x) & 0x3)
+
+/* ADVPORTM register bits */
+#define VSC73XX_ADVPORTM_IFG_PPM	(1 << 7)
+#define VSC73XX_ADVPORTM_EXC_COL_CONT	(1 << 6)
+#define VSC73XX_ADVPORTM_EXT_PORT	(1 << 5)
+#define VSC73XX_ADVPORTM_INV_GTX	(1 << 4)
+#define VSC73XX_ADVPORTM_ENA_GTX	(1 << 3)
+#define VSC73XX_ADVPORTM_DDR_MODE	(1 << 2)
+#define VSC73XX_ADVPORTM_IO_LOOPBACK	(1 << 1)
+#define VSC73XX_ADVPORTM_HOST_LOOPBACK	(1 << 0)
+
+/* MII Block registers */
+#define VSC73XX_MII_STAT	0x0
+#define VSC73XX_MII_CMD		0x1
+#define VSC73XX_MII_DATA	0x2
+
+/* System Block registers */
+#define VSC73XX_ICPU_SIPAD		0x01
+#define VSC73XX_ICPU_CLOCK_DELAY	0x05
+#define VSC73XX_ICPU_CTRL		0x10
+#define VSC73XX_ICPU_ADDR		0x11
+#define VSC73XX_ICPU_SRAM		0x12
+#define VSC73XX_ICPU_MBOX_VAL		0x15
+#define VSC73XX_ICPU_MBOX_SET		0x16
+#define VSC73XX_ICPU_MBOX_CLR		0x17
+#define VSC73XX_ICPU_CHIPID		0x18
+#define VSC73XX_ICPU_GPIO		0x34
+
+#define VSC73XX_ICPU_CTRL_CLK_DIV	(1 << 8)
+#define VSC73XX_ICPU_CTRL_SRST_HOLD	(1 << 7)
+#define VSC73XX_ICPU_CTRL_BOOT_EN	(1 << 3)
+#define VSC73XX_ICPU_CTRL_EXT_ACC_EN	(1 << 2)
+#define VSC73XX_ICPU_CTRL_CLK_EN	(1 << 1)
+#define VSC73XX_ICPU_CTRL_SRST		(1 << 0)
+
+#define VSC73XX_ICPU_CHIPID_ID_SHIFT	12
+#define VSC73XX_ICPU_CHIPID_ID_MASK	0xffff
+#define VSC73XX_ICPU_CHIPID_REV_SHIFT	28
+#define VSC73XX_ICPU_CHIPID_REV_MASK	0xf
+#define VSC73XX_ICPU_CHIPID_ID_7385	0x7385
+#define VSC73XX_ICPU_CHIPID_ID_7395	0x7395
+
+#define VSC73XX_CMD_MODE_READ		0
+#define VSC73XX_CMD_MODE_WRITE		1
+#define VSC73XX_CMD_MODE_SHIFT		4
+#define VSC73XX_CMD_BLOCK_SHIFT		5
+#define VSC73XX_CMD_BLOCK_MASK		0x7
+#define VSC73XX_CMD_SUBBLOCK_MASK	0xf
+
+#define VSC7385_CLOCK_DELAY		((3 << 4) | 3)
+#define VSC7385_CLOCK_DELAY_MASK	((3 << 4) | 3)
+
+#define VSC73XX_ICPU_CTRL_STOP	(VSC73XX_ICPU_CTRL_SRST_HOLD | \
+				 VSC73XX_ICPU_CTRL_BOOT_EN | \
+				 VSC73XX_ICPU_CTRL_EXT_ACC_EN)
+
+#define VSC73XX_ICPU_CTRL_START	(VSC73XX_ICPU_CTRL_CLK_DIV | \
+				 VSC73XX_ICPU_CTRL_BOOT_EN | \
+				 VSC73XX_ICPU_CTRL_CLK_EN | \
+				 VSC73XX_ICPU_CTRL_SRST)
+
+#define VSC7385_ADVPORTM_MASK	(VSC73XX_ADVPORTM_IFG_PPM | \
+				 VSC73XX_ADVPORTM_EXC_COL_CONT | \
+				 VSC73XX_ADVPORTM_EXT_PORT | \
+				 VSC73XX_ADVPORTM_INV_GTX | \
+				 VSC73XX_ADVPORTM_ENA_GTX | \
+				 VSC73XX_ADVPORTM_DDR_MODE | \
+				 VSC73XX_ADVPORTM_IO_LOOPBACK | \
+				 VSC73XX_ADVPORTM_HOST_LOOPBACK)
+
+#define VSC7385_ADVPORTM_INIT	(VSC73XX_ADVPORTM_EXT_PORT | \
+				 VSC73XX_ADVPORTM_ENA_GTX | \
+				 VSC73XX_ADVPORTM_DDR_MODE)
+
+#define VSC7385_MAC_CFG_RESET	(VSC73XX_MAC_CFG_PORT_RST | \
+				 VSC73XX_MAC_CFG_MAC_RX_RST | \
+				 VSC73XX_MAC_CFG_MAC_TX_RST)
+
+#define VSC73XX_MAC_CFG_INIT	(VSC73XX_MAC_CFG_TX_EN | \
+				 VSC73XX_MAC_CFG_FDX | \
+				 VSC73XX_MAC_CFG_GIGE | \
+				 VSC73XX_MAC_CFG_RX_EN)
+
+#define VSC73XX_RESET_DELAY	100
+
+struct vsc7385 {
+	struct spi_device		*spi;
+	struct mutex			lock;
+	struct vsc7385_platform_data	*pdata;
+};
+
+static int vsc7385_is_addr_valid(u8 block, u8 subblock)
+{
+	switch (block) {
+	case VSC73XX_BLOCK_MAC:
+		switch (subblock) {
+		case 0 ... 4:
+		case 6:
+			return 1;
+		}
+		break;
+
+	case VSC73XX_BLOCK_2:
+	case VSC73XX_BLOCK_SYSTEM:
+		switch (subblock) {
+		case 0:
+			return 1;
+		}
+		break;
+
+	case VSC73XX_BLOCK_MII:
+	case VSC73XX_BLOCK_4:
+	case VSC73XX_BLOCK_5:
+		switch (subblock) {
+		case 0 ... 1:
+			return 1;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static inline u8 vsc7385_make_addr(u8 mode, u8 block, u8 subblock)
+{
+	u8 ret;
+
+	ret = (block & VSC73XX_CMD_BLOCK_MASK) << VSC73XX_CMD_BLOCK_SHIFT;
+	ret |= (mode & 1) << VSC73XX_CMD_MODE_SHIFT;
+	ret |= subblock & VSC73XX_CMD_SUBBLOCK_MASK;
+
+	return ret;
+}
+
+static int vsc7385_read(struct vsc7385 *vsc, u8 block, u8 subblock, u8 reg,
+			u32 *value)
+{
+	u8 cmd[4];
+	u8 buf[4];
+	struct spi_transfer t[2];
+	struct spi_message m;
+	int err;
+
+	if (!vsc7385_is_addr_valid(block, subblock))
+		return -EINVAL;
+
+	spi_message_init(&m);
+
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = buf;
+	t[1].len = sizeof(buf);
+	spi_message_add_tail(&t[1], &m);
+
+	cmd[0] = vsc7385_make_addr(VSC73XX_CMD_MODE_READ, block, subblock);
+	cmd[1] = reg;
+	cmd[2] = 0;
+	cmd[3] = 0;
+
+	mutex_lock(&vsc->lock);
+	err = spi_sync(vsc->spi, &m);
+	mutex_unlock(&vsc->lock);
+
+	if (err)
+		return err;
+
+	*value = (((u32) buf[0]) << 24) | (((u32) buf[1]) << 16) |
+		 (((u32) buf[2]) << 8) | ((u32) buf[3]);
+
+	return 0;
+}
+
+
+static int vsc7385_write(struct vsc7385 *vsc, u8 block, u8 subblock, u8 reg,
+			 u32 value)
+{
+	u8 cmd[2];
+	u8 buf[4];
+	struct spi_transfer t[2];
+	struct spi_message m;
+	int err;
+
+	if (!vsc7385_is_addr_valid(block, subblock))
+		return -EINVAL;
+
+	spi_message_init(&m);
+
+	memset(&t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = buf;
+	t[1].len = sizeof(buf);
+	spi_message_add_tail(&t[1], &m);
+
+	cmd[0] = vsc7385_make_addr(VSC73XX_CMD_MODE_WRITE, block, subblock);
+	cmd[1] = reg;
+
+	buf[0] = (value >> 24) & 0xff;
+	buf[1] = (value >> 16) & 0xff;
+	buf[2] = (value >> 8) & 0xff;
+	buf[3] = value & 0xff;
+
+	mutex_lock(&vsc->lock);
+	err = spi_sync(vsc->spi, &m);
+	mutex_unlock(&vsc->lock);
+
+	return err;
+}
+
+static inline int vsc7385_write_verify(struct vsc7385 *vsc, u8 block,
+				       u8 subblock, u8 reg, u32 value,
+				       u32 read_mask, u32 read_val)
+{
+	struct spi_device *spi = vsc->spi;
+	u32 t;
+	int err;
+
+	err = vsc7385_write(vsc, block, subblock, reg, value);
+	if (err)
+		return err;
+
+	err = vsc7385_read(vsc, block, subblock, reg, &t);
+	if (err)
+		return err;
+
+	if ((t & read_mask) != read_val) {
+		dev_err(&spi->dev, "register write error\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static inline int vsc7385_set_clock_delay(struct vsc7385 *vsc, u32 val)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+			     VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int vsc7385_get_clock_delay(struct vsc7385 *vsc, u32 *val)
+{
+	return vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+			    VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int vsc7385_icpu_stop(struct vsc7385 *vsc)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+			     VSC73XX_ICPU_CTRL_STOP);
+}
+
+static inline int vsc7385_icpu_start(struct vsc7385 *vsc)
+{
+	return vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+			     VSC73XX_ICPU_CTRL_START);
+}
+
+static inline int vsc7385_icpu_reset(struct vsc7385 *vsc)
+{
+	int rc;
+
+	rc = vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_ICPU_ADDR,
+			   0x0000);
+	if (rc)
+		dev_err(&vsc->spi->dev,
+			"could not reset microcode, err=%d\n", rc);
+
+	return rc;
+}
+
+static int vsc7385_upload_ucode(struct vsc7385 *vsc)
+{
+	struct spi_device *spi = vsc->spi;
+	const struct firmware *firmware;
+	char *ucode_name;
+	unsigned char *dp;
+	unsigned int curVal;
+	int i;
+	int diffs;
+	int rc;
+
+	ucode_name = (vsc->pdata->ucode_name) ? vsc->pdata->ucode_name
+					      : "vsc7385_ucode.bin";
+	rc = request_firmware(&firmware, ucode_name, &spi->dev);
+	if (rc) {
+		dev_err(&spi->dev, "request_firmware failed, err=%d\n",
+			rc);
+		return rc;
+	}
+
+	rc = vsc7385_icpu_stop(vsc);
+	if (rc)
+		goto out;
+
+	rc = vsc7385_icpu_reset(vsc);
+	if (rc)
+		goto out;
+
+	dev_info(&spi->dev, "uploading microcode...\n");
+
+	dp = (unsigned char *) firmware->data;
+	for (i = 0; i < firmware->size; i++) {
+		rc = vsc7385_write(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				   VSC73XX_ICPU_SRAM, *dp++);
+		if (rc) {
+			dev_err(&spi->dev, "could not load microcode, err=%d\n",
+				rc);
+			goto out;
+		}
+	}
+
+	rc = vsc7385_icpu_reset(vsc);
+	if (rc)
+		goto out;
+
+	dev_info(&spi->dev, "verifying microcode...\n");
+
+	dp = (unsigned char *) firmware->data;
+	diffs = 0;
+	for (i = 0; i < firmware->size; i++) {
+		rc = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				  VSC73XX_ICPU_SRAM, &curVal);
+		if (rc) {
+			dev_err(&spi->dev, "could not read microcode %d\n",
+				rc);
+			goto out;
+		}
+
+		if (curVal > 0xff) {
+			dev_err(&spi->dev, "bad val read: %04x : %02x  %02x\n",
+				i, *dp, curVal);
+			rc = -EIO;
+			goto out;
+		}
+
+		if ((curVal & 0xff) != *dp) {
+			diffs++;
+			dev_err(&spi->dev, "verify error: %04x : %02x  %02x\n",
+				i, *dp, curVal);
+
+			if (diffs > 4)
+				break;
+			}
+		dp++;
+	}
+
+	if (diffs) {
+		dev_err(&spi->dev, "microcode verification failed\n");
+		rc = -EIO;
+		goto out;
+	}
+
+	dev_info(&spi->dev, "microcode uploaded\n");
+
+	rc = vsc7385_icpu_start(vsc);
+
+out:
+	release_firmware(firmware);
+	return rc;
+}
+
+static int vsc7385_setup(struct vsc7385 *vsc)
+{
+	struct vsc7385_platform_data *pdata = vsc->pdata;
+	u32 t;
+	int err;
+
+	err = vsc7385_write_verify(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				   VSC73XX_ICPU_CLOCK_DELAY,
+				   VSC7385_CLOCK_DELAY,
+				   VSC7385_CLOCK_DELAY_MASK,
+				   VSC7385_CLOCK_DELAY);
+	if (err)
+		goto err;
+
+	err = vsc7385_write_verify(vsc, VSC73XX_BLOCK_MAC,
+				   VSC73XX_SUBBLOCK_PORT_MAC, VSC73XX_ADVPORTM,
+				   VSC7385_ADVPORTM_INIT,
+				   VSC7385_ADVPORTM_MASK,
+				   VSC7385_ADVPORTM_INIT);
+	if (err)
+		goto err;
+
+	err = vsc7385_write(vsc, VSC73XX_BLOCK_MAC, VSC73XX_SUBBLOCK_PORT_MAC,
+			    VSC73XX_MAC_CFG, VSC7385_MAC_CFG_RESET);
+	if (err)
+		goto err;
+
+	t = VSC73XX_MAC_CFG_INIT;
+	t |= VSC73XX_MAC_CFG_TX_IPG(pdata->mac_cfg.tx_ipg);
+	t |= VSC73XX_MAC_CFG_CLK_SEL(pdata->mac_cfg.clk_sel);
+	if (pdata->mac_cfg.bit2)
+		t |= VSC73XX_MAC_CFG_BIT2;
+
+	err = vsc7385_write(vsc, VSC73XX_BLOCK_MAC, VSC73XX_SUBBLOCK_PORT_MAC,
+			    VSC73XX_MAC_CFG, t);
+	if (err)
+		goto err;
+
+	return 0;
+
+err:
+	return err;
+}
+
+static int vsc7385_detect(struct vsc7385 *vsc)
+{
+	struct spi_device *spi = vsc->spi;
+	u32 t;
+	u32 id;
+	u32 rev;
+	int err;
+
+	err = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				VSC73XX_ICPU_MBOX_VAL, &t);
+	if (err) {
+		dev_err(&spi->dev, "unable to read mailbox, err=%d\n", err);
+		return err;
+	}
+
+	if (t == 0xffffffff) {
+		dev_dbg(&spi->dev, "assert chip reset\n");
+		if (vsc->pdata->reset)
+			vsc->pdata->reset();
+
+	}
+
+	err = vsc7385_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,
+				VSC73XX_ICPU_CHIPID, &t);
+	if (err) {
+		dev_err(&spi->dev, "unable to read chip id, err=%d\n", err);
+		return err;
+	}
+
+	id = (t >> VSC73XX_ICPU_CHIPID_ID_SHIFT) & VSC73XX_ICPU_CHIPID_ID_MASK;
+	switch (id) {
+	case VSC73XX_ICPU_CHIPID_ID_7385:
+	case VSC73XX_ICPU_CHIPID_ID_7395:
+		break;
+	default:
+		dev_err(&spi->dev, "unsupported chip, id=%04x\n", id);
+		return -ENODEV;
+	}
+
+	rev = (t >> VSC73XX_ICPU_CHIPID_REV_SHIFT) &
+	      VSC73XX_ICPU_CHIPID_REV_MASK;
+	dev_info(&spi->dev, "VSC%04X (rev. %d) switch found\n", id, rev);
+
+	return 0;
+}
+
+static int vsc7385_probe(struct spi_device *spi)
+{
+	struct vsc7385 *vsc;
+	struct vsc7385_platform_data *pdata;
+	int	err;
+
+	printk(KERN_INFO DRV_DESC " version " DRV_VERSION"\n");
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		dev_err(&spi->dev, "no platform data specified\n");
+		return -ENODEV;
+	}
+
+	vsc = kzalloc(sizeof(*vsc), GFP_KERNEL);
+	if (!vsc) {
+		dev_err(&spi->dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&vsc->lock);
+	vsc->pdata = pdata;
+	vsc->spi = spi_dev_get(spi);
+	dev_set_drvdata(&spi->dev, vsc);
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi_setup failed, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = vsc7385_detect(vsc);
+	if (err) {
+		dev_err(&spi->dev, "no chip found, err=%d\n", err);
+		goto err_drvdata;
+	}
+
+	err = vsc7385_upload_ucode(vsc);
+	if (err)
+		goto err_drvdata;
+
+	err = vsc7385_setup(vsc);
+	if (err)
+		goto err_drvdata;
+
+	return 0;
+
+err_drvdata:
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(vsc);
+	return err;
+}
+
+static int vsc7385_remove(struct spi_device *spi)
+{
+	struct vsc7385_data	*vsc;
+
+	vsc = dev_get_drvdata(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(vsc);
+
+	return 0;
+}
+
+static struct spi_driver vsc7385_driver = {
+	.driver = {
+		.name		= DRV_NAME,
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= vsc7385_probe,
+	.remove		= vsc7385_remove,
+};
+
+static int __init vsc7385_init(void)
+{
+	return spi_register_driver(&vsc7385_driver);
+}
+module_init(vsc7385_init);
+
+static void __exit vsc7385_exit(void)
+{
+	spi_unregister_driver(&vsc7385_driver);
+}
+module_exit(vsc7385_exit);
+
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL v2");
+
diff -Nur linux-4.1.13.orig/drivers/tty/serial/serial_core.c linux-4.1.13/drivers/tty/serial/serial_core.c
--- linux-4.1.13.orig/drivers/tty/serial/serial_core.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/tty/serial/serial_core.c	2015-12-04 19:57:05.897979014 +0100
@@ -164,6 +164,8 @@
 	if (retval == 0) {
 		if (uart_console(uport) && uport->cons->cflag) {
 			tty->termios.c_cflag = uport->cons->cflag;
+			tty->termios.c_ospeed = uport->cons->baud;
+			tty->termios.c_ispeed = uport->cons->baud;
 			uport->cons->cflag = 0;
 		}
 		/*
@@ -1901,7 +1903,7 @@
 	{   4800, B4800   },
 	{   2400, B2400   },
 	{   1200, B1200   },
-	{      0, B38400  }
+	{      0, BOTHER  }
 };
 
 /**
@@ -1940,10 +1942,13 @@
 	 * Construct a cflag setting.
 	 */
 	for (i = 0; baud_rates[i].rate; i++)
-		if (baud_rates[i].rate <= baud)
+		if (baud_rates[i].rate == baud)
 			break;
 
 	termios.c_cflag |= baud_rates[i].cflag;
+	if (!baud_rates[i].rate) {
+		termios.c_ospeed = baud;
+	}
 
 	if (bits == 7)
 		termios.c_cflag |= CS7;
@@ -1973,8 +1978,10 @@
 	 * Allow the setting of the UART parameters with a NULL console
 	 * too:
 	 */
-	if (co)
+	if (co) {
 		co->cflag = termios.c_cflag;
+		co->baud = baud;
+	}
 
 	return 0;
 }
diff -Nur linux-4.1.13.orig/drivers/usb/host/ehci-hcd.c linux-4.1.13/drivers/usb/host/ehci-hcd.c
--- linux-4.1.13.orig/drivers/usb/host/ehci-hcd.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/usb/host/ehci-hcd.c	2015-12-04 19:57:03.974104886 +0100
@@ -252,6 +252,37 @@
 	command |= CMD_RESET;
 	dbg_cmd (ehci, "reset", command);
 	ehci_writel(ehci, command, &ehci->regs->command);
+
+	if (ehci->qca_force_host_mode) {
+		u32 usbmode;
+
+		udelay(1000);
+
+		usbmode = ehci_readl(ehci, &ehci->regs->usbmode);
+		usbmode |= USBMODE_CM_HC | (1 << 4);
+		ehci_writel(ehci, usbmode, &ehci->regs->usbmode);
+
+		ehci_dbg(ehci, "forced host mode, usbmode: %08x\n",
+			 ehci_readl(ehci, &ehci->regs->usbmode));
+	}
+
+	if (ehci->qca_force_16bit_ptw) {
+		u32 port_status;
+
+		udelay(1000);
+
+		/* enable 16-bit UTMI interface */
+		port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
+		port_status |= BIT(28);
+		ehci_writel(ehci, port_status, &ehci->regs->port_status[0]);
+
+		ehci_dbg(ehci, "16-bit UTMI interface enabled, status: %08x\n",
+			 ehci_readl(ehci, &ehci->regs->port_status[0]));
+	}
+
+	if (ehci->reset_notifier)
+		ehci->reset_notifier(ehci_to_hcd(ehci));
+
 	ehci->rh_state = EHCI_RH_HALTED;
 	ehci->next_statechange = jiffies;
 	retval = ehci_handshake(ehci, &ehci->regs->command,
diff -Nur linux-4.1.13.orig/drivers/usb/host/ehci-platform.c linux-4.1.13/drivers/usb/host/ehci-platform.c
--- linux-4.1.13.orig/drivers/usb/host/ehci-platform.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/usb/host/ehci-platform.c	2015-12-04 19:57:03.978104624 +0100
@@ -49,6 +49,14 @@
 
 static const char hcd_name[] = "ehci-platform";
 
+static void ehci_platform_reset_notifier(struct usb_hcd *hcd)
+{
+	struct platform_device *pdev = to_platform_device(hcd->self.controller);
+	struct usb_ehci_pdata *pdata = pdev->dev.platform_data;
+
+	pdata->reset_notifier(pdev);
+}
+
 static int ehci_platform_reset(struct usb_hcd *hcd)
 {
 	struct platform_device *pdev = to_platform_device(hcd->self.controller);
diff -Nur linux-4.1.13.orig/drivers/watchdog/ath79_wdt.c linux-4.1.13/drivers/watchdog/ath79_wdt.c
--- linux-4.1.13.orig/drivers/watchdog/ath79_wdt.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/drivers/watchdog/ath79_wdt.c	2015-12-04 19:57:04.398077147 +0100
@@ -114,10 +114,14 @@
 
 static int ath79_wdt_set_timeout(int val)
 {
-	if (val < 1 || val > max_timeout)
+	if (val < 1)
 		return -EINVAL;
 
-	timeout = val;
+	if (val > max_timeout)
+		timeout = max_timeout;
+	else
+		timeout = val;
+
 	ath79_wdt_keepalive();
 
 	return 0;
diff -Nur linux-4.1.13.orig/include/linux/console.h linux-4.1.13/include/linux/console.h
--- linux-4.1.13.orig/include/linux/console.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/linux/console.h	2015-12-04 19:57:05.901978752 +0100
@@ -127,6 +127,7 @@
 	short	flags;
 	short	index;
 	int	cflag;
+	int	baud;
 	void	*data;
 	struct	 console *next;
 };
diff -Nur linux-4.1.13.orig/include/linux/ipv6.h linux-4.1.13/include/linux/ipv6.h
--- linux-4.1.13.orig/include/linux/ipv6.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/linux/ipv6.h	2015-12-04 19:57:05.917977705 +0100
@@ -5,6 +5,7 @@
 
 #define ipv6_optlen(p)  (((p)->hdrlen+1) << 3)
 #define ipv6_authlen(p) (((p)->hdrlen+2) << 2)
+
 /*
  * This structure contains configuration options per IPv6 link.
  */
diff -Nur linux-4.1.13.orig/include/linux/mtd/physmap.h linux-4.1.13/include/linux/mtd/physmap.h
--- linux-4.1.13.orig/include/linux/mtd/physmap.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/linux/mtd/physmap.h	2015-12-04 19:57:03.830114307 +0100
@@ -25,6 +25,8 @@
 	unsigned int		width;
 	int			(*init)(struct platform_device *);
 	void			(*exit)(struct platform_device *);
+	void			(*lock)(struct platform_device *);
+	void			(*unlock)(struct platform_device *);
 	void			(*set_vpp)(struct platform_device *, int);
 	unsigned int		nr_parts;
 	unsigned int		pfow_base;
diff -Nur linux-4.1.13.orig/include/linux/myloader.h linux-4.1.13/include/linux/myloader.h
--- linux-4.1.13.orig/include/linux/myloader.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/myloader.h	2015-12-04 20:10:00.684874021 +0100
@@ -0,0 +1,121 @@
+/*
+ *  Compex's MyLoader specific definitions
+ *
+ *  Copyright (C) 2006-2008 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef _MYLOADER_H_
+#define _MYLOADER_H_
+
+/* Myloader specific magic numbers */
+#define MYLO_MAGIC_SYS_PARAMS	0x20021107
+#define MYLO_MAGIC_PARTITIONS	0x20021103
+#define MYLO_MAGIC_BOARD_PARAMS	0x20021103
+
+/* Vendor ID's (seems to be same as the PCI vendor ID's) */
+#define VENID_COMPEX		0x11F6
+
+/* Devices based on the ADM5120 */
+#define DEVID_COMPEX_NP27G	0x0078
+#define DEVID_COMPEX_NP28G	0x044C
+#define DEVID_COMPEX_NP28GHS	0x044E
+#define DEVID_COMPEX_WP54Gv1C	0x0514
+#define DEVID_COMPEX_WP54G	0x0515
+#define DEVID_COMPEX_WP54AG	0x0546
+#define DEVID_COMPEX_WPP54AG	0x0550
+#define DEVID_COMPEX_WPP54G	0x0555
+
+/* Devices based on the Atheros AR2317 */
+#define DEVID_COMPEX_NP25G	0x05E6
+#define DEVID_COMPEX_WPE53G	0x05DC
+
+/* Devices based on the Atheros AR71xx */
+#define DEVID_COMPEX_WP543	0x0640
+#define DEVID_COMPEX_WPE72	0x0672
+
+/* Devices based on the IXP422 */
+#define DEVID_COMPEX_WP18	0x047E
+#define DEVID_COMPEX_NP18A	0x0489
+
+/* Other devices */
+#define DEVID_COMPEX_NP26G8M	0x03E8
+#define DEVID_COMPEX_NP26G16M	0x03E9
+
+struct mylo_partition {
+	uint16_t	flags;	/* partition flags */
+	uint16_t	type;	/* type of the partition */
+	uint32_t	addr;	/* relative address of the partition from the
+				   flash start */
+	uint32_t	size;	/* size of the partition in bytes */
+	uint32_t	param;	/* if this is the active partition, the
+				   MyLoader load code to this address */
+};
+
+#define PARTITION_FLAG_ACTIVE	0x8000 /* this is the active partition,
+					* MyLoader loads firmware from here */
+#define PARTITION_FLAG_ISRAM	0x2000 /* FIXME: this is a RAM partition? */
+#define PARTIIION_FLAG_RAMLOAD	0x1000 /* FIXME: load this partition into the RAM? */
+#define PARTITION_FLAG_PRELOAD	0x0800 /* the partition data preloaded to RAM
+					* before decompression */
+#define PARTITION_FLAG_LZMA	0x0100 /* partition data compressed by LZMA */
+#define PARTITION_FLAG_HAVEHDR  0x0002 /* the partition data have a header */
+
+#define PARTITION_TYPE_FREE	0
+#define PARTITION_TYPE_USED	1
+
+#define MYLO_MAX_PARTITIONS	8	/* maximum number of partitions in the
+					   partition table */
+
+struct mylo_partition_table {
+	uint32_t	magic;		/* must be MYLO_MAGIC_PARTITIONS */
+	uint32_t	res0;		/* unknown/unused */
+	uint32_t	res1;		/* unknown/unused */
+	uint32_t 	res2;		/* unknown/unused */
+	struct mylo_partition partitions[MYLO_MAX_PARTITIONS];
+};
+
+struct mylo_partition_header {
+	uint32_t	len;		/* length of the partition data */
+	uint32_t	crc;		/* CRC value of the partition data */
+};
+
+struct mylo_system_params {
+	uint32_t	magic;		/* must be MYLO_MAGIC_SYS_PARAMS */
+	uint32_t	res0;
+	uint32_t	res1;
+	uint32_t	mylo_ver;
+	uint16_t	vid;		/* Vendor ID */
+	uint16_t	did;		/* Device ID */
+	uint16_t	svid;		/* Sub Vendor ID */
+	uint16_t	sdid;		/* Sub Device ID */
+	uint32_t	rev;		/* device revision */
+	uint32_t	fwhi;
+	uint32_t	fwlo;
+	uint32_t	tftp_addr;
+	uint32_t	prog_start;
+	uint32_t	flash_size;	/* size of boot FLASH in bytes */
+	uint32_t	dram_size;	/* size of onboard RAM in bytes */
+};
+
+struct mylo_eth_addr {
+	uint8_t	mac[6];
+	uint8_t	csum[2];
+};
+
+#define MYLO_ETHADDR_COUNT	8	/* maximum number of ethernet address
+					   in the board parameters */
+
+struct mylo_board_params {
+	uint32_t	magic;	/* must be MYLO_MAGIC_BOARD_PARAMS */
+	uint32_t	res0;
+	uint32_t	res1;
+	uint32_t	res2;
+	struct mylo_eth_addr addr[MYLO_ETHADDR_COUNT];
+};
+
+#endif /* _MYLOADER_H_*/
diff -Nur linux-4.1.13.orig/include/linux/nxp_74hc153.h linux-4.1.13/include/linux/nxp_74hc153.h
--- linux-4.1.13.orig/include/linux/nxp_74hc153.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/nxp_74hc153.h	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,24 @@
+/*
+ *  NXP 74HC153 - Dual 4-input multiplexer defines
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _NXP_74HC153_H
+#define _NXP_74HC153_H
+
+#define NXP_74HC153_DRIVER_NAME "nxp-74hc153"
+
+struct nxp_74hc153_platform_data {
+	unsigned	gpio_base;
+	unsigned	gpio_pin_s0;
+	unsigned	gpio_pin_s1;
+	unsigned	gpio_pin_1y;
+	unsigned	gpio_pin_2y;
+};
+
+#endif /* _NXP_74HC153_H */
diff -Nur linux-4.1.13.orig/include/linux/phy.h linux-4.1.13/include/linux/phy.h
--- linux-4.1.13.orig/include/linux/phy.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/linux/phy.h	2015-12-04 20:31:10.916990579 +0100
@@ -762,6 +762,7 @@
 void phy_stop_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr);
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
diff -Nur linux-4.1.13.orig/include/linux/platform/ar934x_nfc.h linux-4.1.13/include/linux/platform/ar934x_nfc.h
--- linux-4.1.13.orig/include/linux/platform/ar934x_nfc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/platform/ar934x_nfc.h	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,39 @@
+/*
+ * Platform data definition for the built-in NAND controller of the
+ * Atheros AR934x SoCs
+ *
+ * Copyright (C) 2011-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#ifndef _AR934X_NFC_PLATFORM_H
+#define _AR934X_NFC_PLATFORM_H
+
+#define AR934X_NFC_DRIVER_NAME		"ar934x-nfc"
+
+struct mtd_info;
+struct mtd_partition;
+
+enum ar934x_nfc_ecc_mode {
+	AR934X_NFC_ECC_SOFT = 0,
+	AR934X_NFC_ECC_HW,
+	AR934X_NFC_ECC_SOFT_BCH,
+};
+
+struct ar934x_nfc_platform_data {
+	const char *name;
+	struct mtd_partition *parts;
+	int nr_parts;
+
+	bool swap_dma;
+	enum ar934x_nfc_ecc_mode ecc_mode;
+
+	void (*hw_reset)(bool active);
+	void (*select_chip)(int chip_no);
+	int (*scan_fixup)(struct mtd_info *mtd);
+};
+
+#endif /* _AR934X_NFC_PLATFORM_H */
diff -Nur linux-4.1.13.orig/include/linux/platform_data/gpio-latch.h linux-4.1.13/include/linux/platform_data/gpio-latch.h
--- linux-4.1.13.orig/include/linux/platform_data/gpio-latch.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/platform_data/gpio-latch.h	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,14 @@
+#ifndef _GPIO_LATCH_H_
+#define _GPIO_LATCH_H_
+
+#define GPIO_LATCH_DRIVER_NAME	"gpio-latch"
+
+struct gpio_latch_platform_data {
+	int base;
+	int num_gpios;
+	int *gpios;
+	int le_gpio_index;
+	bool le_active_low;
+};
+
+#endif /* _GPIO_LATCH_H_ */
diff -Nur linux-4.1.13.orig/include/linux/platform_data/phy-at803x.h linux-4.1.13/include/linux/platform_data/phy-at803x.h
--- linux-4.1.13.orig/include/linux/platform_data/phy-at803x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/platform_data/phy-at803x.h	2015-12-04 19:57:03.890110382 +0100
@@ -0,0 +1,11 @@
+#ifndef _PHY_AT803X_PDATA_H
+#define _PHY_AT803X_PDATA_H
+
+struct at803x_platform_data {
+	int disable_smarteee:1;
+	int enable_rgmii_tx_delay:1;
+	int enable_rgmii_rx_delay:1;
+	int fixup_rgmii_tx_delay:1;
+};
+
+#endif /* _PHY_AT803X_PDATA_H */
diff -Nur linux-4.1.13.orig/include/linux/platform_data/rb91x_nand.h linux-4.1.13/include/linux/platform_data/rb91x_nand.h
--- linux-4.1.13.orig/include/linux/platform_data/rb91x_nand.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/platform_data/rb91x_nand.h	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,16 @@
+#ifndef _RB91X_NAND_H_
+#define _RB91X_NAND_H_
+
+#define RB91X_NAND_DRIVER_NAME	"rb91x-nand"
+
+struct rb91x_nand_platform_data {
+	int gpio_nce;	/* chip enable, active low */
+	int gpio_ale;	/* address latch enable */
+	int gpio_cle;   /* command latch enable */
+	int gpio_rdy;
+	int gpio_read;
+	int gpio_nrw;	/* read/write enable, active low */
+	int gpio_nle;	/* latch enable, active low */
+};
+
+#endif /* _RB91X_NAND_H_ */
\ No newline at end of file
diff -Nur linux-4.1.13.orig/include/linux/rle.h linux-4.1.13/include/linux/rle.h
--- linux-4.1.13.orig/include/linux/rle.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/rle.h	2015-12-04 19:57:03.830114307 +0100
@@ -0,0 +1,18 @@
+#ifndef _RLE_H_
+#define _RLE_H_
+
+#ifdef CONFIG_RLE_DECOMPRESS
+int rle_decode(const unsigned char *src, size_t srclen,
+	       unsigned char *dst, size_t dstlen,
+	       size_t *src_done, size_t *dst_done);
+#else
+static inline int
+rle_decode(const unsigned char *src, size_t srclen,
+	   unsigned char *dst, size_t dstlen,
+	   size_t *src_done, size_t *dst_done)
+{
+	return -ENOTSUPP;
+}
+#endif /* CONFIG_RLE_DECOMPRESS */
+
+#endif /* _RLE_H_ */
diff -Nur linux-4.1.13.orig/include/linux/spi/74x164.h linux-4.1.13/include/linux/spi/74x164.h
--- linux-4.1.13.orig/include/linux/spi/74x164.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/spi/74x164.h	2015-12-04 19:57:03.930107765 +0100
@@ -0,0 +1,13 @@
+#ifndef LINUX_SPI_74X164_H
+#define LINUX_SPI_74X164_H
+
+struct gen_74x164_chip_platform_data {
+	/* number assigned to the first GPIO */
+	unsigned        base;
+	/* number of chained registers */
+	unsigned	num_registers;
+	/* address of a buffer containing initial data */
+	u8		*init_data;
+};
+
+#endif
diff -Nur linux-4.1.13.orig/include/linux/spi/flash.h linux-4.1.13/include/linux/spi/flash.h
--- linux-4.1.13.orig/include/linux/spi/flash.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/linux/spi/flash.h	2015-12-04 19:57:03.854112737 +0100
@@ -24,6 +24,7 @@
 	unsigned int	nr_parts;
 
 	char		*type;
+	const char	**part_probes;
 
 	/* we'll likely add more ... use JEDEC IDs, etc */
 };
diff -Nur linux-4.1.13.orig/include/linux/spi/spi_bitbang.h linux-4.1.13/include/linux/spi/spi_bitbang.h
--- linux-4.1.13.orig/include/linux/spi/spi_bitbang.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/linux/spi/spi_bitbang.h	2015-12-04 19:57:03.934107503 +0100
@@ -39,6 +39,7 @@
 extern void spi_bitbang_cleanup(struct spi_device *spi);
 extern int spi_bitbang_setup_transfer(struct spi_device *spi,
 				      struct spi_transfer *t);
+extern int spi_bitbang_bufs(struct spi_device *spi, struct spi_transfer *t);
 
 /* start or stop queue processing */
 extern int spi_bitbang_start(struct spi_bitbang *spi);
diff -Nur linux-4.1.13.orig/include/linux/spi/spi.h linux-4.1.13/include/linux/spi/spi.h
--- linux-4.1.13.orig/include/linux/spi/spi.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/linux/spi/spi.h	2015-12-04 19:57:03.966105410 +0100
@@ -506,6 +506,12 @@
 
 /*---------------------------------------------------------------------------*/
 
+enum spi_transfer_type {
+	SPI_TRANSFER_GENERIC = 0,
+	SPI_TRANSFER_FLASH_READ_CMD,
+	SPI_TRANSFER_FLASH_READ_DATA,
+};
+
 /*
  * I/O INTERFACE between SPI controller and protocol drivers
  *
@@ -618,12 +624,16 @@
 	unsigned	cs_change:1;
 	unsigned	tx_nbits:3;
 	unsigned	rx_nbits:3;
+	unsigned	verify:1;
+	unsigned	fast_write:1;
 #define	SPI_NBITS_SINGLE	0x01 /* 1bit transfer */
 #define	SPI_NBITS_DUAL		0x02 /* 2bits transfer */
 #define	SPI_NBITS_QUAD		0x04 /* 4bits transfer */
 	u8		bits_per_word;
 	u16		delay_usecs;
 	u32		speed_hz;
+	enum spi_transfer_type type;
+	bool dummy;
 
 	struct list_head transfer_list;
 };
@@ -663,6 +673,7 @@
 	struct spi_device	*spi;
 
 	unsigned		is_dma_mapped:1;
+	unsigned		fast_read:1;
 
 	/* REVISIT:  we might want a flag affecting the behavior of the
 	 * last transfer ... allowing things like "read 16 bit length L"
diff -Nur linux-4.1.13.orig/include/linux/spi/vsc7385.h linux-4.1.13/include/linux/spi/vsc7385.h
--- linux-4.1.13.orig/include/linux/spi/vsc7385.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/spi/vsc7385.h	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,19 @@
+/*
+ * Platform data definition for the Vitesse VSC7385 ethernet switch driver
+ *
+ * Copyright (C) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+struct vsc7385_platform_data {
+	void		(*reset)(void);
+	char		*ucode_name;
+	struct {
+		u32	tx_ipg:5;
+		u32	bit2:1;
+		u32	clk_sel:3;
+	} mac_cfg;
+};
diff -Nur linux-4.1.13.orig/include/linux/switch.h linux-4.1.13/include/linux/switch.h
--- linux-4.1.13.orig/include/linux/switch.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/linux/switch.h	2015-12-04 20:52:15.735681740 +0100
@@ -0,0 +1,169 @@
+/*
+ * switch.h: Switch configuration API
+ *
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef _LINUX_SWITCH_H
+#define _LINUX_SWITCH_H
+
+#include <net/genetlink.h>
+#include <uapi/linux/switch.h>
+
+struct switch_dev;
+struct switch_op;
+struct switch_val;
+struct switch_attr;
+struct switch_attrlist;
+struct switch_led_trigger;
+
+int register_switch(struct switch_dev *dev, struct net_device *netdev);
+void unregister_switch(struct switch_dev *dev);
+
+/**
+ * struct switch_attrlist - attribute list
+ *
+ * @n_attr: number of attributes
+ * @attr: pointer to the attributes array
+ */
+struct switch_attrlist {
+	int n_attr;
+	const struct switch_attr *attr;
+};
+
+enum switch_port_speed {
+	SWITCH_PORT_SPEED_UNKNOWN = 0,
+	SWITCH_PORT_SPEED_10 = 10,
+	SWITCH_PORT_SPEED_100 = 100,
+	SWITCH_PORT_SPEED_1000 = 1000,
+};
+
+struct switch_port_link {
+	bool link;
+	bool duplex;
+	bool aneg;
+	bool tx_flow;
+	bool rx_flow;
+	enum switch_port_speed speed;
+	/* in ethtool adv_t format */
+	u32 eee;
+};
+
+struct switch_port_stats {
+	unsigned long tx_bytes;
+	unsigned long rx_bytes;
+};
+
+/**
+ * struct switch_dev_ops - switch driver operations
+ *
+ * @attr_global: global switch attribute list
+ * @attr_port: port attribute list
+ * @attr_vlan: vlan attribute list
+ *
+ * Callbacks:
+ *
+ * @get_vlan_ports: read the port list of a VLAN
+ * @set_vlan_ports: set the port list of a VLAN
+ *
+ * @get_port_pvid: get the primary VLAN ID of a port
+ * @set_port_pvid: set the primary VLAN ID of a port
+ *
+ * @apply_config: apply all changed settings to the switch
+ * @reset_switch: resetting the switch
+ */
+struct switch_dev_ops {
+	struct switch_attrlist attr_global, attr_port, attr_vlan;
+
+	int (*get_vlan_ports)(struct switch_dev *dev, struct switch_val *val);
+	int (*set_vlan_ports)(struct switch_dev *dev, struct switch_val *val);
+
+	int (*get_port_pvid)(struct switch_dev *dev, int port, int *val);
+	int (*set_port_pvid)(struct switch_dev *dev, int port, int val);
+
+	int (*apply_config)(struct switch_dev *dev);
+	int (*reset_switch)(struct switch_dev *dev);
+
+	int (*get_port_link)(struct switch_dev *dev, int port,
+			     struct switch_port_link *link);
+	int (*get_port_stats)(struct switch_dev *dev, int port,
+			      struct switch_port_stats *stats);
+};
+
+struct switch_dev {
+	struct device_node *of_node;
+	const struct switch_dev_ops *ops;
+	/* will be automatically filled */
+	char devname[IFNAMSIZ];
+
+	const char *name;
+	/* NB: either alias or netdev must be set */
+	const char *alias;
+	struct net_device *netdev;
+
+	int ports;
+	int vlans;
+	int cpu_port;
+
+	/* the following fields are internal for swconfig */
+	int id;
+	struct list_head dev_list;
+	unsigned long def_global, def_port, def_vlan;
+
+	struct mutex sw_mutex;
+	struct switch_port *portbuf;
+	struct switch_portmap *portmap;
+
+	char buf[128];
+
+#ifdef CONFIG_SWCONFIG_LEDS
+	struct switch_led_trigger *led_trigger;
+#endif
+};
+
+struct switch_port {
+	u32 id;
+	u32 flags;
+};
+
+struct switch_portmap {
+	u32 virt;
+	const char *s;
+};
+
+struct switch_val {
+	const struct switch_attr *attr;
+	int port_vlan;
+	int len;
+	union {
+		const char *s;
+		u32 i;
+		struct switch_port *ports;
+	} value;
+};
+
+struct switch_attr {
+	int disabled;
+	int type;
+	const char *name;
+	const char *description;
+
+	int (*set)(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val);
+	int (*get)(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val);
+
+	/* for driver internal use */
+	int id;
+	int ofs;
+	int max;
+};
+
+#endif /* _LINUX_SWITCH_H */
diff -Nur linux-4.1.13.orig/include/linux/types.h linux-4.1.13/include/linux/types.h
--- linux-4.1.13.orig/include/linux/types.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/linux/types.h	2015-12-04 19:57:05.925977182 +0100
@@ -215,5 +215,11 @@
 /* clocksource cycle base type */
 typedef u64 cycle_t;
 
+struct net_hdr_word {
+       u32 words[1];
+} __attribute__((packed, aligned(2)));
+
+#define net_hdr_word(_p) (((struct net_hdr_word *) (_p))->words[0])
+
 #endif /*  __ASSEMBLY__ */
 #endif /* _LINUX_TYPES_H */
diff -Nur linux-4.1.13.orig/include/linux/usb/ehci_pdriver.h linux-4.1.13/include/linux/usb/ehci_pdriver.h
--- linux-4.1.13.orig/include/linux/usb/ehci_pdriver.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/linux/usb/ehci_pdriver.h	2015-12-04 20:18:56.085517295 +0100
@@ -49,6 +49,8 @@
 	unsigned	no_io_watchdog:1;
 	unsigned	reset_on_resume:1;
 	unsigned	dma_mask_64:1;
+	unsigned	qca_force_host_mode:1;
+	unsigned	qca_force_16bit_ptw:1;
 
 	/* Turn on all power and clocks */
 	int (*power_on)(struct platform_device *pdev);
@@ -58,6 +60,7 @@
 	 * turn off everything else */
 	void (*power_suspend)(struct platform_device *pdev);
 	int (*pre_setup)(struct usb_hcd *hcd);
+	void (*reset_notifier)(struct platform_device *pdev);
 };
 
 #endif /* __USB_CORE_EHCI_PDRIVER_H */
diff -Nur linux-4.1.13.orig/include/net/addrconf.h linux-4.1.13/include/net/addrconf.h
--- linux-4.1.13.orig/include/net/addrconf.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/net/addrconf.h	2015-12-04 19:57:05.929976920 +0100
@@ -43,7 +43,7 @@
 	__be32			reserved2;
 
 	struct in6_addr		prefix;
-};
+} __attribute__((packed, aligned(2)));
 
 
 #include <linux/netdevice.h>
diff -Nur linux-4.1.13.orig/include/net/inet_ecn.h linux-4.1.13/include/net/inet_ecn.h
--- linux-4.1.13.orig/include/net/inet_ecn.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/net/inet_ecn.h	2015-12-04 19:57:05.929976920 +0100
@@ -115,13 +115,13 @@
 {
 	if (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))
 		return 0;
-	*(__be32*)iph |= htonl(INET_ECN_CE << 20);
+	net_hdr_word(iph) |= htonl(INET_ECN_CE << 20);
 	return 1;
 }
 
 static inline void IP6_ECN_clear(struct ipv6hdr *iph)
 {
-	*(__be32*)iph &= ~htonl(INET_ECN_MASK << 20);
+	net_hdr_word(iph) &= ~htonl(INET_ECN_MASK << 20);
 }
 
 static inline void ipv6_copy_dscp(unsigned int dscp, struct ipv6hdr *inner)
diff -Nur linux-4.1.13.orig/include/net/ipv6.h linux-4.1.13/include/net/ipv6.h
--- linux-4.1.13.orig/include/net/ipv6.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/net/ipv6.h	2015-12-04 19:57:05.929976920 +0100
@@ -107,7 +107,7 @@
 	__u8	reserved;
 	__be16	frag_off;
 	__be32	identification;
-};
+} __attribute__((packed, aligned(2)));
 
 #define	IP6_MF		0x0001
 #define	IP6_OFFSET	0xFFF8
@@ -396,8 +396,8 @@
 	}
 #endif
 #endif
-	addr[0] = wh;
-	addr[1] = wl;
+	net_hdr_word(&addr[0]) = wh;
+	net_hdr_word(&addr[1]) = wl;
 }
 
 static inline void ipv6_addr_set(struct in6_addr *addr, 
@@ -456,6 +456,8 @@
 	const __be32 *a1 = addr1->s6_addr32;
 	const __be32 *a2 = addr2->s6_addr32;
 	unsigned int pdw, pbi;
+	/* Used for last <32-bit fraction of prefix */
+	u32 pbia1, pbia2;
 
 	/* check complete u32 in prefix */
 	pdw = prefixlen >> 5;
@@ -464,7 +466,9 @@
 
 	/* check incomplete u32 in prefix */
 	pbi = prefixlen & 0x1f;
-	if (pbi && ((a1[pdw] ^ a2[pdw]) & htonl((0xffffffff) << (32 - pbi))))
+	pbia1 = net_hdr_word(&a1[pdw]);
+	pbia2 = net_hdr_word(&a2[pdw]);
+	if (pbi && ((pbia1 ^ pbia2) & htonl((0xffffffff) << (32 - pbi))))
 		return false;
 
 	return true;
@@ -607,13 +611,13 @@
  */
 static inline int __ipv6_addr_diff32(const void *token1, const void *token2, int addrlen)
 {
-	const __be32 *a1 = token1, *a2 = token2;
+	const struct in6_addr *a1 = token1, *a2 = token2;
 	int i;
 
 	addrlen >>= 2;
 
 	for (i = 0; i < addrlen; i++) {
-		__be32 xb = a1[i] ^ a2[i];
+		__be32 xb = a1->s6_addr32[i] ^ a2->s6_addr32[i];
 		if (xb)
 			return i * 32 + 31 - __fls(ntohl(xb));
 	}
@@ -739,17 +743,18 @@
 static inline void ip6_flow_hdr(struct ipv6hdr *hdr, unsigned int tclass,
 				__be32 flowlabel)
 {
-	*(__be32 *)hdr = htonl(0x60000000 | (tclass << 20)) | flowlabel;
+	net_hdr_word((__be32 *)hdr) =
+		htonl(0x60000000 | (tclass << 20)) | flowlabel;
 }
 
 static inline __be32 ip6_flowinfo(const struct ipv6hdr *hdr)
 {
-	return *(__be32 *)hdr & IPV6_FLOWINFO_MASK;
+	return net_hdr_word((__be32 *)hdr) & IPV6_FLOWINFO_MASK;
 }
 
 static inline __be32 ip6_flowlabel(const struct ipv6hdr *hdr)
 {
-	return *(__be32 *)hdr & IPV6_FLOWLABEL_MASK;
+	return net_hdr_word((__be32 *)hdr) & IPV6_FLOWLABEL_MASK;
 }
 
 static inline u8 ip6_tclass(__be32 flowinfo)
diff -Nur linux-4.1.13.orig/include/net/ndisc.h linux-4.1.13/include/net/ndisc.h
--- linux-4.1.13.orig/include/net/ndisc.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/net/ndisc.h	2015-12-04 19:57:05.929976920 +0100
@@ -76,7 +76,7 @@
         struct icmp6hdr		icmph;
 	__be32			reachable_time;
 	__be32			retrans_timer;
-};
+} __attribute__((packed, aligned(2)));
 
 struct rd_msg {
 	struct icmp6hdr icmph;
@@ -148,10 +148,10 @@
 {
 	const u32 *p32 = pkey;
 
-	return (((p32[0] ^ hash32_ptr(dev)) * hash_rnd[0]) +
-		(p32[1] * hash_rnd[1]) +
-		(p32[2] * hash_rnd[2]) +
-		(p32[3] * hash_rnd[3]));
+	return (((net_hdr_word(&p32[0]) ^ hash32_ptr(dev)) * hash_rnd[0]) +
+		(net_hdr_word(&p32[1]) * hash_rnd[1]) +
+		(net_hdr_word(&p32[2]) * hash_rnd[2]) +
+		(net_hdr_word(&p32[3]) * hash_rnd[3]));
 }
 
 static inline struct neighbour *__ipv6_neigh_lookup_noref(struct net_device *dev, const void *pkey)
diff -Nur linux-4.1.13.orig/include/net/neighbour.h linux-4.1.13/include/net/neighbour.h
--- linux-4.1.13.orig/include/net/neighbour.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/net/neighbour.h	2015-12-04 19:57:05.933976659 +0100
@@ -262,8 +262,10 @@
 	const u32 *n32 = (const u32 *)n->primary_key;
 	const u32 *p32 = pkey;
 
-	return ((n32[0] ^ p32[0]) | (n32[1] ^ p32[1]) |
-		(n32[2] ^ p32[2]) | (n32[3] ^ p32[3])) == 0;
+	return ((n32[0] ^ net_hdr_word(&p32[0])) |
+		(n32[1] ^ net_hdr_word(&p32[1])) |
+		(n32[2] ^ net_hdr_word(&p32[2])) |
+		(n32[3] ^ net_hdr_word(&p32[3]))) == 0;
 }
 
 static inline struct neighbour *___neigh_lookup_noref(
diff -Nur linux-4.1.13.orig/include/net/secure_seq.h linux-4.1.13/include/net/secure_seq.h
--- linux-4.1.13.orig/include/net/secure_seq.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/net/secure_seq.h	2015-12-04 19:57:05.929976920 +0100
@@ -2,6 +2,7 @@
 #define _NET_SECURE_SEQ
 
 #include <linux/types.h>
+#include <linux/in6.h>
 
 u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);
 u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,
diff -Nur linux-4.1.13.orig/include/uapi/linux/icmp.h linux-4.1.13/include/uapi/linux/icmp.h
--- linux-4.1.13.orig/include/uapi/linux/icmp.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/icmp.h	2015-12-04 19:57:05.917977705 +0100
@@ -80,7 +80,7 @@
 		__be16	mtu;
 	} frag;
   } un;
-};
+} __attribute__((packed, aligned(2)));
 
 
 /*
diff -Nur linux-4.1.13.orig/include/uapi/linux/icmpv6.h linux-4.1.13/include/uapi/linux/icmpv6.h
--- linux-4.1.13.orig/include/uapi/linux/icmpv6.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/icmpv6.h	2015-12-04 19:57:05.929976920 +0100
@@ -76,7 +76,7 @@
 #define icmp6_addrconf_other	icmp6_dataun.u_nd_ra.other
 #define icmp6_rt_lifetime	icmp6_dataun.u_nd_ra.rt_lifetime
 #define icmp6_router_pref	icmp6_dataun.u_nd_ra.router_pref
-};
+} __attribute__((packed, aligned(2)));
 
 
 #define ICMPV6_ROUTER_PREF_LOW		0x3
diff -Nur linux-4.1.13.orig/include/uapi/linux/if_pppox.h linux-4.1.13/include/uapi/linux/if_pppox.h
--- linux-4.1.13.orig/include/uapi/linux/if_pppox.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/if_pppox.h	2015-12-04 19:57:05.933976659 +0100
@@ -47,6 +47,7 @@
  */
 struct pptp_addr {
 	__u16		call_id;
+	__u16		pad;
 	struct in_addr	sin_addr;
 };
 
diff -Nur linux-4.1.13.orig/include/uapi/linux/igmp.h linux-4.1.13/include/uapi/linux/igmp.h
--- linux-4.1.13.orig/include/uapi/linux/igmp.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/igmp.h	2015-12-04 19:57:05.929976920 +0100
@@ -32,7 +32,7 @@
 	__u8 code;		/* For newer IGMP */
 	__sum16 csum;
 	__be32 group;
-};
+} __attribute__((packed, aligned(2)));
 
 /* V3 group record types [grec_type] */
 #define IGMPV3_MODE_IS_INCLUDE		1
@@ -48,7 +48,7 @@
 	__be16	grec_nsrcs;
 	__be32	grec_mca;
 	__be32	grec_src[0];
-};
+} __attribute__((packed, aligned(2)));
 
 struct igmpv3_report {
 	__u8 type;
@@ -57,7 +57,7 @@
 	__be16 resv2;
 	__be16 ngrec;
 	struct igmpv3_grec grec[0];
-};
+} __attribute__((packed, aligned(2)));
 
 struct igmpv3_query {
 	__u8 type;
@@ -78,7 +78,7 @@
 	__u8 qqic;
 	__be16 nsrcs;
 	__be32 srcs[0];
-};
+} __attribute__((packed, aligned(2)));
 
 #define IGMP_HOST_MEMBERSHIP_QUERY	0x11	/* From RFC1112 */
 #define IGMP_HOST_MEMBERSHIP_REPORT	0x12	/* Ditto */
diff -Nur linux-4.1.13.orig/include/uapi/linux/in6.h linux-4.1.13/include/uapi/linux/in6.h
--- linux-4.1.13.orig/include/uapi/linux/in6.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/in6.h	2015-12-04 19:57:05.917977705 +0100
@@ -42,7 +42,7 @@
 #define s6_addr16		in6_u.u6_addr16
 #define s6_addr32		in6_u.u6_addr32
 #endif
-};
+} __attribute__((packed, aligned(2)));
 #endif /* __UAPI_DEF_IN6_ADDR */
 
 #if __UAPI_DEF_SOCKADDR_IN6
diff -Nur linux-4.1.13.orig/include/uapi/linux/in.h linux-4.1.13/include/uapi/linux/in.h
--- linux-4.1.13.orig/include/uapi/linux/in.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/in.h	2015-12-04 19:57:57.978571564 +0100
@@ -78,7 +78,7 @@
 /* Internet address. */
 struct in_addr {
 	__be32	s_addr;
-};
+} __attribute__((packed, aligned(2)));
 
 #define IP_TOS		1
 #define IP_TTL		2
diff -Nur linux-4.1.13.orig/include/uapi/linux/ip.h linux-4.1.13/include/uapi/linux/ip.h
--- linux-4.1.13.orig/include/uapi/linux/ip.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/ip.h	2015-12-04 19:57:05.913977967 +0100
@@ -102,7 +102,7 @@
 	__be32	saddr;
 	__be32	daddr;
 	/*The options start here. */
-};
+} __attribute__((packed, aligned(2)));
 
 
 struct ip_auth_hdr {
diff -Nur linux-4.1.13.orig/include/uapi/linux/ipv6.h linux-4.1.13/include/uapi/linux/ipv6.h
--- linux-4.1.13.orig/include/uapi/linux/ipv6.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/ipv6.h	2015-12-04 19:57:05.913977967 +0100
@@ -129,7 +129,7 @@
 
 	struct	in6_addr	saddr;
 	struct	in6_addr	daddr;
-};
+} __attribute__((packed, aligned(2)));
 
 
 /* index values for the variables in ipv6_devconf */
diff -Nur linux-4.1.13.orig/include/uapi/linux/Kbuild linux-4.1.13/include/uapi/linux/Kbuild
--- linux-4.1.13.orig/include/uapi/linux/Kbuild	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/Kbuild	2015-12-04 21:33:39.775625531 +0100
@@ -380,6 +380,7 @@
 header-y += string.h
 header-y += suspend_ioctls.h
 header-y += swab.h
+header-y += switch.h
 header-y += synclink.h
 header-y += sysctl.h
 header-y += sysinfo.h
diff -Nur linux-4.1.13.orig/include/uapi/linux/netfilter_arp/arp_tables.h linux-4.1.13/include/uapi/linux/netfilter_arp/arp_tables.h
--- linux-4.1.13.orig/include/uapi/linux/netfilter_arp/arp_tables.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/netfilter_arp/arp_tables.h	2015-12-04 19:57:05.933976659 +0100
@@ -68,7 +68,7 @@
 	__u8 flags;
 	/* Inverse flags */
 	__u16 invflags;
-};
+} __attribute__((aligned(4)));
 
 /* Values for "flag" field in struct arpt_ip (general arp structure).
  * No flags defined yet.
diff -Nur linux-4.1.13.orig/include/uapi/linux/switch.h linux-4.1.13/include/uapi/linux/switch.h
--- linux-4.1.13.orig/include/uapi/linux/switch.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/switch.h	2015-12-04 20:52:30.298718052 +0100
@@ -0,0 +1,103 @@
+/*
+ * switch.h: Switch configuration API
+ *
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_LINUX_SWITCH_H
+#define _UAPI_LINUX_SWITCH_H
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/netlink.h>
+#include <linux/genetlink.h>
+#ifndef __KERNEL__
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+#endif
+
+/* main attributes */
+enum {
+	SWITCH_ATTR_UNSPEC,
+	/* global */
+	SWITCH_ATTR_TYPE,
+	/* device */
+	SWITCH_ATTR_ID,
+	SWITCH_ATTR_DEV_NAME,
+	SWITCH_ATTR_ALIAS,
+	SWITCH_ATTR_NAME,
+	SWITCH_ATTR_VLANS,
+	SWITCH_ATTR_PORTS,
+	SWITCH_ATTR_PORTMAP,
+	SWITCH_ATTR_CPU_PORT,
+	/* attributes */
+	SWITCH_ATTR_OP_ID,
+	SWITCH_ATTR_OP_TYPE,
+	SWITCH_ATTR_OP_NAME,
+	SWITCH_ATTR_OP_PORT,
+	SWITCH_ATTR_OP_VLAN,
+	SWITCH_ATTR_OP_VALUE_INT,
+	SWITCH_ATTR_OP_VALUE_STR,
+	SWITCH_ATTR_OP_VALUE_PORTS,
+	SWITCH_ATTR_OP_DESCRIPTION,
+	/* port lists */
+	SWITCH_ATTR_PORT,
+	SWITCH_ATTR_MAX
+};
+
+enum {
+	/* port map */
+	SWITCH_PORTMAP_PORTS,
+	SWITCH_PORTMAP_SEGMENT,
+	SWITCH_PORTMAP_VIRT,
+	SWITCH_PORTMAP_MAX
+};
+
+/* commands */
+enum {
+	SWITCH_CMD_UNSPEC,
+	SWITCH_CMD_GET_SWITCH,
+	SWITCH_CMD_NEW_ATTR,
+	SWITCH_CMD_LIST_GLOBAL,
+	SWITCH_CMD_GET_GLOBAL,
+	SWITCH_CMD_SET_GLOBAL,
+	SWITCH_CMD_LIST_PORT,
+	SWITCH_CMD_GET_PORT,
+	SWITCH_CMD_SET_PORT,
+	SWITCH_CMD_LIST_VLAN,
+	SWITCH_CMD_GET_VLAN,
+	SWITCH_CMD_SET_VLAN
+};
+
+/* data types */
+enum switch_val_type {
+	SWITCH_TYPE_UNSPEC,
+	SWITCH_TYPE_INT,
+	SWITCH_TYPE_STRING,
+	SWITCH_TYPE_PORTS,
+	SWITCH_TYPE_NOVAL,
+};
+
+/* port nested attributes */
+enum {
+	SWITCH_PORT_UNSPEC,
+	SWITCH_PORT_ID,
+	SWITCH_PORT_FLAG_TAGGED,
+	SWITCH_PORT_ATTR_MAX
+};
+
+#define SWITCH_ATTR_DEFAULTS_OFFSET	0x1000
+
+
+#endif /* _UAPI_LINUX_SWITCH_H */
diff -Nur linux-4.1.13.orig/include/uapi/linux/tcp.h linux-4.1.13/include/uapi/linux/tcp.h
--- linux-4.1.13.orig/include/uapi/linux/tcp.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/tcp.h	2015-12-04 19:57:05.913977967 +0100
@@ -54,7 +54,7 @@
 	__be16	window;
 	__sum16	check;
 	__be16	urg_ptr;
-};
+} __attribute__((packed, aligned(2)));
 
 /*
  *	The union cast uses a gcc extension to avoid aliasing problems
@@ -64,7 +64,7 @@
 union tcp_word_hdr { 
 	struct tcphdr hdr;
 	__be32 		  words[5];
-}; 
+} __attribute__((packed, aligned(2)));
 
 #define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
 
diff -Nur linux-4.1.13.orig/include/uapi/linux/udp.h linux-4.1.13/include/uapi/linux/udp.h
--- linux-4.1.13.orig/include/uapi/linux/udp.h	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/include/uapi/linux/udp.h	2015-12-04 19:57:05.917977705 +0100
@@ -24,7 +24,7 @@
 	__be16	dest;
 	__be16	len;
 	__sum16	check;
-};
+} __attribute__((packed, aligned(2)));
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
diff -Nur linux-4.1.13.orig/lib/Kconfig linux-4.1.13/lib/Kconfig
--- linux-4.1.13.orig/lib/Kconfig	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/lib/Kconfig	2015-12-04 19:57:03.826114569 +0100
@@ -235,6 +235,9 @@
 
 source "lib/xz/Kconfig"
 
+config RLE_DECOMPRESS
+	tristate
+
 #
 # These all provide a common interface (hence the apparent duplication with
 # ZLIB_INFLATE; DECOMPRESS_GZIP is just a wrapper.)
diff -Nur linux-4.1.13.orig/lib/rle.c linux-4.1.13/lib/rle.c
--- linux-4.1.13.orig/lib/rle.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/lib/rle.c	2015-12-04 19:57:03.830114307 +0100
@@ -0,0 +1,78 @@
+/*
+ *  RLE decoding routine
+ *
+ *  Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/rle.h>
+
+int rle_decode(const unsigned char *src, size_t srclen,
+	       unsigned char *dst, size_t dstlen,
+	       size_t *src_done, size_t *dst_done)
+{
+	size_t srcpos, dstpos;
+	int ret;
+
+	srcpos = 0;
+	dstpos = 0;
+	ret = -EINVAL;
+
+	/* sanity checks */
+	if (!src || !srclen || !dst || !dstlen)
+		goto out;
+
+	while (1) {
+		char count;
+
+		if (srcpos >= srclen)
+			break;
+
+		count = (char) src[srcpos++];
+		if (count == 0) {
+			ret = 0;
+			break;
+		}
+
+		if (count > 0) {
+			unsigned char c;
+
+			if (srcpos >= srclen)
+				break;
+
+			c = src[srcpos++];
+
+			while (count--) {
+				if (dstpos >= dstlen)
+					break;
+
+				dst[dstpos++] = c;
+			}
+		} else {
+			count *= -1;
+
+			while (count--) {
+				if (srcpos >= srclen)
+					break;
+				if (dstpos >= dstlen)
+					break;
+				dst[dstpos++] = src[srcpos++];
+			}
+		}
+	}
+
+out:
+	if (src_done)
+		*src_done = srcpos;
+	if (dst_done)
+		*dst_done = dstpos;
+
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(rle_decode);
diff -Nur linux-4.1.13.orig/net/core/flow_dissector.c linux-4.1.13/net/core/flow_dissector.c
--- linux-4.1.13.orig/net/core/flow_dissector.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/core/flow_dissector.c	2015-12-04 19:57:05.929976920 +0100
@@ -53,7 +53,7 @@
 		ports = __skb_header_pointer(skb, thoff + poff,
 					     sizeof(_ports), data, hlen, &_ports);
 		if (ports)
-			return *ports;
+			return (__be32)net_hdr_word(ports);
 	}
 
 	return 0;
diff -Nur linux-4.1.13.orig/net/core/secure_seq.c linux-4.1.13/net/core/secure_seq.c
--- linux-4.1.13.orig/net/core/secure_seq.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/core/secure_seq.c	2015-12-04 19:57:05.929976920 +0100
@@ -46,11 +46,12 @@
 	u32 secret[MD5_MESSAGE_BYTES / 4];
 	u32 hash[MD5_DIGEST_WORDS];
 	u32 i;
+	const struct in6_addr *daddr6 = (struct in6_addr *) daddr;
 
 	net_secret_init();
 	memcpy(hash, saddr, 16);
 	for (i = 0; i < 4; i++)
-		secret[i] = net_secret[i] + (__force u32)daddr[i];
+		secret[i] = net_secret[i] + (__force u32)daddr6->s6_addr32[i];
 	secret[4] = net_secret[4] +
 		(((__force u16)sport << 16) + (__force u16)dport);
 	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
@@ -68,11 +69,12 @@
 	u32 secret[MD5_MESSAGE_BYTES / 4];
 	u32 hash[MD5_DIGEST_WORDS];
 	u32 i;
+	const struct in6_addr *daddr6 = (struct in6_addr *) daddr;
 
 	net_secret_init();
 	memcpy(hash, saddr, 16);
 	for (i = 0; i < 4; i++)
-		secret[i] = net_secret[i] + (__force u32) daddr[i];
+		secret[i] = net_secret[i] + (__force u32) daddr6->s6_addr32[i];
 	secret[4] = net_secret[4] + (__force u32)dport;
 	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
 		secret[i] = net_secret[i];
@@ -150,11 +152,12 @@
 	u32 hash[MD5_DIGEST_WORDS];
 	u64 seq;
 	u32 i;
+	const struct in6_addr *daddr6 = (struct in6_addr *) daddr;
 
 	net_secret_init();
 	memcpy(hash, saddr, 16);
 	for (i = 0; i < 4; i++)
-		secret[i] = net_secret[i] + daddr[i];
+		secret[i] = net_secret[i] +  daddr6->s6_addr32[i];
 	secret[4] = net_secret[4] +
 		(((__force u16)sport << 16) + (__force u16)dport);
 	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
diff -Nur linux-4.1.13.orig/net/dsa/mv88e6063.c linux-4.1.13/net/dsa/mv88e6063.c
--- linux-4.1.13.orig/net/dsa/mv88e6063.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.13/net/dsa/mv88e6063.c	2015-09-13 20:04:35.076523692 +0200
@@ -0,0 +1,294 @@
+/*
+ * net/dsa/mv88e6063.c - Driver for Marvell 88e6063 switch chips
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This driver was base on: net/dsa/mv88e6060.c
+ *   net/dsa/mv88e6063.c - Driver for Marvell 88e6060 switch chips
+ *   Copyright (c) 2008-2009 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include "dsa_priv.h"
+
+#define REG_BASE		0x10
+#define REG_PHY(p)		(REG_BASE + (p))
+#define REG_PORT(p)		(REG_BASE + 8 + (p))
+#define REG_GLOBAL		(REG_BASE + 0x0f)
+#define NUM_PORTS		7
+
+static int reg_read(struct dsa_switch *ds, int addr, int reg)
+{
+	return mdiobus_read(ds->master_mii_bus, addr, reg);
+}
+
+#define REG_READ(addr, reg)					\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_read(ds, addr, reg);		\
+		if (__ret < 0)					\
+			return __ret;				\
+		__ret;						\
+	})
+
+
+static int reg_write(struct dsa_switch *ds, int addr, int reg, u16 val)
+{
+	return mdiobus_write(ds->master_mii_bus, addr, reg, val);
+}
+
+#define REG_WRITE(addr, reg, val)				\
+	({							\
+		int __ret;					\
+								\
+		__ret = reg_write(ds, addr, reg, val);		\
+		if (__ret < 0)					\
+			return __ret;				\
+	})
+
+static char *mv88e6063_probe(struct mii_bus *bus, int sw_addr)
+{
+	int ret;
+
+	ret = mdiobus_read(bus, REG_PORT(0), 0x03);
+	if (ret >= 0) {
+		ret &= 0xfff0;
+		if (ret == 0x1530)
+			return "Marvell 88E6063";
+	}
+
+	return NULL;
+}
+
+static int mv88e6063_switch_reset(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	/*
+	 * Set all ports to the disabled state.
+	 */
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = REG_READ(REG_PORT(i), 0x04);
+		REG_WRITE(REG_PORT(i), 0x04, ret & 0xfffc);
+	}
+
+	/*
+	 * Wait for transmit queues to drain.
+	 */
+	msleep(2);
+
+	/*
+	 * Reset the switch.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0xa130);
+
+	/*
+	 * Wait up to one second for reset to complete.
+	 */
+	for (i = 0; i < 1000; i++) {
+		ret = REG_READ(REG_GLOBAL, 0x00);
+		if ((ret & 0x8000) == 0x0000)
+			break;
+
+		msleep(1);
+	}
+	if (i == 1000)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int mv88e6063_setup_global(struct dsa_switch *ds)
+{
+	/*
+	 * Disable discarding of frames with excessive collisions,
+	 * set the maximum frame size to 1536 bytes, and mask all
+	 * interrupt sources.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x04, 0x0800);
+
+	/*
+	 * Enable automatic address learning, set the address
+	 * database size to 1024 entries, and set the default aging
+	 * time to 5 minutes.
+	 */
+	REG_WRITE(REG_GLOBAL, 0x0a, 0x2130);
+
+	return 0;
+}
+
+static int mv88e6063_setup_port(struct dsa_switch *ds, int p)
+{
+	int addr = REG_PORT(p);
+
+	/*
+	 * Do not force flow control, disable Ingress and Egress
+	 * Header tagging, disable VLAN tunneling, and set the port
+	 * state to Forwarding.  Additionally, if this is the CPU
+	 * port, enable Ingress and Egress Trailer tagging mode.
+	 */
+	REG_WRITE(addr, 0x04, dsa_is_cpu_port(ds, p) ?  0x4103 : 0x0003);
+
+	/*
+	 * Port based VLAN map: give each port its own address
+	 * database, allow the CPU port to talk to each of the 'real'
+	 * ports, and allow each of the 'real' ports to only talk to
+	 * the CPU port.
+	 */
+	REG_WRITE(addr, 0x06,
+			((p & 0xf) << 12) |
+			 (dsa_is_cpu_port(ds, p) ?
+				ds->phys_port_mask :
+				(1 << ds->dst->cpu_port)));
+
+	/*
+	 * Port Association Vector: when learning source addresses
+	 * of packets, add the address to the address database using
+	 * a port bitmap that has only the bit for this port set and
+	 * the other bits clear.
+	 */
+	REG_WRITE(addr, 0x0b, 1 << p);
+
+	return 0;
+}
+
+static int mv88e6063_setup(struct dsa_switch *ds)
+{
+	int i;
+	int ret;
+
+	ret = mv88e6063_switch_reset(ds);
+	if (ret < 0)
+		return ret;
+
+	/* @@@ initialise atu */
+
+	ret = mv88e6063_setup_global(ds);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < NUM_PORTS; i++) {
+		ret = mv88e6063_setup_port(ds, i);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mv88e6063_set_addr(struct dsa_switch *ds, u8 *addr)
+{
+	REG_WRITE(REG_GLOBAL, 0x01, (addr[0] << 8) | addr[1]);
+	REG_WRITE(REG_GLOBAL, 0x02, (addr[2] << 8) | addr[3]);
+	REG_WRITE(REG_GLOBAL, 0x03, (addr[4] << 8) | addr[5]);
+
+	return 0;
+}
+
+static int mv88e6063_port_to_phy_addr(int port)
+{
+	if (port >= 0 && port <= NUM_PORTS)
+		return REG_PHY(port);
+	return -1;
+}
+
+static int mv88e6063_phy_read(struct dsa_switch *ds, int port, int regnum)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_read(ds, addr, regnum);
+}
+
+static int
+mv88e6063_phy_write(struct dsa_switch *ds, int port, int regnum, u16 val)
+{
+	int addr;
+
+	addr = mv88e6063_port_to_phy_addr(port);
+	if (addr == -1)
+		return 0xffff;
+
+	return reg_write(ds, addr, regnum, val);
+}
+
+static void mv88e6063_poll_link(struct dsa_switch *ds)
+{
+	int i;
+
+	for (i = 0; i < DSA_MAX_PORTS; i++) {
+		struct net_device *dev;
+		int uninitialized_var(port_status);
+		int link;
+		int speed;
+		int duplex;
+		int fc;
+
+		dev = ds->ports[i];
+		if (dev == NULL)
+			continue;
+
+		link = 0;
+		if (dev->flags & IFF_UP) {
+			port_status = reg_read(ds, REG_PORT(i), 0x00);
+			if (port_status < 0)
+				continue;
+
+			link = !!(port_status & 0x1000);
+		}
+
+		if (!link) {
+			if (netif_carrier_ok(dev)) {
+				printk(KERN_INFO "%s: link down\n", dev->name);
+				netif_carrier_off(dev);
+			}
+			continue;
+		}
+
+		speed = (port_status & 0x0100) ? 100 : 10;
+		duplex = (port_status & 0x0200) ? 1 : 0;
+		fc = ((port_status & 0xc000) == 0xc000) ? 1 : 0;
+
+		if (!netif_carrier_ok(dev)) {
+			printk(KERN_INFO "%s: link up, %d Mb/s, %s duplex, "
+					 "flow control %sabled\n", dev->name,
+					 speed, duplex ? "full" : "half",
+					 fc ? "en" : "dis");
+			netif_carrier_on(dev);
+		}
+	}
+}
+
+static struct dsa_switch_driver mv88e6063_switch_driver = {
+	.tag_protocol	= htons(ETH_P_TRAILER),
+	.probe		= mv88e6063_probe,
+	.setup		= mv88e6063_setup,
+	.set_addr	= mv88e6063_set_addr,
+	.phy_read	= mv88e6063_phy_read,
+	.phy_write	= mv88e6063_phy_write,
+	.poll_link	= mv88e6063_poll_link,
+};
+
+static int __init mv88e6063_init(void)
+{
+	register_switch_driver(&mv88e6063_switch_driver);
+	return 0;
+}
+module_init(mv88e6063_init);
+
+static void __exit mv88e6063_cleanup(void)
+{
+	unregister_switch_driver(&mv88e6063_switch_driver);
+}
+module_exit(mv88e6063_cleanup);
diff -Nur linux-4.1.13.orig/net/dsa/tag_trailer.c linux-4.1.13/net/dsa/tag_trailer.c
--- linux-4.1.13.orig/net/dsa/tag_trailer.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/dsa/tag_trailer.c	2015-12-04 19:57:03.886110643 +0100
@@ -84,7 +84,7 @@
 
 	trailer = skb_tail_pointer(skb) - 4;
 	if (trailer[0] != 0x80 || (trailer[1] & 0xf8) != 0x00 ||
-	    (trailer[3] & 0xef) != 0x00 || trailer[3] != 0x00)
+	    (trailer[2] & 0xef) != 0x00 || (trailer[3] & 0xfe) != 0x00)
 		goto out_drop;
 
 	source_port = trailer[1] & 7;
diff -Nur linux-4.1.13.orig/net/ipv4/af_inet.c linux-4.1.13/net/ipv4/af_inet.c
--- linux-4.1.13.orig/net/ipv4/af_inet.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv4/af_inet.c	2015-12-04 19:57:05.925977182 +0100
@@ -1323,8 +1323,8 @@
 	if (unlikely(ip_fast_csum((u8 *)iph, 5)))
 		goto out_unlock;
 
-	id = ntohl(*(__be32 *)&iph->id);
-	flush = (u16)((ntohl(*(__be32 *)iph) ^ skb_gro_len(skb)) | (id & ~IP_DF));
+	id = ntohl(net_hdr_word(&iph->id));
+	flush = (u16)((ntohl(net_hdr_word(iph)) ^ skb_gro_len(skb)) | (id & ~IP_DF));
 	id >>= 16;
 
 	for (p = *head; p; p = p->next) {
diff -Nur linux-4.1.13.orig/net/ipv4/igmp.c linux-4.1.13/net/ipv4/igmp.c
--- linux-4.1.13.orig/net/ipv4/igmp.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv4/igmp.c	2015-12-04 19:57:05.929976920 +0100
@@ -496,7 +496,7 @@
 		if (!skb)
 			return NULL;
 		psrc = (__be32 *)skb_put(skb, sizeof(__be32));
-		*psrc = psf->sf_inaddr;
+		net_hdr_word(psrc) = psf->sf_inaddr;
 		scount++; stotal++;
 		if ((type == IGMPV3_ALLOW_NEW_SOURCES ||
 		     type == IGMPV3_BLOCK_OLD_SOURCES) && psf->sf_crcount) {
diff -Nur linux-4.1.13.orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c linux-4.1.13/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
--- linux-4.1.13.orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2015-12-04 19:57:05.917977705 +0100
@@ -41,8 +41,8 @@
 	if (ap == NULL)
 		return false;
 
-	tuple->src.u3.ip = ap[0];
-	tuple->dst.u3.ip = ap[1];
+	tuple->src.u3.ip = net_hdr_word(ap++);
+	tuple->dst.u3.ip = net_hdr_word(ap);
 
 	return true;
 }
diff -Nur linux-4.1.13.orig/net/ipv4/route.c linux-4.1.13/net/ipv4/route.c
--- linux-4.1.13.orig/net/ipv4/route.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv4/route.c	2015-12-04 19:57:05.925977182 +0100
@@ -450,7 +450,7 @@
 	else if (skb)
 		pkey = &ip_hdr(skb)->daddr;
 
-	n = __ipv4_neigh_lookup(dev, *(__force u32 *)pkey);
+	n = __ipv4_neigh_lookup(dev, net_hdr_word(pkey));
 	if (n)
 		return n;
 	return neigh_create(&arp_tbl, pkey, dev);
diff -Nur linux-4.1.13.orig/net/ipv4/tcp_input.c linux-4.1.13/net/ipv4/tcp_input.c
--- linux-4.1.13.orig/net/ipv4/tcp_input.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv4/tcp_input.c	2015-12-04 19:57:05.933976659 +0100
@@ -3760,14 +3760,16 @@
 {
 	const __be32 *ptr = (const __be32 *)(th + 1);
 
-	if (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)
-			  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
+	if (net_hdr_word(ptr) ==
+	    htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+		  (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
 		tp->rx_opt.saw_tstamp = 1;
 		++ptr;
-		tp->rx_opt.rcv_tsval = ntohl(*ptr);
+		tp->rx_opt.rcv_tsval = get_unaligned_be32(ptr);
 		++ptr;
-		if (*ptr)
-			tp->rx_opt.rcv_tsecr = ntohl(*ptr) - tp->tsoffset;
+		if (net_hdr_word(ptr))
+			tp->rx_opt.rcv_tsecr = get_unaligned_be32(ptr) -
+					       tp->tsoffset;
 		else
 			tp->rx_opt.rcv_tsecr = 0;
 		return true;
diff -Nur linux-4.1.13.orig/net/ipv4/tcp_output.c linux-4.1.13/net/ipv4/tcp_output.c
--- linux-4.1.13.orig/net/ipv4/tcp_output.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv4/tcp_output.c	2015-12-04 19:57:05.929976920 +0100
@@ -452,48 +452,53 @@
 	u16 options = opts->options;	/* mungable copy */
 
 	if (unlikely(OPTION_MD5 & options)) {
-		*ptr++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
-			       (TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+			      (TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);
 		/* overload cookie hash location */
 		opts->hash_location = (__u8 *)ptr;
 		ptr += 4;
 	}
 
 	if (unlikely(opts->mss)) {
-		*ptr++ = htonl((TCPOPT_MSS << 24) |
-			       (TCPOLEN_MSS << 16) |
-			       opts->mss);
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_MSS << 24) | (TCPOLEN_MSS << 16) |
+			      opts->mss);
 	}
 
 	if (likely(OPTION_TS & options)) {
 		if (unlikely(OPTION_SACK_ADVERTISE & options)) {
-			*ptr++ = htonl((TCPOPT_SACK_PERM << 24) |
-				       (TCPOLEN_SACK_PERM << 16) |
-				       (TCPOPT_TIMESTAMP << 8) |
-				       TCPOLEN_TIMESTAMP);
+			net_hdr_word(ptr++) =
+				htonl((TCPOPT_SACK_PERM << 24) |
+				      (TCPOLEN_SACK_PERM << 16) |
+				      (TCPOPT_TIMESTAMP << 8) |
+				      TCPOLEN_TIMESTAMP);
 			options &= ~OPTION_SACK_ADVERTISE;
 		} else {
-			*ptr++ = htonl((TCPOPT_NOP << 24) |
-				       (TCPOPT_NOP << 16) |
-				       (TCPOPT_TIMESTAMP << 8) |
-				       TCPOLEN_TIMESTAMP);
+			net_hdr_word(ptr++) =
+				htonl((TCPOPT_NOP << 24) |
+				      (TCPOPT_NOP << 16) |
+				      (TCPOPT_TIMESTAMP << 8) |
+				      TCPOLEN_TIMESTAMP);
 		}
-		*ptr++ = htonl(opts->tsval);
-		*ptr++ = htonl(opts->tsecr);
+		net_hdr_word(ptr++) = htonl(opts->tsval);
+		net_hdr_word(ptr++) = htonl(opts->tsecr);
 	}
 
 	if (unlikely(OPTION_SACK_ADVERTISE & options)) {
-		*ptr++ = htonl((TCPOPT_NOP << 24) |
-			       (TCPOPT_NOP << 16) |
-			       (TCPOPT_SACK_PERM << 8) |
-			       TCPOLEN_SACK_PERM);
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_NOP << 24) |
+			      (TCPOPT_NOP << 16) |
+			      (TCPOPT_SACK_PERM << 8) |
+			      TCPOLEN_SACK_PERM);
 	}
 
 	if (unlikely(OPTION_WSCALE & options)) {
-		*ptr++ = htonl((TCPOPT_NOP << 24) |
-			       (TCPOPT_WINDOW << 16) |
-			       (TCPOLEN_WINDOW << 8) |
-			       opts->ws);
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_NOP << 24) |
+			      (TCPOPT_WINDOW << 16) |
+			      (TCPOLEN_WINDOW << 8) |
+			      opts->ws);
 	}
 
 	if (unlikely(opts->num_sack_blocks)) {
@@ -501,16 +506,17 @@
 			tp->duplicate_sack : tp->selective_acks;
 		int this_sack;
 
-		*ptr++ = htonl((TCPOPT_NOP  << 24) |
-			       (TCPOPT_NOP  << 16) |
-			       (TCPOPT_SACK <<  8) |
-			       (TCPOLEN_SACK_BASE + (opts->num_sack_blocks *
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_NOP << 24) |
+			      (TCPOPT_NOP << 16) |
+			      (TCPOPT_SACK << 8) |
+			      (TCPOLEN_SACK_BASE + (opts->num_sack_blocks *
 						     TCPOLEN_SACK_PERBLOCK)));
 
 		for (this_sack = 0; this_sack < opts->num_sack_blocks;
 		     ++this_sack) {
-			*ptr++ = htonl(sp[this_sack].start_seq);
-			*ptr++ = htonl(sp[this_sack].end_seq);
+			net_hdr_word(ptr++) = htonl(sp[this_sack].start_seq);
+			net_hdr_word(ptr++) = htonl(sp[this_sack].end_seq);
 		}
 
 		tp->rx_opt.dsack = 0;
@@ -523,13 +529,14 @@
 
 		if (foc->exp) {
 			len = TCPOLEN_EXP_FASTOPEN_BASE + foc->len;
-			*ptr = htonl((TCPOPT_EXP << 24) | (len << 16) |
+			net_hdr_word(ptr) =
+				htonl((TCPOPT_EXP << 24) | (len << 16) |
 				     TCPOPT_FASTOPEN_MAGIC);
 			p += TCPOLEN_EXP_FASTOPEN_BASE;
 		} else {
 			len = TCPOLEN_FASTOPEN_BASE + foc->len;
-			*p++ = TCPOPT_FASTOPEN;
-			*p++ = len;
+			net_hdr_word(p++) = TCPOPT_FASTOPEN;
+			net_hdr_word(p++) = len;
 		}
 
 		memcpy(p, foc->val, foc->len);
diff -Nur linux-4.1.13.orig/net/ipv6/datagram.c linux-4.1.13/net/ipv6/datagram.c
--- linux-4.1.13.orig/net/ipv6/datagram.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv6/datagram.c	2015-12-04 19:57:05.921977444 +0100
@@ -424,7 +424,7 @@
 				ipv6_iface_scope_id(&sin->sin6_addr,
 						    IP6CB(skb)->iif);
 		} else {
-			ipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),
+			ipv6_addr_set_v4mapped(net_hdr_word(nh + serr->addr_offset),
 					       &sin->sin6_addr);
 			sin->sin6_scope_id = 0;
 		}
@@ -761,12 +761,12 @@
 			}
 
 			if (fl6->flowlabel&IPV6_FLOWINFO_MASK) {
-				if ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {
+				if ((fl6->flowlabel^net_hdr_word(CMSG_DATA(cmsg)))&~IPV6_FLOWINFO_MASK) {
 					err = -EINVAL;
 					goto exit_f;
 				}
 			}
-			fl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);
+			fl6->flowlabel = IPV6_FLOWINFO_MASK & net_hdr_word(CMSG_DATA(cmsg));
 			break;
 
 		case IPV6_2292HOPOPTS:
diff -Nur linux-4.1.13.orig/net/ipv6/exthdrs.c linux-4.1.13/net/ipv6/exthdrs.c
--- linux-4.1.13.orig/net/ipv6/exthdrs.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv6/exthdrs.c	2015-12-04 19:57:05.921977444 +0100
@@ -573,7 +573,7 @@
 		goto drop;
 	}
 
-	pkt_len = ntohl(*(__be32 *)(nh + optoff + 2));
+	pkt_len = ntohl(net_hdr_word(nh + optoff + 2));
 	if (pkt_len <= IPV6_MAXPLEN) {
 		IP6_INC_STATS_BH(net, ipv6_skb_idev(skb),
 				 IPSTATS_MIB_INHDRERRORS);
diff -Nur linux-4.1.13.orig/net/ipv6/ip6_fib.c linux-4.1.13/net/ipv6/ip6_fib.c
--- linux-4.1.13.orig/net/ipv6/ip6_fib.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv6/ip6_fib.c	2015-12-04 19:57:05.929976920 +0100
@@ -137,7 +137,7 @@
 	 * See include/asm-generic/bitops/le.h.
 	 */
 	return (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &
-	       addr[fn_bit >> 5];
+	       net_hdr_word(&addr[fn_bit >> 5]);
 }
 
 static struct fib6_node *node_alloc(void)
diff -Nur linux-4.1.13.orig/net/ipv6/ip6_gre.c linux-4.1.13/net/ipv6/ip6_gre.c
--- linux-4.1.13.orig/net/ipv6/ip6_gre.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv6/ip6_gre.c	2015-12-04 19:57:05.921977444 +0100
@@ -394,7 +394,7 @@
 
 	t = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,
 				flags & GRE_KEY ?
-				*(((__be32 *)p) + (grehlen / 4) - 1) : 0,
+				net_hdr_word(((__be32 *)p) + (grehlen / 4) - 1) : 0,
 				p[1]);
 	if (!t)
 		return;
@@ -476,11 +476,11 @@
 			offset += 4;
 		}
 		if (flags&GRE_KEY) {
-			key = *(__be32 *)(h + offset);
+			key = net_hdr_word(h + offset);
 			offset += 4;
 		}
 		if (flags&GRE_SEQ) {
-			seqno = ntohl(*(__be32 *)(h + offset));
+			seqno = ntohl(net_hdr_word(h + offset));
 			offset += 4;
 		}
 	}
@@ -745,7 +745,7 @@
 
 		if (tunnel->parms.o_flags&GRE_SEQ) {
 			++tunnel->o_seqno;
-			*ptr = htonl(tunnel->o_seqno);
+			net_hdr_word(ptr) = htonl(tunnel->o_seqno);
 			ptr--;
 		}
 		if (tunnel->parms.o_flags&GRE_KEY) {
@@ -841,7 +841,7 @@
 
 	dsfield = ipv6_get_dsfield(ipv6h);
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
-		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);
+		fl6.flowlabel |= net_hdr_word(ipv6h) & IPV6_TCLASS_MASK;
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
 		fl6.flowlabel |= ip6_flowlabel(ipv6h);
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
diff -Nur linux-4.1.13.orig/net/ipv6/ip6_offload.c linux-4.1.13/net/ipv6/ip6_offload.c
--- linux-4.1.13.orig/net/ipv6/ip6_offload.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv6/ip6_offload.c	2015-12-04 19:57:05.929976920 +0100
@@ -221,7 +221,7 @@
 			continue;
 
 		iph2 = (struct ipv6hdr *)(p->data + off);
-		first_word = *(__be32 *)iph ^ *(__be32 *)iph2;
+		first_word = net_hdr_word(iph) ^ net_hdr_word(iph2);
 
 		/* All fields must match except length and Traffic Class.
 		 * XXX skbs on the gro_list have all been parsed and pulled
diff -Nur linux-4.1.13.orig/net/ipv6/ip6_tunnel.c linux-4.1.13/net/ipv6/ip6_tunnel.c
--- linux-4.1.13.orig/net/ipv6/ip6_tunnel.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv6/ip6_tunnel.c	2015-12-04 19:57:05.921977444 +0100
@@ -1190,7 +1190,7 @@
 
 	dsfield = ipv6_get_dsfield(ipv6h);
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
-		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);
+		fl6.flowlabel |= net_hdr_word(ipv6h) & IPV6_TCLASS_MASK;
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
 		fl6.flowlabel |= ip6_flowlabel(ipv6h);
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
diff -Nur linux-4.1.13.orig/net/ipv6/netfilter/nf_log_ipv6.c linux-4.1.13/net/ipv6/netfilter/nf_log_ipv6.c
--- linux-4.1.13.orig/net/ipv6/netfilter/nf_log_ipv6.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv6/netfilter/nf_log_ipv6.c	2015-12-04 19:57:05.933976659 +0100
@@ -66,9 +66,9 @@
 	/* Max length: 44 "LEN=65535 TC=255 HOPLIMIT=255 FLOWLBL=FFFFF " */
 	nf_log_buf_add(m, "LEN=%Zu TC=%u HOPLIMIT=%u FLOWLBL=%u ",
 	       ntohs(ih->payload_len) + sizeof(struct ipv6hdr),
-	       (ntohl(*(__be32 *)ih) & 0x0ff00000) >> 20,
+	       (ntohl(net_hdr_word(ih)) & 0x0ff00000) >> 20,
 	       ih->hop_limit,
-	       (ntohl(*(__be32 *)ih) & 0x000fffff));
+	       (ntohl(net_hdr_word(ih)) & 0x000fffff));
 
 	fragment = 0;
 	ptr = ip6hoff + sizeof(struct ipv6hdr);
diff -Nur linux-4.1.13.orig/net/ipv6/tcp_ipv6.c linux-4.1.13/net/ipv6/tcp_ipv6.c
--- linux-4.1.13.orig/net/ipv6/tcp_ipv6.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/ipv6/tcp_ipv6.c	2015-12-04 19:57:05.917977705 +0100
@@ -39,6 +39,7 @@
 #include <linux/ipsec.h>
 #include <linux/times.h>
 #include <linux/slab.h>
+#include <asm/unaligned.h>
 #include <linux/uaccess.h>
 #include <linux/ipv6.h>
 #include <linux/icmpv6.h>
@@ -772,10 +773,10 @@
 	topt = (__be32 *)(t1 + 1);
 
 	if (tsecr) {
-		*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
-				(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);
-		*topt++ = htonl(tsval);
-		*topt++ = htonl(tsecr);
+		put_unaligned_be32((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+				(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP, topt++);
+		put_unaligned_be32(tsval, topt++);
+		put_unaligned_be32(tsecr, topt++);
 	}
 
 #ifdef CONFIG_TCP_MD5SIG
diff -Nur linux-4.1.13.orig/net/netfilter/nf_conntrack_proto_tcp.c linux-4.1.13/net/netfilter/nf_conntrack_proto_tcp.c
--- linux-4.1.13.orig/net/netfilter/nf_conntrack_proto_tcp.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/netfilter/nf_conntrack_proto_tcp.c	2015-12-04 19:57:05.929976920 +0100
@@ -453,7 +453,7 @@
 
 	/* Fast path for timestamp-only option */
 	if (length == TCPOLEN_TSTAMP_ALIGNED
-	    && *(__be32 *)ptr == htonl((TCPOPT_NOP << 24)
+	    && net_hdr_word(ptr) == htonl((TCPOPT_NOP << 24)
 				       | (TCPOPT_NOP << 16)
 				       | (TCPOPT_TIMESTAMP << 8)
 				       | TCPOLEN_TIMESTAMP))
diff -Nur linux-4.1.13.orig/net/sched/cls_u32.c linux-4.1.13/net/sched/cls_u32.c
--- linux-4.1.13.orig/net/sched/cls_u32.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/sched/cls_u32.c	2015-12-04 19:57:05.929976920 +0100
@@ -151,7 +151,7 @@
 			data = skb_header_pointer(skb, toff, 4, &hdata);
 			if (!data)
 				goto out;
-			if ((*data ^ key->val) & key->mask) {
+			if ((net_hdr_word(data) ^ key->val) & key->mask) {
 				n = rcu_dereference_bh(n->next);
 				goto next_knode;
 			}
@@ -204,8 +204,8 @@
 						  &hdata);
 			if (!data)
 				goto out;
-			sel = ht->divisor & u32_hash_fold(*data, &n->sel,
-							  n->fshift);
+			sel = ht->divisor & u32_hash_fold(net_hdr_word(data),
+							  &n->sel, n->fshift);
 		}
 		if (!(n->sel.flags & (TC_U32_VAROFFSET | TC_U32_OFFSET | TC_U32_EAT)))
 			goto next_ht;
diff -Nur linux-4.1.13.orig/net/xfrm/xfrm_input.c linux-4.1.13/net/xfrm/xfrm_input.c
--- linux-4.1.13.orig/net/xfrm/xfrm_input.c	2015-11-09 23:34:10.000000000 +0100
+++ linux-4.1.13/net/xfrm/xfrm_input.c	2015-12-04 19:57:05.929976920 +0100
@@ -154,8 +154,8 @@
 	if (!pskb_may_pull(skb, hlen))
 		return -EINVAL;
 
-	*spi = *(__be32 *)(skb_transport_header(skb) + offset);
-	*seq = *(__be32 *)(skb_transport_header(skb) + offset_seq);
+	*spi = net_hdr_word(skb_transport_header(skb) + offset);
+	*seq = net_hdr_word(skb_transport_header(skb) + offset_seq);
 	return 0;
 }
 
